[{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now clears the result of the last update. I had left it as is. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "clear", "result", "last", "updat", "had", "left", "it", "as", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver patch was failing because I added another GLIBC - 2 closing loop. Clarify variable name to match new BrentSolver. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "patch", "wa", "fail", "becaus", "ad", "anoth", "glibc", "close", "loop", "clarifi", "variabl", "name", "match", "new", "brentsolv", "brent", "solver", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added patch for variable max value function. Added verifyBracketing ( min  max  f ). ", "B_clean_title": ["ad", "patch", "variabl", "max", "valu", "function", "ad", "verifybracket", "verifi", "bracket", "min", "max"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Reset the iterator count as well. Added verifyBracketing to the BrentSolver. revert patch. ", "B_clean_title": ["reset", "iter", "count", "as", "well", "ad", "verifybracket", "verifi", "bracket", "brentsolv", "brent", "solver", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fixing the BrentSolver bug .. Add patch for bisection. ", "B_clean_title": ["fix", "brentsolv", "brent", "solver", "bug", "add", "patch", "bisect"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix the bug in BrentSolver from patch 0 .. Added verifyBracketing to the BrentSolver. Add back missing patch. ", "B_clean_title": ["fix", "bug", "brentsolv", "brent", "solver", "patch", "ad", "verifybracket", "verifi", "bracket", "brentsolv", "brent", "solver", "add", "back", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove a couple incorrect lines. I was confused  sorry. Add back missing patch. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "wa", "confus", "sorri", "add", "back", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value  but is not good enough. changed default function value accuracy in BrentSolver. Added patch for function value endpoints. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "but", "not", "good", "enough", "chang", "default", "function", "valu", "accuraci", "brentsolv", "brent", "solver", "ad", "patch", "function", "valu", "endpoint", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "remove clearResult ( ) from verifySequence ( ). Remove erroneous test. Set variable name as used by the BrentSolver class .. Added patch for function value min and max. ", "B_clean_title": ["remov", "clearresult", "clear", "result", "verifysequ", "verifi", "sequenc", "remov", "erron", "test", "set", "variabl", "name", "as", "use", "by", "brentsolv", "brent", "solver", "class", "ad", "patch", "function", "valu", "min", "max"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver patch was not re - used .. Clarify BrentSolver with better error handling. Set x1 = x2 before setting result .. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "patch", "wa", "not", "re", "use", "clarifi", "brentsolv", "brent", "solver", "better", "error", "handl", "set", "x1", "x2", "befor", "set", "result", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "I had left it as is. Add back missing patch. revert patch. ", "B_clean_title": ["had", "left", "it", "as", "add", "back", "miss", "patch", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added patch for variable max value checking. Added verifyBracketing ( min  max  f ). ", "B_clean_title": ["ad", "patch", "variabl", "max", "valu", "check", "ad", "verifybracket", "verifi", "bracket", "min", "max"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set iterationCount as it is only used when checking the sequence. Set iterationCount as well as verifyBracketing ( min  max  f ). revert patch. ", "B_clean_title": ["set", "iterationcount", "iter", "count", "as", "it", "onli", "use", "when", "check", "sequenc", "set", "iterationcount", "iter", "count", "as", "well", "as", "verifybracket", "verifi", "bracket", "min", "max", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added patch for 1 . 8 . 3 .. Reset the iterator count as well. Added verifyBracketing to the BrentSolver. revert patch. ", "B_clean_title": ["ad", "patch", "reset", "iter", "count", "as", "well", "ad", "verifybracket", "verifi", "bracket", "brentsolv", "brent", "solver", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the fixed value function  so it is normally possible to reuse it .. changed variable name. Clarify BrentSolver with better error handling. Added patch to prove that the function value is close to 0 . 0 .. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "fix", "valu", "function", "so", "it", "normal", "possibl", "reus", "it", "chang", "variabl", "name", "clarifi", "brentsolv", "brent", "solver", "better", "error", "handl", "ad", "patch", "prove", "that", "function", "valu", "close"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing ( min  max  f ) to the BrentSolver bug. Fix the bug in the elm function to be compatible with the current AEJC. I had left it as is done in the last commit .. Add a missing return value in inverse quadratic interpolation. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "min", "max", "brentsolv", "brent", "solver", "bug", "fix", "bug", "elm", "function", "compat", "current", "aejc", "had", "left", "it", "as", "done", "last", "commit", "add", "miss", "return", "valu", "invers", "quadrat", "interpol"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "changed variable name for BrentSolver. Added verifyBracketing method to the BrentSolver. Fix erroneous test .. ", "B_clean_title": ["chang", "variabl", "name", "brentsolv", "brent", "solver", "ad", "verifybracket", "verifi", "bracket", "method", "brentsolv", "brent", "solver", "fix", "erron", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove a couple incorrect code lines. changed max value of BrentSolver to be 0 if max is good enough. ", "B_clean_title": ["remov", "coupl", "incorrect", "code", "line", "chang", "max", "valu", "brentsolv", "brent", "solver", "max", "good", "enough"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix erroneous test. Clarify variable name to match new BrentSolver. revert patch. ", "B_clean_title": ["fix", "erron", "test", "clarifi", "variabl", "name", "match", "new", "brentsolv", "brent", "solver", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Clarify BrentSolver with better error handling. revert patch. ", "B_clean_title": ["clarifi", "brentsolv", "brent", "solver", "better", "error", "handl", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Updated BrentSolver . setResult ( initial  0 ) ;. Clarify BrentSolver . resultComputed with better accuracy .. Added patch for function value coherency. Add patch for easing of the bug. ", "B_clean_title": ["updat", "brentsolv", "brent", "solver", "setresult", "set", "result", "initi", "clarifi", "brentsolv", "brent", "solver", "resultcomput", "result", "comput", "better", "accuraci", "ad", "patch", "function", "valu", "coher", "add", "patch", "eas", "bug"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver patch was not re - used .. Clarify solution with better error handling. ", "B_clean_title": ["brentsolv", "brent", "solver", "patch", "wa", "not", "re", "use", "clarifi", "solut", "better", "error", "handl"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set this . iterationCount = iterationCount + 1 ; rather than the default max .. Set iterationCount as it is normally possible to reuse the same x  y  yInitial .. Added patch for function value min and max. revert patch. ", "B_clean_title": ["set", "thi", "iterationcount", "iter", "count", "iterationcount", "iter", "count", "rather", "than", "default", "max", "set", "iterationcount", "iter", "count", "as", "it", "normal", "possibl", "reus", "same", "yiniti", "initi", "ad", "patch", "function", "valu", "min", "max", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default  as it is done every time. Added verifyBracketing ( ) to the function value accuracy patch. Fix erroneous test case. revert patch. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "as", "it", "done", "everi", "time", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "fix", "erron", "test", "case", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set x2 and y2 as arguments to the BrentSolver class .. Clarify solution with better error handling. revert patch. ", "B_clean_title": ["set", "x2", "y2", "as", "argument", "brentsolv", "brent", "solver", "class", "clarifi", "solut", "better", "error", "handl", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set x2 = max value of BrentSolver as well. Clarify variable name to match provided function value accuracy. revert patch. ", "B_clean_title": ["set", "x2", "max", "valu", "brentsolv", "brent", "solver", "as", "well", "clarifi", "variabl", "name", "match", "provid", "function", "valu", "accuraci", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing ( ) to the function value accuracy patch. I had left it as was done before the move . . .. revert patch. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "had", "left", "it", "as", "wa", "done", "befor", "move", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set x2 = max as the max is not good enough .. Added verifyBracketing ( ) to the function value accuracy patch. Remove a redundant check. ", "B_clean_title": ["set", "x2", "max", "as", "max", "not", "good", "enough", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "remov", "redund", "check"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) patch from BrentSolver. Added erroneous inverse of verifyBracketing ( min  max  f ). Set p1 = 1 . 0 - r3 instead of p0 = 0 . 5 *. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "patch", "brentsolv", "brent", "solver", "ad", "erron", "invers", "verifybracket", "verifi", "bracket", "min", "max", "set", "p1", "r3", "instead", "p0"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value ( already provided by valgrind ). Set this . iterationCount to zero so that the function value is always good enough. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "alreadi", "provid", "by", "valgrind", "set", "thi", "iterationcount", "iter", "count", "zero", "so", "that", "function", "valu", "alway", "good", "enough", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "changed variable name for BrentSolver. Added more iterations to the stub. Fix erroneous test .. ", "B_clean_title": ["chang", "variabl", "name", "brentsolv", "brent", "solver", "ad", "more", "iter", "stub", "fix", "erron", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Clarify variable name to match new BrentSolver. ", "B_clean_title": ["clarifi", "variabl", "name", "match", "new", "brentsolv", "brent", "solver"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing ( ) to the function value accuracy patch. Added patch for 1 . 8 . 0 .. I had left it harwired to verifyBracketing .. Added patch for variable x0 in BrentSolver. revert patch. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "ad", "patch", "had", "left", "it", "harwir", "verifybracket", "verifi", "bracket", "ad", "patch", "variabl", "x0", "brentsolv", "brent", "solver", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value .. Fix swapped line. I had left it harwired to verifyBracketing .. Add a missing return value in inverse quadratic interpolation. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "fix", "swap", "line", "had", "left", "it", "harwir", "verifybracket", "verifi", "bracket", "add", "miss", "return", "valu", "invers", "quadrat", "interpol"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) call. Added verifyBracketing ( ) to the function value otherwise it will break the build .. Clarify variable name to match provided function value accuracy .. Add back missing patch. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "call", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "otherwis", "it", "will", "break", "build", "clarifi", "variabl", "name", "match", "provid", "function", "valu", "accuraci", "add", "back", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "remove clearResult ( ) from verifySequence ( ). Added verifyBracketing ( min  max  f ). Set p1 = 1 . 0 - r3 instead of p1 = 0 . 5 *. ", "B_clean_title": ["remov", "clearresult", "clear", "result", "verifysequ", "verifi", "sequenc", "ad", "verifybracket", "verifi", "bracket", "min", "max", "set", "p1", "r3", "instead", "p1"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing ( ) to the function value accuracy patch. Clarify a use case .. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "clarifi", "use", "case"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now clears the result of the last fix. Set iterationCount as it was done before the closure was opened .. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "clear", "result", "last", "fix", "set", "iterationcount", "iter", "count", "as", "it", "wa", "done", "befor", "closur", "wa", "open", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value  but not the initial guess. changed max value of BrentSolver to be 0 if ( yMax < min ). ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "but", "not", "initi", "guess", "chang", "max", "valu", "brentsolv", "brent", "solver", "ymax", "max", "min"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now clears the result of the last fix. I had made a mistake in the previous patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "clear", "result", "last", "fix", "had", "made", "mistak", "previou", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set iterationCount as well as verifyBracketing ( min  max  f ). ", "B_clean_title": ["set", "iterationcount", "iter", "count", "as", "well", "as", "verifybracket", "verifi", "bracket", "min", "max"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove a couple incorrect code lines. Set maxIterCount and verifyBracketing ( ) as well as maxIterCount. Added patch for function value min and max. ", "B_clean_title": ["remov", "coupl", "incorrect", "code", "line", "set", "maxitercount", "max", "iter", "count", "verifybracket", "verifi", "bracket", "as", "well", "as", "maxitercount", "max", "iter", "count", "ad", "patch", "function", "valu", "min", "max"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value ( already provided by valgrind ). Set function value accuracy to default  this way we can use the expanded function .. Fix erroneous test .. Fix erroneous variable. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "alreadi", "provid", "by", "valgrind", "set", "function", "valu", "accuraci", "default", "thi", "way", "we", "use", "expand", "function", "fix", "erron", "test", "fix", "erron", "variabl", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing ( min  max  f ). Added patch for BrentSolver. revert patch. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "min", "max", "ad", "patch", "brentsolv", "brent", "solver", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing ( ) to the function value accuracy patch. Remove a redundant patch. Added patch to erroneous integration test .. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "remov", "redund", "patch", "ad", "patch", "erron", "integr", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Reset function value accuracy to default function value accuracy. Added verifyBracketing ( ) to the function value accuracy patch. Added verifyBracketing to the BrentSolver. revert patch. ", "B_clean_title": ["reset", "function", "valu", "accuraci", "default", "function", "valu", "accuraci", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "ad", "verifybracket", "verifi", "bracket", "brentsolv", "brent", "solver", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added patch for variable max value function. Added verifyBracketing ( min  max  f ). revert patch. ", "B_clean_title": ["ad", "patch", "variabl", "max", "valu", "function", "ad", "verifybracket", "verifi", "bracket", "min", "max", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value .. Clarify BrentSolver . resultComputed with updated max value. Added patch for function value endpoints. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "clarifi", "brentsolv", "brent", "solver", "resultcomput", "result", "comput", "updat", "max", "valu", "ad", "patch", "function", "valu", "endpoint", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses Object . POSITIVE_INFINITY for parallel execution. Added verifyBracketing ( ) to the function value accuracy patch. Set iterationCount as it was done before the closure closure closure closure closure closure .. revert accidently change. BrentSolver now uses the old delta value .. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "object", "posit", "infin", "parallel", "execut", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "set", "iterationcount", "iter", "count", "as", "it", "wa", "done", "befor", "closur", "closur", "closur", "closur", "closur", "closur", "revert", "accid", "chang", "brentsolv", "brent", "solver", "now", "use", "old", "delta", "valu"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default  as it is done every time. Added verifyBracketing ( ) to the function value accuracy patch. Fixing a minor typo in the BrentSolver test. revert patch. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "as", "it", "done", "everi", "time", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "fix", "minor", "typo", "brentsolv", "brent", "solver", "test", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set x1 = 0 after verifying the pair. Added a throw to the right part of BrentSolver. Fix erroneous test .. ", "B_clean_title": ["set", "x1", "after", "verifi", "pair", "ad", "throw", "right", "part", "brentsolv", "brent", "solver", "fix", "erron", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix erroneous regression in BrentSolver. I had left it harwired to verifyBracketing .. ", "B_clean_title": ["fix", "erron", "regress", "brentsolv", "brent", "solver", "had", "left", "it", "harwir", "verifybracket", "verifi", "bracket"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix erroneous integration with BrentSolver. I had left it as is done in the last commit .. Set iterationCount as - 1 . 5 for inverse quadratic interpolation .. ", "B_clean_title": ["fix", "erron", "integr", "brentsolv", "brent", "solver", "had", "left", "it", "as", "done", "last", "commit", "set", "iterationcount", "iter", "count", "as", "invers", "quadrat", "interpol"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set this . iterationCount to zero so that the function value is always good enough. revert patch. ", "B_clean_title": ["set", "thi", "iterationcount", "iter", "count", "zero", "so", "that", "function", "valu", "alway", "good", "enough", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing ( min  max  f ). ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "min", "max"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) call. changed vars as well. Set p1 = 1 . 0 - r3 instead of p1 = 0 . 5 *. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "call", "chang", "var", "as", "well", "set", "p1", "r3", "instead", "p1"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) call. Added verifyBracketing ( min  max  f ). Add the missing patch .. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "call", "ad", "verifybracket", "verifi", "bracket", "min", "max", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now clears the result of the last fix. Added patch for bracketing in BrentSolver. I had left it as is. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "clear", "result", "last", "fix", "ad", "patch", "bracket", "brentsolv", "brent", "solver", "had", "left", "it", "as", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set updated iteration count. Added patch for function value endpoints. revert patch. ", "B_clean_title": ["set", "updat", "iter", "count", "ad", "patch", "function", "valu", "endpoint", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) call. changed maxIterCount as well. I had left it harwired to verifyBracketing .. revert patch. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "call", "chang", "maxitercount", "max", "iter", "count", "as", "well", "had", "left", "it", "harwir", "verifybracket", "verifi", "bracket", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added patch for variable max value function. Added verifyBracketing ( ) to the function value accuracy patch. Clarify solution with the min value in the function valueAccuracy. Added missing variable .. ", "B_clean_title": ["ad", "patch", "variabl", "max", "valu", "function", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "clarifi", "solut", "min", "valu", "function", "valueaccuraci", "valu", "accuraci", "ad", "miss", "variabl"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing ( ) to the function value accuracy patch. Set iterationCount as well. Added patch to erroneous integration test .. Add a missing line. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "set", "iterationcount", "iter", "count", "as", "well", "ad", "patch", "erron", "integr", "test", "add", "miss", "line"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added x2 = max ; to the main objective function. Set iterationCount as it is normally possible to reuse the same x  y  yInitial .. revert patch. ", "B_clean_title": ["ad", "x2", "max", "main", "object", "function", "set", "iterationcount", "iter", "count", "as", "it", "normal", "possibl", "reus", "same", "yiniti", "initi", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now returns 0 iff y = = min ;. Reset the iterator count as well. I had left it as is. Fix erroneous test .. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "return", "iff", "min", "reset", "iter", "count", "as", "well", "had", "left", "it", "as", "fix", "erron", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added patch for 1 . 6 . 2. changed itercount. revert patch. ", "B_clean_title": ["ad", "patch", "chang", "itercount", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "revert patch. ", "B_clean_title": ["revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set x2 = max oversampling in BrentSolver. Added verifyBracketing ( ) to the function value accuracy patch. Remove a redundant patch. ", "B_clean_title": ["set", "x2", "max", "oversampl", "brentsolv", "brent", "solver", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "remov", "redund", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "changed erroneously set maxIterCount as well. Add back missing patch. ", "B_clean_title": ["chang", "erron", "set", "maxitercount", "max", "iter", "count", "as", "well", "add", "back", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "remove clearResult ( ) from verifySequence ( ). Fix erroneous variable. Add back missing patch .. revert patch. ", "B_clean_title": ["remov", "clearresult", "clear", "result", "verifysequ", "verifi", "sequenc", "fix", "erron", "variabl", "add", "back", "miss", "patch", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix erroneous test. Clarify BrentSolver . resultComputed with better accuracy .. Added patch for function value endpoints. revert patch. ", "B_clean_title": ["fix", "erron", "test", "clarifi", "brentsolv", "brent", "solver", "resultcomput", "result", "comput", "better", "accuraci", "ad", "patch", "function", "valu", "endpoint", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "I had left it as a last resort .. I had left it as is done in the last commit .. ", "B_clean_title": ["had", "left", "it", "as", "last", "resort", "had", "left", "it", "as", "done", "last", "commit"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added patch for 1 . 8 . 3. Set default function value accuracy using provided bracketing. ", "B_clean_title": ["ad", "patch", "set", "default", "function", "valu", "accuraci", "provid", "bracket"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove a couple incorrect lines. Set iterationCount as full Brent algorithm. Added patch to erroneous integration test .. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "set", "iterationcount", "iter", "count", "as", "full", "brent", "algorithm", "ad", "patch", "erron", "integr", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now clears the result of the last fix. Added verifyBracketing ( ) to the function value accuracy patch. changed max iter count. Add patch for wrong step .. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "clear", "result", "last", "fix", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "chang", "max", "iter", "count", "add", "patch", "wrong", "step"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set iterationCount = this . iterationCount + 1 ;. Added patch to prevent adding value to the same endpoint .. ", "B_clean_title": ["set", "iterationcount", "iter", "count", "thi", "iterationcount", "iter", "count", "ad", "patch", "prevent", "ad", "valu", "same", "endpoint"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value ( already provided by valgrind ). Set function value accuracy to default  this way we can use the expanded function .. Added patch for BrentSolver .. Fix erroneous variable. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "alreadi", "provid", "by", "valgrind", "set", "function", "valu", "accuraci", "default", "thi", "way", "we", "use", "expand", "function", "ad", "patch", "brentsolv", "brent", "solver", "fix", "erron", "variabl", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default function value accuracy in BrentSolver. Clarify the Brent solver with better error handling. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "function", "valu", "accuraci", "brentsolv", "brent", "solver", "clarifi", "brent", "solver", "better", "error", "handl"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added default function value accuracy checking for BrentSolver. revert patch. ", "B_clean_title": ["ad", "default", "function", "valu", "accuraci", "check", "brentsolv", "brent", "solver", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value ( already provided by valgrind ). Clarify BrentSolver with better error handling. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "alreadi", "provid", "by", "valgrind", "clarifi", "brentsolv", "brent", "solver", "better", "error", "handl", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added patch to verifySequence ( ). Added verifyBracketing ( ) to the function value accuracy patch. Remove a redundant patch. ", "B_clean_title": ["ad", "patch", "verifysequ", "verifi", "sequenc", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "remov", "redund", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value ( already provided by valgrind ). Clarify BrentSolver with better error handling. Fix erroneous test .. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "alreadi", "provid", "by", "valgrind", "clarifi", "brentsolv", "brent", "solver", "better", "error", "handl", "fix", "erron", "test", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added patch to verifySequence ( ). Added verifyBracketing ( ) to the function value accuracy patch. Clarify a use case for BrentSolver as well. Added missing variable .. ", "B_clean_title": ["ad", "patch", "verifysequ", "verifi", "sequenc", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "clarifi", "use", "case", "brentsolv", "brent", "solver", "as", "well", "ad", "miss", "variabl"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) call. Added verifyBracketing ( ) to the function value otherwise it will break the build .. I was confused  sorry. Add back missing patch .. revert patch. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "call", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "otherwis", "it", "will", "break", "build", "wa", "confus", "sorri", "add", "back", "miss", "patch", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "changed variable name for BrentSolver. I had left it as is. Fix erroneous test .. ", "B_clean_title": ["chang", "variabl", "name", "brentsolv", "brent", "solver", "had", "left", "it", "as", "fix", "erron", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the fixed value function  so it is normally possible to reuse it .. I had left it as is. Fix erroneous test .. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "fix", "valu", "function", "so", "it", "normal", "possibl", "reus", "it", "had", "left", "it", "as", "fix", "erron", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix erroneous regression in BrentSolver. Added verifyBracketing method to the BrentSolver class .. ", "B_clean_title": ["fix", "erron", "regress", "brentsolv", "brent", "solver", "ad", "verifybracket", "verifi", "bracket", "method", "brentsolv", "brent", "solver", "class"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set x2 = max oversampling in BrentSolver. Added patch to verifyBracketing ( min  max  f ). Clarify a use case for BrentSolver as well. revert patch. ", "B_clean_title": ["set", "x2", "max", "oversampl", "brentsolv", "brent", "solver", "ad", "patch", "verifybracket", "verifi", "bracket", "min", "max", "clarifi", "use", "case", "brentsolv", "brent", "solver", "as", "well", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "changed variable names. Set p1 = 1 . 0 - r3 instead of p1 = 0 . 5 *. ", "B_clean_title": ["chang", "variabl", "name", "set", "p1", "r3", "instead", "p1"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set default function value accuracy across the board. Remove erroneous test. I had left it harwired to verifyBracketing .. ", "B_clean_title": ["set", "default", "function", "valu", "accuraci", "across", "board", "remov", "erron", "test", "had", "left", "it", "harwir", "verifybracket", "verifi", "bracket"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) line. changed max value of BrentSolver to 0  this way we avoid an NPE. I had left it harwired to verifyBracketing  was causing some problem in the code. revert wrong patch. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "line", "chang", "max", "valu", "brentsolv", "brent", "solver", "thi", "way", "we", "avoid", "npe", "had", "left", "it", "harwir", "verifybracket", "verifi", "bracket", "wa", "caus", "some", "problem", "code", "revert", "wrong", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix variable name error in BrentSolver. changed max value of BrentSolver to verify bracketing. Add back missing patch. ", "B_clean_title": ["fix", "variabl", "name", "error", "brentsolv", "brent", "solver", "chang", "max", "valu", "brentsolv", "brent", "solver", "verifi", "bracket", "add", "back", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now returns 0 if the initial guess is good enough. Added verifyBracketing ( ) to the function value accuracy patch. Clarify solution with better error handling. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "return", "initi", "guess", "good", "enough", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "clarifi", "solut", "better", "error", "handl", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add i = 0 ;. Clarify BrentSolver with better error handling. Fix erroneous test .. ", "B_clean_title": ["add", "clarifi", "brentsolv", "brent", "solver", "better", "error", "handl", "fix", "erron", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "changed variable name for BrentSolver. Set function value accuracy to 0 if max is not good enough. Fix erroneous test .. Set x1 = x2 before setting result. revert patch. ", "B_clean_title": ["chang", "variabl", "name", "brentsolv", "brent", "solver", "set", "function", "valu", "accuraci", "max", "not", "good", "enough", "fix", "erron", "test", "set", "x1", "x2", "befor", "set", "result", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set this . iterationCount as this . x1 = x1 + 1 ;. Clarify variable name to match provided function value accuracy. revert patch. ", "B_clean_title": ["set", "thi", "iterationcount", "iter", "count", "as", "thi", "x1", "x1", "clarifi", "variabl", "name", "match", "provid", "function", "valu", "accuraci", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix erroneous variable name. Added patch to erroneous integration test .. ", "B_clean_title": ["fix", "erron", "variabl", "name", "ad", "patch", "erron", "integr", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set iterationCount as it is normally possible to reuse the same thread. Set iterationCount as it is normally possible to reuse the same x0 value as the min value. revert patch. ", "B_clean_title": ["set", "iterationcount", "iter", "count", "as", "it", "normal", "possibl", "reus", "same", "thread", "set", "iterationcount", "iter", "count", "as", "it", "normal", "possibl", "reus", "same", "x0", "valu", "as", "min", "valu", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Reset function value accuracy to default function value accuracy. Added verifyBracketing ( ) to the function value accuracy patch. Clarify solution with the fix from Wright. ", "B_clean_title": ["reset", "function", "valu", "accuraci", "default", "function", "valu", "accuraci", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "clarifi", "solut", "fix", "wright"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver patch was failing because I added another GLIBC - 2 closing loop. Added verifyBracketing ( ) to the function value accuracy patch. Set default function value accuracy to 1 . 0e - 15 ( minor ). Fix a minor bug in the same way as in the old german. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "patch", "wa", "fail", "becaus", "ad", "anoth", "glibc", "close", "loop", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "set", "default", "function", "valu", "accuraci", "0e", "15", "minor", "fix", "minor", "bug", "same", "way", "as", "old", "german", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "remove clearResult ( ) from BrentSolver. Remove erroneous test. Set iterationCount and default function value accuracy. Added patch for function value coherency. ", "B_clean_title": ["remov", "clearresult", "clear", "result", "brentsolv", "brent", "solver", "remov", "erron", "test", "set", "iterationcount", "iter", "count", "default", "function", "valu", "accuraci", "ad", "patch", "function", "valu", "coher"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added patch for 1 . 8 . 3 .. Clarify solution with better error handling. ", "B_clean_title": ["ad", "patch", "clarifi", "solut", "better", "error", "handl"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value .. Fixing erroneous variable. Added patch for function value endpoints. Add 284 patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "fix", "erron", "variabl", "ad", "patch", "function", "valu", "endpoint", "add", "284", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove a couple incorrect lines. Set iterationCount as well as verifyBracketing ( min  max  f ). Added patch to erroneous integration test .. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "set", "iterationcount", "iter", "count", "as", "well", "as", "verifybracket", "verifi", "bracket", "min", "max", "ad", "patch", "erron", "integr", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set iterationCount and default function value accuracy. Added patch to prevent app from being loaded into workflow. ", "B_clean_title": ["set", "iterationcount", "iter", "count", "default", "function", "valu", "accuraci", "ad", "patch", "prevent", "app", "be", "load", "into", "workflow"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing to class path. Fix a minor bug in the same way as in the old german. revert patch. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "class", "path", "fix", "minor", "bug", "same", "way", "as", "old", "german", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "I had a bit more debug .. Fix erroneous variable. Add patch for easing of logistics .. ", "B_clean_title": ["had", "bit", "more", "debug", "fix", "erron", "variabl", "add", "patch", "eas", "logist"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now clears the result of the last fix. Added patch for bracketing. Clarify variable name as match provided by the old pull request. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "clear", "result", "last", "fix", "ad", "patch", "bracket", "clarifi", "variabl", "name", "as", "match", "provid", "by", "old", "pull", "request", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set iterationCount = this . iterationCount + 1 ; as it was the case before the reverse. Add back missing patch. revert patch. ", "B_clean_title": ["set", "iterationcount", "iter", "count", "thi", "iterationcount", "iter", "count", "as", "it", "wa", "case", "befor", "revers", "add", "back", "miss", "patch", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix variable local variable warning. Added support for bracketing in BrentSolver. Fix a minor bug in the same way as in the old german. revert patch. ", "B_clean_title": ["fix", "variabl", "local", "variabl", "warn", "ad", "support", "bracket", "brentsolv", "brent", "solver", "fix", "minor", "bug", "same", "way", "as", "old", "german", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver patch was failing because I added another GLIBC - 2 closing loop. Added patch for bracketing in BrentSolver. Set default function value accuracy to 1 . 0e - 15 ( minor ). Fix a minor warning. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "patch", "wa", "fail", "becaus", "ad", "anoth", "glibc", "close", "loop", "ad", "patch", "bracket", "brentsolv", "brent", "solver", "set", "default", "function", "valu", "accuraci", "0e", "15", "minor", "fix", "minor", "warn", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add a fix for changed variable names in BrentSolver . java. Clarify BrentSolver with better error handling. Added patch to verifyInterval. ", "B_clean_title": ["add", "fix", "chang", "variabl", "name", "brentsolv", "brent", "solver", "java", "clarifi", "brentsolv", "brent", "solver", "better", "error", "handl", "ad", "patch", "verifyinterv", "verifi", "interv"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing ( min  max  f ). Add a missing return value in inverse quadratic interpolation. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "min", "max", "add", "miss", "return", "valu", "invers", "quadrat", "interpol"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now clears the result of the last fix. Added verifyBracketing ( ) to the function value accuracy patch. Set iterationCount as it was done before the closure closure closure closure closure closure .. revert accidently change. BrentSolver now uses the old delta value .. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "clear", "result", "last", "fix", "ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "set", "iterationcount", "iter", "count", "as", "it", "wa", "done", "befor", "closur", "closur", "closur", "closur", "closur", "closur", "revert", "accid", "chang", "brentsolv", "brent", "solver", "now", "use", "old", "delta", "valu"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix erroneous variable. revert patch. ", "B_clean_title": ["fix", "erron", "variabl", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyInterval ( min  max  f ) to BrentSolver. I had left it harwired to verifyBracketing .. ", "B_clean_title": ["ad", "verifyinterv", "verifi", "interv", "min", "max", "brentsolv", "brent", "solver", "had", "left", "it", "harwir", "verifybracket", "verifi", "bracket"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set iterationCount as it is only used when checking the sequence. Clarify variable name to match provided function value accuracy. revert patch. ", "B_clean_title": ["set", "iterationcount", "iter", "count", "as", "it", "onli", "use", "when", "check", "sequenc", "clarifi", "variabl", "name", "match", "provid", "function", "valu", "accuraci", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver doesn  t clear the result before attempting to use it. Fixing the BrentSolver bug .. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "doesn", "clear", "result", "befor", "attempt", "use", "it", "fix", "brentsolv", "brent", "solver", "bug", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Clarify a use case for bracketing the root .. I had left it harwired to verifyBracketing  was causing some problem in the code. revert patch. ", "B_clean_title": ["clarifi", "use", "case", "bracket", "root", "had", "left", "it", "harwir", "verifybracket", "verifi", "bracket", "wa", "caus", "some", "problem", "code", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) call. Fix erroneous variable. Add back missing patch .. revert patch. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "call", "fix", "erron", "variabl", "add", "back", "miss", "patch", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing ( ) to the function value accuracy patch. Clarify variable name to match provided input .. revert patch. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "function", "valu", "accuraci", "patch", "clarifi", "variabl", "name", "match", "provid", "input", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set iterationCount as it is normally possible to reuse old BrentSolver. ", "B_clean_title": ["set", "iterationcount", "iter", "count", "as", "it", "normal", "possibl", "reus", "old", "brentsolv", "brent", "solver"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value  but is not good enough. Clarify BrentSolver . resultComputed with better accuracy .. Added patch for function value coherency. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "but", "not", "good", "enough", "clarifi", "brentsolv", "brent", "solver", "resultcomput", "result", "comput", "better", "accuraci", "ad", "patch", "function", "valu", "coher", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value ( already provided by valgrind ). Clarify solution with better error handling. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "alreadi", "provid", "by", "valgrind", "clarifi", "solut", "better", "error", "handl"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "changed variable name for BrentSolver. Clarify BrentSolver with better error handling. Fix erroneous test .. ", "B_clean_title": ["chang", "variabl", "name", "brentsolv", "brent", "solver", "clarifi", "brentsolv", "brent", "solver", "better", "error", "handl", "fix", "erron", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing ( min  max  f ). ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "min", "max"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) call. Fix NPE in BrentSolver. I was confused  sorry. Add back missing patch. revert patch. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "call", "fix", "npe", "brentsolv", "brent", "solver", "wa", "confus", "sorri", "add", "back", "miss", "patch", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added patch to verifySequence. Set maxIterCount to zero if min is good enough .. revert patch. ", "B_clean_title": ["ad", "patch", "verifysequ", "verifi", "sequenc", "set", "maxitercount", "max", "iter", "count", "zero", "min", "good", "enough", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "remove clearResult ( ) from verifySequence ( ). Set iterationCount and default function value accuracy. ", "B_clean_title": ["remov", "clearresult", "clear", "result", "verifysequ", "verifi", "sequenc", "set", "iterationcount", "iter", "count", "default", "function", "valu", "accuraci"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the result of running f ( x  y ) instead of the min /. I had made a mistake in the previous patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "result", "run", "instead", "min", "had", "made", "mistak", "previou", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Clarify solution with the right function value. ", "B_clean_title": ["clarifi", "solut", "right", "function", "valu"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "remove clearResult ( ) from verifySequence ( ). Remove unused variable. Set iterationCount as well as the last set of functions. I had left it harwired to verifyBracketing  was causing some problem in the code. ", "B_clean_title": ["remov", "clearresult", "clear", "result", "verifysequ", "verifi", "sequenc", "remov", "unus", "variabl", "set", "iterationcount", "iter", "count", "as", "well", "as", "last", "set", "function", "had", "left", "it", "harwir", "verifybracket", "verifi", "bracket", "wa", "caus", "some", "problem", "code"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove erroneous test. Clarify solution with better error handling. Added patch to erroneous integration test .. ", "B_clean_title": ["remov", "erron", "test", "clarifi", "solut", "better", "error", "handl", "ad", "patch", "erron", "integr", "test"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "remove clearResult ( ) from BrentSolver. Added verifyBracketing ( min  max  f ). Set p1 = 1 . 0 - r3 instead of p1 = 0 . 5 *. ", "B_clean_title": ["remov", "clearresult", "clear", "result", "brentsolv", "brent", "solver", "ad", "verifybracket", "verifi", "bracket", "min", "max", "set", "p1", "r3", "instead", "p1"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix erroneous variable. revert patch. ", "B_clean_title": ["fix", "erron", "variabl", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) line. changed max value of BrentSolver to 0  this way we avoid an NPE. I had left it harwired to verifyBracketing  was causing some problem in the code. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "line", "chang", "max", "valu", "brentsolv", "brent", "solver", "thi", "way", "we", "avoid", "npe", "had", "left", "it", "harwir", "verifybracket", "verifi", "bracket", "wa", "caus", "some", "problem", "code"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the patched value ( already provided by valgrind ). Set default function value accuracy to 0 if max is good enough. Fix erroneous test .. Fix erroneous variable. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "patch", "valu", "alreadi", "provid", "by", "valgrind", "set", "default", "function", "valu", "accuraci", "max", "good", "enough", "fix", "erron", "test", "fix", "erron", "variabl"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "I had left it as a last resort .. I had left it harwired to the IGN patch .. revert patch. ", "B_clean_title": ["had", "left", "it", "as", "last", "resort", "had", "left", "it", "harwir", "ign", "patch", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "fixed NPE in UnivariateRealSolverImpl . verifyInterval. Fix broken patch. Add missing patch. ", "B_clean_title": ["fix", "npe", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "verifyinterv", "verifi", "interv", "fix", "broken", "patch", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set the result of the patch as it was clear before the patch was added .. Add missing patch. ", "B_clean_title": ["set", "result", "patch", "as", "it", "wa", "clear", "befor", "patch", "wa", "ad", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Reset the inverse of the patch to the last result .. Add missing patch. changed max iterations count. ", "B_clean_title": ["reset", "invers", "patch", "last", "result", "add", "miss", "patch", "chang", "max", "iter", "count"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) call. Added a solution if the function value is good enough. Add missing patch. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "call", "ad", "solut", "function", "valu", "good", "enough", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) call. Add missing patch. Added patch to root cause error .. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "call", "add", "miss", "patch", "ad", "patch", "root", "caus", "error"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. Fix swapped vec3s in BrentSolver . java. ", "B_clean_title": ["add", "miss", "patch", "fix", "swap", "vec3", "brentsolv", "brent", "solver", "java"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing exception. Fix swapped vecs in BrentSolver . java. ", "B_clean_title": ["add", "miss", "except", "fix", "swap", "vec", "brentsolv", "brent", "solver", "java"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) call. Add missing patch. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "call", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Reduce min and initial bracket the root .. Add missing patch. ", "B_clean_title": ["reduc", "min", "initi", "bracket", "root", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove a couple incorrect code lines. Set default function value accuracy back to 0 . 5 . 4. Add missing patch. ", "B_clean_title": ["remov", "coupl", "incorrect", "code", "line", "set", "default", "function", "valu", "accuraci", "back", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver does not clear the result flag at the end of a test. Add missing patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "not", "clear", "result", "flag", "at", "end", "test", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. Added missing patch. ", "B_clean_title": ["add", "miss", "patch", "ad", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now returns 0 if yMin is < 0 .. Add missing patch. Fix swapped deltas. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "return", "ymin", "min", "add", "miss", "patch", "fix", "swap", "delta"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Removed a redundant line. Add missing patch. ", "B_clean_title": ["remov", "redund", "line", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "added fix from pull request. Set function value accuracy to default function value accuracy. Add missing patch. ", "B_clean_title": ["ad", "fix", "pull", "request", "set", "function", "valu", "accuraci", "default", "function", "valu", "accuraci", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing exception. Set default function value accuracy to 1 . 0e - 15 .. ", "B_clean_title": ["add", "miss", "except", "set", "default", "function", "valu", "accuraci", "0e", "15"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "throw exception if function to solve cannot be null. Add missing patch. ", "B_clean_title": ["throw", "except", "function", "solv", "not", "null", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now returns 0 if yMin is < 0 .. Add missing patch. revert patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "return", "ymin", "min", "add", "miss", "patch", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix broken patch. Add missing patch. ", "B_clean_title": ["fix", "broken", "patch", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added a throw exception if the function value at endpoints do not have the same signs .. Set default function value accuracy to 1 . 0e - 15 .. ", "B_clean_title": ["ad", "throw", "except", "function", "valu", "at", "endpoint", "not", "have", "same", "sign", "set", "default", "function", "valu", "accuraci", "0e", "15"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. revert patch. ", "B_clean_title": ["add", "miss", "patch", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default value accuracy. Add missing patch. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "valu", "accuraci", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix broken patch. Add missing patch. ", "B_clean_title": ["fix", "broken", "patch", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Reset the inverse of the patch if it is better than the function value .. Add missing patch. ", "B_clean_title": ["reset", "invers", "patch", "it", "better", "than", "function", "valu", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. BrentSolver . setResult ( x1  i ) ;. ", "B_clean_title": ["add", "miss", "patch", "brentsolv", "brent", "solver", "setresult", "set", "result", "x1"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Reset the computed result as false in BrentSolver .. Add missing patch. Fix broken patch. ", "B_clean_title": ["reset", "comput", "result", "as", "fals", "brentsolv", "brent", "solver", "add", "miss", "patch", "fix", "broken", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. Add a throw exception if the function to solve cannot be null. ", "B_clean_title": ["add", "miss", "patch", "add", "throw", "except", "function", "solv", "not", "null"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyInterval to BrentSolver. ", "B_clean_title": ["ad", "verifyinterv", "verifi", "interv", "brentsolv", "brent", "solver"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver doesn  t clear the result before attempting to use it. Added a throw to the console. ", "B_clean_title": ["brentsolv", "brent", "solver", "doesn", "clear", "result", "befor", "attempt", "use", "it", "ad", "throw", "consol"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver doesn  t clear the result before attempting to use it. Add missing patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "doesn", "clear", "result", "befor", "attempt", "use", "it", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyInterval ( ) to function value function. Add missing patch. Fix a minor bug in BrentSolver. ", "B_clean_title": ["ad", "verifyinterv", "verifi", "interv", "function", "valu", "function", "add", "miss", "patch", "fix", "minor", "bug", "brentsolv", "brent", "solver"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. changed max iterations count. ", "B_clean_title": ["add", "miss", "patch", "chang", "max", "iter", "count"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Removed erroneous test. Added a throw to the console. ", "B_clean_title": ["remov", "erron", "test", "ad", "throw", "consol"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. revert accidently change. ", "B_clean_title": ["add", "miss", "patch", "revert", "accid", "chang"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "added update of erroneous line. Added a throw to the console. BrentSolver . setResult ( x1  i ) ;. ", "B_clean_title": ["ad", "updat", "erron", "line", "ad", "throw", "consol", "brentsolv", "brent", "solver", "setresult", "set", "result", "x1"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove a redundant patch. Add missing patch. ", "B_clean_title": ["remov", "redund", "patch", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "added fix from pull request. Fix broken patch. Add missing patch. ", "B_clean_title": ["ad", "fix", "pull", "request", "fix", "broken", "patch", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix broken patch. Add missing patch. ", "B_clean_title": ["fix", "broken", "patch", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added a solution if the solution is good enough. Add missing patch. ", "B_clean_title": ["ad", "solut", "solut", "good", "enough", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added missing exception check. ", "B_clean_title": ["ad", "miss", "except", "check"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added a throw to the console. Set default function value accuracy to 1 . 0e - 15 .. ", "B_clean_title": ["ad", "throw", "consol", "set", "default", "function", "valu", "accuraci", "0e", "15"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "add a throw exception if one of the interval is not a sequence. Add missing exception. ", "B_clean_title": ["add", "throw", "except", "one", "interv", "not", "sequenc", "add", "miss", "except"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to 0 .. Add missing patch. BrentSolver setResult ( x1  i ) ;. ", "B_clean_title": ["set", "function", "valu", "accuraci", "add", "miss", "patch", "brentsolv", "brent", "solver", "setresult", "set", "result", "x1"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added a throw to the console. revert accidently change to the old one. ", "B_clean_title": ["ad", "throw", "consol", "revert", "accid", "chang", "old", "one"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to 0 if yInitial is good enough .. Add missing patch. ", "B_clean_title": ["set", "function", "valu", "accuraci", "yiniti", "initi", "good", "enough", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added a result computed so that it can be used as the sole endpoint .. ", "B_clean_title": ["ad", "result", "comput", "so", "that", "it", "use", "as", "sole", "endpoint"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix broken patch. Add missing patch. ", "B_clean_title": ["fix", "broken", "patch", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added a throw exception if the function value at endpoints do not have the same signs .. ", "B_clean_title": ["ad", "throw", "except", "function", "valu", "at", "endpoint", "not", "have", "same", "sign"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default function value accuracy. Add missing patch. Add a throw exception if the function to solve cannot be null. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "function", "valu", "accuraci", "add", "miss", "patch", "add", "throw", "except", "function", "solv", "not", "null"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "added backprop to verifySequence ( ). Add missing patch. ", "B_clean_title": ["ad", "backprop", "verifysequ", "verifi", "sequenc", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default  as it is done with the default function value accuracy. Fix broken patch. Add missing patch. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "as", "it", "done", "default", "function", "valu", "accuraci", "fix", "broken", "patch", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "I had left it as a last resort .. Add missing patch. ", "B_clean_title": ["had", "left", "it", "as", "last", "resort", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Reset the iterator count as we proceeded to the next test. Add missing patch. ", "B_clean_title": ["reset", "iter", "count", "as", "we", "proceed", "next", "test", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "throw exception if function to solve is null. Added missing exception check. ", "B_clean_title": ["throw", "except", "function", "solv", "null", "ad", "miss", "except", "check"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "fixed a minor bug in UnivariateRealSolverImpl . verifyInterval. Added a throw to the console. revert accidently change to the old one. ", "B_clean_title": ["fix", "minor", "bug", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "verifyinterv", "verifi", "interv", "ad", "throw", "consol", "revert", "accid", "chang", "old", "one"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix the case for the min function to be good enough. Add missing patch. ", "B_clean_title": ["fix", "case", "min", "function", "good", "enough", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to 0 if endpoints are not good enough. ", "B_clean_title": ["set", "function", "valu", "accuraci", "endpoint", "are", "not", "good", "enough"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. Fixing a minor bug in BrentSolver .. ", "B_clean_title": ["add", "miss", "patch", "fix", "minor", "bug", "brentsolv", "brent", "solver"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. ", "B_clean_title": ["add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Removed a redundant line. Added a throw to the console. Fix erroneous cross - sentence error in BrentSolver. ", "B_clean_title": ["remov", "redund", "line", "ad", "throw", "consol", "fix", "erron", "cross", "sentenc", "error", "brentsolv", "brent", "solver"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default function value accuracy. Add missing patch. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "function", "valu", "accuraci", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set this . resultComputed to false in BrentSolver . java. Add missing patch. ", "B_clean_title": ["set", "thi", "resultcomput", "result", "comput", "fals", "brentsolv", "brent", "solver", "java", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix the case for the min function to work properly. Add missing patch. changed max iter count. ", "B_clean_title": ["fix", "case", "min", "function", "work", "properli", "add", "miss", "patch", "chang", "max", "iter", "count"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Reset the inverse of the patch if it is better than the function value .. Add missing patch. BrentSolver . setResult ( x1  i ) ;. ", "B_clean_title": ["reset", "invers", "patch", "it", "better", "than", "function", "valu", "add", "miss", "patch", "brentsolv", "brent", "solver", "setresult", "set", "result", "x1"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. Added patch to prevent adding iterations to the same thread. ", "B_clean_title": ["add", "miss", "patch", "ad", "patch", "prevent", "ad", "iter", "same", "thread"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "throw exception if function to solve is null. Add missing patch. ", "B_clean_title": ["throw", "except", "function", "solv", "null", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses 0 . 0 solution. Add missing patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "solut", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix broken patch. Add missing patch. ", "B_clean_title": ["fix", "broken", "patch", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing exception. changed parallel patch. ", "B_clean_title": ["add", "miss", "except", "chang", "parallel", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to 0 if y < min && y > max. Add missing patch. ", "B_clean_title": ["set", "function", "valu", "accuraci", "min", "max", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "throw exception if function to solve is null. Add missing patch. changed line. ", "B_clean_title": ["throw", "except", "function", "solv", "null", "add", "miss", "patch", "chang", "line"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added missing exception check. Fix broken patch. ", "B_clean_title": ["ad", "miss", "except", "check", "fix", "broken", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix test. Add missing patch. Add a throw exception if the function to solve cannot be null. ", "B_clean_title": ["fix", "test", "add", "miss", "patch", "add", "throw", "except", "function", "solv", "not", "null"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now returns 0 if yMin is < 0 .. Add missing patch. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "return", "ymin", "min", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix broken patch. Add missing exception. ", "B_clean_title": ["fix", "broken", "patch", "add", "miss", "except"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added a throw exception if the function value at endpoints do not have the same signs .. revert accidently change. ", "B_clean_title": ["ad", "throw", "except", "function", "valu", "at", "endpoint", "not", "have", "same", "sign", "revert", "accid", "chang"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "throw exception if function to solve cannot be null. Remove a redundant check. Added a throw to the console. ", "B_clean_title": ["throw", "except", "function", "solv", "not", "null", "remov", "redund", "check", "ad", "throw", "consol"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. Fix broken patch. ", "B_clean_title": ["add", "miss", "patch", "fix", "broken", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add a throw exception if we can  t find a solution. ", "B_clean_title": ["add", "throw", "except", "we", "find", "solut"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default value accuracy. Add missing exception. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "valu", "accuraci", "add", "miss", "except"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default function value accuracy. Add missing patch. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "function", "valu", "accuraci", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "fixed a minor bug in UnivariateRealSolverImpl . verifyInterval. Add missing patch. ", "B_clean_title": ["fix", "minor", "bug", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "verifyinterv", "verifi", "interv", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. ", "B_clean_title": ["add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Removed a redundant line. revert patch. ", "B_clean_title": ["remov", "redund", "line", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing exception. BrentSolver had a clear result ; removed redundant clearResult calls. ", "B_clean_title": ["add", "miss", "except", "brentsolv", "brent", "solver", "had", "clear", "result", "remov", "redund", "clearresult", "clear", "result", "call"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set default function value accuracy to 1 . 0e - 15 .. Add missing patch. Fixing a minor bug in BrentSolver .. ", "B_clean_title": ["set", "default", "function", "valu", "accuraci", "0e", "15", "add", "miss", "patch", "fix", "minor", "bug", "brentsolv", "brent", "solver"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix incorrect patch. Add missing patch. ", "B_clean_title": ["fix", "incorrect", "patch", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "added missing line. Add missing patch. ", "B_clean_title": ["ad", "miss", "line", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default function value accuracy. Add missing patch. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "function", "valu", "accuraci", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default value accuracy. Add missing patch. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "valu", "accuraci", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "added verifyBracketing. Add missing patch. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix broken patch. Add missing patch. ", "B_clean_title": ["fix", "broken", "patch", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses the result of running function with a lower tolerance .. Added a throw to the console. ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "result", "run", "function", "lower", "toler", "ad", "throw", "consol"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. revert patch. Add a throw exception if the function to solve cannot be null. ", "B_clean_title": ["add", "miss", "patch", "revert", "patch", "add", "throw", "except", "function", "solv", "not", "null"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing exception. BrentSolver . setResult ( x1  i ). ", "B_clean_title": ["add", "miss", "except", "brentsolv", "brent", "solver", "setresult", "set", "result", "x1"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default function value accuracy. I had made a mistake of failing test. Add missing patch. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "function", "valu", "accuraci", "had", "made", "mistak", "fail", "test", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set default function value accuracy. ", "B_clean_title": ["set", "default", "function", "valu", "accuraci"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. Fix changed delta .. ", "B_clean_title": ["add", "miss", "patch", "fix", "chang", "delta"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set default function value accuracy back to 0 . 1 . 0. Fix broken patch. Add missing patch. ", "B_clean_title": ["set", "default", "function", "valu", "accuraci", "back", "fix", "broken", "patch", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix the case for the min function to return the first endpoint. Add missing patch. ", "B_clean_title": ["fix", "case", "min", "function", "return", "first", "endpoint", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added a throw exception if the function value at endpoints do not have the same signs .. changed max iterations count. ", "B_clean_title": ["ad", "throw", "except", "function", "valu", "at", "endpoint", "not", "have", "same", "sign", "chang", "max", "iter", "count"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Set function value accuracy to default function value accuracy. Add missing patch. revert patch. ", "B_clean_title": ["set", "function", "valu", "accuraci", "default", "function", "valu", "accuraci", "add", "miss", "patch", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix the merge of one - to - one calls into conferences. Add missing patch. Fix a minor bug in the BrentSolver such that yMin and yMax are not close to. ", "B_clean_title": ["fix", "merg", "one", "one", "call", "into", "confer", "add", "miss", "patch", "fix", "minor", "bug", "brentsolv", "brent", "solver", "such", "that", "ymin", "min", "ymax", "max", "are", "not", "close"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Remove redundant clearResult ( ) call. Set function value accuracy to default function value accuracy. Add missing patch. ", "B_clean_title": ["remov", "redund", "clearresult", "clear", "result", "call", "set", "function", "valu", "accuraci", "default", "function", "valu", "accuraci", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "update inverse patch. Added a throw to the console. revert patch. ", "B_clean_title": ["updat", "invers", "patch", "ad", "throw", "consol", "revert", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Add missing patch. improve stability of BrentSolver. ", "B_clean_title": ["add", "miss", "patch", "improv", "stabil", "brentsolv", "brent", "solver"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Reset the cached result of the BrentSolver such that it is not possible to reduce the interval of. Add missing patch. ", "B_clean_title": ["reset", "cach", "result", "brentsolv", "brent", "solver", "such", "that", "it", "not", "possibl", "reduc", "interv", "add", "miss", "patch"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "BrentSolver now uses verifyBracketing ( ). ", "B_clean_title": ["brentsolv", "brent", "solver", "now", "use", "verifybracket", "verifi", "bracket"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fix null pointer exception in UnivariateRealSolverImpl . verifyInterval. revert accidently change. ", "B_clean_title": ["fix", "null", "pointer", "except", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "verifyinterv", "verifi", "interv", "revert", "accid", "chang"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Repair fix from # 77. ", "B_clean_title": ["repair", "fix", "77"]},
{"A_title": "Crash on the web closure compilerNone", "A_clean_title": ["crash", "web", "closur", "compilernon", "compil", "none"], "B_title": "Removing old warning. Removing copyInformationFrom ( ) from replacements list .. ", "B_clean_title": ["remov", "old", "warn", "remov", "copyinformationfrom", "copi", "inform", "replac", "list"]},
{"A_title": "Crash on the web closure compilerNone", "A_clean_title": ["crash", "web", "closur", "compilernon", "compil", "none"], "B_title": "Add generated paramName to replacements  for efficiency .. Add paramName to closure context so it can be used by filer .. ", "B_clean_title": ["add", "gener", "paramnam", "param", "name", "replac", "effici", "add", "paramnam", "param", "name", "closur", "context", "so", "it", "use", "by", "filer"]},
{"A_title": "SystemUtils.getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime/Dalvik VMCan be replicated in the Android emulator quite easily. Stack trace:   at org.apache.commons.lang.builder.ToStringBuilder.<clinit>(ToStringBuilder.java:98) E/AndroidRuntime( 1681): ... 17 more E/AndroidRuntime( 1681): Caused by: java.lang.ExceptionInInitializerError E/AndroidRuntime( 1681): at org.apache.commons.lang.builder.ToStringStyle MultiLineToStringStyle.<init>(ToStringStyle.java:2276) E/AndroidRuntime( 1681): at org.apache.commons.lang.builder.ToStringStyle.<clinit>(ToStringStyle.java:94) E/AndroidRuntime( 1681): ... 18 more E/AndroidRuntime( 1681): Caused by: java.lang.StringIndexOutOfBoundsException E/AndroidRuntime( 1681): at java.lang.String.substring(String.java:1571) E/AndroidRuntime( 1681): at org.apache.commons.lang.SystemUtils.getJavaVersionAsFloat(SystemUtils.java:1153) E/AndroidRuntime( 1681): at org.apache.commons.lang.SystemUtils.<clinit>(SystemUtils.java:818)", "A_clean_title": ["systemutil", "getjavaversionasfloat", "system", "util", "get", "java", "version", "as", "float", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "android", "runtim", "dalvik", "vmcan", "vm", "replic", "android", "emul", "quit", "easili", "stack", "trace", "at", "org", "apach", "common", "lang", "builder", "tostringbuild", "string", "builder", "clinit", "tostringbuild", "java:98", "string", "builder", "androidruntim", "android", "runtim", "1681", "17", "more", "androidruntim", "android", "runtim", "1681", "caus", "by", "java", "lang", "exceptionininitializererror", "except", "initi", "error", "androidruntim", "android", "runtim", "1681", "at", "org", "apach", "common", "lang", "builder", "tostringstyl", "string", "style", "multilinetostringstyl", "multi", "line", "string", "style", "init", "tostringstyl", "java:2276", "string", "style", "androidruntim", "android", "runtim", "1681", "at", "org", "apach", "common", "lang", "builder", "tostringstyl", "string", "style", "clinit", "tostringstyl", "java:94", "string", "style", "androidruntim", "android", "runtim", "1681", "18", "more", "androidruntim", "android", "runtim", "1681", "caus", "by", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "androidruntim", "android", "runtim", "1681", "at", "java", "lang", "string", "substr", "string", "java:1571", "androidruntim", "android", "runtim", "1681", "at", "org", "apach", "common", "lang", "systemutil", "getjavaversionasfloat", "system", "util", "get", "java", "version", "as", "float", "systemutil", "java:1153", "system", "util", "androidruntim", "android", "runtim", "1681", "at", "org", "apach", "common", "lang", "systemutil", "system", "util", "clinit", "systemutil", "java:818", "system", "util"], "B_title": "Fix toJavaVersionInt from String to boolean. ", "B_clean_title": ["fix", "tojavaversionint", "java", "version", "int", "string", "boolean"]},
{"A_title": "Incomplete reinitialization with some events handlingI get a bug with event handling: I track 2 events that occur in the same step when the first one is accepted it resets the state but the reinitialization is not complete and the second one becomes unable to find its way. I cant give my context which is rather large but I tried a patch that works for me unfortunately it breaks the unit tests.", "A_clean_title": ["incomplet", "reiniti", "some", "event", "handlingi", "handl", "get", "bug", "event", "handl", "track", "event", "that", "occur", "same", "step", "when", "first", "one", "accept", "it", "reset", "state", "but", "reiniti", "not", "complet", "second", "one", "becom", "unabl", "find", "it", "way", "cant", "give", "my", "context", "which", "rather", "larg", "but", "tri", "patch", "that", "work", "me", "unfortun", "it", "break", "unit", "test"], "B_title": "Fix load / load of confix classes. Fix typo in EventState. ", "B_clean_title": ["fix", "load", "load", "confix", "class", "fix", "typo", "eventst", "event", "state"]},
{"A_title": "SerializationUtils throws ClassNotFoundException when cloning primitive classesIf a serializable object contains a reference to a primitive class e.g. int.class or int.class the SerializationUtils throw a ClassNotFoundException when trying to clone that object.  import org.apache.commons.lang3.SerializationUtils; import org.junit.Test;   public class SerializationUtilsTest    @Test public void primitiveTypeClassSerialization() Class<?> primitiveType = int.class;  Class<?> clone = SerializationUtils.clone(primitiveType); assertEquals(primitiveType clone);     The problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4. The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStreams resoleClass method without delegating to the super method in case of a ClassNotFoundException. I understand the intention of the ClassLoaderAwareObjectInputStream but this implementation should also implement a fallback to the original implementation. For example:          protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException ClassNotFoundException              String name = desc.getName();             try                  return Class.forName(name false classLoader);              catch (ClassNotFoundException ex)              try                   return Class.forName(name false Thread.currentThread().getContextClassLoader());              catch (Exception e)       return super.resolveClass(desc);                          Here is the code in ObjectInputStream that fixed the java bug.      protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException ClassNotFoundException      String name = desc.getName(); try      return Class.forName(name false latestUserDefinedLoader());  catch (ClassNotFoundException ex)      Class cl = (Class) primClasses.get(name);     if (cl != null)  return cl;      else  throw ex;           ", "A_clean_title": ["serializationutil", "serial", "util", "throw", "classnotfoundexcept", "class", "not", "found", "except", "when", "clone", "primit", "classesif", "class", "serializ", "object", "contain", "refer", "primit", "class", "int", "class", "or", "int", "class", "serializationutil", "serial", "util", "throw", "classnotfoundexcept", "class", "not", "found", "except", "when", "tri", "clone", "that", "object", "import", "org", "apach", "common", "lang3", "serializationutil", "serial", "util", "import", "org", "junit", "test", "public", "class", "serializationutilstest", "serial", "util", "test", "test", "public", "void", "primitivetypeclassseri", "primit", "type", "class", "serial", "class", "primitivetyp", "primit", "type", "int", "class", "class", "clone", "serializationutil", "clone", "serial", "util", "primitivetyp", "primit", "type", "assertequ", "assert", "equal", "primitivetyp", "primit", "type", "clone", "problem", "wa", "alreadi", "report", "as", "java", "bug", "http", "sun", "bug", "bug", "com", "view", "bug", "id=4171142", "objectinputstream", "object", "input", "stream", "fix", "sinc", "java", "version", "serializationutil", "serial", "util", "problem", "aris", "becaus", "serializationutil", "serial", "util", "intern", "use", "classloaderawareobjectinputstream", "class", "loader", "awar", "object", "input", "stream", "that", "overrid", "objectinputstream", "object", "input", "stream", "resoleclass", "resol", "class", "method", "without", "deleg", "super", "method", "case", "classnotfoundexcept", "class", "not", "found", "except", "understand", "intent", "classloaderawareobjectinputstream", "class", "loader", "awar", "object", "input", "stream", "but", "thi", "implement", "also", "implement", "fallback", "origin", "implement", "exampl", "protect", "class", "resolveclass", "resolv", "class", "objectstreamclass", "object", "stream", "class", "desc", "throw", "ioexcept", "io", "except", "classnotfoundexcept", "class", "not", "found", "except", "string", "name", "desc", "getnam", "get", "name", "tri", "return", "class", "fornam", "name", "name", "fals", "classload", "class", "loader", "catch", "classnotfoundexcept", "class", "not", "found", "except", "ex", "tri", "return", "class", "fornam", "name", "name", "fals", "thread", "currentthread", "current", "thread", "getcontextclassload", "get", "context", "class", "loader", "catch", "except", "return", "super", "resolveclass", "resolv", "class", "desc", "here", "code", "objectinputstream", "object", "input", "stream", "that", "fix", "java", "bug", "protect", "class", "resolveclass", "resolv", "class", "objectstreamclass", "object", "stream", "class", "desc", "throw", "ioexcept", "io", "except", "classnotfoundexcept", "class", "not", "found", "except", "string", "name", "desc", "getnam", "get", "name", "tri", "return", "class", "fornam", "name", "name", "fals", "latestuserdefinedload", "latest", "user", "defin", "loader", "catch", "classnotfoundexcept", "class", "not", "found", "except", "ex", "class", "cl", "class", "primclass", "get", "prim", "class", "name", "cl", "null", "return", "cl", "throw", "ex"], "B_title": "Remove unused resolveClass method. ", "B_clean_title": ["remov", "unus", "resolveclass", "resolv", "class", "method"]},
{"A_title": "SerializationUtils throws ClassNotFoundException when cloning primitive classesIf a serializable object contains a reference to a primitive class e.g. int.class or int.class the SerializationUtils throw a ClassNotFoundException when trying to clone that object.  import org.apache.commons.lang3.SerializationUtils; import org.junit.Test;   public class SerializationUtilsTest    @Test public void primitiveTypeClassSerialization() Class<?> primitiveType = int.class;  Class<?> clone = SerializationUtils.clone(primitiveType); assertEquals(primitiveType clone);     The problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4. The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStreams resoleClass method without delegating to the super method in case of a ClassNotFoundException. I understand the intention of the ClassLoaderAwareObjectInputStream but this implementation should also implement a fallback to the original implementation. For example:          protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException ClassNotFoundException              String name = desc.getName();             try                  return Class.forName(name false classLoader);              catch (ClassNotFoundException ex)              try                   return Class.forName(name false Thread.currentThread().getContextClassLoader());              catch (Exception e)       return super.resolveClass(desc);                          Here is the code in ObjectInputStream that fixed the java bug.      protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException ClassNotFoundException      String name = desc.getName(); try      return Class.forName(name false latestUserDefinedLoader());  catch (ClassNotFoundException ex)      Class cl = (Class) primClasses.get(name);     if (cl != null)  return cl;      else  throw ex;           ", "A_clean_title": ["serializationutil", "serial", "util", "throw", "classnotfoundexcept", "class", "not", "found", "except", "when", "clone", "primit", "classesif", "class", "serializ", "object", "contain", "refer", "primit", "class", "int", "class", "or", "int", "class", "serializationutil", "serial", "util", "throw", "classnotfoundexcept", "class", "not", "found", "except", "when", "tri", "clone", "that", "object", "import", "org", "apach", "common", "lang3", "serializationutil", "serial", "util", "import", "org", "junit", "test", "public", "class", "serializationutilstest", "serial", "util", "test", "test", "public", "void", "primitivetypeclassseri", "primit", "type", "class", "serial", "class", "primitivetyp", "primit", "type", "int", "class", "class", "clone", "serializationutil", "clone", "serial", "util", "primitivetyp", "primit", "type", "assertequ", "assert", "equal", "primitivetyp", "primit", "type", "clone", "problem", "wa", "alreadi", "report", "as", "java", "bug", "http", "sun", "bug", "bug", "com", "view", "bug", "id=4171142", "objectinputstream", "object", "input", "stream", "fix", "sinc", "java", "version", "serializationutil", "serial", "util", "problem", "aris", "becaus", "serializationutil", "serial", "util", "intern", "use", "classloaderawareobjectinputstream", "class", "loader", "awar", "object", "input", "stream", "that", "overrid", "objectinputstream", "object", "input", "stream", "resoleclass", "resol", "class", "method", "without", "deleg", "super", "method", "case", "classnotfoundexcept", "class", "not", "found", "except", "understand", "intent", "classloaderawareobjectinputstream", "class", "loader", "awar", "object", "input", "stream", "but", "thi", "implement", "also", "implement", "fallback", "origin", "implement", "exampl", "protect", "class", "resolveclass", "resolv", "class", "objectstreamclass", "object", "stream", "class", "desc", "throw", "ioexcept", "io", "except", "classnotfoundexcept", "class", "not", "found", "except", "string", "name", "desc", "getnam", "get", "name", "tri", "return", "class", "fornam", "name", "name", "fals", "classload", "class", "loader", "catch", "classnotfoundexcept", "class", "not", "found", "except", "ex", "tri", "return", "class", "fornam", "name", "name", "fals", "thread", "currentthread", "current", "thread", "getcontextclassload", "get", "context", "class", "loader", "catch", "except", "return", "super", "resolveclass", "resolv", "class", "desc", "here", "code", "objectinputstream", "object", "input", "stream", "that", "fix", "java", "bug", "protect", "class", "resolveclass", "resolv", "class", "objectstreamclass", "object", "stream", "class", "desc", "throw", "ioexcept", "io", "except", "classnotfoundexcept", "class", "not", "found", "except", "string", "name", "desc", "getnam", "get", "name", "tri", "return", "class", "fornam", "name", "name", "fals", "latestuserdefinedload", "latest", "user", "defin", "loader", "catch", "classnotfoundexcept", "class", "not", "found", "except", "ex", "class", "cl", "class", "primclass", "get", "prim", "class", "name", "cl", "null", "return", "cl", "throw", "ex"], "B_title": "Fix possible NPE in RSRepairDefects4J_Lang_13. ", "B_clean_title": ["fix", "possibl", "npe", "rsrepairdefects4j", "lang", "13", "rs", "repair", "defects4j"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "don  t sort XYSeries by default. ", "B_clean_title": ["don", "sort", "xyseri", "xy", "seri", "by", "default"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Updated chart with the new column doesn  t already exist .. ", "B_clean_title": ["updat", "chart", "new", "column", "doesn", "alreadi", "exist"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "AddOrUpdate ( double x  double y ). ", "B_clean_title": ["addorupd", "add", "or", "updat", "doubl", "doubl"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fixed bug in XYSeries. ", "B_clean_title": ["fix", "bug", "xyseri", "xy", "seri"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fix bug in XYSeries. ", "B_clean_title": ["fix", "bug", "xyseri", "xy", "seri"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fix bug in XYSeries. ", "B_clean_title": ["fix", "bug", "xyseri", "xy", "seri"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fix - issue with the XYSeries class - patch. ", "B_clean_title": ["fix", "issu", "xyseri", "xy", "seri", "class", "patch"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "don  t allow duplicate x values in XYSeries. ", "B_clean_title": ["don", "allow", "duplic", "valu", "xyseri", "xy", "seri"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Don  t allow duplicate x values in XYSeries. ", "B_clean_title": ["don", "allow", "duplic", "valu", "xyseri", "xy", "seri"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fixed issue with XYSeries . add ( ). ", "B_clean_title": ["fix", "issu", "xyseri", "xy", "seri", "add"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fix bug in XYSeries addOrUpdate. ", "B_clean_title": ["fix", "bug", "xyseri", "xy", "seri", "addorupd", "add", "or", "updat"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Improved method to append XYDataItems. ", "B_clean_title": ["improv", "method", "append", "xydataitem", "xy", "data", "item"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Add some missing imports. Fix bug in addOrUpdate. ", "B_clean_title": ["add", "some", "miss", "import", "fix", "bug", "addorupd", "add", "or", "updat"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fix bug in chart. ", "B_clean_title": ["fix", "bug", "chart"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Remove an overwritten throw exception if it is null. Improved method to append XYSeries items. Fix overwritten variable. ", "B_clean_title": ["remov", "overwritten", "throw", "except", "it", "null", "improv", "method", "append", "xyseri", "xy", "seri", "item", "fix", "overwritten", "variabl"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Remove an overwritten check. Improved method to append XYSeries items. ", "B_clean_title": ["remov", "overwritten", "check", "improv", "method", "append", "xyseri", "xy", "seri", "item"]},
{"A_title": "testing for symmetric positive definite matrix in CholeskyDecompositionI used this matrix:         double cv =   0.40434286 0.09376327 0.30328980 0.04909388   0.09376327 0.10400408 0.07137959 0.04762857   0.30328980 0.07137959 0.30458776 0.04882449             0.04909388 0.04762857 0.04882449 0.07543265         ;  And it works fine because it is symmetric positive definite  I tried this matrix:          double cv =              0.40434286 -0.09376327 0.30328980 0.04909388             -0.09376327 0.10400408 0.07137959 0.04762857             0.30328980 0.07137959 0.30458776 0.04882449              0.04909388 0.04762857 0.04882449 0.07543265         ; And it should throw an exception but it does not.  I tested the matrix in R and Rs cholesky decomposition method returns that the matrix is not symmetric positive definite. Obviously your code is not catching this appropriately. By the way (in my opinion) the use of exceptions to check these conditions is not the best design or use for exceptions.  If you are going to force the use to try and catch these exceptions at least provide methods  to test the conditions prior to the possibility of the exception.", "A_clean_title": ["test", "symmetr", "posit", "definit", "matrix", "choleskydecompositioni", "choleski", "decomposit", "use", "thi", "matrix", "doubl", "cv", "40434286", "09376327", "30328980", "04909388", "09376327", "10400408", "07137959", "04762857", "30328980", "07137959", "30458776", "04882449", "04909388", "04762857", "04882449", "07543265", "it", "work", "fine", "becaus", "it", "symmetr", "posit", "definit", "tri", "thi", "matrix", "doubl", "cv", "40434286", "09376327", "30328980", "04909388", "09376327", "10400408", "07137959", "04762857", "30328980", "07137959", "30458776", "04882449", "04909388", "04762857", "04882449", "07543265", "it", "throw", "except", "but", "it", "not", "test", "matrix", "rs", "choleski", "decomposit", "method", "return", "that", "matrix", "not", "symmetr", "posit", "definit", "obvious", "your", "code", "not", "catch", "thi", "appropri", "by", "way", "my", "opinion", "use", "except", "check", "these", "condit", "not", "best", "design", "or", "use", "except", "you", "are", "go", "forc", "use", "tri", "catch", "these", "except", "at", "least", "provid", "method", "test", "condit", "prior", "possibl", "except"], "B_title": "throw exception if abs / max is not greater than threshold. ", "B_clean_title": ["throw", "except", "ab", "max", "not", "greater", "than", "threshold"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Add a isNaN check. ", "B_clean_title": ["add", "isnan", "na", "check"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Add the missing isNaN in Complex . isNaN ( ) .. ", "B_clean_title": ["add", "miss", "isnan", "na", "complex", "isnan", "na"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Add the isNaN check. ", "B_clean_title": ["add", "isnan", "na", "check"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fix isNaN in complex comparison output. ", "B_clean_title": ["fix", "isnan", "na", "complex", "comparison", "output"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fix isNaN. ", "B_clean_title": ["fix", "isnan", "na"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fix NaN in Object . equals ( ). ", "B_clean_title": ["fix", "nan", "na", "object", "equal"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fixed a bug in Complex . reciprocal ( ). ", "B_clean_title": ["fix", "bug", "complex", "reciproc"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Extend reciprocal to fix max claims. ", "B_clean_title": ["extend", "reciproc", "fix", "max", "claim"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fix potential inf special case for complex type in code. Removed unnecessary equals implementation. ", "B_clean_title": ["fix", "potenti", "inf", "special", "case", "complex", "type", "code", "remov", "unnecessari", "equal", "implement"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fixed a minor typo in Complex . reciprocal ( ). Removed unnecessary equals implementation. ", "B_clean_title": ["fix", "minor", "typo", "complex", "reciproc", "remov", "unnecessari", "equal", "implement"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fix potential inf special case for complex type in code. ", "B_clean_title": ["fix", "potenti", "inf", "special", "case", "complex", "type", "code"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Revert back to NaN since it  s defined in the old one. Fix toString ( ) of Complex. ", "B_clean_title": ["revert", "back", "nan", "na", "sinc", "it", "defin", "old", "one", "fix", "tostr", "string", "complex"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "fix a minor infinity in Complex . reciprocal ( ). Removed unnecessary equals implementation. ", "B_clean_title": ["fix", "minor", "infin", "complex", "reciproc", "remov", "unnecessari", "equal", "implement"]},
{"A_title": "Erroneous optimization in ADVANCED_OPTIMIZATIONS modeNone", "A_clean_title": ["erron", "optim", "advanc", "optim", "modenon", "mode", "none"], "B_title": "Allow side effects for function arguments  see canBeSideEffected for the corresponding // @ javadoc. ", "B_clean_title": ["allow", "side", "effect", "function", "argument", "see", "canbesideeffect", "side", "effect", "correspond", "javadoc"]},
{"A_title": "Erroneous optimization in ADVANCED_OPTIMIZATIONS modeNone", "A_clean_title": ["erron", "optim", "advanc", "optim", "modenon", "mode", "none"], "B_title": "Allow side effects for function arguments. ", "B_clean_title": ["allow", "side", "effect", "function", "argument"]},
{"A_title": "Erroneous optimization in ADVANCED_OPTIMIZATIONS modeNone", "A_clean_title": ["erron", "optim", "advanc", "optim", "modenon", "mode", "none"], "B_title": "Allow inline with function calls via @ isDirectCallNodeReplacementPossible. ", "B_clean_title": ["allow", "inlin", "function", "call", "via", "isdirectcallnodereplacementposs", "direct", "call", "node", "replac", "possibl"]},
{"A_title": "Statistics.setVarianceImpl makes getStandardDeviation produce NaNInvoking SummaryStatistics.setVarianceImpl(new Variance(true/false) makes getStandardDeviation produce NaN. The code to reproduce it:  int scores = 1 2 3 4; SummaryStatistics stats = new SummaryStatistics(); stats.setVarianceImpl(new Variance(false)); //use population variance for(int i : scores)    stats.addValue(i);  double sd = stats.getStandardDeviation(); System.out.println(sd);   A workaround suggested by Mikkel is:    double sd = FastMath.sqrt(stats.getSecondMoment() / stats.getN());", "A_clean_title": ["statist", "setvarianceimpl", "set", "varianc", "impl", "make", "getstandarddevi", "get", "standard", "deviat", "produc", "naninvok", "na", "invok", "summarystatist", "setvarianceimpl", "summari", "statist", "set", "varianc", "impl", "new", "varianc", "true", "fals", "make", "getstandarddevi", "get", "standard", "deviat", "produc", "nan", "na", "code", "reproduc", "it", "int", "score", "summarystatist", "summari", "statist", "stat", "new", "summarystatist", "summari", "statist", "stat", "setvarianceimpl", "set", "varianc", "impl", "new", "varianc", "fals", "use", "popul", "varianc", "int", "score", "stat", "addvalu", "add", "valu", "doubl", "sd", "stat", "getstandarddevi", "get", "standard", "deviat", "system", "out", "println", "sd", "workaround", "suggest", "by", "mikkel", "doubl", "sd", "fastmath", "sqrt", "fast", "math", "stat", "getsecondmo", "get", "second", "moment", "stat", "getn", "get"], "B_title": "Added missing if / else .. Fix secondMoment increment .. Fix minor bug in SummaryStatistics. ", "B_clean_title": ["ad", "miss", "fix", "secondmo", "second", "moment", "increment", "fix", "minor", "bug", "summarystatist", "summari", "statist"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "StrBuilder delete doesn  t overwrite the capacity. ", "B_clean_title": ["strbuilder", "str", "builder", "delet", "doesn", "overwrit", "capac"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "StrBuilder . contains ( ) now returns true if the builder contains the character. ", "B_clean_title": ["strbuilder", "str", "builder", "contain", "now", "return", "true", "builder", "contain", "charact"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "StrBuilder . contains ( ) uses the array copy constructor. ", "B_clean_title": ["strbuilder", "str", "builder", "contain", "use", "array", "copi", "constructor"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Added missing 1111. ", "B_clean_title": ["ad", "miss", "1111"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( ). Fix buffer size too large. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( ). Fix buffer size > = length ( ). ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( len + 1 ). Fix buffer size too large. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "len", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "reset nullText if it is empty string ( # 1267 ). Fix buffer size too large. ", "B_clean_title": ["reset", "nulltext", "null", "text", "it", "empti", "string", "1267", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "reset nullText on deleteFirst ( ). Fix buffer size > = length ( ). ", "B_clean_title": ["reset", "nulltext", "null", "text", "deletefirst", "delet", "first", "fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add more ensureCapacity .. Fix buffer size too large. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( size + 4 ). Fix buffer size too large. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "size", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fix ensureCapacity .. Fix buffer size > = length ( ). ", "B_clean_title": ["fix", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( ). Fix buffer size increase. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "increas"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add throw inside if / else .. fixed a small bug. ", "B_clean_title": ["add", "throw", "insid", "fix", "small", "bug"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fix ensureCapacity .. Fix buffer size > = length ( ). ", "B_clean_title": ["fix", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fix buffer size > = length ( ). ", "B_clean_title": ["fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Revert previous patch. ", "B_clean_title": ["revert", "previou", "patch"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add missing ensureCapacity .. Fix buffer size too large. ", "B_clean_title": ["add", "miss", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "StrBuilder deleteFirst ( ) returns this if the builder is empty .. Fix buffer size too large. ", "B_clean_title": ["strbuilder", "str", "builder", "deletefirst", "delet", "first", "return", "thi", "builder", "empti", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fix buffer size increase. ", "B_clean_title": ["fix", "buffer", "size", "increas"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add patch for nullText builder. Fix buffer size too large. ", "B_clean_title": ["add", "patch", "nulltext", "null", "text", "builder", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add accidently removed backslash. ", "B_clean_title": ["add", "accid", "remov", "backslash"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add line separator. Fix buffer size too large. ", "B_clean_title": ["add", "line", "separ", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( len + 1 ) if we have > 0 length. Fix buffer size too large. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "len", "we", "have", "length", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add patch for letter case. Fix buffer size too large. ", "B_clean_title": ["add", "patch", "letter", "case", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "Switched order of delete key and key in statements changes semanticNone", "A_clean_title": ["switch", "order", "delet", "key", "key", "statement", "chang", "semanticnon", "semant", "none"], "B_title": "Remove one more test. ", "B_clean_title": ["remov", "one", "more", "test"]},
{"A_title": "Variable names prefixed with MSG_ cause error with advanced optimizationsNone", "A_clean_title": ["variabl", "name", "prefix", "msg", "caus", "error", "advanc", "optimizationsnon", "optim", "none"], "B_title": "Fix cruise - add - message - bundle. ", "B_clean_title": ["fix", "cruis", "add", "messag", "bundl"]},
{"A_title": "Variable names prefixed with MSG_ cause error with advanced optimizationsNone", "A_clean_title": ["variabl", "name", "prefix", "msg", "caus", "error", "advanc", "optimizationsnon", "optim", "none"], "B_title": "HHH - 9733 - Set typeBasedOptimizationOptions ( ) to the right level so it. ", "B_clean_title": ["hhh", "9733", "set", "typebasedoptimizationopt", "type", "base", "optim", "option", "right", "level", "so", "it"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix bug for empty range. ", "B_clean_title": ["fix", "bug", "empti", "rang"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix bug # 944. ", "B_clean_title": ["fix", "bug", "944"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix bug in TimeSeries . java. ", "B_clean_title": ["fix", "bug", "timeseri", "time", "seri", "java"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix an issue with TimeSeries . isEmptyRange ( ) .. ", "B_clean_title": ["fix", "issu", "timeseri", "time", "seri", "isemptyrang", "empti", "rang"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix a bug in chart_9_TimeSeries_t. ", "B_clean_title": ["fix", "bug", "chart", "timeseri", "time", "seri"]},
{"A_title": "One of Variance.evaluate() methods does not work correctlyThe method org.apache.commons.math.stat.descriptive.moment.Variance.evaluate(double values double weights double mean int begin int length) does not work properly. Looks loke it ignores the length parameter and grabs the whole dataset. Similar method in Mean class seems to work. I did not check other methods taking the part of the array; they may have the same problem. Workaround: I had to shrink my arrays and use the method without the length.", "A_clean_title": ["one", "varianc", "evalu", "method", "not", "work", "correctlyth", "correctli", "method", "org", "apach", "common", "math", "stat", "descript", "moment", "varianc", "evalu", "doubl", "valu", "doubl", "weight", "doubl", "mean", "int", "begin", "int", "length", "not", "work", "properli", "look", "loke", "it", "ignor", "length", "paramet", "grab", "whole", "dataset", "similar", "method", "mean", "class", "seem", "work", "did", "not", "check", "other", "method", "take", "part", "array", "they", "may", "have", "same", "problem", "workaround", "had", "shrink", "my", "array", "use", "method", "without", "length"], "B_title": "Fix the var test .. ", "B_clean_title": ["fix", "var", "test"]},
{"A_title": "One of Variance.evaluate() methods does not work correctlyThe method org.apache.commons.math.stat.descriptive.moment.Variance.evaluate(double values double weights double mean int begin int length) does not work properly. Looks loke it ignores the length parameter and grabs the whole dataset. Similar method in Mean class seems to work. I did not check other methods taking the part of the array; they may have the same problem. Workaround: I had to shrink my arrays and use the method without the length.", "A_clean_title": ["one", "varianc", "evalu", "method", "not", "work", "correctlyth", "correctli", "method", "org", "apach", "common", "math", "stat", "descript", "moment", "varianc", "evalu", "doubl", "valu", "doubl", "weight", "doubl", "mean", "int", "begin", "int", "length", "not", "work", "properli", "look", "loke", "it", "ignor", "length", "paramet", "grab", "whole", "dataset", "similar", "method", "mean", "class", "seem", "work", "did", "not", "check", "other", "method", "take", "part", "array", "they", "may", "have", "same", "problem", "workaround", "had", "shrink", "my", "array", "use", "method", "without", "length"], "B_title": "Added missing if (. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "removed loop. ", "B_clean_title": ["remov", "loop"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "Fix bug in StringUtils. ", "B_clean_title": ["fix", "bug", "stringutil", "string", "util"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "match any string with spaces  fixes # 3642. ", "B_clean_title": ["match", "ani", "string", "space", "fix", "3642"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "added missing loop. ", "B_clean_title": ["ad", "miss", "loop"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "added fix. ", "B_clean_title": ["ad", "fix"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "remove replacementList . length ( ). ", "B_clean_title": ["remov", "replacementlist", "replac", "list", "length"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "start = textIndex + searchList  replaceIndex  . length ( ). ", "B_clean_title": ["start", "textindex", "text", "index", "searchlist", "search", "list", "replaceindex", "replac", "index", "length"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "added missing if (. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "added missing patch. ", "B_clean_title": ["ad", "miss", "patch"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "Fix bug in StringUtils. Fix bug in StringUtils. ", "B_clean_title": ["fix", "bug", "stringutil", "string", "util", "fix", "bug", "stringutil", "string", "util"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "Added throw exception if search and replace array lengths do not match. revert accidently change. remove a for loop. ", "B_clean_title": ["ad", "throw", "except", "search", "replac", "array", "length", "not", "match", "revert", "accid", "chang", "remov", "loop"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "removed unnecessary check for null / non - empty text fields. remove a for loop. ", "B_clean_title": ["remov", "unnecessari", "check", "null", "non", "empti", "text", "field", "remov", "loop"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "remove accidently leftover from StringUtils. ", "B_clean_title": ["remov", "accid", "leftov", "stringutil", "string", "util"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "remove unused patch. ", "B_clean_title": ["remov", "unus", "patch"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "throw exception if timeToLive < 0. remove a unused variable. ", "B_clean_title": ["throw", "except", "timetol", "time", "live", "remov", "unus", "variabl"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "revert accidently change for StringUtils. remove a for loop. ", "B_clean_title": ["revert", "accid", "chang", "stringutil", "string", "util", "remov", "loop"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "revert accidently change. remove a redundant line. ", "B_clean_title": ["revert", "accid", "chang", "remov", "redund", "line"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "removed unnecessary check for null / non - empty text fields. reset replaceIndex. remove a for loop. fixed NPE and NPE in StringUtils. ", "B_clean_title": ["remov", "unnecessari", "check", "null", "non", "empti", "text", "field", "reset", "replaceindex", "replac", "index", "remov", "loop", "fix", "npe", "npe", "stringutil", "string", "util"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a small bug in Precision . nextAfter ( double  double ). Fix NPE. FastMath . nextAfter ( unscaled  Double . NEGATIVE_INFINITY ) doesn  t work. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "small", "bug", "precis", "nextaft", "next", "after", "doubl", "doubl", "fix", "npe", "fastmath", "fast", "math", "nextaft", "next", "after", "unscal", "doubl", "neg", "infin", "doesn", "work", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix Colt precision reduction. Add one line for precision patch. Fix for redundant rounding in BigDecimal precision test. Fix precision warning. ", "B_clean_title": ["fix", "colt", "precis", "reduct", "add", "one", "line", "precis", "patch", "fix", "redund", "round", "bigdecim", "big", "decim", "precis", "test", "fix", "precis", "warn"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a small bug in Precision . ceil ( ) .. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "small", "bug", "precis", "ceil", "fix", "nextaft", "next", "after", "bigdecim", "big", "decim", "precis", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix precision bug. Remove nextAfter in Precision . java. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "precis", "bug", "remov", "nextaft", "next", "after", "precis", "java", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in Math_8e5867ed .. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "math", "8e5867", "fix", "nextaft", "next", "after", "bigdecim", "big", "decim", "precis", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix precision issue. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "precis", "issu", "fix", "nextaft", "next", "after", "bigdecim", "big", "decim", "precis", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix one more test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "one", "more", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in Math_8e5867ed .. Add one line  as per EvilSeph  s request. Fix 64 - bit precision mistake. FixBigDecimal roundoff. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "math", "8e5867", "add", "one", "line", "as", "per", "evilseph", "evil", "seph", "request", "fix", "64", "bit", "precis", "mistak", "fixbigdecim", "fix", "big", "decim", "roundoff", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Add a facta field to precision . abs. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["add", "facta", "field", "precis", "ab", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix 64 bit fallthrough in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "64", "bit", "fallthrough", "bigdecim", "big", "decim", "precis", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in Math_8e5867ed .. Fix a bug in BigDecimal precision. Fix precision issue. FixBigDecimal roundoff. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "math", "8e5867", "fix", "bug", "bigdecim", "big", "decim", "precis", "fix", "precis", "issu", "fixbigdecim", "fix", "big", "decim", "roundoff", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix reduceResults. Add one line for precision patch. Fix a bug in BigDecimal precision checking. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "reduceresult", "reduc", "result", "add", "one", "line", "precis", "patch", "fix", "bug", "bigdecim", "big", "decim", "precis", "check", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in BigDecimal precision. Fix a minor issue with floor ( ) / 2 . 0 being too far away. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "bigdecim", "big", "decim", "precis", "fix", "minor", "issu", "floor", "be", "too", "far", "away", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in BigDecimal precision. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "bigdecim", "big", "decim", "precis", "fix", "nextaft", "next", "after", "bigdecim", "big", "decim", "precis", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in BigDecimal precision. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "bigdecim", "big", "decim", "precis", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in the precision of Math_8e5867ed. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "precis", "math", "8e5867", "fix", "nextaft", "next", "after", "bigdecim", "big", "decim", "precis", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in BigDecimal precision. Fix nextAfter in Math_8e5867ed. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "bigdecim", "big", "decim", "precis", "fix", "nextaft", "next", "after", "math", "8e5867", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix Colt rounding bug. Add one line for precision patch. Fix for previous round. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "colt", "round", "bug", "add", "one", "line", "precis", "patch", "fix", "previou", "round", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Add pi2b precision. Fix the rounded corner case for BigDecimal precision .. Fix nextAfter in Math_8e5867ed. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["add", "pi2b", "precis", "fix", "round", "corner", "case", "bigdecim", "big", "decim", "precis", "fix", "nextaft", "next", "after", "math", "8e5867", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in Math_8e5867ed. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "math", "8e5867", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in Math_8e5867ed .. Fix floor. FastMath . nextAfter ( unscaled  Double . NEGATIVE_INFINITY ) added missing patch. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "math", "8e5867", "fix", "floor", "fastmath", "fast", "math", "nextaft", "next", "after", "unscal", "doubl", "neg", "infin", "ad", "miss", "patch", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in Math_8e5867ed .. Fix the rounded angles of the precision column .. Fix a bug in the floor of Math . floor ( unscaled ) .. FastMath . nextAfter ( unscaled  Double . NEGATIVE_INFINITY ) fix. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "math", "8e5867", "fix", "round", "angl", "precis", "column", "fix", "bug", "floor", "math", "floor", "unscal", "fastmath", "fast", "math", "nextaft", "next", "after", "unscal", "doubl", "neg", "infin", "fix", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix MCP patch. Fix a bug in the rounded part of the Math class .. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "mcp", "patch", "fix", "bug", "round", "part", "math", "class", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix MCP patch. Remove nextAfter in BigDecimal precision. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "mcp", "patch", "remov", "nextaft", "next", "after", "bigdecim", "big", "decim", "precis", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Add zb to precision fix .. Fix a potential NPE in BigDecimal precision test. Fix the rounded angles of the precision column .. ", "B_clean_title": ["add", "zb", "precis", "fix", "fix", "potenti", "npe", "bigdecim", "big", "decim", "precis", "test", "fix", "round", "angl", "precis", "column"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Remove patch from unscaled precision test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["remov", "patch", "unscal", "precis", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a potential NPE in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "potenti", "npe", "bigdecim", "big", "decim", "precis", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix Colt precision reduction. Fix precision warning. Fix a bug in BigDecimal precision checking. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "colt", "precis", "reduct", "fix", "precis", "warn", "fix", "bug", "bigdecim", "big", "decim", "precis", "check", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "raw precision fix. Fix a small bug in Precision . nextAfter ( double  double ). Fix the rounded corner bug in Math_8e5867ed .. Fix PMD precision test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["raw", "precis", "fix", "fix", "small", "bug", "precis", "nextaft", "next", "after", "doubl", "doubl", "fix", "round", "corner", "bug", "math", "8e5867", "fix", "pmd", "precis", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Add pi2b precision. Fix the rounded corner case for BigDecimal precision .. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["add", "pi2b", "precis", "fix", "round", "corner", "case", "bigdecim", "big", "decim", "precis", "fix", "nextaft", "next", "after", "bigdecim", "big", "decim", "precis", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a small bug in Precision . nextAfter ( double  double ). FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "small", "bug", "precis", "nextaft", "next", "after", "doubl", "doubl", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix Colt precision reduction. Fix the bug for Java 8 . 5 .. Fix compile error. ", "B_clean_title": ["fix", "colt", "precis", "reduct", "fix", "bug", "java", "fix", "compil", "error"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Add a facta field to precision . abs. Remove patch from unscaled to ceil. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["add", "facta", "field", "precis", "ab", "remov", "patch", "unscal", "ceil", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix the rounded corner case for BigDecimal precision .. Fix nextAfter in Math_8e5867ed. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "round", "corner", "case", "bigdecim", "big", "decim", "precis", "fix", "nextaft", "next", "after", "math", "8e5867", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in BigDecimal precision. Fix precision thingie in java 8e5867ed. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "bigdecim", "big", "decim", "precis", "fix", "precis", "thingi", "java", "8e5867", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in BigDecimal precision. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "bigdecim", "big", "decim", "precis", "fix", "nextaft", "next", "after", "bigdecim", "big", "decim", "precis", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix Colt precision reduction. Add one line for precision patch. Fix for previous round. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "colt", "precis", "reduct", "add", "one", "line", "precis", "patch", "fix", "previou", "round", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in the rounded part of the Math class .. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "round", "part", "math", "class", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in Math_8e5867ed. Fix the rounded angles of the precision column .. ", "B_clean_title": ["fix", "bug", "math", "8e5867", "fix", "round", "angl", "precis", "column"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in BigDecimal precision. Add Rln10a patch .. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "bigdecim", "big", "decim", "precis", "add", "rln10a", "patch", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix Colt precision reduction. Fix precision warning. Fix for previous round. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "colt", "precis", "reduct", "fix", "precis", "warn", "fix", "previou", "round", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in Math_8e5867ed. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "math", "8e5867", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix precision bug. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "precis", "bug", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix precision bug. Fix a bug in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "precis", "bug", "fix", "bug", "bigdecim", "big", "decim", "precis", "test", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Incorrect rounding of floatpackage org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0 2 BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0 2) = 0.0 Precision.round(0.0 2 BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think same problem will be found at usage of other round modes.", "A_clean_title": ["incorrect", "round", "floatpackag", "org", "apach", "common", "math3", "util", "exampl", "usag", "round", "function", "precis", "class", "precis", "round", "0f", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "bigdecim", "big", "decim", "round", "up", "01", "precis", "round", "float", "precis", "round", "bigdecim", "big", "decim", "round", "up", "seem", "reason", "usag", "extend", "float", "doubl", "insid", "round", "function", "get", "influenc", "memori", "trash", "as", "valu", "think", "same", "problem", "will", "found", "at", "usag", "other", "round", "mode"], "B_title": "Fix a bug in BigDecimal precision. FastMath . ceil ( unscaled ) doesn  t fix the rounded angles .. ", "B_clean_title": ["fix", "bug", "bigdecim", "big", "decim", "precis", "fastmath", "fast", "math", "ceil", "unscal", "doesn", "fix", "round", "angl"]},
{"A_title": "Exception when parsing erroneous jsdoc: /**@return @code foo bar   *    baz. */None", "A_clean_title": ["except", "when", "pars", "erron", "jsdoc", "return", "code", "foo", "bar", "baz", "none"], "B_title": "Fix the return  s description for the current ( ) token .. ", "B_clean_title": ["fix", "return", "descript", "current", "token"]},
{"A_title": "Exception when parsing erroneous jsdoc: /**@return @code foo bar   *    baz. */None", "A_clean_title": ["except", "when", "pars", "erron", "jsdoc", "return", "code", "foo", "bar", "baz", "none"], "B_title": "don  t look ahead for empty lines. ", "B_clean_title": ["don", "look", "ahead", "empti", "line"]},
{"A_title": "Exception when parsing erroneous jsdoc: /**@return @code foo bar   *    baz. */None", "A_clean_title": ["except", "when", "pars", "erron", "jsdoc", "return", "code", "foo", "bar", "baz", "none"], "B_title": "Allow non - type annotations .. ", "B_clean_title": ["allow", "non", "type", "annot"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Fix avoid warning. ", "B_clean_title": ["fix", "avoid", "warn"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Remove patched put token equals method. Remove patch for rebase. ", "B_clean_title": ["revert", "updat", "latest", "patch", "remov", "patch", "put", "token", "equal", "method", "remov", "patch", "rebas"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patched commitTS. Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["remov", "patch", "committ", "commit", "ts", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache size . Revert  update to latest put token  after patch . remove blobStoreNeedsClose check. ", "B_clean_title": ["revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close", "check"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. don  t write initial commit. Revert  update to latest put token  after patch . Remove rethrowing of closed stream objects in patch. ", "B_clean_title": ["updat", "checkstyl", "don", "write", "initi", "commit", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "rethrow", "close", "stream", "object", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patched files. Revert  update to latest head . Remove patched put token equals method. ", "B_clean_title": ["remov", "patch", "file", "revert", "updat", "latest", "head", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to 2005 - 12 - 29 . Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "2005", "12", "29", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update tmp. Revert  update to latest cache with updated memory . Revert  update patch to match class name . ", "B_clean_title": ["updat", "tmp", "revert", "updat", "latest", "cach", "updat", "memori", "revert", "updat", "patch", "match", "class", "name"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache size . Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest oak - mk implements new constructor . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "oak", "mk", "implement", "new", "constructor", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. remove patched code. Remove patched put token equals method. ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "remov", "patch", "code", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove fail silently on stop ( ). Remove rethrowing of stderr in case of error. Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["remov", "fail", "silent", "stop", "remov", "rethrow", "stderr", "case", "error", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Revert  update to latest put token  after patch . update tmp. ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "revert", "updat", "latest", "put", "token", "after", "patch", "updat", "tmp"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Revert  update to latest put token  after patch . remove patched file. ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "file"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache with updated memory . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "cach", "updat", "memori", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update tmp. remove patched commitTS. Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["updat", "tmp", "remov", "patch", "committ", "commit", "ts", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update tmp. update checkstyle. Revert  update to latest put token  after patch . remove checkstyle blobstore close. ", "B_clean_title": ["updat", "tmp", "updat", "checkstyl", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "checkstyl", "blobstor", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "add patch. Revert  update to latest put token  after patch . ", "B_clean_title": ["add", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Remove rethrowing of deprecated API in DefaultRevisionStore. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "remov", "rethrow", "deprec", "api", "defaultrevisionstor", "default", "revis", "store", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patched commit ts. Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "commit", "ts", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest put token  after patch . remove patched file. remove blobStoreNeedsClose. ", "B_clean_title": ["revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "file", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest head . Revert  update to latest put token . Remove patch from tmp. ", "B_clean_title": ["revert", "updat", "latest", "head", "revert", "updat", "latest", "put", "token", "remov", "patch", "tmp"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Remove redundant shutdown method. Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "patch", "remov", "redund", "shutdown", "method", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patched commitTS. Remove redundant shutdown / restore lines. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "committ", "commit", "ts", "remov", "redund", "shutdown", "restor", "line", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update tmp. remove patched commit ts. Revert  update to latest put token  after patch . ", "B_clean_title": ["updat", "tmp", "remov", "patch", "commit", "ts", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update cache to not use full disk. Remove patch from tmp. Revert  update to latest put token  after patch . ", "B_clean_title": ["updat", "cach", "not", "use", "full", "disk", "remov", "patch", "tmp", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest put token  after patch . remove patched file. Remove IOUtils . closeQuietly for repo replication. ", "B_clean_title": ["revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "file", "remov", "ioutil", "io", "util", "closequietli", "close", "quietli", "repo", "replic"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest put token  after patch . remove patched file. ", "B_clean_title": ["revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "file"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patched file. remove patched commitTS. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "file", "remov", "patch", "committ", "commit", "ts", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write head twice. Remove patched put token equals method. update tmp. remove blobStoreNeedsClose. ", "B_clean_title": ["don", "write", "head", "twice", "remov", "patch", "put", "token", "equal", "method", "updat", "tmp", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patch for hadoop / fs / LengthFileChecksum . java. Revert  update to latest cache with updated memory . Revert  update to latest put token . ", "B_clean_title": ["remov", "patch", "hadoop", "fs", "lengthfilechecksum", "length", "file", "checksum", "java", "revert", "updat", "latest", "cach", "updat", "memori", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest head . Revert  check initialized . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "head", "revert", "check", "initi", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized before attempting to patch . Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "check", "initi", "befor", "attempt", "patch", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove closeQuietly. Remove patched put token equals method. ", "B_clean_title": ["remov", "closequietli", "close", "quietli", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patched file. Remove patched put token equals method. ", "B_clean_title": ["remov", "patch", "file", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  remove marked  after readIds ( ) . Revert  update to latest put token  after patching. ", "B_clean_title": ["revert", "remov", "mark", "after", "readid", "read", "id", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. don  t write head twice. Revert  update to latest put token  after patch . remove fail silently on stop ( ). ", "B_clean_title": ["updat", "checkstyl", "don", "write", "head", "twice", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "fail", "silent", "stop"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache size . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized . Revert  update to latest put token  after patch . remove patched gate commit. ", "B_clean_title": ["revert", "check", "initi", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "gate", "commit"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. Revert  update to latest put token  after patch . ", "B_clean_title": ["updat", "checkstyl", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write initial commit. Revert  update to latest put token  after patch . ", "B_clean_title": ["don", "write", "initi", "commit", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "check", "initi", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patch from tmp. Revert  update to latest put token  after patch . remove fail silently on stop ( ). ", "B_clean_title": ["remov", "patch", "tmp", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "fail", "silent", "stop"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest head . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "head", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patch from repo. Revert  update to latest put token  after patching . ", "B_clean_title": ["remov", "patch", "repo", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest . Remove patch_10w1 try . Revert  update to latest head of cache in case of need . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "remov", "patch", "10w1", "tri", "revert", "updat", "latest", "head", "cach", "case", "need", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove IOUtils . closeQuietly for patch_908. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "ioutil", "io", "util", "closequietli", "close", "quietli", "patch", "908", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patched file. don  t write head twice. Remove patched put token equals method. ", "B_clean_title": ["remov", "patch", "file", "don", "write", "head", "twice", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove rethrowing of closed streams in ` init ` file. Revert  update to latest head . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "rethrow", "close", "stream", "init", "file", "revert", "updat", "latest", "head", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized before attempting to patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "check", "initi", "befor", "attempt", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized . Revert  update to latest put token  after patch . Remove IOUtils . closeQuietly for patch_1268. ", "B_clean_title": ["revert", "check", "initi", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "ioutil", "io", "util", "closequietli", "close", "quietli", "patch", "1268"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patch. Remove redundant shutdown / restore of cache in case of error. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "remov", "redund", "shutdown", "restor", "cach", "case", "error", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to 2005 - 12 - 29 . Revert  update to latest put token  after patch . remove patch. ", "B_clean_title": ["revert", "updat", "2005", "12", "29", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patch for now. Revert  check initialized before attempting to patch . Remove rethrowing of stderr in case of error. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "now", "revert", "check", "initi", "befor", "attempt", "patch", "remov", "rethrow", "stderr", "case", "error", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write head twice. Revert  update to latest cache size . Remove patch from put token equals method. ", "B_clean_title": ["don", "write", "head", "twice", "revert", "updat", "latest", "cach", "size", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove possible NPE in dependency. Revert  update to latest patch . Revert  update to latest put token . ", "B_clean_title": ["remov", "possibl", "npe", "depend", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Remove patched put token equals method. remove blobStoreNeedsClose. ", "B_clean_title": ["revert", "updat", "latest", "patch", "remov", "patch", "put", "token", "equal", "method", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized before attempting to patch . remove patch_139. Revert  update to latest cache size . Revert  update patch to match class name . ", "B_clean_title": ["revert", "check", "initi", "befor", "attempt", "patch", "remov", "patch", "139", "revert", "updat", "latest", "cach", "size", "revert", "updat", "patch", "match", "class", "name"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache . Remove patch from tmp. Revert  update patch to match class name . ", "B_clean_title": ["revert", "updat", "latest", "cach", "remov", "patch", "tmp", "revert", "updat", "patch", "match", "class", "name"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write head twice. Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["don", "write", "head", "twice", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write initial commit. Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["don", "write", "initi", "commit", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update patch to match class name . remove fail silently on stop ( ). ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "patch", "match", "class", "name", "remov", "fail", "silent", "stop"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized before attempting to patch . don  t write initial commit. Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "check", "initi", "befor", "attempt", "patch", "don", "write", "initi", "commit", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose check. Remove patch for failing test. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "check", "remov", "patch", "fail", "test", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest head . don  t write initial commit. Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "head", "don", "write", "initi", "commit", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write head twice. Remove patch from tmp. Revert  update to latest put token  after patch . ", "B_clean_title": ["don", "write", "head", "twice", "remov", "patch", "tmp", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "shut down the hell for the duration of the upgrade. Revert  update to latest cache with updated memory . Revert  update to latest put token  after patch . ", "B_clean_title": ["shut", "down", "hell", "durat", "upgrad", "revert", "updat", "latest", "cach", "updat", "memori", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patch from tmp. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "tmp", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. remove patch_178. Revert  update to latest cache size . Revert  update to latest put token . ", "B_clean_title": ["updat", "checkstyl", "remov", "patch", "178", "revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove fail silently on stop ( ). Revert  update to latest cache size . Revert  update to latest put token . ", "B_clean_title": ["remov", "fail", "silent", "stop", "revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized . Revert  update to latest put token  after patch . remove blobStoreNeedsClose check. ", "B_clean_title": ["revert", "check", "initi", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close", "check"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  remove objects . clear ( ) . Revert  update patch to match class name . ", "B_clean_title": ["revert", "remov", "object", "clear", "revert", "updat", "patch", "match", "class", "name"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest head . Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["revert", "updat", "latest", "head", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. Remove rethrowing of deprecated API in DefaultRevisionStore. Revert  update to latest put token  after patch . ", "B_clean_title": ["updat", "checkstyl", "remov", "rethrow", "deprec", "api", "defaultrevisionstor", "default", "revis", "store", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest put token  after patch . remove patch for hadoop / fs / LengthFileChecksum . java. ", "B_clean_title": ["revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "hadoop", "fs", "lengthfilechecksum", "length", "file", "checksum", "java"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update tmp. Revert  update to latest cache . Revert  update to latest put token  after patch . ", "B_clean_title": ["updat", "tmp", "revert", "updat", "latest", "cach", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache size . Revert  update to latest . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest put token . remove blobStoreNeedsClose. ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patched commit ts. Revert  update to latest oak - mk . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "commit", "ts", "revert", "updat", "latest", "oak", "mk", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest head . Revert  update to latest oak - mk . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "head", "revert", "updat", "latest", "oak", "mk", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. don  t write head twice. Revert  update to latest put token  after patch . ", "B_clean_title": ["updat", "checkstyl", "don", "write", "head", "twice", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patch from tmp. Revert  update to latest put token . Revert  update to latest . ", "B_clean_title": ["remov", "patch", "tmp", "revert", "updat", "latest", "put", "token", "revert", "updat", "latest"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest oak - mk implements new constructor . Revert  update to latest put token . ", "B_clean_title": ["revert", "updat", "latest", "oak", "mk", "implement", "new", "constructor", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest oak - mk implements new constructor . Revert  update to latest put token  after patch . Remove IOUtils . closeQuietly for patch_3185 .. ", "B_clean_title": ["revert", "updat", "latest", "oak", "mk", "implement", "new", "constructor", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "ioutil", "io", "util", "closequietli", "close", "quietli", "patch", "3185"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest put token  after patch . remove patch for hadoop / fs / LengthFileChecksum . java. ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "hadoop", "fs", "lengthfilechecksum", "length", "file", "checksum", "java"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patched file. Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["remov", "patch", "file", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest head of cache in case of need . Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "head", "cach", "case", "need", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. Revert  update to latest patch . Remove patched put token equals method. ", "B_clean_title": ["updat", "checkstyl", "revert", "updat", "latest", "patch", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update tmp. Revert  update to 2005 - 12 - 29 . Revert  update to latest put token  after patch . ", "B_clean_title": ["updat", "tmp", "revert", "updat", "2005", "12", "29", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. Revert  update to latest put token . update tmp. ", "B_clean_title": ["updat", "checkstyl", "revert", "updat", "latest", "put", "token", "updat", "tmp"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  set rep to null . Revert  check initialized before attempting to patch . remove patched commitTS. Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "set", "rep", "null", "revert", "check", "initi", "befor", "attempt", "patch", "remov", "patch", "committ", "commit", "ts", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache with updated memory . Remove patch from put token equals method. remove blobStoreNeedsClose. ", "B_clean_title": ["revert", "updat", "latest", "cach", "updat", "memori", "remov", "patch", "put", "token", "equal", "method", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized before attempting to patch . Revert  check initialized . Revert  update patch to match class name . ", "B_clean_title": ["revert", "check", "initi", "befor", "attempt", "patch", "revert", "check", "initi", "revert", "updat", "patch", "match", "class", "name"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove fail silently on stop ( ). update checkstyle. Revert  check initialized . Revert  update to latest put token . ", "B_clean_title": ["remov", "fail", "silent", "stop", "updat", "checkstyl", "revert", "check", "initi", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Remove patched files. Remove patched put token equals method. ", "B_clean_title": ["revert", "updat", "latest", "patch", "remov", "patch", "file", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write head twice. Revert  update to latest put token  after patch . ", "B_clean_title": ["don", "write", "head", "twice", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patch from tmp. Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["remov", "patch", "tmp", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache with updated memory . don  t write head twice. Remove patched put token equals method. Revert  update to latest patch . ", "B_clean_title": ["revert", "updat", "latest", "cach", "updat", "memori", "don", "write", "head", "twice", "remov", "patch", "put", "token", "equal", "method", "revert", "updat", "latest", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest head . Revert  update to latest patch . Revert  update to latest put token . ", "B_clean_title": ["revert", "updat", "latest", "head", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache and shutdown ( ) . Revert  update to latest put token . remove patched file. ", "B_clean_title": ["revert", "updat", "latest", "cach", "shutdown", "revert", "updat", "latest", "put", "token", "remov", "patch", "file"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove fail silently on stop ( ). Remove redundant shutdown method. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "fail", "silent", "stop", "remov", "redund", "shutdown", "method", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache with updated data . Revert  update to latest put token . ", "B_clean_title": ["revert", "updat", "latest", "cach", "updat", "data", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write head twice. Revert  update patch to match class name . remove blobStoreNeedsClose. ", "B_clean_title": ["don", "write", "head", "twice", "revert", "updat", "patch", "match", "class", "name", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patch for now. update cache size to fix # 1227. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "now", "updat", "cach", "size", "fix", "1227", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  check initialized . Remove patched put token equals method. ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "check", "initi", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest put token  after patch . remove closeQuietly. ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "closequietli", "close", "quietli"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patched file. Revert  update to latest patch . Revert  update to latest put token . ", "B_clean_title": ["remov", "patch", "file", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized before attempting to patch . remove patched dirs. Revert  update to latest put token . ", "B_clean_title": ["revert", "check", "initi", "befor", "attempt", "patch", "remov", "patch", "dir", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patch from tmp. remove patched commit ts. Revert  update to latest oak - mk implements new constructor . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "tmp", "remov", "patch", "commit", "ts", "revert", "updat", "latest", "oak", "mk", "implement", "new", "constructor", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. Remove patched put token equals method. remove fail silently on stop ( ). ", "B_clean_title": ["updat", "checkstyl", "remov", "patch", "put", "token", "equal", "method", "remov", "fail", "silent", "stop"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Revert  check initialized before attempting to patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "revert", "check", "initi", "befor", "attempt", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache size . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest put token  after patch . Remove IOUtils . closeQuietly for repo replication. ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "ioutil", "io", "util", "closequietli", "close", "quietli", "repo", "replic"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write head twice. Remove redundant shutdown / restore of cache .. Revert  update to latest put token  after patch . ", "B_clean_title": ["don", "write", "head", "twice", "remov", "redund", "shutdown", "restor", "cach", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. Revert  update to latest oak - mk implements new constructor . Revert  update to latest put token  after patch . remove patch for hadoop / fs / LengthFileChecksum . java. ", "B_clean_title": ["updat", "checkstyl", "revert", "updat", "latest", "oak", "mk", "implement", "new", "constructor", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "hadoop", "fs", "lengthfilechecksum", "length", "file", "checksum", "java"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . don  t write initial commit. Revert  update to latest patch . Revert  update to latest put token  after patching . ", "B_clean_title": ["revert", "updat", "latest", "patch", "don", "write", "initi", "commit", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write head twice. Revert  update to latest oak - mk implements new constructor . Revert  update to latest put token . ", "B_clean_title": ["don", "write", "head", "twice", "revert", "updat", "latest", "oak", "mk", "implement", "new", "constructor", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest head . Revert  remove patched opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl. Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "head", "revert", "remov", "patch", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write initial commit. Revert  check initialized . Revert  update to latest put token . Remove patched file. ", "B_clean_title": ["don", "write", "initi", "commit", "revert", "check", "initi", "revert", "updat", "latest", "put", "token", "remov", "patch", "file"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest . Revert  check initialized before attempting to start. Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "revert", "check", "initi", "befor", "attempt", "start", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patched files. don  t write head twice. Remove patched put token equals method. ", "B_clean_title": ["remov", "patch", "file", "don", "write", "head", "twice", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update tmp. update checkstyle. Remove patched put token equals method. ", "B_clean_title": ["updat", "tmp", "updat", "checkstyl", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patch for same node. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "same", "node", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Revert  update to latest cache with updated memory . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "revert", "updat", "latest", "cach", "updat", "memori", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. update default revision store. Revert  update to latest put token  after patch . ", "B_clean_title": ["updat", "checkstyl", "updat", "default", "revis", "store", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update cache size to not increase in case of an update. Revert  update to latest put token  after patch . Revert  update to latest patch . ", "B_clean_title": ["updat", "cach", "size", "not", "increas", "case", "updat", "revert", "updat", "latest", "put", "token", "after", "patch", "revert", "updat", "latest", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove redundant shutdown / restore lines. Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["remov", "redund", "shutdown", "restor", "line", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache size . Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "set gcStart. Revert  update to latest put token  after patching . ", "B_clean_title": ["set", "gcstart", "gc", "start", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patch from tmp. remove patch_156. Revert  check initialized . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "tmp", "remov", "patch", "156", "revert", "check", "initi", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose check. Revert  update to 2005 - 12 - 29 . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "check", "revert", "updat", "2005", "12", "29", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache . Revert  update to latest patch . Revert  update to latest put token . ", "B_clean_title": ["revert", "updat", "latest", "cach", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patched directory. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "directori", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest source of authority . Revert  update to latest patch . Revert  update to latest put token . ", "B_clean_title": ["revert", "updat", "latest", "sourc", "author", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove fail silently on stop ( ). Revert  update to latest patch . Revert  update to latest put token . ", "B_clean_title": ["remov", "fail", "silent", "stop", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized . Revert  update to latest put token  after patch . remove patch for hadoop / fs / LengthFileChecksum . java. ", "B_clean_title": ["revert", "check", "initi", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "hadoop", "fs", "lengthfilechecksum", "length", "file", "checksum", "java"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest source / rdoc . Revert  update to 2005 - 12 - 29 . Revert  update to latest master ; . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "sourc", "rdoc", "revert", "updat", "2005", "12", "29", "revert", "updat", "latest", "master", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest ( = = snapshot ) . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "snapshot", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["updat", "checkstyl", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . don  t write head twice. Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "patch", "don", "write", "head", "twice", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache . Revert  update to latest patch . Remove patched put token equals method. ", "B_clean_title": ["revert", "updat", "latest", "cach", "revert", "updat", "latest", "patch", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest head . Remove patched put token equals method. remove blobStoreNeedsClose check. ", "B_clean_title": ["revert", "updat", "latest", "head", "remov", "patch", "put", "token", "equal", "method", "remov", "blobstoreneedsclos", "blob", "store", "need", "close", "check"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write initial commit. Revert  update to latest put token  after patch . Revert  update to latest patch . ", "B_clean_title": ["don", "write", "initi", "commit", "revert", "updat", "latest", "put", "token", "after", "patch", "revert", "updat", "latest", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest put token  after patch . remove shut down try catch block. Revert  update to latest patch . ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "shut", "down", "tri", "catch", "block", "revert", "updat", "latest", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Revert  update to latest cache with updated memory . Revert  update to latest cache . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "revert", "updat", "latest", "cach", "updat", "memori", "revert", "updat", "latest", "cach", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patched commit ts. Revert  update to latest put token . remove blobStoreNeedsClose. ", "B_clean_title": ["remov", "patch", "commit", "ts", "revert", "updat", "latest", "put", "token", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patch .. Revert  update to latest archive  started with . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "revert", "updat", "latest", "archiv", "start", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update checkstyle. Revert  update to latest put token  after patching . remove patched file. ", "B_clean_title": ["updat", "checkstyl", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "file"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest head . remove patch_187. Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "head", "remov", "patch", "187", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to 2005 - 12 - 29 . Revert  update to latest patch . Remove patched put token equals method. ", "B_clean_title": ["revert", "updat", "2005", "12", "29", "revert", "updat", "latest", "patch", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest put token . ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update tmp. Revert  update to latest head . remove patched commit ts. Revert  check initialized . Revert  update to latest put token  after patch . ", "B_clean_title": ["updat", "tmp", "revert", "updat", "latest", "head", "remov", "patch", "commit", "ts", "revert", "check", "initi", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest archive  started with . Revert  update to latest put token  after patching. update tmp. ", "B_clean_title": ["revert", "updat", "latest", "archiv", "start", "revert", "updat", "latest", "put", "token", "after", "patch", "updat", "tmp"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest put token  after patch . Revert  set rep to null . ", "B_clean_title": ["revert", "updat", "latest", "put", "token", "after", "patch", "revert", "set", "rep", "null"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  set rep to null . Revert  update to latest put token . ", "B_clean_title": ["revert", "set", "rep", "null", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  set rep to null . Revert  update to latest cache size . Revert  update to latest put token . ", "B_clean_title": ["revert", "set", "rep", "null", "revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest put token . ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest patch . Revert  update to latest put token . ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest oak - mk implements new constructor . Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["revert", "updat", "latest", "oak", "mk", "implement", "new", "constructor", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update tmp. Revert  update patch to match class name . ", "B_clean_title": ["updat", "tmp", "revert", "updat", "patch", "match", "class", "name"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. don  t write initial commit. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "don", "write", "initi", "commit", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write head twice. Revert  update to latest cache size . Revert  update to latest put token  after patch . Remove patch from tmp. remove blobStoreNeedsClose. ", "B_clean_title": ["don", "write", "head", "twice", "revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "tmp", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patched commitTS. Revert  update to latest cache size . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "committ", "commit", "ts", "revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove fail silently on stop ( ). Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "fail", "silent", "stop", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest head . Remove patched put token equals method. ", "B_clean_title": ["revert", "updat", "latest", "head", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove redundant shutdown / restore of cache .. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "redund", "shutdown", "restor", "cach", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose check. don  t write initial commit. Revert  remove patched opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "check", "don", "write", "initi", "commit", "revert", "remov", "patch", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write initial commit. Remove patch from tmp. Revert  update to latest put token  after patch . ", "B_clean_title": ["don", "write", "initi", "commit", "remov", "patch", "tmp", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache with updated memory . remove patch_120. Revert  update to latest put token . remove patch from tmp. ", "B_clean_title": ["revert", "updat", "latest", "cach", "updat", "memori", "remov", "patch", "120", "revert", "updat", "latest", "put", "token", "remov", "patch", "tmp"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patched put token equals method. remove blobStoreNeedsClose. ", "B_clean_title": ["remov", "patch", "put", "token", "equal", "method", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patched commitTS. Revert  update to latest patch . Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["remov", "patch", "committ", "commit", "ts", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to 2005 - 06 07 . remove closeQuietly. Revert  update patch to match class name . ", "B_clean_title": ["revert", "updat", "2005", "06", "07", "remov", "closequietli", "close", "quietli", "revert", "updat", "patch", "match", "class", "name"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write head twice. Revert  update to latest put token  after patch . remove fail silently on stop ( ). ", "B_clean_title": ["don", "write", "head", "twice", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "fail", "silent", "stop"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove closeQuietly. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "closequietli", "close", "quietli", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest put token  after patch . shut down the hell for the duration of the upgrade. ", "B_clean_title": ["revert", "updat", "latest", "put", "token", "after", "patch", "shut", "down", "hell", "durat", "upgrad"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache . Revert  update to latest put token  after patch . remove patched file. ", "B_clean_title": ["revert", "updat", "latest", "cach", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "file"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove redundant shutdown / restore of cache .. Revert  check initialized . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "redund", "shutdown", "restor", "cach", "revert", "check", "initi", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove unused opengl. Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "unus", "opengl", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Revert  update to latest cache size . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patch from tmp. Remove patch from put token equals method. remove patch. ", "B_clean_title": ["remov", "patch", "tmp", "remov", "patch", "put", "token", "equal", "method", "remov", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "added patch for readIds. Revert  update to 2005 - 06 07 . don  t write head twice. Revert  update to latest put token . ", "B_clean_title": ["ad", "patch", "readid", "read", "id", "revert", "updat", "2005", "06", "07", "don", "write", "head", "twice", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "cach", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest archive  started with . Revert  update to latest put token . Revert  update to latest patch . ", "B_clean_title": ["revert", "updat", "latest", "archiv", "start", "revert", "updat", "latest", "put", "token", "revert", "updat", "latest", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patch from gate. Revert  update to latest cache size . Revert  update patch to match class name . ", "B_clean_title": ["remov", "patch", "gate", "revert", "updat", "latest", "cach", "size", "revert", "updat", "patch", "match", "class", "name"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove fail silently on stop ( ). Revert  update to latest put token . remove blobStoreNeedsClose. ", "B_clean_title": ["remov", "fail", "silent", "stop", "revert", "updat", "latest", "put", "token", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write head twice. Revert  update to latest patch . Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["don", "write", "head", "twice", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to 2005 - 06 07 . Revert  update to latest cache size . Revert  update patch to match class name . ", "B_clean_title": ["revert", "updat", "2005", "06", "07", "revert", "updat", "latest", "cach", "size", "revert", "updat", "patch", "match", "class", "name"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Remove patch from put token equals method. ", "B_clean_title": ["revert", "updat", "latest", "patch", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose check. Revert  remove closeQuietly ( pm )  for readme. Revert  update to latest put token  after patching . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "check", "revert", "remov", "closequietli", "close", "quietli", "pm", "readm", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest put token  after patch . remove patched gate commit. ", "B_clean_title": ["revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "gate", "commit"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to 2005 - 06 07 . Revert  update to latest patch . Revert  update to latest put token . ", "B_clean_title": ["revert", "updat", "2005", "06", "07", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove closeQuietly. Remove patched files. Revert  update to latest put token . ", "B_clean_title": ["remov", "closequietli", "close", "quietli", "remov", "patch", "file", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove patched commit ts. Revert  check initialized . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "patch", "commit", "ts", "revert", "check", "initi", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized before attempting to patch . Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["revert", "check", "initi", "befor", "attempt", "patch", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "update gcpm. Revert  update to latest put token  after patch . ", "B_clean_title": ["updat", "gcpm", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write initial commit. Revert  update to latest patch . Remove patched put token equals method. ", "B_clean_title": ["don", "write", "initi", "commit", "revert", "updat", "latest", "patch", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest put token  after patch . Revert  update to latest patch . ", "B_clean_title": ["revert", "updat", "latest", "put", "token", "after", "patch", "revert", "updat", "latest", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove redundant shutdown / restore lines. Revert  update to latest put token  after patch . Fix commit of gate. ", "B_clean_title": ["remov", "redund", "shutdown", "restor", "line", "revert", "updat", "latest", "put", "token", "after", "patch", "fix", "commit", "gate"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to 2005 - 06 07 . Revert  update to latest head . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "2005", "06", "07", "revert", "updat", "latest", "head", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest patch . Revert  update to latest put token  after patch . remove blobStoreNeedsClose check. ", "B_clean_title": ["revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close", "check"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest put token  after patch . remove blobStoreNeedsClose. ", "B_clean_title": ["revert", "updat", "latest", "put", "token", "after", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. Revert  update to latest patch . Revert  update to latest put token  after patch . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized . Revert  update to latest put token  after patch . Revert  update to latest patch . ", "B_clean_title": ["revert", "check", "initi", "revert", "updat", "latest", "put", "token", "after", "patch", "revert", "updat", "latest", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose check. Revert  update to latest patch . Revert  update to latest put token . ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "check", "revert", "updat", "latest", "patch", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest . Revert  update to latest cache size . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "revert", "updat", "latest", "cach", "size", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Remove patch from put token equals method. Remove patch for now. remove closeQuietly. ", "B_clean_title": ["remov", "patch", "put", "token", "equal", "method", "remov", "patch", "now", "remov", "closequietli", "close", "quietli"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "don  t write initial commit. Revert  update to latest patch . Revert  update patch to match class name . ", "B_clean_title": ["don", "write", "initi", "commit", "revert", "updat", "latest", "patch", "revert", "updat", "patch", "match", "class", "name"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  check initialized before attempting to patch . remove patched commitTS. Revert  update to latest oak - mk . Revert  update to latest put token  after patch . Remove IOUtils . closeQuietly for patch_248. ", "B_clean_title": ["revert", "check", "initi", "befor", "attempt", "patch", "remov", "patch", "committ", "commit", "ts", "revert", "updat", "latest", "oak", "mk", "revert", "updat", "latest", "put", "token", "after", "patch", "remov", "ioutil", "io", "util", "closequietli", "close", "quietli", "patch", "248"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  remove marked  after readIds ( ) . Revert  update to 2005 - 12 - 29 . Revert  update to latest put token . ", "B_clean_title": ["revert", "remov", "mark", "after", "readid", "read", "id", "revert", "updat", "2005", "12", "29", "revert", "updat", "latest", "put", "token"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "remove blobStoreNeedsClose. don  t write initial commit. Remove patched put token equals method. ", "B_clean_title": ["remov", "blobstoreneedsclos", "blob", "store", "need", "close", "don", "write", "initi", "commit", "remov", "patch", "put", "token", "equal", "method"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest cache . Revert  update to latest put token  after patch . ", "B_clean_title": ["revert", "updat", "latest", "cach", "revert", "updat", "latest", "put", "token", "after", "patch"]},
{"A_title": "PutTokenImpl not thread safePutTokenImpl uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.", "A_clean_title": ["puttokenimpl", "put", "token", "impl", "not", "thread", "safeputtokenimpl", "safe", "put", "token", "impl", "use", "prefix", "increment", "static", "member", "gener", "presum", "uniqu", "identifi", "prefix", "increment", "not", "atom", "though", "which", "might", "result", "non", "uniqu", "id", "be", "gener"], "B_title": "Revert  update to latest put token  after patch . remove patch. remove blobStoreNeedsClose. ", "B_clean_title": ["revert", "updat", "latest", "put", "token", "after", "patch", "remov", "patch", "remov", "blobstoreneedsclos", "blob", "store", "need", "close"]},
{"A_title": "Break in finally block isnt optimized properlyNone", "A_clean_title": ["break", "final", "block", "isnt", "optim", "properlynon", "properli", "none"], "B_title": "Allow code to be removed from the map .. ", "B_clean_title": ["allow", "code", "remov", "map"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Fix cost relative tolerance in LevenbergMarquardtOptimizer . java. ", "B_clean_title": ["fix", "cost", "rel", "toler", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "java"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "remove one more line. Fix the bit between the two ends of the matrix  and the one in the reverseEach method. ", "B_clean_title": ["remov", "one", "more", "line", "fix", "bit", "between", "two", "end", "matrix", "one", "reverseeach", "revers", "each", "method"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Fix the case for better orthotoxical fit in LevenbergMarquardtOptimizer . java. ", "B_clean_title": ["fix", "case", "better", "orthotox", "fit", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "java"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Added missing throw in patch 158 Gaussian dataset. ", "B_clean_title": ["ad", "miss", "throw", "patch", "158", "gaussian", "dataset"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Added correction for typo in case of erroneous data. ", "B_clean_title": ["ad", "correct", "typo", "case", "erron", "data"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Fix regression in GaussianFitter .. ", "B_clean_title": ["fix", "regress", "gaussianfitt", "gaussian", "fitter"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Add back missing patch. Added a throw if necessary. Add insampling error. ", "B_clean_title": ["add", "back", "miss", "patch", "ad", "throw", "necessari", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert accidently removed from fit ( ) .. Add insampling error. Fix Gaussian function parameter length. ", "B_clean_title": ["revert", "accid", "remov", "fit", "add", "insampl", "error", "fix", "gaussian", "function", "paramet", "length"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Remove a couple of points that are not used .. ", "B_clean_title": ["revert", "accid", "remov", "param", "remov", "coupl", "point", "that", "are", "not", "use"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Added a null check. Add insampling error. ", "B_clean_title": ["revert", "accid", "remov", "param", "ad", "null", "check", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Added throw if observations . length < 4 to GaussianFitter . guess ( ). ", "B_clean_title": ["revert", "accid", "remov", "param", "ad", "throw", "observ", "length", "gaussianfitt", "gaussian", "fitter", "guess"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert change to GaussianFitter . fit ( ) .. Add insampling error. Add NPE if y is null. ", "B_clean_title": ["revert", "chang", "gaussianfitt", "gaussian", "fitter", "fit", "add", "insampl", "error", "add", "npe", "null"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Add NPE if points are null. ", "B_clean_title": ["revert", "accid", "remov", "param", "add", "npe", "point", "are", "null"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Put back previous patch. Reverted accidently removed param. Throw NPE if observations . length < 4. Throw an error if observations is null. ", "B_clean_title": ["put", "back", "previou", "patch", "revert", "accid", "remov", "param", "throw", "npe", "observ", "length", "throw", "error", "observ", "null"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed change from fit ( ) .. Allow null input array to be used for GaussianFitter .. Add missing param for GaussianFitter ( maxYIdx - > X ). ", "B_clean_title": ["revert", "accid", "remov", "chang", "fit", "allow", "null", "input", "array", "use", "gaussianfitt", "gaussian", "fitter", "add", "miss", "param", "gaussianfitt", "gaussian", "fitter", "maxyidx", "max", "idx"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Remove a couple of points that are not used .. Fix GaussianFitter parameter error. ", "B_clean_title": ["revert", "accid", "remov", "param", "remov", "coupl", "point", "that", "are", "not", "use", "fix", "gaussianfitt", "gaussian", "fitter", "paramet", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Add back missing patch. Remove a couple of points that are not used .. Fix GaussianFitter . sort ( ). ", "B_clean_title": ["add", "back", "miss", "patch", "remov", "coupl", "point", "that", "are", "not", "use", "fix", "gaussianfitt", "gaussian", "fitter", "sort"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert accidently removed from fit ( ) .. Add a patch for GaussianFitter . guess ( ). Add NPE if y is null. Add insampling error. ", "B_clean_title": ["revert", "accid", "remov", "fit", "add", "patch", "gaussianfitt", "gaussian", "fitter", "guess", "add", "npe", "null", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert accidently removed from fit ( ) .. Added throw exception if observations . length < 4. Add a throw if param  2  is not strictly positive. ", "B_clean_title": ["revert", "accid", "remov", "fit", "ad", "throw", "except", "observ", "length", "add", "throw", "param", "not", "strictli", "posit"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Add a throw if observations . length < 3. ", "B_clean_title": ["revert", "accid", "remov", "param", "add", "throw", "observ", "length"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Add insampling error. ", "B_clean_title": ["revert", "accid", "remov", "param", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert change to GaussianFitter . fit ( ) .. Add insampling error. ", "B_clean_title": ["revert", "chang", "gaussianfitt", "gaussian", "fitter", "fit", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Allow null input array to be used for GaussianFitter .. Add one exception. ", "B_clean_title": ["revert", "accid", "remov", "param", "allow", "null", "input", "array", "use", "gaussianfitt", "gaussian", "fitter", "add", "one", "except"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert accidently removed from fit ( ) .. Allow null input array to be used for GaussianFitter .. Add insampling error. ", "B_clean_title": ["revert", "accid", "remov", "fit", "allow", "null", "input", "array", "use", "gaussianfitt", "gaussian", "fitter", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Add NPE if observations is null. Fix GaussianFitter . isBetween ( y  x  y ) .. ", "B_clean_title": ["revert", "accid", "remov", "param", "add", "npe", "observ", "null", "fix", "gaussianfitt", "gaussian", "fitter", "isbetween", "between"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert change to GaussianFitter . fit ( ) .. Add insampling exception. ", "B_clean_title": ["revert", "chang", "gaussianfitt", "gaussian", "fitter", "fit", "add", "insampl", "except"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert change to GaussianFitter . fit ( ) .. Allow null input array to be used for GaussianFitter .. ", "B_clean_title": ["revert", "chang", "gaussianfitt", "gaussian", "fitter", "fit", "allow", "null", "input", "array", "use", "gaussianfitt", "gaussian", "fitter"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Add a dimension mismatch check. Reverted accidently removed param. Add insampling exception. ", "B_clean_title": ["add", "dimens", "mismatch", "check", "revert", "accid", "remov", "param", "add", "insampl", "except"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Add back missing patch. Remove a couple of points that are not used .. Added a null check. ", "B_clean_title": ["add", "back", "miss", "patch", "remov", "coupl", "point", "that", "are", "not", "use", "ad", "null", "check"]},
{"A_title": "Overzealous optimization confuses variablesNone", "A_clean_title": ["overzeal", "optim", "confus", "variablesnon", "variabl", "none"], "B_title": "Remove broke patch. ", "B_clean_title": ["remov", "broke", "patch"]},
{"A_title": "MathUtils.factorial(n) fails for n >= 17The result of MathUtils.factorial( n ) for n = 17 18 19 is wrong probably because of rounding errors in the double calculations. Replace the first line of MathUtilsTest.testFactorial() by         for (int i = 1; i <= 20; i++)  to check all valid arguments for the long result and see the failure. I suggest implementing a simple loop to multiply the long result - or even using a precomputed long - instead of adding logarithms.", "A_clean_title": ["mathutil", "factori", "math", "util", "fail", "17the", "result", "mathutil", "factori", "math", "util", "17", "18", "19", "wrong", "probabl", "becaus", "round", "error", "doubl", "calcul", "replac", "first", "line", "mathutilstest", "testfactori", "math", "util", "test", "test", "factori", "by", "int", "20", "i++", "check", "all", "valid", "argument", "long", "result", "see", "failur", "suggest", "implement", "simpl", "loop", "multipli", "long", "result", "or", "even", "precomput", "long", "instead", "ad", "logarithm"], "B_title": "removed erroneous legacy call in MathUtils. ", "B_clean_title": ["remov", "erron", "legaci", "call", "mathutil", "math", "util"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix for OE. Fix compile error. ", "B_clean_title": ["fix", "oe", "fix", "compil", "error"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix NPE in runge kutta integration loop. ", "B_clean_title": ["fix", "npe", "rung", "kutta", "integr", "loop"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix NPE in refactoring  see. Fix a minor bug in the code. ", "B_clean_title": ["fix", "npe", "refactor", "see", "fix", "minor", "bug", "code"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Reset stepStart after each runge test .. Fix test in parallel. ", "B_clean_title": ["reset", "stepstart", "step", "start", "after", "each", "rung", "test", "fix", "test", "parallel"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix bug in OE. Fix for OE. ", "B_clean_title": ["fix", "bug", "oe", "fix", "oe"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the code that was not working right now. Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "bug", "code", "that", "wa", "not", "work", "right", "now", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Remove sanity checks from test script. Set stepSize to Double . NaN for nonstiff integration. Fix NPE in runge kutta integator. ", "B_clean_title": ["remov", "saniti", "check", "test", "script", "set", "stepsiz", "step", "size", "doubl", "nan", "na", "nonstiff", "integr", "fix", "npe", "rung", "kutta", "integ"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Add one more test patch. Fix a bug in the interpolator .. ", "B_clean_title": ["add", "one", "more", "test", "patch", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the coherency checks of ANT ( and OE ). ", "B_clean_title": ["fix", "bug", "coher", "check", "ant", "oe"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix step size of JAR in reverse order ( fixes # 77 ). Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "step", "size", "jar", "revers", "order", "fix", "77", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Add stepStart variable to variable yDotTmp. Fix test in parallel. ", "B_clean_title": ["add", "stepstart", "step", "start", "variabl", "variabl", "ydottmp", "dot", "tmp", "fix", "test", "parallel"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Set stepSize to Double . NaN for parallel execution. Fix a bug in the interpolator .. ", "B_clean_title": ["set", "stepsiz", "step", "size", "doubl", "nan", "na", "parallel", "execut", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the code that was failing the other day .. Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "bug", "code", "that", "wa", "fail", "other", "day", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix minor bug in runge kutta integration loop. ", "B_clean_title": ["fix", "minor", "bug", "rung", "kutta", "integr", "loop"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Remove sanity checks from test script. Fix a bug in the step interpolator  s definition .. Fix a bug in the interpolator .. ", "B_clean_title": ["remov", "saniti", "check", "test", "script", "fix", "bug", "step", "interpol", "definit", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix for step size > = t. Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "step", "size", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Remove sanity checks from test script. Fix a bug in the step method. ", "B_clean_title": ["remov", "saniti", "check", "test", "script", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Remove sanity checks from test script. Fix minor bug in runge kutta integration. Fix a bug in the step method. ", "B_clean_title": ["remov", "saniti", "check", "test", "script", "fix", "minor", "bug", "rung", "kutta", "integr", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix for OE. Fix a bug in the step method. ", "B_clean_title": ["fix", "oe", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the code that binaries together with the others .. Fix a bug in the step method. ", "B_clean_title": ["fix", "bug", "code", "that", "binari", "togeth", "other", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix NPE in OE. Fix minor bug in runge kutta integration loop. ", "B_clean_title": ["fix", "npe", "oe", "fix", "minor", "bug", "rung", "kutta", "integr", "loop"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fixed a bug in the runge kutta integration test. Fix a bug in the step method. ", "B_clean_title": ["fix", "bug", "rung", "kutta", "integr", "test", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "added patch for runge kutta integator. Fix for OE. ", "B_clean_title": ["ad", "patch", "rung", "kutta", "integ", "fix", "oe"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fixed the bug where the polynomials were not being used .. Fix a bug in the runge kutta integator .. ", "B_clean_title": ["fix", "bug", "where", "polynomi", "were", "not", "be", "use", "fix", "bug", "rung", "kutta", "integ"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the code that binaries together with the others .. Fix for OE. ", "B_clean_title": ["fix", "bug", "code", "that", "binari", "togeth", "other", "fix", "oe"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix step size not being greater than t. Fix a bug where the step was not being applied  as the code now requires new interpolator .. ", "B_clean_title": ["fix", "step", "size", "not", "be", "greater", "than", "fix", "bug", "where", "step", "wa", "not", "be", "appli", "as", "code", "now", "requir", "new", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the code that was failing the other day .. Fix test in parallel. ", "B_clean_title": ["fix", "bug", "code", "that", "wa", "fail", "other", "day", "fix", "test", "parallel"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "fixed a small bug. Fix for OE. ", "B_clean_title": ["fix", "small", "bug", "fix", "oe"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix step size not being able to move between 0 and t - stepStart. Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "step", "size", "not", "be", "abl", "move", "between", "stepstart", "step", "start", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "minimize step size for nonstiffed rune kutta integrator. added missing patch. Fix for OE. ", "B_clean_title": ["minim", "step", "size", "nonstif", "rune", "kutta", "integr", "ad", "miss", "patch", "fix", "oe"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix bug in step number. Fix a bug in the step method. ", "B_clean_title": ["fix", "bug", "step", "number", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Add sanity checks back. added missing patch. Fix a bug in the interpolator .. ", "B_clean_title": ["add", "saniti", "check", "back", "ad", "miss", "patch", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix minor bug in runge kutta integration loop. ", "B_clean_title": ["fix", "minor", "bug", "rung", "kutta", "integr", "loop"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the step method. ", "B_clean_title": ["fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "added patch for runge kutta integration. Fix a bug in the step method. ", "B_clean_title": ["ad", "patch", "rung", "kutta", "integr", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a minor bug in the code. Fix a bug in the step method. ", "B_clean_title": ["fix", "minor", "bug", "code", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Remove sanity checks from test script. Fix a bug in the interpolator .. ", "B_clean_title": ["remov", "saniti", "check", "test", "script", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a minor bug in the code. Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "minor", "bug", "code", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Remove sanity checks from test script. added patch for runge kutta integration. Fix a bug in the step method. ", "B_clean_title": ["remov", "saniti", "check", "test", "script", "ad", "patch", "rung", "kutta", "integr", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "reset isLastStep = false ;. Fix minor bug in runge kutta integration loop. ", "B_clean_title": ["reset", "islaststep", "last", "step", "fals", "fix", "minor", "bug", "rung", "kutta", "integr", "loop"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the code that binaries together with the others .. Fix a bug in the coherency checks of ANT ( and OE ). ", "B_clean_title": ["fix", "bug", "code", "that", "binari", "togeth", "other", "fix", "bug", "coher", "check", "ant", "oe"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix bug in step number. Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "bug", "step", "number", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix NPE in AE Rigid Body < - > world collisions. Fix a minor bug in the code. Fix a bug in the step method. ", "B_clean_title": ["fix", "npe", "ae", "rigid", "bodi", "world", "collis", "fix", "minor", "bug", "code", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "adding stepSize to code. Fix a bug in the interpolator .. ", "B_clean_title": ["ad", "stepsiz", "step", "size", "code", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix step size not being greater than t. ", "B_clean_title": ["fix", "step", "size", "not", "be", "greater", "than"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "added patch for @@. Fix a bug in the interpolator .. ", "B_clean_title": ["ad", "patch", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix NPE in AE Rigid Body < - > world collisions. Fix bug in step interpolator for backwards compatibility. Fix a bug in the step method. ", "B_clean_title": ["fix", "npe", "ae", "rigid", "bodi", "world", "collis", "fix", "bug", "step", "interpol", "backward", "compat", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Add one more patch. Fix double step loop. ", "B_clean_title": ["add", "one", "more", "patch", "fix", "doubl", "step", "loop"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "NPE in runge kutta integators. Fix a bug in the interpolator .. ", "B_clean_title": ["npe", "rung", "kutta", "integ", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the code that binaries together with the others .. Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "bug", "code", "that", "binari", "togeth", "other", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the step interpolator patch .. Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "bug", "step", "interpol", "patch", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix minor bug in runge kutta integration loop. ", "B_clean_title": ["fix", "minor", "bug", "rung", "kutta", "integr", "loop"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix NPE in OE. ", "B_clean_title": ["fix", "npe", "oe"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Reset stepStart after each runge test .. Fix a bug in the interpolator .. ", "B_clean_title": ["reset", "stepstart", "step", "start", "after", "each", "rung", "test", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Add stepStart variable to equations  for rebase. Fix a minor bug in the code. ", "B_clean_title": ["add", "stepstart", "step", "start", "variabl", "equat", "rebas", "fix", "minor", "bug", "code"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Add sanity checks back. Fix for OE. ", "B_clean_title": ["add", "saniti", "check", "back", "fix", "oe"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Set stepSize to Double . NaN for nonstiff integration. Fix a bug in the interpolator .. ", "B_clean_title": ["set", "stepsiz", "step", "size", "doubl", "nan", "na", "nonstiff", "integr", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix minor bug in runge kutta integration loop. Fix a bug where the step was not being applied properly .. ", "B_clean_title": ["fix", "minor", "bug", "rung", "kutta", "integr", "loop", "fix", "bug", "where", "step", "wa", "not", "be", "appli", "properli"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the yDotK  field. ", "B_clean_title": ["fix", "bug", "ydotk", "dot", "field"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix step size = t - stepStart if we are not in the last step. Fix a bug in the interpolator not last step. ", "B_clean_title": ["fix", "step", "size", "stepstart", "step", "start", "we", "are", "not", "last", "step", "fix", "bug", "interpol", "not", "last", "step"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "added patch for parallel execution. Fix a bug in the interpolator .. ", "B_clean_title": ["ad", "patch", "parallel", "execut", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "added patch for parallel execution. Fix a bug in the interpolator .. ", "B_clean_title": ["ad", "patch", "parallel", "execut", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the step method where the reverse is not the intentional .. ", "B_clean_title": ["fix", "bug", "step", "method", "where", "revers", "not", "intent"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Set stepSize to Double . NaN for nonstiff integration. Fix for OE. ", "B_clean_title": ["set", "stepsiz", "step", "size", "doubl", "nan", "na", "nonstiff", "integr", "fix", "oe"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Added missing super call to sanity checks. Fix a bug in the interpolator .. ", "B_clean_title": ["ad", "miss", "super", "call", "saniti", "check", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "added patch for runge kutta integator. Fix minor typo in test. Fix a bug in the step method. ", "B_clean_title": ["ad", "patch", "rung", "kutta", "integ", "fix", "minor", "typo", "test", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Remove sanity checks from test script. added patch for CI integration. Fix a bug in the interpolator .. ", "B_clean_title": ["remov", "saniti", "check", "test", "script", "ad", "patch", "ci", "integr", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Remove sanity checks from opengl. Fix step size for parallel builds. Fix a bug in the step method. ", "B_clean_title": ["remov", "saniti", "check", "opengl", "fix", "step", "size", "parallel", "build", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Set stepSize to Double . NaN for nonstiffed runge kutta integration. Fix a bug in the interpolator .. ", "B_clean_title": ["set", "stepsiz", "step", "size", "doubl", "nan", "na", "nonstif", "rung", "kutta", "integr", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Set stepSize = forward ? - step : 1 . step. Fix a bug in the interpolator .. ", "B_clean_title": ["set", "stepsiz", "step", "size", "forward", "step", "step", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix test in parallel. Fix a bug in the step method. ", "B_clean_title": ["fix", "test", "parallel", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix NPE in parallel. Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "npe", "parallel", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "I had left it harwired to the edges  but I noticed this got an NPE. Fix a bug in the interpolator .. ", "B_clean_title": ["had", "left", "it", "harwir", "edg", "but", "notic", "thi", "got", "npe", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Add sanity checks back. Fix a bug in the interpolator .. ", "B_clean_title": ["add", "saniti", "check", "back", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Remove sanity checks from opengl. Fix max step size reached in DL. Fix a minor bug in the interpolator .. ", "B_clean_title": ["remov", "saniti", "check", "opengl", "fix", "max", "step", "size", "reach", "dl", "fix", "minor", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the code of RungeKuttaIntegator . reinitialize (. Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "bug", "code", "rungekuttainteg", "rung", "kutta", "integ", "reiniti", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Remove sanity checks from opengl. Fix for OE. Fix a bug in the step method. ", "B_clean_title": ["remov", "saniti", "check", "opengl", "fix", "oe", "fix", "bug", "step", "method"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix a bug in the code. Fix a bug in the interpolator .. ", "B_clean_title": ["fix", "bug", "code", "fix", "bug", "interpol"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Add sanity checks back. Fix for OE. ", "B_clean_title": ["add", "saniti", "check", "back", "fix", "oe"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix RSRepair_Bug_dot_jar_Commons - Math_69273. ", "B_clean_title": ["fix", "rsrepair", "bug", "dot", "jar", "common", "rs", "repair", "math", "69273"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix bug with last step. ", "B_clean_title": ["fix", "bug", "last", "step"]}]