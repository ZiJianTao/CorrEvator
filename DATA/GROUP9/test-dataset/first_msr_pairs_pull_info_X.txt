[{"A_title": "division by zero wrongly throws JSC_DIVIDE_BY_0_ERRORNone", "A_clean_title": ["divis", "by", "zero", "wrongli", "throw", "jsc", "divid", "by", "errornon", "error", "none"], "B_title": "disable division by zero check. disable division by zero check. ", "B_clean_title": ["disabl", "divis", "by", "zero", "check", "disabl", "divis", "by", "zero", "check"]},
{"A_title": "ArrayUtils.add(T array T element) can create unexpected ClassCastExceptionArrayUtils.add(T array T element) can create an unexpected ClassCastException. For example the following code compiles without a warning:  String sa = ArrayUtils.add(stringArray aString);   and works fine provided at least one of the parameters is non-null. However if both parameters are null the add() method returns an Object array hence the Exception. If both parameters are null its not possible to determine the correct array type to return so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.", "A_clean_title": ["arrayutil", "add", "array", "util", "array", "element", "creat", "unexpect", "classcastexceptionarrayutil", "add", "class", "cast", "except", "array", "util", "array", "element", "creat", "unexpect", "classcastexcept", "class", "cast", "except", "exampl", "follow", "code", "compil", "without", "warn", "string", "sa", "arrayutil", "add", "array", "util", "stringarray", "string", "array", "astr", "string", "work", "fine", "provid", "at", "least", "one", "paramet", "non", "null", "howev", "both", "paramet", "are", "null", "add", "method", "return", "object", "array", "henc", "except", "both", "paramet", "are", "null", "it", "not", "possibl", "determin", "correct", "array", "type", "return", "so", "it", "seem", "me", "thi", "disallow", "think", "method", "ought", "chang", "throw", "illegalparameterexcept", "illeg", "paramet", "except", "when", "both", "paramet", "are", "null"], "B_title": "Allow null to be stored in Java ArrayUtils. Allow null to be added to the array .. ", "B_clean_title": ["allow", "null", "store", "java", "arrayutil", "array", "util", "allow", "null", "ad", "array"]},
{"A_title": "NumberUtils.isNumber(String)  is not right when the String is 1.1L1.1L  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp;                to:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             ", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "string", "not", "right", "when", "string", "1l1", "1l", "not", "java", "number", "but", "numberutil", "isnumb", "number", "util", "number", "string", "return", "true", "perhap", "chang", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "hasdecpoint", "ha", "dec", "point"], "B_title": "allow L with a decimal point. ", "B_clean_title": ["allow", "decim", "point"]},
{"A_title": "NumberUtils.isNumber(String)  is not right when the String is 1.1L1.1L  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp;                to:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             ", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "string", "not", "right", "when", "string", "1l1", "1l", "not", "java", "number", "but", "numberutil", "isnumb", "number", "util", "number", "string", "return", "true", "perhap", "chang", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "hasdecpoint", "ha", "dec", "point"], "B_title": "Allow trailing commas in NumberUtils. ", "B_clean_title": ["allow", "trail", "comma", "numberutil", "number", "util"]},
{"A_title": "NumberUtils.isNumber(String)  is not right when the String is 1.1L1.1L  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp;                to:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             ", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "string", "not", "right", "when", "string", "1l1", "1l", "not", "java", "number", "but", "numberutil", "isnumb", "number", "util", "number", "string", "return", "true", "perhap", "chang", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "hasdecpoint", "ha", "dec", "point"], "B_title": "Allow L with an exponent or decimal point. remove wrong java char. ", "B_clean_title": ["allow", "expon", "or", "decim", "point", "remov", "wrong", "java", "char"]},
{"A_title": "NumberUtils.isNumber(String)  is not right when the String is 1.1L1.1L  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp;                to:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             ", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "string", "not", "right", "when", "string", "1l1", "1l", "not", "java", "number", "but", "numberutil", "isnumb", "number", "util", "number", "string", "return", "true", "perhap", "chang", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "hasdecpoint", "ha", "dec", "point"], "B_title": "Allow L with an exponent or decimal point. ", "B_clean_title": ["allow", "expon", "or", "decim", "point"]},
{"A_title": "Dependency sorting with closurePass set to false no longer works.None", "A_clean_title": ["depend", "sort", "closurepass", "closur", "pass", "set", "fals", "no", "longer", "work", "none"], "B_title": "remove 1287 from the closure pass condition. ", "B_clean_title": ["remov", "1287", "closur", "pass", "condit"]},
{"A_title": "Dependency sorting with closurePass set to false no longer works.None", "A_clean_title": ["depend", "sort", "closurepass", "closur", "pass", "set", "fals", "no", "longer", "work", "none"], "B_title": "Fix the  closure pass  flag in Compiler . java. ", "B_clean_title": ["fix", "closur", "pass", "flag", "compil", "java"]},
{"A_title": "Identifier minus a negative number needs a space between the -sNone", "A_clean_title": ["identifi", "minu", "neg", "number", "need", "space", "between", "snone", "none"], "B_title": "Improved javadoc comment .. ", "B_clean_title": ["improv", "javadoc", "comment"]},
{"A_title": "Identifier minus a negative number needs a space between the -sNone", "A_clean_title": ["identifi", "minu", "neg", "number", "need", "space", "between", "snone", "none"], "B_title": "Fix negative zero log in case of a - sign in JSON. ", "B_clean_title": ["fix", "neg", "zero", "log", "case", "sign", "json"]},
{"A_title": "Identifier minus a negative number needs a space between the -sNone", "A_clean_title": ["identifi", "minu", "neg", "number", "need", "space", "between", "snone", "none"], "B_title": "Fix whitespace in code consumer. ", "B_clean_title": ["fix", "whitespac", "code", "consum"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "KMeansPlusPlusClusterer copy constructor. ", "B_clean_title": ["kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "copi", "constructor"]},
{"A_title": "FastDateFormat.format() outputs incorrect week of year because locale isnt respectedFastDateFormat apparently doesnt respect the locale it was sent on creation when outputting week in year (e.g. ww) in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which (depending on the year) may result in the incorrect week number being output. Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right:  import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.text.SimpleDateFormat;  import org.apache.commons.lang.time.FastDateFormat;  public class FastDateFormatWeekBugDemo      public static void main(String args)          Locale.setDefault(new Locale(en US));         Locale locale = new Locale(sv SE);          Calendar cal = Calendar.getInstance(); // setting locale here doesnt change outcome         cal.set(2010 0 1 12 0 0);         Date d = cal.getTime();         System.out.println(Target date:  + d);          FastDateFormat fdf = FastDateFormat.getInstance(EEEE week ww locale);         SimpleDateFormat sdf = new SimpleDateFormat(EEEE week ww locale);         System.out.println(FastDateFormat:    + fdf.format(d)); // will output FastDateFormat:   fredag week 01         System.out.println(SimpleDateFormat:  + sdf.format(d)); // will output SimpleDateFormat: fredag week 53         If sv/SE is passed to Locale.setDefault() instead of en/US both FastDateFormat and SimpleDateFormat output the correct week number.", "A_clean_title": ["fastdateformat", "format", "fast", "date", "format", "output", "incorrect", "week", "year", "becaus", "local", "isnt", "respectedfastdateformat", "respect", "fast", "date", "format", "appar", "doesnt", "respect", "local", "it", "wa", "sent", "creation", "when", "output", "week", "year", "ww", "format", "it", "seem", "use", "set", "system", "local", "firstdayofweek", "first", "day", "week", "minimaldaysinfirstweek", "minim", "day", "first", "week", "which", "depend", "year", "may", "result", "incorrect", "week", "number", "be", "output", "here", "simpl", "test", "program", "demonstr", "problem", "by", "compar", "simpledateformat", "simpl", "date", "format", "which", "get", "week", "number", "right", "import", "java", "util", "calendar", "import", "java", "util", "date", "import", "java", "util", "local", "import", "java", "text", "simpledateformat", "simpl", "date", "format", "import", "org", "apach", "common", "lang", "time", "fastdateformat", "fast", "date", "format", "public", "class", "fastdateformatweekbugdemo", "fast", "date", "format", "week", "bug", "demo", "public", "static", "void", "main", "string", "arg", "local", "setdefault", "set", "default", "new", "local", "en", "us", "local", "local", "new", "local", "sv", "se", "calendar", "cal", "calendar", "getinst", "get", "instanc", "set", "local", "here", "doesnt", "chang", "outcom", "cal", "set", "2010", "12", "date", "cal", "gettim", "get", "time", "system", "out", "println", "target", "date", "fastdateformat", "fast", "date", "format", "fdf", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "eeee", "week", "ww", "local", "simpledateformat", "simpl", "date", "format", "sdf", "new", "simpledateformat", "simpl", "date", "format", "eeee", "week", "ww", "local", "system", "out", "println", "fastdateformat", "fast", "date", "format", "fdf", "format", "will", "output", "fastdateformat", "fast", "date", "format", "fredag", "week", "01", "system", "out", "println", "simpledateformat", "simpl", "date", "format", "sdf", "format", "will", "output", "simpledateformat", "simpl", "date", "format", "fredag", "week", "53", "sv", "se", "pass", "local", "setdefault", "set", "default", "instead", "en", "us", "both", "fastdateformat", "fast", "date", "format", "simpledateformat", "simpl", "date", "format", "output", "correct", "week", "number"], "B_title": "Missing locale argument. ", "B_clean_title": ["miss", "local", "argument"]},
{"A_title": "FastDateFormat.format() outputs incorrect week of year because locale isnt respectedFastDateFormat apparently doesnt respect the locale it was sent on creation when outputting week in year (e.g. ww) in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which (depending on the year) may result in the incorrect week number being output. Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right:  import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.text.SimpleDateFormat;  import org.apache.commons.lang.time.FastDateFormat;  public class FastDateFormatWeekBugDemo      public static void main(String args)          Locale.setDefault(new Locale(en US));         Locale locale = new Locale(sv SE);          Calendar cal = Calendar.getInstance(); // setting locale here doesnt change outcome         cal.set(2010 0 1 12 0 0);         Date d = cal.getTime();         System.out.println(Target date:  + d);          FastDateFormat fdf = FastDateFormat.getInstance(EEEE week ww locale);         SimpleDateFormat sdf = new SimpleDateFormat(EEEE week ww locale);         System.out.println(FastDateFormat:    + fdf.format(d)); // will output FastDateFormat:   fredag week 01         System.out.println(SimpleDateFormat:  + sdf.format(d)); // will output SimpleDateFormat: fredag week 53         If sv/SE is passed to Locale.setDefault() instead of en/US both FastDateFormat and SimpleDateFormat output the correct week number.", "A_clean_title": ["fastdateformat", "format", "fast", "date", "format", "output", "incorrect", "week", "year", "becaus", "local", "isnt", "respectedfastdateformat", "respect", "fast", "date", "format", "appar", "doesnt", "respect", "local", "it", "wa", "sent", "creation", "when", "output", "week", "year", "ww", "format", "it", "seem", "use", "set", "system", "local", "firstdayofweek", "first", "day", "week", "minimaldaysinfirstweek", "minim", "day", "first", "week", "which", "depend", "year", "may", "result", "incorrect", "week", "number", "be", "output", "here", "simpl", "test", "program", "demonstr", "problem", "by", "compar", "simpledateformat", "simpl", "date", "format", "which", "get", "week", "number", "right", "import", "java", "util", "calendar", "import", "java", "util", "date", "import", "java", "util", "local", "import", "java", "text", "simpledateformat", "simpl", "date", "format", "import", "org", "apach", "common", "lang", "time", "fastdateformat", "fast", "date", "format", "public", "class", "fastdateformatweekbugdemo", "fast", "date", "format", "week", "bug", "demo", "public", "static", "void", "main", "string", "arg", "local", "setdefault", "set", "default", "new", "local", "en", "us", "local", "local", "new", "local", "sv", "se", "calendar", "cal", "calendar", "getinst", "get", "instanc", "set", "local", "here", "doesnt", "chang", "outcom", "cal", "set", "2010", "12", "date", "cal", "gettim", "get", "time", "system", "out", "println", "target", "date", "fastdateformat", "fast", "date", "format", "fdf", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "eeee", "week", "ww", "local", "simpledateformat", "simpl", "date", "format", "sdf", "new", "simpledateformat", "simpl", "date", "format", "eeee", "week", "ww", "local", "system", "out", "println", "fastdateformat", "fast", "date", "format", "fdf", "format", "will", "output", "fastdateformat", "fast", "date", "format", "fredag", "week", "01", "system", "out", "println", "simpledateformat", "simpl", "date", "format", "sdf", "format", "will", "output", "simpledateformat", "simpl", "date", "format", "fredag", "week", "53", "sv", "se", "pass", "local", "setdefault", "set", "default", "instead", "en", "us", "both", "fastdateformat", "fast", "date", "format", "simpledateformat", "simpl", "date", "format", "output", "correct", "week", "number"], "B_title": "Missing locale string for format ( Date ). ", "B_clean_title": ["miss", "local", "string", "format", "date"]},
{"A_title": "Codepoint U+007f appears raw in outputNone", "A_clean_title": ["codepoint", "u+007f", "appear", "raw", "outputnon", "output", "none"], "B_title": "Remove spurious check for UTF - 8 .. ", "B_clean_title": ["remov", "spuriou", "check", "utf"]},
{"A_title": "Codepoint U+007f appears raw in outputNone", "A_clean_title": ["codepoint", "u+007f", "appear", "raw", "outputnon", "output", "none"], "B_title": "Fix typo in codeGenerator where  c  was passed through  but was accidentally ignored .. ", "B_clean_title": ["fix", "typo", "codegener", "code", "gener", "where", "wa", "pass", "through", "but", "wa", "accident", "ignor"]},
{"A_title": "Codepoint U+007f appears raw in outputNone", "A_clean_title": ["codepoint", "u+007f", "appear", "raw", "outputnon", "output", "none"], "B_title": "Fix typo in codeGenerator . java. ", "B_clean_title": ["fix", "typo", "codegener", "code", "gener", "java"]},
{"A_title": "Codepoint U+007f appears raw in outputNone", "A_clean_title": ["codepoint", "u+007f", "appear", "raw", "outputnon", "output", "none"], "B_title": "Fix typo in codeGenerator . java. ", "B_clean_title": ["fix", "typo", "codegener", "code", "gener", "java"]},
{"A_title": "Codepoint U+007f appears raw in outputNone", "A_clean_title": ["codepoint", "u+007f", "appear", "raw", "outputnon", "output", "none"], "B_title": "Fix typo in codeGenerator . java. ", "B_clean_title": ["fix", "typo", "codegener", "code", "gener", "java"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "Added missing if (. Added missing if (. ", "B_clean_title": ["ad", "miss", "ad", "miss"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "added fix. added fix. ", "B_clean_title": ["ad", "fix", "ad", "fix"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "Add null check in SubLine. Add null check in SubLine  closes # 77. ", "B_clean_title": ["add", "null", "check", "sublin", "sub", "line", "add", "null", "check", "sublin", "sub", "line", "close", "77"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "added null check in subLine copy. ", "B_clean_title": ["ad", "null", "check", "sublin", "sub", "line", "copi"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "added missing if (. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "Add null check in patch2. ", "B_clean_title": ["add", "null", "check", "patch2"]},
{"A_title": "fixed a verify() call example in @Captor javadoc.None", "A_clean_title": ["fix", "verifi", "call", "exampl", "captor", "javadoc", "none"], "B_title": "Fix appendQuoting ( ). ", "B_clean_title": ["fix", "appendquot", "append", "quot"]},
{"A_title": "fixed a verify() call example in @Captor javadoc.None", "A_clean_title": ["fix", "verifi", "call", "exampl", "captor", "javadoc", "none"], "B_title": "Fix appendText ( ) with null values .. ", "B_clean_title": ["fix", "appendtext", "append", "text", "null", "valu"]},
{"A_title": "Bug propgated from v1.0.5 on to presentThe method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset (possibly zero).  The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.", "A_clean_title": ["bug", "propgat", "v1", "presentth", "present", "method", "getrowcount", "get", "row", "count", "class", "org", "jfree", "data", "categori", "defaultintervalcategorydataset", "default", "interv", "categori", "dataset", "say", "that", "it", "return", "number", "seri", "dataset", "possibl", "zero", "implement", "v1", "no", "longer", "check", "null", "condit", "which", "would", "then", "return", "zero", "serieskey", "seri", "key", "as", "it", "did", "v1", "previou", "thi", "now", "throw", "null", "pointer", "serieskey", "seri", "key", "never", "got", "initi", "getrowcount", "get", "row", "count", "method", "call"], "B_title": "Fix bug in chart 16. ", "B_clean_title": ["fix", "bug", "chart", "16"]},
{"A_title": "Bug propgated from v1.0.5 on to presentThe method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset (possibly zero).  The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.", "A_clean_title": ["bug", "propgat", "v1", "presentth", "present", "method", "getrowcount", "get", "row", "count", "class", "org", "jfree", "data", "categori", "defaultintervalcategorydataset", "default", "interv", "categori", "dataset", "say", "that", "it", "return", "number", "seri", "dataset", "possibl", "zero", "implement", "v1", "no", "longer", "check", "null", "condit", "which", "would", "then", "return", "zero", "serieskey", "seri", "key", "as", "it", "did", "v1", "previou", "thi", "now", "throw", "null", "pointer", "serieskey", "seri", "key", "never", "got", "initi", "getrowcount", "get", "row", "count", "method", "call"], "B_title": "Fix bug in chart - 16. ", "B_clean_title": ["fix", "bug", "chart", "16"]},
{"A_title": "Division by zeroIn class Complex division by zero always returns NaN. I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF. See here.", "A_clean_title": ["divis", "by", "zeroin", "zero", "class", "complex", "divis", "by", "zero", "alway", "return", "nan", "na", "think", "that", "it", "return", "nan", "na", "onli", "when", "numer", "also", "zero", "otherwis", "result", "inf", "see", "here"], "B_title": "Add fix from MATH - 657. Fix typo in MATH - 657. ", "B_clean_title": ["add", "fix", "math", "657", "fix", "typo", "math", "657"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix nullability assertion .. ", "B_clean_title": ["fix", "nullabl", "assert"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fixed nullability assertion that was accidentally made too strong. ", "B_clean_title": ["fix", "nullabl", "assert", "that", "wa", "accident", "made", "too", "strong"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix nullability note in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "nullabl", "note", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix null pointer check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "null", "pointer", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix nullability assertion .. ", "B_clean_title": ["fix", "nullabl", "assert"]},
{"A_title": "Can not Return deep stubs from generic method that returns generic type.if I try to mock a generic method which a generic returntype where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it. When you dont use deep stubs and a raw Supplier mock to pass around it works:", "A_clean_title": ["not", "return", "deep", "stub", "gener", "method", "that", "return", "gener", "type", "tri", "mock", "gener", "method", "which", "gener", "returntyp", "where", "returntyp", "deriv", "gener", "type", "method", "deep", "stub", "get", "classcastexcept", "class", "cast", "except", "when", "call", "when", "it", "when", "you", "dont", "use", "deep", "stub", "raw", "supplier", "mock", "pass", "around", "it", "work"], "B_title": "added a bit more tidying of the areEqual method. ", "B_clean_title": ["ad", "bit", "more", "tidi", "areequ", "are", "equal", "method"]},
{"A_title": "display the exact number of tablet serversThis is a regression of ACCUMULO-1140", "A_clean_title": ["display", "exact", "number", "tablet", "serversthi", "server", "thi", "regress", "accumulo", "1140"], "B_title": "fixed PreciseNumberType and wrote a unit test to make sure it really does precise numbers", "B_clean_title": ["fix", "precisenumbertyp", "precis", "number", "type", "wrote", "unit", "test", "make", "sure", "it", "realli", "precis", "number"]},
{"A_title": "du on a table without files does not reportnoformat shell> createtable t shell> du t shell> noformat  expected:  noformat shell> du t              0 t shell> noformat", "A_clean_title": ["du", "tabl", "without", "file", "not", "reportnoformat", "shell", "createt", "shell", "du", "shell", "noformat", "expect", "noformat", "shell", "du", "shell", "noformat"], "B_title": "applying Kevin Faros patch to fix du on an empty table", "B_clean_title": ["appli", "kevin", "faro", "patch", "fix", "du", "empti", "tabl"]},
{"A_title": "Streaming does not correctly forward ExecutionConfig to runtimeWhen running streaming jobs you see this log entry: Environment did not contain an ExecutionConfig - using a default config.  Some parts of the code use an ExecutionConfig at runtime. This will be a default config without registered serializers and other user settings.", "A_clean_title": ["stream", "not", "correctli", "forward", "executionconfig", "execut", "config", "runtimewhen", "runtim", "when", "run", "stream", "job", "you", "see", "thi", "log", "entri", "environ", "did", "not", "contain", "executionconfig", "execut", "config", "default", "config", "some", "part", "code", "use", "executionconfig", "execut", "config", "at", "runtim", "thi", "will", "default", "config", "without", "regist", "serial", "other", "user", "set"], "B_title": "streaming Add ExecutionConfig serialization for streaming jobs", "B_clean_title": ["stream", "add", "executionconfig", "execut", "config", "serial", "stream", "job"]},
{"A_title": "ArrayIndexOutOfBoundsException in MathArrays.linearCombinationWhen MathArrays.linearCombination is passed arguments with length 1 it throws an ArrayOutOfBoundsException. This is caused by this line:  double prodHighNext = prodHigh1;  linearCombination should check the length of the arguments and fall back to simple multiplication if length == 1.", "A_clean_title": ["arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "matharray", "linearcombinationwhen", "math", "array", "linear", "combin", "when", "matharray", "linearcombin", "math", "array", "linear", "combin", "pass", "argument", "length", "it", "throw", "arrayoutofboundsexcept", "array", "out", "bound", "except", "thi", "caus", "by", "thi", "line", "doubl", "prodhighnext", "prod", "high", "next", "prodhigh1", "prod", "high1", "linearcombin", "linear", "combin", "check", "length", "argument", "fall", "back", "simpl", "multipl", "length"], "B_title": "Array of length 1 must be handled as a special case.", "B_clean_title": ["array", "length", "must", "handl", "as", "special", "case"]},
{"A_title": "NaN singular value from SVDThe following jython code Start code  from org.apache.commons.math.linear import *   Alist = 1.0 2.0 3.02.03.04.03.05.07.0   A = Array2DRowRealMatrix(Alist)   decomp = SingularValueDecompositionImpl(A)   print decomp.getSingularValues()  End code  prints array(d 11.218599757513008 0.3781791648535976 nan) The last singular value should be something very close to 0 since the matrix is rank deficient.  When i use the result from getSolver() to solve a system i end  up with a bunch of NaNs in the solution.  I assumed i would get back a least squares solution.  Does this SVD implementation require that the matrix be full rank?  If so then i would expect an exception to be thrown from the constructor or one of the methods.", "A_clean_title": ["nan", "na", "singular", "valu", "svdthe", "svd", "follow", "jython", "code", "start", "code", "org", "apach", "common", "math", "linear", "import", "alist", "02", "03", "04", "03", "05", "07", "array2drowrealmatrix", "array2d", "row", "real", "matrix", "alist", "decomp", "singularvaluedecompositionimpl", "singular", "valu", "decomposit", "impl", "print", "decomp", "getsingularvalu", "get", "singular", "valu", "end", "code", "print", "array", "11", "218599757513008", "3781791648535976", "nan", "last", "singular", "valu", "someth", "veri", "close", "sinc", "matrix", "rank", "defici", "when", "use", "result", "getsolv", "get", "solver", "solv", "system", "end", "up", "bunch", "nan", "na", "ns", "solut", "assum", "would", "get", "back", "least", "squar", "solut", "thi", "svd", "implement", "requir", "that", "matrix", "full", "rank", "so", "then", "would", "expect", "except", "thrown", "constructor", "or", "one", "method"], "B_title": "Singular Value Decomposition now computes either the compact SVD (using only positive singular values) or truncated SVD (using a user-specified maximal number of singular values). Fixed Singular Value Decomposition solving of singular systems. JIRA: MATH-320 MATH-321", "B_clean_title": ["singular", "valu", "decomposit", "now", "comput", "either", "compact", "svd", "onli", "posit", "singular", "valu", "or", "truncat", "svd", "user", "specifi", "maxim", "number", "singular", "valu", "fix", "singular", "valu", "decomposit", "solv", "singular", "system", "jira", "math", "320", "math", "321"]},
{"A_title": "hashCode for Mutation has an unfortunate implementationWhile looking at how a tablet server processes constraint violations I happened to look into Mutations hashCode implementation:  code   @Override   public int hashCode()      return toThrift(false).hashCode();    code  Clicking through to TMutation hashCode finds this gem:  code   @Override   public int hashCode()      return 0;    code", "A_clean_title": ["hashcod", "hash", "code", "mutat", "ha", "unfortun", "implementationwhil", "implement", "while", "look", "at", "how", "tablet", "server", "process", "constraint", "violat", "happen", "look", "into", "mutat", "hashcod", "hash", "code", "implement", "code", "overrid", "public", "int", "hashcod", "hash", "code", "return", "tothrift", "thrift", "fals", "hashcod", "hash", "code", "code", "click", "through", "tmutat", "mutat", "hashcod", "hash", "code", "find", "thi", "gem", "code", "overrid", "public", "int", "hashcod", "hash", "code", "return", "code"], "B_title": "more better hashCode", "B_clean_title": ["more", "better", "hashcod", "hash", "code"]},
{"A_title": "issues with JsopBuilder.encode and .escape1) escape() escapes many characters that do not need to be escaped (>127)  2) encode() does not encode many control characters that would need to be escaped when read through a JSON parser.", "A_clean_title": ["issu", "jsopbuild", "encod", "jsop", "builder", "escape1", "escap", "escap", "mani", "charact", "that", "not", "need", "escap", "127", "encod", "not", "encod", "mani", "control", "charact", "that", "would", "need", "escap", "when", "read", "through", "json", "parser"], "B_title": "- optimize escape/encode not to encode characters >= 127 update tests (patch by Thomas Mueller)", "B_clean_title": ["optim", "escap", "encod", "not", "encod", "charact", "127", "updat", "test", "patch", "by", "thoma", "mueller"]},
{"A_title": "WebPageRenderer must not render full page in Ajax requestsWebPageRenderer renders the full page when WebRequest#shouldPreserveClientUrl() is true or RedirectStrategy.NEVER_REDIRECT is configured.  For Ajax request this means that wicket-ajax-js will not be able to parse the HTML response.", "A_clean_title": ["webpagerender", "web", "page", "render", "must", "not", "render", "full", "page", "ajax", "requestswebpagerender", "request", "web", "page", "render", "render", "full", "page", "when", "webrequest", "web", "request", "shouldpreserveclienturl", "preserv", "client", "url", "true", "or", "redirectstrategi", "redirect", "strategi", "never", "redirect", "configur", "ajax", "request", "thi", "mean", "that", "wicket", "ajax", "js", "will", "not", "abl", "pars", "html", "respons"], "B_title": "rendering and writing of a page should never happen on an Ajax request even if other circumstances imply otherwise", "B_clean_title": ["render", "write", "page", "never", "happen", "ajax", "request", "even", "other", "circumst", "impli", "otherwis"]},
{"A_title": "Problem spying on abstract classesTheres a problem with spying on abstract classes when the real implementation calls out to the abstract method.", "A_clean_title": ["problem", "spi", "abstract", "classesther", "class", "there", "problem", "spi", "abstract", "class", "when", "real", "implement", "call", "out", "abstract", "method"], "B_title": "Changed CallsRealMethods to delegate to default answer for abstract methods.", "B_clean_title": ["chang", "callsrealmethod", "call", "real", "method", "deleg", "default", "answer", "abstract", "method"]},
{"A_title": "nicer textual printing of typed parametersWhen matchers fail but yield the same toString() Mockito prints extra type information. However the type information is awkwardly printed for Strings. Ive encountered this issue while working on removing hard dependency to hamcrest.", "A_clean_title": ["nicer", "textual", "print", "type", "parameterswhen", "paramet", "when", "matcher", "fail", "but", "yield", "same", "tostr", "string", "mockito", "print", "extra", "type", "inform", "howev", "type", "inform", "awkwardli", "print", "string", "ive", "encount", "thi", "issu", "while", "work", "remov", "hard", "depend", "hamcrest"], "B_title": "fix for issue 236 : mocks are injected a bit less aggressively", "B_clean_title": ["fix", "issu", "236", "mock", "are", "inject", "bit", "less", "aggress"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Fixing #LANG-294. The indexOf method did not take into account the size variable that limited the amount of the buffer that should be looked at.", "B_clean_title": ["fix", "lang", "294", "indexof", "index", "method", "did", "not", "take", "into", "account", "size", "variabl", "that", "limit", "amount", "buffer", "that", "look", "at"]},
{"A_title": "Line.revert() is impreciseLine.revert() only maintains ~10 digits for the direction. This becomes an issue when the lines position is evaluated far from the origin. A simple fix would be to use Vector3D.negate() for the direction. Also is there a reason why Line is not immutable? It is just comprised of two vectors.", "A_clean_title": ["line", "revert", "impreciselin", "revert", "imprecis", "line", "onli", "maintain", "~10", "digit", "direct", "thi", "becom", "issu", "when", "line", "posit", "evalu", "far", "origin", "simpl", "fix", "would", "use", "vector3d", "negat", "direct", "also", "there", "reason", "whi", "line", "not", "immut", "it", "just", "compris", "two", "vector"], "B_title": "Fixed accuracy of 3D Line.revert().", "B_clean_title": ["fix", "accuraci", "3d", "line", "revert"]},
{"A_title": "String escaping mishandles null byteNone", "A_clean_title": ["string", "escap", "mishandl", "null", "bytenon", "byte", "none"], "B_title": "Encode the null byte more correctly because we have to be careful of look ahead. Contributed by kosmo.zb Fixes issue 486", "B_clean_title": ["encod", "null", "byte", "more", "correctli", "becaus", "we", "have", "care", "look", "ahead", "contribut", "by", "kosmo", "zb", "fix", "issu", "486"]},
{"A_title": "division by zero wrongly throws JSC_DIVIDE_BY_0_ERRORNone", "A_clean_title": ["divis", "by", "zero", "wrongli", "throw", "jsc", "divid", "by", "errornon", "error", "none"], "B_title": "Delete the divide by zero error Ive never heard of this catching any real bug. It seems like if you explicitly typed 1 / 0 you meant to do that. fixes issue 381", "B_clean_title": ["delet", "divid", "by", "zero", "error", "ive", "never", "heard", "thi", "catch", "ani", "real", "bug", "it", "seem", "like", "you", "explicitli", "type", "you", "meant", "that", "fix", "issu", "381"]},
{"A_title": "Session.getItem violates JCR SpecSession.getItem(path) is supposed to first return a node for the given path and if no node is found return a property.  The oak implementation returns this in the opposite order.  see attached patch for a possible fix.", "A_clean_title": ["session", "getitem", "get", "item", "violat", "jcr", "specsess", "getitem", "spec", "session", "get", "item", "path", "suppos", "first", "return", "node", "given", "path", "no", "node", "found", "return", "properti", "oak", "implement", "return", "thi", "opposit", "order", "see", "attach", "patch", "possibl", "fix"], "B_title": "Session.getItem violates JCR Spec Applying patch. Credits to Will McGauley", "B_clean_title": ["session", "getitem", "get", "item", "violat", "jcr", "spec", "appli", "patch", "credit", "will", "mcgauley", "mc", "gauley"]},
{"A_title": "Generated urls for mounted pages contain redundant trailing /Is it OK (i.e. by design as opposed to by mistake) that the urls generated for the mounted pages end up with the /?  Provided that theres a page that expects single parameter (here: content)... public class HelpPage extends WebPage  public HelpPage(PageParameters p)  super(p); add(new DynamicContentPanel(contentPanel new Model<String>(p.getString(content))));    ...and it is mounted in the Application#init() mount(new BookmarkablePageRequestTargetUrlCodingStrategy(help HelpPage.class null));  ...and further referred to somewhere else as: add(new BookmarkablePageLink(helpPage HelpPage.class new PageParameters(content=a)));  the url in the generated markup is in the following form: http://localhost:8080/dummy-web/help/content/a/;jsessionid=11624C6125F8DF4867E3218676D79A29  While IMHO it should read: http://localhost:8080/dummy-web/help/content/a;jsessionid=11624C6125F8DF4867E3218676D79A29  It looks even more awkward when there are more parameters and part of them is encoded as a query string: http://localhost:8080/dummy-web/help/content/a/?param2=value2/;jsessionid=11624C6125F8DF4867E3218676D79A29  The page parameter for both cases is resolved correctly by the HelpPages constructor so it seems that even though theres an extra / at the end of the url it gets omitted. Then why bother generating it?  I stumbled upon an issue https://issues.apache.org/jira/browse/WICKET-765. Apart from the compatibility with wicket 1.2 I see no rationale for trailing /. Looking at implementations of IRequestTargetUrlCodingStrategy I come to the conclusion the the append(/) is being overused and redundant especially when it is preceded by the following code which makes sure that the / is in place before adding another parameter.", "A_clean_title": ["gener", "url", "mount", "page", "contain", "redund", "trail", "it", "ok", "by", "design", "as", "oppos", "by", "mistak", "that", "url", "gener", "mount", "page", "end", "up", "provid", "that", "there", "page", "that", "expect", "singl", "paramet", "here", "content", "public", "class", "helppag", "help", "page", "extend", "webpag", "web", "page", "public", "helppag", "help", "page", "pageparamet", "page", "paramet", "super", "add", "new", "dynamiccontentpanel", "dynam", "content", "panel", "contentpanel", "content", "panel", "new", "model", "string", "getstr", "get", "string", "content", "it", "mount", "applic", "init", "mount", "new", "bookmarkablepagerequesttargeturlcodingstrategi", "bookmark", "page", "request", "target", "url", "code", "strategi", "help", "helppag", "class", "help", "page", "null", "further", "refer", "somewher", "as", "add", "new", "bookmarkablepagelink", "bookmark", "page", "link", "helppag", "help", "page", "helppag", "class", "help", "page", "new", "pageparamet", "page", "paramet", "content=a", "url", "gener", "markup", "follow", "form", "http", "localhost:8080", "dummi", "web", "help", "content", "jsessionid=11624c6125f8df4867e3218676d79a29", "while", "imho", "it", "read", "http", "localhost:8080", "dummi", "web", "help", "content", "jsessionid=11624c6125f8df4867e3218676d79a29", "it", "look", "even", "more", "awkward", "when", "there", "are", "more", "paramet", "part", "them", "encod", "as", "queri", "string", "http", "localhost:8080", "dummi", "web", "help", "content", "param2=value2", "jsessionid=11624c6125f8df4867e3218676d79a29", "page", "paramet", "both", "case", "resolv", "correctli", "by", "helppag", "help", "page", "constructor", "so", "it", "seem", "that", "even", "though", "there", "extra", "at", "end", "url", "it", "get", "omit", "then", "whi", "bother", "gener", "it", "stumbl", "upon", "issu", "http", "765", "apach", "issu", "org", "jira", "brows", "wicket", "apart", "compat", "wicket", "see", "no", "rational", "trail", "look", "at", "implement", "irequesttargeturlcodingstrategi", "request", "target", "url", "code", "strategi", "come", "conclus", "append", "be", "overus", "redund", "especi", "when", "it", "preced", "by", "follow", "code", "which", "make", "sure", "that", "place", "befor", "ad", "anoth", "paramet"], "B_title": "", "B_clean_title": []},
{"A_title": "generic type Regression in being able to spoon GuavaIt seems that  #1218 introduced a regression on Guava project which is used by our CI to check the behaviour of Spoon see the trace :     See full stack trace:   https://ci.inria.fr/sos/job/Guava/262/console", "A_clean_title": ["gener", "type", "regress", "be", "abl", "spoon", "guavait", "guava", "it", "seem", "that", "1218", "introduc", "regress", "guava", "project", "which", "use", "by", "our", "ci", "check", "behaviour", "spoon", "see", "trace", "see", "full", "stack", "trace", "http", "inria", "ci", "fr", "so", "job", "guava", "262", "consol"], "B_title": "fix: fix regression regarding actual type arguments resolving (#1273)  close #1271", "B_clean_title": ["fix", "fix", "regress", "regard", "actual", "type", "argument", "resolv", "1273", "close", "1271"]},
{"A_title": "Early cancel calls can cause Tasks to not cancel properlyWhen a task receives the cancel() call before the operators are properly instantiated it can be that the operator never receives a cancel call.  In certain cases this causes the operator to hang.", "A_clean_title": ["earli", "cancel", "call", "caus", "task", "not", "cancel", "properlywhen", "properli", "when", "task", "receiv", "cancel", "call", "befor", "oper", "are", "properli", "instanti", "it", "that", "oper", "never", "receiv", "cancel", "call", "certain", "case", "thi", "caus", "oper", "hang"], "B_title": "streaming Fix case where early cancel messages do not properly cancel a stream operator.", "B_clean_title": ["stream", "fix", "case", "where", "earli", "cancel", "messag", "not", "properli", "cancel", "stream", "oper"]},
{"A_title": "Brent solver returns the wrong value if either bracket endpoint is rootThe solve(final UnivariateRealFunction f final double min final double max final double initial) function returns yMin or yMax if min or max are deemed to be roots respectively instead of min or max.", "A_clean_title": ["brent", "solver", "return", "wrong", "valu", "either", "bracket", "endpoint", "rootth", "root", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "function", "return", "ymin", "min", "or", "ymax", "max", "min", "or", "max", "are", "deem", "root", "respect", "instead", "min", "or", "max"], "B_title": "Fixed wrong return values when enpoints are roots in Brent solver with a user provided initial guess JIRA: MATH-344", "B_clean_title": ["fix", "wrong", "return", "valu", "when", "enpoint", "are", "root", "brent", "solver", "user", "provid", "initi", "guess", "jira", "math", "344"]},
{"A_title": "Improve identifier metadata detection for XML based entity mappings DATAJPA-658opened and commented I have a model in POJOs and my persistence configuration in a separated project with an orm.xml file. I want to expose my persistence API and I have detected that entities are only configured when they are annotated with persistence annotations (  @Id for example). We cannot annotate our entities as they come from a target model which we dont have the source code. It would be great that Spring Data REST were configurable using  orm.xml files or other .xml source apart from annotations. Thank you    Affects: 1.7.1 (Evans SR1) 1.8 M1 (Fowler)  Issue Links:     Referenced from: pull request #146  Backported to:  2.0.4 (Kay SR4)  1.11.11 (Ingalls SR11) 2 votes 6 watchers", "A_clean_title": ["improv", "identifi", "metadata", "detect", "xml", "base", "entiti", "map", "datajpa", "658open", "comment", "have", "model", "pojo", "poj", "os", "my", "persist", "configur", "separ", "project", "orm", "xml", "file", "want", "expos", "my", "persist", "api", "have", "detect", "that", "entiti", "are", "onli", "configur", "when", "they", "are", "annot", "persist", "annot", "id", "exampl", "we", "not", "annot", "our", "entiti", "as", "they", "come", "target", "model", "which", "we", "dont", "have", "sourc", "code", "it", "would", "great", "that", "spring", "data", "rest", "were", "configur", "orm", "xml", "file", "or", "other", "xml", "sourc", "apart", "annot", "thank", "you", "affect", "evan", "sr1", "m1", "fowler", "issu", "link", "referenc", "pull", "request", "146", "backport", "kay", "sr4", "11", "11", "ingal", "sr11", "vote", "watcher"], "B_title": "DATAJPA-658 - Fixed potential NullPointerException in JpaMetamodel.  When iterating over EntityType<?> we need to guard against ….getJavaType() returning null. That seems to be the case for Hibernate Envers which apparently registers EntityType instances without a backing type.  Original pull request: #146.", "B_clean_title": ["datajpa", "658", "fix", "potenti", "nullpointerexcept", "null", "pointer", "except", "jpametamodel", "jpa", "metamodel", "when", "iter", "over", "entitytyp", "entiti", "type", "we", "need", "guard", "against", "getjavatyp", "get", "java", "type", "return", "null", "that", "seem", "case", "hibern", "enver", "which", "appar", "regist", "entitytyp", "entiti", "type", "instanc", "without", "back", "type", "origin", "pull", "request", "146"]},
{"A_title": "TarMK compaction can create mixed segmentsAs described in http://markmail.org/message/ujkqdlthudaortxf commits that occur while the compaction operation is running can make the compacted segments contain references to older data segments which prevents old data from being reclaimed during cleanup.", "A_clean_title": ["tarmk", "tar", "mk", "compact", "creat", "mix", "segmentsa", "segment", "as", "describ", "http", "markmail", "org", "messag", "ujkqdlthudaortxf", "commit", "that", "occur", "while", "compact", "oper", "run", "make", "compact", "segment", "contain", "refer", "older", "data", "segment", "which", "prevent", "old", "data", "be", "reclaim", "dure", "cleanup"], "B_title": "TarMK compaction can create mixed segments  - allowed the compactor to take into consideration the initial state", "B_clean_title": ["tarmk", "tar", "mk", "compact", "creat", "mix", "segment", "allow", "compactor", "take", "into", "consider", "initi", "state"]},
{"A_title": "FencedFeedbackPanel is broken with RefreshingView(and its implementations)FencedFeedbackPanel doesnt work correctly if inner form(s) are in RefreshingView(or its implementations).. in this case outerform feedbackpanel just starts including messages meant for inner feedbackpanel. with ListView FencedFeedbackPanel works correctly.. actually one user(Mike Dundee) created this issue in quickview https://github.com/vineetsemwal/quickview/issues/19  so in that link he has described his problem and pasted the code you can use to reproduce ... there i have also explained why its broken with RefreshingView and its implementations currently(its a little complex so i am trying to avoid explaining all again also english is not my first language :-) )   thank you !", "A_clean_title": ["fencedfeedbackpanel", "fenc", "feedback", "panel", "broken", "refreshingview", "refresh", "view", "it", "implement", "fencedfeedbackpanel", "fenc", "feedback", "panel", "doesnt", "work", "correctli", "inner", "form", "are", "refreshingview", "refresh", "view", "or", "it", "implement", "thi", "case", "outerform", "feedbackpanel", "just", "start", "includ", "messag", "meant", "inner", "feedbackpanel", "listview", "list", "view", "fencedfeedbackpanel", "fenc", "feedback", "panel", "work", "correctli", "actual", "one", "user", "mike", "dunde", "creat", "thi", "issu", "quickview", "http", "github", "com", "vineetsemw", "quickview", "issu", "19", "so", "that", "link", "he", "ha", "describ", "hi", "problem", "past", "code", "you", "use", "reproduc", "there", "have", "also", "explain", "whi", "it", "broken", "refreshingview", "refresh", "view", "it", "implement", "current", "it", "littl", "complex", "so", "am", "tri", "avoid", "explain", "all", "again", "also", "english", "not", "my", "first", "languag", "thank", "you"], "B_title": "recreate fence mark when removing and readding a fencedfeedbackpanel", "B_clean_title": ["recreat", "fenc", "mark", "when", "remov", "read", "fencedfeedbackpanel"]},
{"A_title": "RegExFilter does not properly regex when using multi-byte charactersThe current RegExFilter class uses a ByteArrayBackedCharSequence to set the data to match against. The ByteArrayBackedCharSequence contains a line of code that prevents the matcher from properly matching multi-byte characters.  Line 49 of ByteArrayBackedCharSequence.java is: return (char) (0xff & dataoffset + index);                                                                                                This incorrectly casts a single byte from the byte array to a char which is 2 bytes in Java. This prevents the RegExFilter from properly performing Regular Expressions on multi-byte character encoded values.  A patch for the RegExFilter.java file has been created and will be submitted.", "A_clean_title": ["regexfilt", "reg", "ex", "filter", "not", "properli", "regex", "when", "multi", "byte", "charactersth", "charact", "current", "regexfilt", "reg", "ex", "filter", "class", "use", "bytearraybackedcharsequ", "byte", "array", "back", "char", "sequenc", "set", "data", "match", "against", "bytearraybackedcharsequ", "byte", "array", "back", "char", "sequenc", "contain", "line", "code", "that", "prevent", "matcher", "properli", "match", "multi", "byte", "charact", "line", "49", "bytearraybackedcharsequ", "java", "byte", "array", "back", "char", "sequenc", "return", "char", "0xff", "dataoffset", "index", "thi", "incorrectli", "cast", "singl", "byte", "byte", "array", "char", "which", "byte", "java", "thi", "prevent", "regexfilt", "reg", "ex", "filter", "properli", "perform", "regular", "express", "multi", "byte", "charact", "encod", "valu", "patch", "regexfilt", "java", "reg", "ex", "filter", "file", "ha", "been", "creat", "will", "submit"], "B_title": "applied patch", "B_clean_title": ["appli", "patch"]},
{"A_title": "ArrayUtils.add(T array T element) can create unexpected ClassCastExceptionArrayUtils.add(T array T element) can create an unexpected ClassCastException. For example the following code compiles without a warning:  String sa = ArrayUtils.add(stringArray aString);   and works fine provided at least one of the parameters is non-null. However if both parameters are null the add() method returns an Object array hence the Exception. If both parameters are null its not possible to determine the correct array type to return so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.", "A_clean_title": ["arrayutil", "add", "array", "util", "array", "element", "creat", "unexpect", "classcastexceptionarrayutil", "add", "class", "cast", "except", "array", "util", "array", "element", "creat", "unexpect", "classcastexcept", "class", "cast", "except", "exampl", "follow", "code", "compil", "without", "warn", "string", "sa", "arrayutil", "add", "array", "util", "stringarray", "string", "array", "astr", "string", "work", "fine", "provid", "at", "least", "one", "paramet", "non", "null", "howev", "both", "paramet", "are", "null", "add", "method", "return", "object", "array", "henc", "except", "both", "paramet", "are", "null", "it", "not", "possibl", "determin", "correct", "array", "type", "return", "so", "it", "seem", "me", "thi", "disallow", "think", "method", "ought", "chang", "throw", "illegalparameterexcept", "illeg", "paramet", "except", "when", "both", "paramet", "are", "null"], "B_title": "ArrayUtils.add(T array offset T element) can create unexpected ClassCastException", "B_clean_title": ["arrayutil", "add", "array", "util", "array", "offset", "element", "creat", "unexpect", "classcastexcept", "class", "cast", "except"]},
{"A_title": "delete mutations not working through the ProxyAru Sahni writes:  quote Im new to Accumulo and am still trying to wrap my head around its ways. To further that challenge Im using Pyaccumulo which doesnt present much in terms of available reference material.  Right now Im trying to understand how Accumulo manages record (key-value pair) deletions.  conn = Accumulo(host port user password) table = test_table conn.create_table(table) writer = conn.create_batch_writer(table) mut = Mutation(mut_01) mut.put(cf=item cq=name value=car) writer.add_mutation(mut) writer.close() conn.close()  Will generate a record (found via a shell scan):  mut_01 item:name     car  However the subsequent mutation...  writer = conn.create_batch_writer(table) mut = Mutation(mut_01) mut.put(cf=item cq=name is_delete=True) writer.add_mutation(mut) writer.close()  Results in:  mut_01 item:name   How should one expect the deleted row to be represented? That record sticks around even after I force a compaction of the table.  I was expecting it to not show up in any iterators or at least provide an easy way to see if the cell has been deleted. quote  ~ecn has confirmed the problem.", "A_clean_title": ["delet", "mutat", "not", "work", "through", "proxyaru", "proxi", "aru", "sahni", "write", "quot", "im", "new", "accumulo", "am", "still", "tri", "wrap", "my", "head", "around", "it", "way", "further", "that", "challeng", "im", "pyaccumulo", "which", "doesnt", "present", "much", "term", "avail", "refer", "materi", "right", "now", "im", "tri", "understand", "how", "accumulo", "manag", "record", "key", "valu", "pair", "delet", "conn", "accumulo", "host", "port", "user", "password", "tabl", "test", "tabl", "conn", "creat", "tabl", "tabl", "writer", "conn", "creat", "batch", "writer", "tabl", "mut", "mutat", "mut", "01", "mut", "put", "cf=item", "cq=name", "value=car", "writer", "add", "mutat", "mut", "writer", "close", "conn", "close", "will", "gener", "record", "found", "via", "shell", "scan", "mut", "01", "item", "name", "car", "howev", "subsequ", "mutat", "writer", "conn", "creat", "batch", "writer", "tabl", "mut", "mutat", "mut", "01", "mut", "put", "cf=item", "cq=name", "delete=tru", "writer", "add", "mutat", "mut", "writer", "close", "result", "mut", "01", "item", "name", "how", "one", "expect", "delet", "row", "repres", "that", "record", "stick", "around", "even", "after", "forc", "compact", "tabl", "wa", "expect", "it", "not", "show", "up", "ani", "iter", "or", "at", "least", "provid", "easi", "way", "see", "cell", "ha", "been", "delet", "quot", "~ecn", "ha", "confirm", "problem"], "B_title": "fix deletes added test", "B_clean_title": ["fix", "delet", "ad", "test"]},
{"A_title": "Repository upgrade does not copy default values of property definitionsThe RepositoryUpgrade class needs to copy also the default values of property definitions in the node types being upgraded. See the TODO in https://github.com/apache/jackrabbit-oak/blob/jackrabbit-oak-0.20.0/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java#L485.", "A_clean_title": ["repositori", "upgrad", "not", "copi", "default", "valu", "properti", "definitionsth", "definit", "repositoryupgrad", "repositori", "upgrad", "class", "need", "copi", "also", "default", "valu", "properti", "definit", "node", "type", "be", "upgrad", "see", "todo", "http", "oak", "oak", "blob", "jackrabbit", "20", "java", "github", "com", "apach", "jackrabbit", "oak", "upgrad", "src", "main", "java", "org", "apach", "jackrabbit", "oak", "upgrad", "repositoryupgrad", "repositori", "upgrad", "l485"], "B_title": "Repository upgrade does not copy default values of property definitions Copy default values of property definitions during upgrade", "B_clean_title": ["repositori", "upgrad", "not", "copi", "default", "valu", "properti", "definit", "copi", "default", "valu", "properti", "definit", "dure", "upgrad"]},
{"A_title": "NumberUtils.isNumber(String)  is not right when the String is 1.1L1.1L  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp;                to:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "string", "not", "right", "when", "string", "1l1", "1l", "not", "java", "number", "but", "numberutil", "isnumb", "number", "util", "number", "string", "return", "true", "perhap", "chang", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "hasdecpoint", "ha", "dec", "point"], "B_title": "Fixing NumberUtils.isNumber so that 1.1L is not considered a number. LANG-664", "B_clean_title": ["fix", "numberutil", "isnumb", "number", "util", "number", "so", "that", "1l", "not", "consid", "number", "lang", "664"]},
{"A_title": "Compiler fails to find amd module in a subdirectoryNone", "A_clean_title": ["compil", "fail", "find", "amd", "modul", "subdirectorynon", "subdirectori", "none"], "B_title": "counter DOS shell file name normalization fixes issue 824", "B_clean_title": ["counter", "do", "shell", "file", "name", "normal", "fix", "issu", "824"]},
{"A_title": "Full-text search on the traversing index fails if the condition contains a slashA full-text search on the traversing index falls back to a sort of manual evaluation of results.  This is handled by the _FullTextTerm_ class and it appears that it passes the constraint text through a cleanup process where it strips most of the characters that are neither _Character.isLetterOrDigit(c)_ not in the list _+-:&_  Im not exactly sure where this list comes from but I see the / character is missing which causes a certain type of query to fail.  Example: code //*jcr:contains(. text/plain) code", "A_clean_title": ["full", "text", "search", "travers", "index", "fail", "condit", "contain", "slasha", "slash", "full", "text", "search", "travers", "index", "fall", "back", "sort", "manual", "evalu", "result", "thi", "handl", "by", "fulltextterm", "full", "text", "term", "class", "it", "appear", "that", "it", "pass", "constraint", "text", "through", "cleanup", "process", "where", "it", "strip", "most", "charact", "that", "are", "neither", "isletterordigit", "charact", "letter", "or", "digit", "not", "list", "im", "not", "exactli", "sure", "where", "thi", "list", "come", "but", "see", "charact", "miss", "which", "caus", "certain", "type", "queri", "fail", "exampl", "code", "jcr", "contain", "text", "plain", "code"], "B_title": "Full-text search on the traversing index fails if the condition contains a slash  - added dot character to the full-text checks", "B_clean_title": ["full", "text", "search", "travers", "index", "fail", "condit", "contain", "slash", "ad", "dot", "charact", "full", "text", "check"]},
{"A_title": "Ajax buttons inside ModalWindows dont submit properlyI have a ModalWindow that contains an IndicatingAjaxButton. When I click the button I get a big Java error complaining that the form submit wasnt multipart.  Digging into the javascript in wicket-ajax.js I found this from line 1102 in the method handleMultipart  code multipart=multipart||form.enctype==multipart/form-data;  if (multipart==false)       // nothing to handle     return false;   code  When this executed multipart was false and enctype was  and therefore the submit aborted. This may be the cause.  Heres the Java stacktrace  noformat java.lang.IllegalStateException: ServletRequest does not contain multipart content at org.apache.wicket.protocol.http.servlet.MultipartServletWebRequest.<init>(MultipartServletWebRequest.java:113) at org.apache.wicket.protocol.http.servlet.MultipartServletWebRequest.<init>(MultipartServletWebRequest.java:83) at org.apache.wicket.extensions.ajax.markup.html.form.upload.MultipartRequest.<init>(MultipartRequest.java:41) at org.apache.wicket.extensions.ajax.markup.html.form.upload.UploadWebRequest.newMultipartWebRequest(UploadWebRequest.java:66) at org.apache.wicket.markup.html.form.Form.handleMultiPart(Form.java:1651) at org.apache.wicket.markup.html.form.Form.onFormSubmitted(Form.java:850) at org.apache.wicket.ajax.form.AjaxFormSubmitBehavior.onEvent(AjaxFormSubmitBehavior.java:135) at org.apache.wicket.ajax.AjaxEventBehavior.respond(AjaxEventBehavior.java:177) at org.apache.wicket.ajax.AbstractDefaultAjaxBehavior.onRequest(AbstractDefaultAjaxBehavior.java:299) at org.apache.wicket.request.target.component.listener.BehaviorRequestTarget.processEvents(BehaviorRequestTarget.java:119) at org.apache.wicket.request.AbstractRequestCycleProcessor.processEvents(AbstractRequestCycleProcessor.java:92) at org.apache.wicket.RequestCycle.processEventsAndRespond(RequestCycle.java:1250) at org.apache.wicket.RequestCycle.step(RequestCycle.java:1329) at org.apache.wicket.RequestCycle.steps(RequestCycle.java:1428) at org.apache.wicket.RequestCycle.request(RequestCycle.java:545) at org.apache.wicket.protocol.http.WicketFilter.doGet(WicketFilter.java:479) at org.apache.wicket.protocol.http.WicketFilter.doFilter(WicketFilter.java:312) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235) noformat", "A_clean_title": ["ajax", "button", "insid", "modalwindow", "modal", "window", "dont", "submit", "properlyi", "properli", "have", "modalwindow", "modal", "window", "that", "contain", "indicatingajaxbutton", "indic", "ajax", "button", "when", "click", "button", "get", "big", "java", "error", "complain", "that", "form", "submit", "wasnt", "multipart", "dig", "into", "javascript", "wicket", "ajax", "js", "found", "thi", "line", "1102", "method", "handlemultipart", "handl", "multipart", "code", "data", "multipart=multipart||form", "enctype==multipart", "form", "multipart==fals", "noth", "handl", "return", "fals", "code", "when", "thi", "execut", "multipart", "wa", "fals", "enctyp", "wa", "therefor", "submit", "abort", "thi", "may", "caus", "here", "java", "stacktrac", "noformat", "java", "lang", "illegalstateexcept", "illeg", "state", "except", "servletrequest", "servlet", "request", "not", "contain", "multipart", "content", "at", "org", "apach", "wicket", "protocol", "http", "servlet", "multipartservletwebrequest", "multipart", "servlet", "web", "request", "init", "multipartservletwebrequest", "java:113", "multipart", "servlet", "web", "request", "at", "org", "apach", "wicket", "protocol", "http", "servlet", "multipartservletwebrequest", "multipart", "servlet", "web", "request", "init", "multipartservletwebrequest", "java:83", "multipart", "servlet", "web", "request", "at", "org", "apach", "wicket", "extens", "ajax", "markup", "html", "form", "upload", "multipartrequest", "multipart", "request", "init", "multipartrequest", "java:41", "multipart", "request", "at", "org", "apach", "wicket", "extens", "ajax", "markup", "html", "form", "upload", "uploadwebrequest", "newmultipartwebrequest", "upload", "web", "request", "new", "multipart", "web", "request", "uploadwebrequest", "java:66", "upload", "web", "request", "at", "org", "apach", "wicket", "markup", "html", "form", "form", "handlemultipart", "handl", "multi", "part", "form", "java:1651", "at", "org", "apach", "wicket", "markup", "html", "form", "form", "onformsubmit", "form", "submit", "form", "java:850", "at", "org", "apach", "wicket", "ajax", "form", "ajaxformsubmitbehavior", "onev", "ajax", "form", "submit", "behavior", "event", "ajaxformsubmitbehavior", "java:135", "ajax", "form", "submit", "behavior", "at", "org", "apach", "wicket", "ajax", "ajaxeventbehavior", "respond", "ajax", "event", "behavior", "ajaxeventbehavior", "java:177", "ajax", "event", "behavior", "at", "org", "apach", "wicket", "ajax", "abstractdefaultajaxbehavior", "onrequest", "abstract", "default", "ajax", "behavior", "request", "abstractdefaultajaxbehavior", "java:299", "abstract", "default", "ajax", "behavior", "at", "org", "apach", "wicket", "request", "target", "compon", "listen", "behaviorrequesttarget", "processev", "behavior", "request", "target", "process", "event", "behaviorrequesttarget", "java:119", "behavior", "request", "target", "at", "org", "apach", "wicket", "request", "abstractrequestcycleprocessor", "processev", "abstract", "request", "cycl", "processor", "process", "event", "abstractrequestcycleprocessor", "java:92", "abstract", "request", "cycl", "processor", "at", "org", "apach", "wicket", "requestcycl", "processeventsandrespond", "request", "cycl", "process", "event", "respond", "requestcycl", "java:1250", "request", "cycl", "at", "org", "apach", "wicket", "requestcycl", "step", "request", "cycl", "requestcycl", "java:1329", "request", "cycl", "at", "org", "apach", "wicket", "requestcycl", "step", "request", "cycl", "requestcycl", "java:1428", "request", "cycl", "at", "org", "apach", "wicket", "requestcycl", "request", "request", "cycl", "requestcycl", "java:545", "request", "cycl", "at", "org", "apach", "wicket", "protocol", "http", "wicketfilt", "doget", "wicket", "filter", "get", "wicketfilt", "java:479", "wicket", "filter", "at", "org", "apach", "wicket", "protocol", "http", "wicketfilt", "dofilt", "wicket", "filter", "filter", "wicketfilt", "java:312", "wicket", "filter", "at", "org", "apach", "catalina", "core", "applicationfilterchain", "internaldofilt", "applic", "filter", "chain", "intern", "filter", "applicationfilterchain", "java:235", "applic", "filter", "chain", "noformat"], "B_title": "Issue: WICKET-2621", "B_clean_title": ["issu", "wicket", "2621"]},
{"A_title": "ProxyServer does not set column information on BatchScannerThe createScanner method uses the options from the thrift request to call fetchColumn() and fetchColumnFamily(). The createBatchScanner should be doing have the same feature though the statements are absent from the code.", "A_clean_title": ["proxyserv", "proxi", "server", "not", "set", "column", "inform", "batchscannerth", "batch", "scanner", "createscann", "creat", "scanner", "method", "use", "option", "thrift", "request", "call", "fetchcolumn", "fetch", "column", "fetchcolumnfamili", "fetch", "column", "famili", "createbatchscann", "creat", "batch", "scanner", "do", "have", "same", "featur", "though", "statement", "are", "absent", "code"], "B_title": "applying patch from Corey Nolet", "B_clean_title": ["appli", "patch", "corey", "nolet"]},
{"A_title": "Dependency sorting with closurePass set to false no longer works.None", "A_clean_title": ["depend", "sort", "closurepass", "closur", "pass", "set", "fals", "no", "longer", "work", "none"], "B_title": "Allow dependency sorting even when closure pass is off. Fixes issue 768", "B_clean_title": ["allow", "depend", "sort", "even", "when", "closur", "pass", "off", "fix", "issu", "768"]},
{"A_title": "Do not use the parsed PageParameters when re-creating an expired pageWICKET-4014 and WICKET-4290 provided functionality to re-create an expired page if there is a mount path in the current requests url. There is a minor problem with that because the page parameters are passed to the freshly created page. I.e. parameters for a callback behavior are now set as page construction parameters. Since the execution of the behavior is ignored for the recreated page these parameters should be ignored too.", "A_clean_title": ["not", "use", "pars", "pageparamet", "page", "paramet", "when", "re", "creat", "expir", "pagewicket", "4014", "page", "wicket", "wicket", "4290", "provid", "function", "re", "creat", "expir", "page", "there", "mount", "path", "current", "request", "url", "there", "minor", "problem", "that", "becaus", "page", "paramet", "are", "pass", "freshli", "creat", "page", "paramet", "callback", "behavior", "are", "now", "set", "as", "page", "construct", "paramet", "sinc", "execut", "behavior", "ignor", "recreat", "page", "these", "paramet", "ignor", "too"], "B_title": "added test that stateless pages get page parameters", "B_clean_title": ["ad", "test", "that", "stateless", "page", "get", "page", "paramet"]},
{"A_title": "UrlRenderer renders invalid relative URLs if first segment contains colonSeen on Wicket 1.5.3.  If a relative url of a link starts with a path segment containing a colon then the whole uri will be regarded as absolute uri so typically browsers will complain that there is no handle for the protocol foo in foo:bar/dee/per.  See also the attached quickstart. The start page contains three links one relative with colon one absolute and one to a mounted page without colon for comparison. The application also has a static switch to add an extended urlrenderer prepending ./ if needed. This fix is merely a quick shot and there might be better alternatives.", "A_clean_title": ["urlrender", "url", "render", "render", "invalid", "rel", "url", "ur", "ls", "first", "segment", "contain", "colonseen", "colon", "seen", "wicket", "rel", "url", "link", "start", "path", "segment", "contain", "colon", "then", "whole", "uri", "will", "regard", "as", "absolut", "uri", "so", "typic", "browser", "will", "complain", "that", "there", "no", "handl", "protocol", "foo", "foo", "bar", "dee", "per", "see", "also", "attach", "quickstart", "start", "page", "contain", "three", "link", "one", "rel", "colon", "one", "absolut", "one", "mount", "page", "without", "colon", "comparison", "applic", "also", "ha", "static", "switch", "add", "extend", "urlrender", "prepend", "need", "thi", "fix", "mere", "quick", "shot", "there", "might", "better", "altern"], "B_title": "remove leading dot in sendRedirect()", "B_clean_title": ["remov", "lead", "dot", "sendredirect", "send", "redirect"]},
{"A_title": "int overflow with orderby causing huge slowdownConsider the following query: code //element(*slingevent:Job) order by @slingevent:created ascending code this query - when running with a large number of slingevent:Job around - will take a very long time due to the fact that FilterIterators.SortIterator.init() in the following loop: code if (list.size() > max * 2)    // remove tail entries right now to save memory   Collections.sort(list orderBy);   keepFirst(list max);  code does a multiplication with max which is by default set to Integer.MAX_VALUE (see FilterIterators.newCombinedFilter). This results in max *2 to overflow (result is -2) - thus that init-loop will sort the list for every additional entry. Which is definitely not the intention.", "A_clean_title": ["int", "overflow", "orderbi", "caus", "huge", "slowdownconsid", "slowdown", "consid", "follow", "queri", "code", "element", "slingev", "job", "order", "by", "slingev", "creat", "ascend", "code", "thi", "queri", "when", "run", "larg", "number", "slingev", "job", "around", "will", "take", "veri", "long", "time", "due", "fact", "that", "filteriter", "sortiter", "init", "filter", "iter", "sort", "iter", "follow", "loop", "code", "list", "size", "max", "remov", "tail", "entri", "right", "now", "save", "memori", "collect", "sort", "list", "orderbi", "order", "by", "keepfirst", "keep", "first", "list", "max", "code", "multipl", "max", "which", "by", "default", "set", "integ", "max", "valu", "see", "filteriter", "newcombinedfilt", "filter", "iter", "new", "combin", "filter", "thi", "result", "max", "overflow", "result", "thu", "that", "init", "loop", "will", "sort", "list", "everi", "addit", "entri", "which", "definit", "not", "intent"], "B_title": "int overflow with orderby causing huge slowdown", "B_clean_title": ["int", "overflow", "orderbi", "caus", "huge", "slowdown"]},
{"A_title": "@JsonIdentityReference not used when setup on class onlyI am trying to setup @JsonIdentityInfo/@JsonIdentityReference in order to serialize all references to a given class as Object Id (and deserialize them later using a custom ObjectIdResolver to retrieve the proper referenced instance)  I use @JsonIdentityReference(alwaysAsId=true) in order to enforce exporting the object id in all cases.  It does not work as expected when I define the annotation only on the class (but it works fine when I set it directly on the property). I would rather not have to define it on every property as I will probably miss some... From what I see in  BeanSerializerBase  the alwaysAsId is reset when not ObjectIdInfo is found on the accessor:   Shouldnt it be kept to the current value when no override is found ?  I tried to set it back in the default ObjectIdInfo created with NAME_FOR_OBJECT_REF but I am not sure if this is the right way to fix this. Here is test I added in  TestObjectIdSerialization for this case:", "A_clean_title": ["jsonidentityrefer", "json", "ident", "refer", "not", "use", "when", "setup", "class", "onlyi", "onli", "am", "tri", "setup", "jsonidentityinfo", "json", "ident", "info", "jsonidentityrefer", "json", "ident", "refer", "order", "serial", "all", "refer", "given", "class", "as", "object", "id", "deseri", "them", "later", "custom", "objectidresolv", "object", "id", "resolv", "retriev", "proper", "referenc", "instanc", "use", "jsonidentityrefer", "json", "ident", "refer", "alwaysasid=tru", "alway", "as", "id=tru", "order", "enforc", "export", "object", "id", "all", "case", "it", "not", "work", "as", "expect", "when", "defin", "annot", "onli", "class", "but", "it", "work", "fine", "when", "set", "it", "directli", "properti", "would", "rather", "not", "have", "defin", "it", "everi", "properti", "as", "will", "probabl", "miss", "some", "what", "see", "beanserializerbas", "bean", "serial", "base", "alwaysasid", "alway", "as", "id", "reset", "when", "not", "objectidinfo", "object", "id", "info", "found", "accessor", "shouldnt", "it", "kept", "current", "valu", "when", "no", "overrid", "found", "tri", "set", "it", "back", "default", "objectidinfo", "object", "id", "info", "creat", "name", "object", "ref", "but", "am", "not", "sure", "thi", "right", "way", "fix", "thi", "here", "test", "ad", "testobjectidseri", "test", "object", "id", "serial", "thi", "case"], "B_title": "Fix #1607", "B_clean_title": ["fix", "1607"]},
{"A_title": "math Complex Tanh for big numbersHi In Complex.java the tanh is computed with the following formula: tanh(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + sin(2b)/(cosh(2a)+cos(2b))i The problem that Im finding is that as soon as a is a big number both sinh(2a) and cosh(2a) are infinity and then the method tanh returns in the real part NaN (infinity/infinity) when it should return 1.0. Wouldnt it be appropiate to add something as in the FastMath library??: if (real>20.0)       return createComplex(1.0 0.0);  if (real<-20.0)       return createComplex(-1.0 0.0);  Best regards JBB", "A_clean_title": ["math", "complex", "tanh", "big", "numbershi", "number", "hi", "complex", "java", "tanh", "comput", "follow", "formula", "tanh", "bi", "sinh", "2a", "cosh", "2a", "+co", "2b", "sin", "2b", "cosh", "2a", "+co", "2b", "problem", "that", "im", "find", "that", "as", "soon", "as", "big", "number", "both", "sinh", "2a", "cosh", "2a", "are", "infin", "then", "method", "tanh", "return", "real", "part", "nan", "na", "infin", "infin", "when", "it", "return", "wouldnt", "it", "appropi", "add", "someth", "as", "fastmath", "fast", "math", "librari", "real", "20", "return", "createcomplex", "creat", "complex", "real", "20", "return", "createcomplex", "creat", "complex", "best", "regard", "jbb"], "B_title": "Introduced tests to guard against overflow (MATH-722). Corrected Javadoc and updated unit tests accordingly.", "B_clean_title": ["introduc", "test", "guard", "against", "overflow", "math", "722", "correct", "javadoc", "updat", "unit", "test", "accordingli"]},
{"A_title": "Links with multiple parameters are wrongly generatedIf you have a PageParameters with multiple params then the resulting link will be something like this /url?id=123&amp;sid=456 so for some reason the & sign is encoded to &amp; which will result in the following parameters on the receiving page: id=123 amp;sid=456 See the attached quickstart for example.", "A_clean_title": ["link", "multipl", "paramet", "are", "wrongli", "generatedif", "gener", "you", "have", "pageparamet", "page", "paramet", "multipl", "param", "then", "result", "link", "will", "someth", "like", "thi", "url", "id=123", "amp", "sid=456", "so", "some", "reason", "sign", "encod", "amp", "which", "will", "result", "follow", "paramet", "receiv", "page", "id=123", "amp", "sid=456", "see", "attach", "quickstart", "exampl"], "B_title": "Links with multiple parameters are wrongly generated WICKET-2829 Tag attributes values are not escaped properly during writeOutput", "B_clean_title": ["link", "multipl", "paramet", "are", "wrongli", "gener", "wicket", "2829", "tag", "attribut", "valu", "are", "not", "escap", "properli", "dure", "writeoutput", "write", "output"]},
{"A_title": "Evaluation with restriction is not consistent with parent ACLsconsider the following ACL setup:  noformat testuser allow rep:readrep:write      /testroot testuser deny  jcr:removeNode /testroot/a  glob=*/c testuser allow jcr:removeNode /testroot/a  glob=*/b noformat  now: hasPermission(/tesroot/a/b/c jcr:removeNode) == false but the user is still able to delete the node.  * if we change the order of the ACEs with the restriction it works (i.e. the user cant delete) * if we use direct ACLs on the respective nodes it works  I think this is a bug...but Im not sure if hasPermission is wrong or the check during node deletion.", "A_clean_title": ["evalu", "restrict", "not", "consist", "parent", "aclsconsid", "ac", "lsconsid", "follow", "acl", "setup", "noformat", "testus", "allow", "rep", "readrep", "write", "testroot", "testus", "deni", "jcr", "removenod", "remov", "node", "testroot", "glob=", "testus", "allow", "jcr", "removenod", "remov", "node", "testroot", "glob=", "noformat", "now", "haspermiss", "ha", "permiss", "tesroot", "jcr", "removenod", "remov", "node", "fals", "but", "user", "still", "abl", "delet", "node", "we", "chang", "order", "ace", "ac", "es", "restrict", "it", "work", "user", "cant", "delet", "we", "use", "direct", "acl", "ac", "ls", "respect", "node", "it", "work", "think", "thi", "bug", "but", "im", "not", "sure", "haspermiss", "ha", "permiss", "wrong", "or", "check", "dure", "node", "delet"], "B_title": "Evaluation with restriction is not consistent with parent ACLs", "B_clean_title": ["evalu", "restrict", "not", "consist", "parent", "acl", "ac", "ls"]},
{"A_title": "ArrayIndexOutOfBoundsException on impossible non-static inner class constructorMinimal repro:     Fails like this:   Validation is missing for this impossible constructor. Works as expected when  InnerSomething is static.", "A_clean_title": ["arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "imposs", "non", "static", "inner", "class", "constructorminim", "constructor", "minim", "repro", "fail", "like", "thi", "valid", "miss", "thi", "imposs", "constructor", "work", "as", "expect", "when", "innersometh", "inner", "someth", "static"], "B_title": "Fix #1501", "B_clean_title": ["fix", "1501"]},
{"A_title": "Hierarchy conflict detection brokenHierarchy conflict detection is broken in 1.0.14. It may happen that a child document is created even though the parent is considered deleted.", "A_clean_title": ["hierarchi", "conflict", "detect", "brokenhierarchi", "broken", "hierarchi", "conflict", "detect", "broken", "14", "it", "may", "happen", "that", "child", "document", "creat", "even", "though", "parent", "consid", "delet"], "B_title": "Hierarchy conflict detection broken", "B_clean_title": ["hierarchi", "conflict", "detect", "broken"]},
{"A_title": "BigFraction.doubleValue() returns Double.NaN for large numerators or denominatorsThe current implementation of doubleValue() divides numerator.doubleValue() / denominator.doubleValue().  BigInteger.doubleValue() fails for any number greater than Double.MAX_VALUE.  So if the user has 308-digit numerator or denominator the resulting quotient fails even in cases where the result would be well inside Doubles range. I have a patch to fix it if I can figure out how to attach it here I will.", "A_clean_title": ["bigfract", "doublevalu", "big", "fraction", "doubl", "valu", "return", "doubl", "nan", "na", "larg", "numer", "or", "denominatorsth", "denomin", "current", "implement", "doublevalu", "doubl", "valu", "divid", "numer", "doublevalu", "doubl", "valu", "denomin", "doublevalu", "doubl", "valu", "biginteg", "doublevalu", "big", "integ", "doubl", "valu", "fail", "ani", "number", "greater", "than", "doubl", "max", "valu", "so", "user", "ha", "308", "digit", "numer", "or", "denomin", "result", "quotient", "fail", "even", "case", "where", "result", "would", "well", "insid", "doubl", "rang", "have", "patch", "fix", "it", "figur", "out", "how", "attach", "it", "here", "will"], "B_title": "Fixed doubleValue() and floatValue() when numerator and denominator are larger than the range of the corresponding primitive type.", "B_clean_title": ["fix", "doublevalu", "doubl", "valu", "floatvalu", "float", "valu", "when", "numer", "denomin", "are", "larger", "than", "rang", "correspond", "primit", "type"]},
{"A_title": "CompactCommand description is incorrectThe compact command has the following description  code root@accumulo> compact -? usage: compact <table> <table> -? -b <begin-row> --cancel -e <end-row> -nf -ns <namespace> | -p <pattern> | -t <tableName>  -pn <profile>  -w description: sets all tablets for a table to major compact as soon as possible (based on current time)   -?--help                       display this help   -b--begin-row <begin-row>      begin row (inclusive)      --cancel                     cancel user initiated compactions   -e--end-row <end-row>          end row (inclusive)   -nf--noFlush                   do not flush table data in memory before compacting.   -ns--namespace <namespace>     name of a namespace to operate on   -p--pattern <pattern>          regex pattern of table names to operate on   -pn--profile <profile>         iterator profile name   -t--table <tableName>          name of a table to operate on   -w--wait                       wait for compact to finish code  However the --begin-row is not inclusive.  Here is a simple demonstration. code createtable compacttest addsplits a b c insert a 1   insert a 2   insert b 3   insert b 4   insert c 5   insert c 6   flush -w scan -t accumulo.metadata -np compact -b a -e c -t compacttest -w scan -t accumulo.metadata -np deletetable compacttest -f code  You will see that file associated with the a split is still a F flush file which the files in the b and c split are A files.  Not sure if the fix is to update the commands description which would be easy or to make the begin row actually inclusive.", "A_clean_title": ["compactcommand", "compact", "command", "descript", "incorrectth", "incorrect", "compact", "command", "ha", "follow", "descript", "code", "root", "accumulo", "compact", "usag", "compact", "tabl", "tabl", "begin", "row", "cancel", "end", "row", "nf", "ns", "namespac", "pattern", "tablenam", "tabl", "name", "pn", "profil", "descript", "set", "all", "tablet", "tabl", "major", "compact", "as", "soon", "as", "possibl", "base", "current", "time", "help", "display", "thi", "help", "begin", "row", "begin", "row", "begin", "row", "inclus", "cancel", "cancel", "user", "initi", "compact", "end", "row", "end", "row", "end", "row", "inclus", "nf", "noflush", "no", "flush", "not", "flush", "tabl", "data", "memori", "befor", "compact", "ns", "namespac", "namespac", "name", "namespac", "oper", "pattern", "pattern", "regex", "pattern", "tabl", "name", "oper", "pn", "profil", "profil", "iter", "profil", "name", "tabl", "tablenam", "tabl", "name", "name", "tabl", "oper", "wait", "wait", "compact", "finish", "code", "howev", "begin", "row", "not", "inclus", "here", "simpl", "demonstr", "code", "createt", "compacttest", "addsplit", "insert", "insert", "insert", "insert", "insert", "insert", "flush", "scan", "accumulo", "metadata", "np", "compact", "compacttest", "scan", "accumulo", "metadata", "np", "deletet", "compacttest", "code", "you", "will", "see", "that", "file", "associ", "split", "still", "flush", "file", "which", "file", "split", "are", "file", "not", "sure", "fix", "updat", "command", "descript", "which", "would", "easi", "or", "make", "begin", "row", "actual", "inclus"], "B_title": "Fix the description of -b options", "B_clean_title": ["fix", "descript", "option"]},
{"A_title": "Troublesome ExternalIdentityRef.equals(Object) implementationin the light of OAK-3508 i looked at the ExternalIdentifyRef class and found the following implementation of Object.equals(Object):  code public boolean equals(Object o)          try              // assuming that we never compare other types of classes             return this == o || string.equals(((ExternalIdentityRef) o).string);          catch (Exception e)              return false;               code  since this class is public and exported as part of a public API i dont think the assumption made in the code is justified. also i would argue that catching Exception is bad style as is exception driven development. in this particular case it was IMHO perfectly trivial to just get rid of the catch clause altogether.", "A_clean_title": ["troublesom", "externalidentityref", "equal", "extern", "ident", "ref", "object", "implementationin", "light", "oak", "3508", "look", "at", "externalidentifyref", "extern", "identifi", "ref", "class", "found", "follow", "implement", "object", "equal", "object", "code", "public", "boolean", "equal", "object", "tri", "assum", "that", "we", "never", "compar", "other", "type", "class", "return", "thi", "string", "equal", "externalidentityref", "extern", "ident", "ref", "string", "catch", "except", "return", "fals", "code", "sinc", "thi", "class", "public", "export", "as", "part", "public", "api", "dont", "think", "assumpt", "made", "code", "justifi", "also", "would", "argu", "that", "catch", "except", "bad", "style", "as", "except", "driven", "develop", "thi", "particular", "case", "it", "wa", "imho", "perfectli", "trivial", "just", "get", "rid", "catch", "claus", "altogeth"], "B_title": ": Troublesome ExternalIdentityRef.equals(Object) implementation", "B_clean_title": ["troublesom", "externalidentityref", "equal", "extern", "ident", "ref", "object", "implement"]},
{"A_title": "Failed task deployment causes NPE on input split assignmentThe input split assignment code is returning null if the Task has failed which is causing a NPE.  We should improve our error handling / reporting in that situation.  code 13:12:31002 INFO  org.apache.flink.yarn.ApplicationMaster  anonfun 2  anon 1    - Status of job c0b47ce41e9a85a628a628a3977705ef (Flink Java Job at Tue Apr 21 13:10:36 UTC 2015) changed to FAILING Cannot deploy task - TaskManager not responding.. .... 13:12:47591 ERROR org.apache.flink.runtime.operators.RegularPactTask            - Error in task code:  CHAIN DataSource (at userMethod (org.apache.flink.api.java.io.AvroInputFormat)) -> FlatMap (FlatMap at main(UserClass.java:111)) (20/50) java.lang.RuntimeException: Requesting the next InputSplit failed. at org.apache.flink.runtime.taskmanager.TaskInputSplitProvider.getNextInputSplit(TaskInputSplitProvider.java:88) at org.apache.flink.runtime.operators.DataSourceTask 1.hasNext(DataSourceTask.java:337) at org.apache.flink.runtime.operators.DataSourceTask.invoke(DataSourceTask.java:136) at org.apache.flink.runtime.execution.RuntimeEnvironment.run(RuntimeEnvironment.java:217) at java.lang.Thread.run(Thread.java:744) Caused by: java.lang.NullPointerException at java.io.ByteArrayInputStream.<init>(ByteArrayInputStream.java:106) at org.apache.flink.util.InstantiationUtil.deserializeObject(InstantiationUtil.java:301) at org.apache.flink.runtime.taskmanager.TaskInputSplitProvider.getNextInputSplit(TaskInputSplitProvider.java:83) ... 4 more 13:12:47595 INFO  org.apache.flink.runtime.taskmanager.Task                     - CHAIN DataSource (at SomeMethod (org.apache.flink.api.java.io.AvroInputFormat)) -> FlatMap (FlatMap at main(SomeClass.java:111)) (20/50) switched to FAILED : java.lang.RuntimeException: Requesting the next InputSplit failed. at org.apache.flink.runtime.taskmanager.TaskInputSplitProvider.getNextInputSplit(TaskInputSplitProvider.java:88) at org.apache.flink.runtime.operators.DataSourceTask 1.hasNext(DataSourceTask.java:337) at org.apache.flink.runtime.operators.DataSourceTask.invoke(DataSourceTask.java:136) at org.apache.flink.runtime.execution.RuntimeEnvironment.run(RuntimeEnvironment.java:217) at java.lang.Thread.run(Thread.java:744) Caused by: java.lang.NullPointerException at java.io.ByteArrayInputStream.<init>(ByteArrayInputStream.java:106) at org.apache.flink.util.InstantiationUtil.deserializeObject(InstantiationUtil.java:301) at org.apache.flink.runtime.taskmanager.TaskInputSplitProvider.getNextInputSplit(TaskInputSplitProvider.java:83) ... 4 more code", "A_clean_title": ["fail", "task", "deploy", "caus", "npe", "input", "split", "assignmentth", "assign", "input", "split", "assign", "code", "return", "null", "task", "ha", "fail", "which", "caus", "npe", "we", "improv", "our", "error", "handl", "report", "that", "situat", "code", "13:12:31002", "info", "org", "apach", "flink", "yarn", "applicationmast", "applic", "master", "anonfun", "anon", "statu", "job", "c0b47ce41e9a85a628a628a3977705ef", "flink", "java", "job", "at", "tue", "apr", "21", "13:10:36", "utc", "2015", "chang", "fail", "not", "deploy", "task", "taskmanag", "task", "manag", "not", "respond", "13:12:47591", "error", "org", "apach", "flink", "runtim", "oper", "regularpacttask", "regular", "pact", "task", "error", "task", "code", "chain", "datasourc", "data", "sourc", "at", "usermethod", "user", "method", "org", "apach", "flink", "api", "java", "io", "avroinputformat", "avro", "input", "format", "flatmap", "flat", "map", "flatmap", "flat", "map", "at", "main", "userclass", "java:111", "user", "class", "20", "50", "java", "lang", "runtimeexcept", "runtim", "except", "request", "next", "inputsplit", "input", "split", "fail", "at", "org", "apach", "flink", "runtim", "taskmanag", "taskinputsplitprovid", "getnextinputsplit", "task", "input", "split", "provid", "get", "next", "input", "split", "taskinputsplitprovid", "java:88", "task", "input", "split", "provid", "at", "org", "apach", "flink", "runtim", "oper", "datasourcetask", "data", "sourc", "task", "hasnext", "ha", "next", "datasourcetask", "java:337", "data", "sourc", "task", "at", "org", "apach", "flink", "runtim", "oper", "datasourcetask", "invok", "data", "sourc", "task", "datasourcetask", "java:136", "data", "sourc", "task", "at", "org", "apach", "flink", "runtim", "execut", "runtimeenviron", "run", "runtim", "environ", "runtimeenviron", "java:217", "runtim", "environ", "at", "java", "lang", "thread", "run", "thread", "java:744", "caus", "by", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "java", "io", "bytearrayinputstream", "byte", "array", "input", "stream", "init", "bytearrayinputstream", "java:106", "byte", "array", "input", "stream", "at", "org", "apach", "flink", "util", "instantiationutil", "deserializeobject", "instanti", "util", "deseri", "object", "instantiationutil", "java:301", "instanti", "util", "at", "org", "apach", "flink", "runtim", "taskmanag", "taskinputsplitprovid", "getnextinputsplit", "task", "input", "split", "provid", "get", "next", "input", "split", "taskinputsplitprovid", "java:83", "task", "input", "split", "provid", "more", "13:12:47595", "info", "org", "apach", "flink", "runtim", "taskmanag", "task", "chain", "datasourc", "data", "sourc", "at", "somemethod", "some", "method", "org", "apach", "flink", "api", "java", "io", "avroinputformat", "avro", "input", "format", "flatmap", "flat", "map", "flatmap", "flat", "map", "at", "main", "someclass", "java:111", "some", "class", "20", "50", "switch", "fail", "java", "lang", "runtimeexcept", "runtim", "except", "request", "next", "inputsplit", "input", "split", "fail", "at", "org", "apach", "flink", "runtim", "taskmanag", "taskinputsplitprovid", "getnextinputsplit", "task", "input", "split", "provid", "get", "next", "input", "split", "taskinputsplitprovid", "java:88", "task", "input", "split", "provid", "at", "org", "apach", "flink", "runtim", "oper", "datasourcetask", "data", "sourc", "task", "hasnext", "ha", "next", "datasourcetask", "java:337", "data", "sourc", "task", "at", "org", "apach", "flink", "runtim", "oper", "datasourcetask", "invok", "data", "sourc", "task", "datasourcetask", "java:136", "data", "sourc", "task", "at", "org", "apach", "flink", "runtim", "execut", "runtimeenviron", "run", "runtim", "environ", "runtimeenviron", "java:217", "runtim", "environ", "at", "java", "lang", "thread", "run", "thread", "java:744", "caus", "by", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "java", "io", "bytearrayinputstream", "byte", "array", "input", "stream", "init", "bytearrayinputstream", "java:106", "byte", "array", "input", "stream", "at", "org", "apach", "flink", "util", "instantiationutil", "deserializeobject", "instanti", "util", "deseri", "object", "instantiationutil", "java:301", "instanti", "util", "at", "org", "apach", "flink", "runtim", "taskmanag", "taskinputsplitprovid", "getnextinputsplit", "task", "input", "split", "provid", "get", "next", "input", "split", "taskinputsplitprovid", "java:83", "task", "input", "split", "provid", "more", "code"], "B_title": "runtime Fixes NPE when TM receives a null input split", "B_clean_title": ["runtim", "fix", "npe", "when", "tm", "receiv", "null", "input", "split"]},
{"A_title": "Wrong type name reported on missing property error.None", "A_clean_title": ["wrong", "type", "name", "report", "miss", "properti", "error", "none"], "B_title": "Rejigger type name printing. Fixes issue 1047 R=johnlenz", "B_clean_title": ["rejigg", "type", "name", "print", "fix", "issu", "1047", "r=johnlenz"]},
{"A_title": "Parantheses problem with UrlValidatorOne of our users got an error message when trying to add a new URL:  http://en.wikipedia.org/wiki/Genus_(mathematics) is not a valid URL  I just created very quickly a junit test and it fails:  String schemes = http; UrlValidator urlValidator = new UrlValidator(schemes); assertTrue(urlValidator.isValid(http://en.wikipedia.org/wiki/Genus_(mathematics)));", "A_clean_title": ["paranthes", "problem", "urlvalidatoron", "url", "valid", "one", "our", "user", "got", "error", "messag", "when", "tri", "add", "new", "url", "http", "wikipedia", "en", "org", "wiki", "genu", "mathemat", "not", "valid", "url", "just", "creat", "veri", "quickli", "junit", "test", "it", "fail", "string", "scheme", "http", "urlvalid", "url", "valid", "urlvalid", "url", "valid", "new", "urlvalid", "url", "valid", "scheme", "asserttru", "assert", "true", "urlvalid", "isvalid", "url", "valid", "valid", "http", "wikipedia", "en", "org", "wiki", "genu", "mathemat"], "B_title": "parentheses are valid in url path", "B_clean_title": ["parenthes", "are", "valid", "url", "path"]},
{"A_title": "InjectMocks injects mock into wrong field.When using @InjectMocks on some Android TextViews the mock is injected into the wrong field.  We have two fields txtGateView & txtNextStep in a class and our test mocks out txtNextStep then tried to inject. This field is injected wrong. From our quick testing the name txtNextView doesnt matter that can be changed. But both txtGateView and txtGateLabel messed things up. If we mock out both fields it works correctly.", "A_clean_title": ["injectmock", "inject", "mock", "inject", "mock", "into", "wrong", "field", "when", "injectmock", "inject", "mock", "some", "android", "textview", "text", "view", "mock", "inject", "into", "wrong", "field", "we", "have", "two", "field", "txtgateview", "txt", "gate", "view", "txtnextstep", "txt", "next", "step", "class", "our", "test", "mock", "out", "txtnextstep", "txt", "next", "step", "then", "tri", "inject", "thi", "field", "inject", "wrong", "our", "quick", "test", "name", "txtnextview", "txt", "next", "view", "doesnt", "matter", "that", "chang", "but", "both", "txtgateview", "txt", "gate", "view", "txtgatelabel", "txt", "gate", "label", "mess", "thing", "up", "we", "mock", "out", "both", "field", "it", "work", "correctli"], "B_title": "Fixes #205.", "B_clean_title": ["fix", "205"]},
{"A_title": "Page.checkRendering fails after setting BorderBodyContainer visiblity to falseAfter toggling visibility of the BorderBodyContainer to false the Page.checkRendering method fails in line 1157 claiming an iterator IllegalStateException. This happens because iterator.remove() is called twice for a child component in the border component if the body is not visible.  My Code:  public class TogglePanel extends Border  private boolean expanded = true;  public TogglePanel(String id IModel<String> titleModel)  super(id titleModel);  Link link = new Link(title)   @Override public void onClick()  expanded = !expanded; getBodyContainer().setVisible(expanded);  ; link.add(new Label(titleLabel titleModel));  add(link);     Markup:  <wicket:border> <h3 class=collapse wicket:id=title> <span class=label wicket:id=titleLabel>Panel Title</span> <a class=foldicon>&nbsp;</a> </h3> <wicket:body /> </wicket:border>", "A_clean_title": ["page", "checkrend", "check", "render", "fail", "after", "set", "borderbodycontain", "border", "bodi", "contain", "visibl", "falseaft", "fals", "after", "toggl", "visibl", "borderbodycontain", "border", "bodi", "contain", "fals", "page", "checkrend", "check", "render", "method", "fail", "line", "1157", "claim", "iter", "illegalstateexcept", "illeg", "state", "except", "thi", "happen", "becaus", "iter", "remov", "call", "twice", "child", "compon", "border", "compon", "bodi", "not", "visibl", "my", "code", "public", "class", "togglepanel", "toggl", "panel", "extend", "border", "privat", "boolean", "expand", "true", "public", "togglepanel", "toggl", "panel", "string", "id", "imodel", "model", "string", "titlemodel", "titl", "model", "super", "id", "titlemodel", "titl", "model", "link", "link", "new", "link", "titl", "overrid", "public", "void", "onclick", "click", "expand", "expand", "getbodycontain", "get", "bodi", "contain", "setvis", "set", "visibl", "expand", "link", "add", "new", "label", "titlelabel", "titl", "label", "titlemodel", "titl", "model", "add", "link", "markup", "wicket", "border", "h3", "class=collaps", "wicket", "id=titl", "span", "class=label", "wicket", "id=titlelabel", "id=titl", "label", "panel", "titl", "span", "class=foldicon", "nbsp", "h3", "wicket", "bodi", "wicket", "border"], "B_title": "fixed: Page.checkRendering fails after setting BorderBodyContainer visiblity to false Issue: WICKET-2368", "B_clean_title": ["fix", "page", "checkrend", "check", "render", "fail", "after", "set", "borderbodycontain", "border", "bodi", "contain", "visibl", "fals", "issu", "wicket", "2368"]},
{"A_title": "Lucene suggestions index definition cant be restricted to a specific type of nodeWhile performing a suggestor query like   code SELECT rep:suggest() as suggestion  FROM nt:unstructured WHERE suggest(foo) code  Suggestor does not provide any result. In current implementation suggestions|http://jackrabbit.apache.org/oak/docs/query/lucene.html#Suggestions in Oak work only for index definitions for nt:base nodetype. So an index definition like: code:xml     <lucene-suggest         jcr:primaryType=oak:QueryIndexDefinition         async=async         compatVersion=Long2         type=lucene>         <indexRules jcr:primaryType=nt:unstructured>             <nt:base jcr:primaryType=nt:unstructured>                 <properties jcr:primaryType=nt:unstructured>                     <description                         jcr:primaryType=nt:unstructured                         analyzed=Booleantrue                         name=description                         propertyIndex=Booleantrue                         useInSuggest=Booleantrue/>                 </properties>             </nt:base>         </indexRules>     </lucene-suggest> code works but if we change nodetype to nt:unstructured like: code:xml     <lucene-suggest         jcr:primaryType=oak:QueryIndexDefinition         async=async         compatVersion=Long2         type=lucene>         <indexRules jcr:primaryType=nt:unstructured>             <nt:unstructured jcr:primaryType=nt:unstructured>                 <properties jcr:primaryType=nt:unstructured>                     <description                         jcr:primaryType=nt:unstructured                         analyzed=Booleantrue                         name=description                         propertyIndex=Booleantrue                         useInSuggest=Booleantrue/>                 </properties>             </nt:base>         </indexRules>     </lucene-suggest> code  it wont work.  The issue is that suggestor implementation essentially is passing a pseudo row with path=/.: code:title=LucenePropertyIndex.java     private boolean loadDocs()  ...                         queue.add(new LuceneResultRow(suggestedWords)); ... code and code:title=LucenePropertyIndex.java         LuceneResultRow(Iterable<String> suggestWords)              this.path = /;             this.score = 1.0d;             this.suggestWords = suggestWords;          code Due to path being set to / SelectorImpl later filters out the result as rep:root (primary type of /) isnt a nt:unstructured.", "A_clean_title": ["lucen", "suggest", "index", "definit", "cant", "restrict", "specif", "type", "nodewhil", "node", "while", "perform", "suggestor", "queri", "like", "code", "select", "rep", "suggest", "as", "suggest", "nt", "unstructur", "where", "suggest", "foo", "code", "suggestor", "not", "provid", "ani", "result", "current", "implement", "suggestions|http", "apach", "html", "jackrabbit", "org", "oak", "doc", "queri", "lucen", "suggest", "oak", "work", "onli", "index", "definit", "nt", "base", "nodetyp", "so", "index", "definit", "like", "code", "xml", "lucen", "suggest", "jcr", "primarytype=oak", "primari", "type=oak", "queryindexdefinit", "queri", "index", "definit", "async=async", "compatversion=long2", "compat", "version=long2", "type=lucen", "indexrul", "index", "rule", "jcr", "primarytype=nt", "primari", "type=nt", "unstructur", "nt", "base", "jcr", "primarytype=nt", "primari", "type=nt", "unstructur", "properti", "jcr", "primarytype=nt", "primari", "type=nt", "unstructur", "descript", "jcr", "primarytype=nt", "primari", "type=nt", "unstructur", "analyzed=booleantru", "name=descript", "propertyindex=booleantru", "properti", "index=booleantru", "useinsuggest=booleantru", "use", "suggest=booleantru", "properti", "nt", "base", "indexrul", "index", "rule", "suggest", "lucen", "code", "work", "but", "we", "chang", "nodetyp", "nt", "unstructur", "like", "code", "xml", "lucen", "suggest", "jcr", "primarytype=oak", "primari", "type=oak", "queryindexdefinit", "queri", "index", "definit", "async=async", "compatversion=long2", "compat", "version=long2", "type=lucen", "indexrul", "index", "rule", "jcr", "primarytype=nt", "primari", "type=nt", "unstructur", "nt", "unstructur", "jcr", "primarytype=nt", "primari", "type=nt", "unstructur", "properti", "jcr", "primarytype=nt", "primari", "type=nt", "unstructur", "descript", "jcr", "primarytype=nt", "primari", "type=nt", "unstructur", "analyzed=booleantru", "name=descript", "propertyindex=booleantru", "properti", "index=booleantru", "useinsuggest=booleantru", "use", "suggest=booleantru", "properti", "nt", "base", "indexrul", "index", "rule", "suggest", "lucen", "code", "it", "wont", "work", "issu", "that", "suggestor", "implement", "essenti", "pass", "pseudo", "row", "path=", "code", "title=lucenepropertyindex", "java", "title=lucen", "properti", "index", "privat", "boolean", "loaddoc", "load", "doc", "queue", "add", "new", "luceneresultrow", "lucen", "result", "row", "suggestedword", "suggest", "word", "code", "code", "title=lucenepropertyindex", "java", "title=lucen", "properti", "index", "luceneresultrow", "lucen", "result", "row", "iter", "string", "suggestword", "suggest", "word", "thi", "path", "thi", "score", "0d", "thi", "suggestword", "suggest", "word", "suggestword", "suggest", "word", "code", "due", "path", "be", "set", "selectorimpl", "selector", "impl", "later", "filter", "out", "result", "as", "rep", "root", "primari", "type", "isnt", "nt", "unstructur"], "B_title": "- Lucene suggestions shouldnt be restricted to specific node types", "B_clean_title": ["lucen", "suggest", "shouldnt", "restrict", "specif", "node", "type"]},
{"A_title": "Identifier minus a negative number needs a space between the -sNone", "A_clean_title": ["identifi", "minu", "neg", "number", "need", "space", "between", "snone", "none"], "B_title": "Negative zero is a special case and needs to be handled differently to prevent it from getting confused with decrement fixes issue 657", "B_clean_title": ["neg", "zero", "special", "case", "need", "handl", "differ", "prevent", "it", "get", "confus", "decrement", "fix", "issu", "657"]},
{"A_title": "Cryptic error message on invalid @type function annotationNone", "A_clean_title": ["cryptic", "error", "messag", "invalid", "type", "function", "annotationnon", "annot", "none"], "B_title": "Fix a jsdoc parser bug where it was dropping the EndOfComment token Fixes issue 477", "B_clean_title": ["fix", "jsdoc", "parser", "bug", "where", "it", "wa", "drop", "endofcom", "end", "comment", "token", "fix", "issu", "477"]},
{"A_title": "Negative millis display incorrectly in Period.toStringThe last line should produce PT-0.100S instead of PT0.100S.", "A_clean_title": ["neg", "milli", "display", "incorrectli", "period", "tostringth", "string", "last", "line", "produc", "pt", "100", "instead", "pt0", "100"], "B_title": "Fix period formatter to correctly output values negative milliseconds 3564249", "B_clean_title": ["fix", "period", "formatt", "correctli", "output", "valu", "neg", "millisecond", "3564249"]},
{"A_title": "Cost per entry for Lucene index of type v1 should be higher than that of v2Currently default cost per entry for Lucene index of type # v1 - which uses query time aggregation # v2 - which uses index time aggregation  Are same. However given that query time aggregation would require more effort it should result in a higher cost per entry.  This fact impacts the result in cases like OAK-2081 (see last few comments) where with usage of limits both index are currently considered equals", "A_clean_title": ["cost", "per", "entri", "lucen", "index", "type", "v1", "higher", "than", "that", "v2current", "default", "cost", "per", "entri", "lucen", "index", "type", "v1", "which", "use", "queri", "time", "aggreg", "v2", "which", "use", "index", "time", "aggreg", "are", "same", "howev", "given", "that", "queri", "time", "aggreg", "would", "requir", "more", "effort", "it", "result", "higher", "cost", "per", "entri", "thi", "fact", "impact", "result", "case", "like", "oak", "2081", "see", "last", "few", "comment", "where", "usag", "limit", "both", "index", "are", "current", "consid", "equal"], "B_title": "- Cost per entry for Lucene index of type v1 should be higher than that of v2", "B_clean_title": ["cost", "per", "entri", "lucen", "index", "type", "v1", "higher", "than", "that", "v2"]},
{"A_title": "NPE importing EMX with abtract entity type dataHow to Reproduce  Import  this file Expected behavior  Success or if I am not allowed to add data to abstract entities I expect a message  Observed behavior  Importer hangs server logs report a null pointer exception in the  dataservice.add() method.", "A_clean_title": ["npe", "import", "emx", "abtract", "entiti", "type", "datahow", "data", "how", "reproduc", "import", "thi", "file", "expect", "behavior", "success", "or", "am", "not", "allow", "add", "data", "abstract", "entiti", "expect", "messag", "observ", "behavior", "import", "hang", "server", "log", "report", "null", "pointer", "except", "dataservic", "add", "method"], "B_title": "Merge pull request #7320 from dennishendriksen/fix/6945-emxAbstractEntityTypeData  Fix #6945 NPE importing EMX with abtract entity type data", "B_clean_title": ["merg", "pull", "request", "7320", "emxabstractentitytypedata", "dennishendriksen", "fix", "6945", "emx", "abstract", "entiti", "type", "data", "fix", "6945", "npe", "import", "emx", "abtract", "entiti", "type", "data"]},
{"A_title": "TypeUtils.getTypeArguments() misses type arguments for partially-assigned classesfailing test code to add to TypeUtilsTest.testGetTypeArguments():  typeVarAssigns = TypeUtils.getTypeArguments(Other.class This.class); Assert.assertEquals(2 typeVarAssigns.size()); Assert.assertEquals(String.class typeVarAssigns.get(This.class.getTypeParameters()0)); Assert.assertEquals(Other.class.getTypeParameters()0 typeVarAssigns.get(This.class.getTypeParameters()1));   These should pass based on:   public interface This<K V>    public class Other<T> implements This<String T>     This case fails because the current code ignores the Other class due to its specifying its own type variables which is obviously incorrect.  This report is extrapolated from an offline report received by Hen.", "A_clean_title": ["typeutil", "gettypeargu", "type", "util", "get", "type", "argument", "miss", "type", "argument", "partial", "assign", "classesfail", "test", "code", "add", "typeutilstest", "testgettypeargu", "type", "util", "test", "test", "get", "type", "argument", "typevarassign", "type", "var", "assign", "typeutil", "gettypeargu", "type", "util", "get", "type", "argument", "other", "class", "thi", "class", "assert", "assertequ", "assert", "equal", "typevarassign", "size", "type", "var", "assign", "assert", "assertequ", "assert", "equal", "string", "class", "typevarassign", "get", "type", "var", "assign", "thi", "class", "gettypeparamet", "get", "type", "paramet", "assert", "assertequ", "assert", "equal", "other", "class", "gettypeparamet", "get", "type", "paramet", "typevarassign", "get", "type", "var", "assign", "thi", "class", "gettypeparamet", "get", "type", "paramet", "these", "pass", "base", "public", "interfac", "thi", "public", "class", "other", "implement", "thi", "string", "thi", "case", "fail", "becaus", "current", "code", "ignor", "other", "class", "due", "it", "specifi", "it", "own", "type", "variabl", "which", "obvious", "incorrect", "thi", "report", "extrapol", "offlin", "report", "receiv", "by", "hen"], "B_title": "LANG-776 fix related bugs dealing with type variable inheritance", "B_clean_title": ["lang", "776", "fix", "relat", "bug", "deal", "type", "variabl", "inherit"]},
{"A_title": "Wrong results and NPE with copy operationThe following code either results in an NPE or in a wrong result depending on which Microkernel instance is used.   code     mk.commit( +/root: mk.getHeadRevision() );     mk.commit( +/root/N0:*/root/N0:/root/N1+/root/N0/N4:             mk.getHeadRevision() ); code  The wrong result is  code      :childNodeCount: 2     N0:          :childNodeCount: 1         N4:              :childNodeCount: 0                   N1:          :childNodeCount: 1         N4:              :childNodeCount: 0                code  The expected result is code      :childNodeCount: 2     N0:          :childNodeCount: 1         N4:              :childNodeCount: 0                   N1:          :childNodeCount: 0       code  simple:fs:target/temp: wrong result fs:homeDir/target: NPE http-bridge:fs:homeDir/target: NPE simple: wrong result", "A_clean_title": ["wrong", "result", "npe", "copi", "operationth", "oper", "follow", "code", "either", "result", "npe", "or", "wrong", "result", "depend", "which", "microkernel", "instanc", "use", "code", "mk", "commit", "root", "mk", "getheadrevis", "get", "head", "revis", "mk", "commit", "root", "n0", "root", "n0", "root", "n1+", "root", "n0", "n4", "mk", "getheadrevis", "get", "head", "revis", "code", "wrong", "result", "code", "childnodecount", "child", "node", "count", "n0", "childnodecount", "child", "node", "count", "n4", "childnodecount", "child", "node", "count", "n1", "childnodecount", "child", "node", "count", "n4", "childnodecount", "child", "node", "count", "code", "expect", "result", "code", "childnodecount", "child", "node", "count", "n0", "childnodecount", "child", "node", "count", "n4", "childnodecount", "child", "node", "count", "n1", "childnodecount", "child", "node", "count", "code", "simpl", "fs", "target", "temp", "wrong", "result", "fs", "homedir", "target", "home", "dir", "npe", "http", "bridg", "fs", "homedir", "target", "home", "dir", "npe", "simpl", "wrong", "result"], "B_title": "Wrong results and NPE with copy operation (support the copy operation in the Indexer and the SimpleKernel)", "B_clean_title": ["wrong", "result", "npe", "copi", "oper", "support", "copi", "oper", "index", "simplekernel", "simpl", "kernel"]},
{"A_title": "Repeated MongoMK.rebase() always adds new revisionMongoMK always adds a new revision to the branch on rebase even when the branch is already up-to-date.", "A_clean_title": ["repeat", "mongomk", "rebas", "mongo", "mk", "alway", "add", "new", "revisionmongomk", "revis", "mongo", "mk", "alway", "add", "new", "revis", "branch", "rebas", "even", "when", "branch", "alreadi", "up", "date"], "B_title": "Repeated MongoMK.rebase() always adds new revision", "B_clean_title": ["repeat", "mongomk", "rebas", "mongo", "mk", "alway", "add", "new", "revis"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "Wrong  variable type (int instead of double).", "B_clean_title": ["wrong", "variabl", "type", "int", "instead", "doubl"]},
{"A_title": "Interval class upper and lower checkIn class Interval which is in the package org.apache.commons.math4.geometry.euclidean.oned it is possible to pass the value for variable upper  less than the value of variable lower which is logically incorrect and  also causes the method getSize() to return negative value.  For example:   @Test   public void test1()  throws Throwable         Interval interval0 = new Interval(0.0 (-1.0));       double double0 = interval0.getSize();       assertEquals((-1.0) double0 0.01D);", "A_clean_title": ["interv", "class", "upper", "lower", "checkin", "check", "class", "interv", "which", "packag", "org", "apach", "common", "math4", "geometri", "euclidean", "one", "it", "possibl", "pass", "valu", "variabl", "upper", "less", "than", "valu", "variabl", "lower", "which", "logic", "incorrect", "also", "caus", "method", "getsiz", "get", "size", "return", "neg", "valu", "exampl", "test", "public", "void", "test1", "throw", "throwabl", "interv", "interval0", "new", "interv", "doubl", "double0", "interval0", "getsiz", "get", "size", "assertequ", "assert", "equal", "double0", "01d"], "B_title": "", "B_clean_title": []},
{"A_title": "Node builder for existing node return null for base stateMemoryNodeBuilder.getBaseState() returns null on builder for an existing node.", "A_clean_title": ["node", "builder", "exist", "node", "return", "null", "base", "statememorynodebuild", "getbasest", "state", "memori", "node", "builder", "get", "base", "state", "return", "null", "builder", "exist", "node"], "B_title": " Node builder for existing node return null for base state", "B_clean_title": ["node", "builder", "exist", "node", "return", "null", "base", "state"]},
{"A_title": "--process_closure_primitives cant be set to falseNone", "A_clean_title": ["process", "closur", "primit", "cant", "set", "falsenon", "fals", "none"], "B_title": "Removing useless members variables. (Alan) R=robert DELTA=4  (0 added 4 deleted 0 changed)", "B_clean_title": ["remov", "useless", "member", "variabl", "alan", "r=robert", "delta=4", "ad", "delet", "chang"]},
{"A_title": "Path parsing must support SNS indexes irrespective of SNS supportcode Session.getNode(/foo/bar2); code  throws javax.jcr.RepositoryException: Invalid name or path: /foo/bar2  This should be an ItemNotFoundException (if the item does not exist) irrespective if the repository supports SNS or not.", "A_clean_title": ["path", "pars", "must", "support", "sn", "index", "irrespect", "sn", "supportcod", "session", "getnod", "get", "node", "foo", "bar2", "code", "throw", "javax", "jcr", "repositoryexcept", "repositori", "except", "invalid", "name", "or", "path", "foo", "bar2", "thi", "itemnotfoundexcept", "item", "not", "found", "except", "item", "not", "exist", "irrespect", "repositori", "support", "sn", "or", "not"], "B_title": "Path parsing must support SNS indexes irrespective of SNS support", "B_clean_title": ["path", "pars", "must", "support", "sn", "index", "irrespect", "sn", "support"]},
{"A_title": "Days#daysBetween throw exception for MonthDay with 29 FebruaryIs there a way to avoid this happening? I understand fiddling around with the leap year youre bound to get issues.", "A_clean_title": ["day", "daysbetween", "day", "between", "throw", "except", "monthday", "month", "day", "29", "februaryi", "februari", "there", "way", "avoid", "thi", "happen", "understand", "fiddl", "around", "leap", "year", "your", "bound", "get", "issu"], "B_title": "Days.daysBetween fails for MonthDay", "B_clean_title": ["day", "daysbetween", "day", "between", "fail", "monthday", "month", "day"]},
{"A_title": "Non-root lucene index throws exception if query constraints match root of sub-treeLucenePropetyIndexProvider returns incorrect (normalized) path for root of sub-tree if index is defined on the sub-tree. e.g. /jcr:root/test//element(* nt:base)@foo=bar would fail with following defn noformat + /test     - foo=bar     + test1           - foo=bar     + oak:index            - indexRules/nt:base/properties/foo/propertyIndex=true noformat", "A_clean_title": ["non", "root", "lucen", "index", "throw", "except", "queri", "constraint", "match", "root", "sub", "treelucenepropetyindexprovid", "tree", "lucen", "propeti", "index", "provid", "return", "incorrect", "normal", "path", "root", "sub", "tree", "index", "defin", "sub", "tree", "jcr", "root", "test", "element", "nt", "base", "foo=bar", "would", "fail", "follow", "defn", "noformat", "test", "foo=bar", "test1", "foo=bar", "oak", "index", "indexrul", "nt", "index", "rule", "base", "properti", "foo", "propertyindex=tru", "properti", "index=tru", "noformat"], "B_title": "Non-root lucene index throws exception if query constraints match root of sub-tree", "B_clean_title": ["non", "root", "lucen", "index", "throw", "except", "queri", "constraint", "match", "root", "sub", "tree"]},
{"A_title": "optimization fails with variable in catch clauseNone", "A_clean_title": ["optim", "fail", "variabl", "catch", "clausenon", "claus", "none"], "B_title": "Special case catch expressions to work around the fact that we dont module catch block as lexical scope for the exception and it doesnt belong in the function scope. Fixes issue 864.", "B_clean_title": ["special", "case", "catch", "express", "work", "around", "fact", "that", "we", "dont", "modul", "catch", "block", "as", "lexic", "scope", "except", "it", "doesnt", "belong", "function", "scope", "fix", "issu", "864"]},
{"A_title": "BrentOptimizer not always reporting the best pointBrentOptimizer (package o.a.c.m.optimization.univariate) does not check that the point it is going to return is indeed the best one it has encountered. Indeed the last evaluated point might be slightly worse than the one before last.", "A_clean_title": ["brentoptim", "brent", "optim", "not", "alway", "report", "best", "pointbrentoptim", "point", "brent", "optim", "packag", "optim", "univari", "not", "check", "that", "point", "it", "go", "return", "inde", "best", "one", "it", "ha", "encount", "inde", "last", "evalu", "point", "might", "slightli", "wors", "than", "one", "befor", "last"], "B_title": "The best point is sometimes not the last one evaluated.", "B_clean_title": ["best", "point", "sometim", "not", "last", "one", "evalu"]},
{"A_title": "ColumnVisibility parse tree nodes do not have correct location offsets for AND and OR nodesTrying to do some transformations on visibility strings and running into issues working with the parse tree:  Clojure 1.5.1 user=> (import org.apache.accumulo.core.security ColumnVisibility) org.apache.accumulo.core.security.ColumnVisibility user=> (def vis (ColumnVisibility. (W)|(U|V))) #user/vis user=> (.getTermStart (first (.getChildren (.getParseTree vis)))) 1 user=> (.getTermEnd (first (.getChildren (.getParseTree vis)))) 2 user=> (.getTermStart (second (.getChildren (.getParseTree vis)))) 0 user=> (.getTermEnd (second (.getChildren (.getParseTree vis)))) 8  Shouldnt those last two be 5 and 8?", "A_clean_title": ["columnvis", "column", "visibl", "pars", "tree", "node", "not", "have", "correct", "locat", "offset", "or", "nodestri", "node", "tri", "some", "transform", "visibl", "string", "run", "into", "issu", "work", "pars", "tree", "clojur", "user=", "import", "org", "apach", "accumulo", "core", "secur", "columnvis", "column", "visibl", "org", "apach", "accumulo", "core", "secur", "columnvis", "column", "visibl", "user=", "def", "vi", "columnvis", "column", "visibl", "u|v", "user", "vi", "user=", "gettermstart", "get", "term", "start", "first", "getchildren", "get", "children", "getparsetre", "get", "pars", "tree", "vi", "user=", "gettermend", "get", "term", "end", "first", "getchildren", "get", "children", "getparsetre", "get", "pars", "tree", "vi", "user=", "gettermstart", "get", "term", "start", "second", "getchildren", "get", "children", "getparsetre", "get", "pars", "tree", "vi", "user=", "gettermend", "get", "term", "end", "second", "getchildren", "get", "children", "getparsetre", "get", "pars", "tree", "vi", "shouldnt", "those", "last", "two"], "B_title": "Reinsert changes inadvertently lost in cherry-pick", "B_clean_title": ["reinsert", "chang", "inadvert", "lost", "cherri", "pick"]},
{"A_title": "PropertyResolver does not scan for NotNull in annotation treeWhen annotating a field of a bean with e.g. org.hibernate.validator.constraints.NotEmpty this implies javax.validation.constraints.NotNull but PropertyValidator only checks for the annotations immediately on the filed not the tree of annotations. As a result Wicket does not mark the field as required in the UI which it should.  Also PropertyResolver.findNotNullConstraints() is not even protected so cannot be patched in a simple way.  So as a solution I suggest changing findNotNullConstraints() to be protected and rather be something like findConstraints(filter) or findConstraints(clazz) and then in that method method recursively invoking getComposingConstraints to get all constraints but collecting only those of interest. Possibly some care needs to be taken to prevent infinite recursion where constraints are composed of each other (if that compiles).", "A_clean_title": ["propertyresolv", "properti", "resolv", "not", "scan", "notnul", "not", "null", "annot", "treewhen", "tree", "when", "annot", "field", "bean", "org", "hibern", "valid", "constraint", "notempti", "not", "empti", "thi", "impli", "javax", "valid", "constraint", "notnul", "not", "null", "but", "propertyvalid", "properti", "valid", "onli", "check", "annot", "immedi", "file", "not", "tree", "annot", "as", "result", "wicket", "not", "mark", "field", "as", "requir", "ui", "which", "it", "also", "propertyresolv", "findnotnullconstraint", "properti", "resolv", "find", "not", "null", "constraint", "not", "even", "protect", "so", "not", "patch", "simpl", "way", "so", "as", "solut", "suggest", "chang", "findnotnullconstraint", "find", "not", "null", "constraint", "protect", "rather", "someth", "like", "findconstraint", "find", "constraint", "filter", "or", "findconstraint", "find", "constraint", "clazz", "then", "that", "method", "method", "recurs", "invok", "getcomposingconstraint", "get", "compos", "constraint", "get", "all", "constraint", "but", "collect", "onli", "those", "interest", "possibl", "some", "care", "need", "taken", "prevent", "infinit", "recurs", "where", "constraint", "are", "compos", "each", "other", "that", "compil"], "B_title": "PropertyResolver does not scan for NotNull in annotation tree", "B_clean_title": ["propertyresolv", "properti", "resolv", "not", "scan", "notnul", "not", "null", "annot", "tree"]},
{"A_title": "TracingP6SpyListener is not computing the Tags.DB_TYPE properly.Type: bugfix  In the TracingP6SpyListener class line 112   We should take into account that a url returned by a DatabaseMetaData can be null.", "A_clean_title": ["tracingp6spylisten", "trace", "p6spi", "listen", "not", "comput", "tag", "db", "type", "properli", "type", "bugfix", "tracingp6spylisten", "trace", "p6spi", "listen", "class", "line", "112", "we", "take", "into", "account", "that", "url", "return", "by", "databasemetadata", "databas", "meta", "data", "null"], "B_title": "Fixes #4 : protect against possible contractual null values returned by different method from the jdbc interface. Update various dependencies", "B_clean_title": ["fix", "protect", "against", "possibl", "contractu", "null", "valu", "return", "by", "differ", "method", "jdbc", "interfac", "updat", "variou", "depend"]},
{"A_title": "Feedback messages not cleared for invisible/disabled form components on submit.Having:  - IFeedbackMessageFilter.NONE used as the default applications feedback message cleanup filter (in order to make feedback messages not to disappear after page refresh i.e. persistent) - form with validatable component whose enabled/visible state may be dynamically changed by user (e.g. checkbox send me email and text field email)  First user tries to submit form having invalid value - as the result validation error occurs.  Then user makes that component invisible and retries form submitting - as the result no validation errors but form wasnt submitted.  This happens because that component still has error feedback message got from first submit. Note that when using default applications feedback message cleanup filter form is successfully submitted.  Probably feedback messages should be cleared for invisible/disabled form components on submit as it done for visible/enabled components in FormComponent.validate()", "A_clean_title": ["feedback", "messag", "not", "clear", "invis", "disabl", "form", "compon", "submit", "have", "ifeedbackmessagefilt", "none", "feedback", "messag", "filter", "use", "as", "default", "applic", "feedback", "messag", "cleanup", "filter", "order", "make", "feedback", "messag", "not", "disappear", "after", "page", "refresh", "persist", "form", "validat", "compon", "whose", "enabl", "visibl", "state", "may", "dynam", "chang", "by", "user", "checkbox", "send", "me", "email", "text", "field", "email", "first", "user", "tri", "submit", "form", "have", "invalid", "valu", "as", "result", "valid", "error", "occur", "then", "user", "make", "that", "compon", "invis", "retri", "form", "submit", "as", "result", "no", "valid", "error", "but", "form", "wasnt", "submit", "thi", "happen", "becaus", "that", "compon", "still", "ha", "error", "feedback", "messag", "got", "first", "submit", "note", "that", "when", "default", "applic", "feedback", "messag", "cleanup", "filter", "form", "success", "submit", "probabl", "feedback", "messag", "clear", "invis", "disabl", "form", "compon", "submit", "as", "it", "done", "visibl", "enabl", "compon", "formcompon", "valid", "form", "compon"], "B_title": "Feedback messages not cleared for invisible/disabled form components on submit.", "B_clean_title": ["feedback", "messag", "not", "clear", "invis", "disabl", "form", "compon", "submit"]},
{"A_title": "Adding a node to a node that doesnt accept children doesnt fail with ConstraintViolationExceptionMore node type fun!  I ran into this via the tck test org.apache.jackrabbit.test.api.query.SaveTest#testConstraintViolationException.  It seems adding a node to a node that doesnt accept children (like for example nt:query) fails with a RepositoryException that wraps a CommitFailedException with a message along the lines of: Cannot add node q2 at /q1 further wrapping a weird-looking RepositoryException: No matching node definition found for org.apache.jackrabbit.oak.plugins.nodetype.ValidatingNodeTypeManager@257f1b  While this seems ok enough the tck test expects a ConstraintViolationException so thats why I created this bug.   Ill attach a test case shortly.  Trace  code javax.jcr.RepositoryException at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27) at java.lang.reflect.Constructor.newInstance(Constructor.java:513) at org.apache.jackrabbit.oak.api.CommitFailedException.throwRepositoryException(CommitFailedException.java:57) at org.apache.jackrabbit.oak.jcr.SessionDelegate.save(SessionDelegate.java:244) at org.apache.jackrabbit.oak.jcr.SessionImpl.save(SessionImpl.java:283) at org.apache.jackrabbit.oak.jcr.nodetype.NodeTypeTest.illegalAddNode(NodeTypeTest.java:39) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.junit.runners.model.FrameworkMethod 1.runReflectiveCall(FrameworkMethod.java:45) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:30) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47) at org.junit.runners.ParentRunner 3.run(ParentRunner.java:231) at org.junit.runners.ParentRunner 1.schedule(ParentRunner.java:60) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229) at org.junit.runners.ParentRunner.access 000(ParentRunner.java:50) at org.junit.runners.ParentRunner 2.evaluate(ParentRunner.java:222) at org.junit.runners.ParentRunner.run(ParentRunner.java:300) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197) Caused by: org.apache.jackrabbit.oak.api.CommitFailedException: Cannot add node q2 at /q1 at org.apache.jackrabbit.oak.plugins.nodetype.TypeValidator.childNodeAdded(TypeValidator.java:134) at org.apache.jackrabbit.oak.spi.commit.CompositeValidator.childNodeAdded(CompositeValidator.java:68) at org.apache.jackrabbit.oak.spi.commit.ValidatingHook ValidatorDiff.childNodeAdded(ValidatingHook.java:155) at org.apache.jackrabbit.oak.spi.state.AbstractNodeState.compareAgainstBaseState(AbstractNodeState.java:157) at org.apache.jackrabbit.oak.kernel.KernelNodeState.compareAgainstBaseState(KernelNodeState.java:243) at org.apache.jackrabbit.oak.spi.commit.ValidatingHook ValidatorDiff.validate(ValidatingHook.java:110) at org.apache.jackrabbit.oak.spi.commit.ValidatingHook ValidatorDiff.validate(ValidatingHook.java:101) at org.apache.jackrabbit.oak.spi.commit.ValidatingHook ValidatorDiff.childNodeAdded(ValidatingHook.java:157) at org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState 3.childNodeAdded(ModifiedNodeState.java:292) at org.apache.jackrabbit.oak.spi.state.AbstractNodeState.compareAgainstBaseState(AbstractNodeState.java:157) at org.apache.jackrabbit.oak.kernel.KernelNodeState.compareAgainstBaseState(KernelNodeState.java:243) at org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState.compareAgainstBaseState(ModifiedNodeState.java:269) at org.apache.jackrabbit.oak.spi.commit.ValidatingHook ValidatorDiff.validate(ValidatingHook.java:110) at org.apache.jackrabbit.oak.spi.commit.ValidatingHook ValidatorDiff.validate(ValidatingHook.java:101) at org.apache.jackrabbit.oak.spi.commit.ValidatingHook.processCommit(ValidatingHook.java:73) at org.apache.jackrabbit.oak.spi.commit.CompositeHook.processCommit(CompositeHook.java:59) at org.apache.jackrabbit.oak.kernel.KernelNodeStoreBranch.merge(KernelNodeStoreBranch.java:127) at org.apache.jackrabbit.oak.core.RootImpl 2.run(RootImpl.java:239) at org.apache.jackrabbit.oak.core.RootImpl 2.run(RootImpl.java:1) at java.security.AccessController.doPrivileged(Native Method) at javax.security.auth.Subject.doAs(Subject.java:337) at org.apache.jackrabbit.oak.core.RootImpl.commit(RootImpl.java:234) at org.apache.jackrabbit.oak.jcr.SessionDelegate.save(SessionDelegate.java:241) ... 27 more Caused by: javax.jcr.RepositoryException: No matching node definition found for org.apache.jackrabbit.oak.plugins.nodetype.ValidatingNodeTypeManager@257f1b at org.apache.jackrabbit.oak.plugins.nodetype.ReadOnlyNodeTypeManager.getDefinition(ReadOnlyNodeTypeManager.java:406) at org.apache.jackrabbit.oak.plugins.nodetype.TypeValidator EffectiveNodeType.getDefinition(TypeValidator.java:302) at org.apache.jackrabbit.oak.plugins.nodetype.TypeValidator EffectiveNodeType.checkAddChildNode(TypeValidator.java:249) at org.apache.jackrabbit.oak.plugins.nodetype.TypeValidator.childNodeAdded(TypeValidator.java:127) ... 49 more code", "A_clean_title": ["ad", "node", "node", "that", "doesnt", "accept", "children", "doesnt", "fail", "constraintviolationexceptionmor", "constraint", "violat", "except", "more", "node", "type", "fun", "ran", "into", "thi", "via", "tck", "test", "org", "apach", "jackrabbit", "test", "api", "queri", "savetest", "save", "test", "testconstraintviolationexcept", "test", "constraint", "violat", "except", "it", "seem", "ad", "node", "node", "that", "doesnt", "accept", "children", "like", "exampl", "nt", "queri", "fail", "repositoryexcept", "repositori", "except", "that", "wrap", "commitfailedexcept", "commit", "fail", "except", "messag", "along", "line", "not", "add", "node", "q2", "at", "q1", "further", "wrap", "weird", "look", "repositoryexcept", "repositori", "except", "no", "match", "node", "definit", "found", "org", "apach", "jackrabbit", "oak", "plugin", "nodetyp", "validatingnodetypemanag", "valid", "node", "type", "manag", "257f1b", "while", "thi", "seem", "ok", "enough", "tck", "test", "expect", "constraintviolationexcept", "constraint", "violat", "except", "so", "that", "whi", "creat", "thi", "bug", "ill", "attach", "test", "case", "shortli", "trace", "code", "javax", "jcr", "repositoryexcept", "repositori", "except", "at", "sun", "reflect", "nativeconstructoraccessorimpl", "newinstance0", "nativ", "constructor", "accessor", "impl", "new", "instance0", "nativ", "method", "at", "sun", "reflect", "nativeconstructoraccessorimpl", "newinst", "nativ", "constructor", "accessor", "impl", "new", "instanc", "nativeconstructoraccessorimpl", "java:39", "nativ", "constructor", "accessor", "impl", "at", "sun", "reflect", "delegatingconstructoraccessorimpl", "newinst", "deleg", "constructor", "accessor", "impl", "new", "instanc", "delegatingconstructoraccessorimpl", "java:27", "deleg", "constructor", "accessor", "impl", "at", "java", "lang", "reflect", "constructor", "newinst", "new", "instanc", "constructor", "java:513", "at", "org", "apach", "jackrabbit", "oak", "api", "commitfailedexcept", "throwrepositoryexcept", "commit", "fail", "except", "throw", "repositori", "except", "commitfailedexcept", "java:57", "commit", "fail", "except", "at", "org", "apach", "jackrabbit", "oak", "jcr", "sessiondeleg", "save", "session", "deleg", "sessiondeleg", "java:244", "session", "deleg", "at", "org", "apach", "jackrabbit", "oak", "jcr", "sessionimpl", "save", "session", "impl", "sessionimpl", "java:283", "session", "impl", "at", "org", "apach", "jackrabbit", "oak", "jcr", "nodetyp", "nodetypetest", "illegaladdnod", "node", "type", "test", "illeg", "add", "node", "nodetypetest", "java:39", "node", "type", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:597", "at", "org", "junit", "runner", "model", "frameworkmethod", "framework", "method", "runreflectivecal", "run", "reflect", "call", "frameworkmethod", "java:45", "framework", "method", "at", "org", "junit", "intern", "runner", "model", "reflectivecal", "run", "reflect", "callabl", "reflectivecal", "java:15", "reflect", "callabl", "at", "org", "junit", "runner", "model", "frameworkmethod", "invokeexplos", "framework", "method", "invok", "explos", "frameworkmethod", "java:42", "framework", "method", "at", "org", "junit", "intern", "runner", "statement", "invokemethod", "evalu", "invok", "method", "invokemethod", "java:20", "invok", "method", "at", "org", "junit", "intern", "runner", "statement", "runbefor", "evalu", "run", "befor", "runbefor", "java:28", "run", "befor", "at", "org", "junit", "intern", "runner", "statement", "runaft", "evalu", "run", "after", "runaft", "java:30", "run", "after", "at", "org", "junit", "runner", "parentrunn", "runleaf", "parent", "runner", "run", "leaf", "parentrunn", "java:263", "parent", "runner", "at", "org", "junit", "runner", "blockjunit4classrunn", "runchild", "block", "unit4class", "runner", "run", "child", "blockjunit4classrunn", "java:68", "block", "unit4class", "runner", "at", "org", "junit", "runner", "blockjunit4classrunn", "runchild", "block", "unit4class", "runner", "run", "child", "blockjunit4classrunn", "java:47", "block", "unit4class", "runner", "at", "org", "junit", "runner", "parentrunn", "parent", "runner", "run", "parentrunn", "java:231", "parent", "runner", "at", "org", "junit", "runner", "parentrunn", "parent", "runner", "schedul", "parentrunn", "java:60", "parent", "runner", "at", "org", "junit", "runner", "parentrunn", "runchildren", "parent", "runner", "run", "children", "parentrunn", "java:229", "parent", "runner", "at", "org", "junit", "runner", "parentrunn", "access", "parent", "runner", "000", "parentrunn", "java:50", "parent", "runner", "at", "org", "junit", "runner", "parentrunn", "parent", "runner", "evalu", "parentrunn", "java:222", "parent", "runner", "at", "org", "junit", "runner", "parentrunn", "run", "parent", "runner", "parentrunn", "java:300", "parent", "runner", "at", "org", "eclips", "jdt", "intern", "junit4", "runner", "junit4testrefer", "run", "unit4test", "refer", "junit4testrefer", "java:50", "unit4test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:467", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:683", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:390", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:197", "remot", "test", "runner", "caus", "by", "org", "apach", "jackrabbit", "oak", "api", "commitfailedexcept", "commit", "fail", "except", "not", "add", "node", "q2", "at", "q1", "at", "org", "apach", "jackrabbit", "oak", "plugin", "nodetyp", "typevalid", "childnodead", "type", "valid", "child", "node", "ad", "typevalid", "java:134", "type", "valid", "at", "org", "apach", "jackrabbit", "oak", "spi", "commit", "compositevalid", "childnodead", "composit", "valid", "child", "node", "ad", "compositevalid", "java:68", "composit", "valid", "at", "org", "apach", "jackrabbit", "oak", "spi", "commit", "validatinghook", "valid", "hook", "validatordiff", "childnodead", "valid", "diff", "child", "node", "ad", "validatinghook", "java:155", "valid", "hook", "at", "org", "apach", "jackrabbit", "oak", "spi", "state", "abstractnodest", "compareagainstbasest", "abstract", "node", "state", "compar", "against", "base", "state", "abstractnodest", "java:157", "abstract", "node", "state", "at", "org", "apach", "jackrabbit", "oak", "kernel", "kernelnodest", "compareagainstbasest", "kernel", "node", "state", "compar", "against", "base", "state", "kernelnodest", "java:243", "kernel", "node", "state", "at", "org", "apach", "jackrabbit", "oak", "spi", "commit", "validatinghook", "valid", "hook", "validatordiff", "valid", "valid", "diff", "validatinghook", "java:110", "valid", "hook", "at", "org", "apach", "jackrabbit", "oak", "spi", "commit", "validatinghook", "valid", "hook", "validatordiff", "valid", "valid", "diff", "validatinghook", "java:101", "valid", "hook", "at", "org", "apach", "jackrabbit", "oak", "spi", "commit", "validatinghook", "valid", "hook", "validatordiff", "childnodead", "valid", "diff", "child", "node", "ad", "validatinghook", "java:157", "valid", "hook", "at", "org", "apach", "jackrabbit", "oak", "plugin", "memori", "modifiednodest", "modifi", "node", "state", "childnodead", "child", "node", "ad", "modifiednodest", "java:292", "modifi", "node", "state", "at", "org", "apach", "jackrabbit", "oak", "spi", "state", "abstractnodest", "compareagainstbasest", "abstract", "node", "state", "compar", "against", "base", "state", "abstractnodest", "java:157", "abstract", "node", "state", "at", "org", "apach", "jackrabbit", "oak", "kernel", "kernelnodest", "compareagainstbasest", "kernel", "node", "state", "compar", "against", "base", "state", "kernelnodest", "java:243", "kernel", "node", "state", "at", "org", "apach", "jackrabbit", "oak", "plugin", "memori", "modifiednodest", "compareagainstbasest", "modifi", "node", "state", "compar", "against", "base", "state", "modifiednodest", "java:269", "modifi", "node", "state", "at", "org", "apach", "jackrabbit", "oak", "spi", "commit", "validatinghook", "valid", "hook", "validatordiff", "valid", "valid", "diff", "validatinghook", "java:110", "valid", "hook", "at", "org", "apach", "jackrabbit", "oak", "spi", "commit", "validatinghook", "valid", "hook", "validatordiff", "valid", "valid", "diff", "validatinghook", "java:101", "valid", "hook", "at", "org", "apach", "jackrabbit", "oak", "spi", "commit", "validatinghook", "processcommit", "valid", "hook", "process", "commit", "validatinghook", "java:73", "valid", "hook", "at", "org", "apach", "jackrabbit", "oak", "spi", "commit", "compositehook", "processcommit", "composit", "hook", "process", "commit", "compositehook", "java:59", "composit", "hook", "at", "org", "apach", "jackrabbit", "oak", "kernel", "kernelnodestorebranch", "merg", "kernel", "node", "store", "branch", "kernelnodestorebranch", "java:127", "kernel", "node", "store", "branch", "at", "org", "apach", "jackrabbit", "oak", "core", "rootimpl", "root", "impl", "run", "rootimpl", "java:239", "root", "impl", "at", "org", "apach", "jackrabbit", "oak", "core", "rootimpl", "root", "impl", "run", "rootimpl", "java:1", "root", "impl", "at", "java", "secur", "accesscontrol", "doprivileg", "access", "control", "privileg", "nativ", "method", "at", "javax", "secur", "auth", "subject", "doa", "as", "subject", "java:337", "at", "org", "apach", "jackrabbit", "oak", "core", "rootimpl", "commit", "root", "impl", "rootimpl", "java:234", "root", "impl", "at", "org", "apach", "jackrabbit", "oak", "jcr", "sessiondeleg", "save", "session", "deleg", "sessiondeleg", "java:241", "session", "deleg", "27", "more", "caus", "by", "javax", "jcr", "repositoryexcept", "repositori", "except", "no", "match", "node", "definit", "found", "org", "apach", "jackrabbit", "oak", "plugin", "nodetyp", "validatingnodetypemanag", "valid", "node", "type", "manag", "257f1b", "at", "org", "apach", "jackrabbit", "oak", "plugin", "nodetyp", "readonlynodetypemanag", "getdefinit", "read", "onli", "node", "type", "manag", "get", "definit", "readonlynodetypemanag", "java:406", "read", "onli", "node", "type", "manag", "at", "org", "apach", "jackrabbit", "oak", "plugin", "nodetyp", "typevalid", "type", "valid", "effectivenodetyp", "getdefinit", "effect", "node", "type", "get", "definit", "typevalid", "java:302", "type", "valid", "at", "org", "apach", "jackrabbit", "oak", "plugin", "nodetyp", "typevalid", "type", "valid", "effectivenodetyp", "checkaddchildnod", "effect", "node", "type", "check", "add", "child", "node", "typevalid", "java:249", "type", "valid", "at", "org", "apach", "jackrabbit", "oak", "plugin", "nodetyp", "typevalid", "childnodead", "type", "valid", "child", "node", "ad", "typevalid", "java:127", "type", "valid", "49", "more", "code"], "B_title": "Adding a node to a node that doesnt accept children doesnt fail with ConstraintViolationException", "B_clean_title": ["ad", "node", "node", "that", "doesnt", "accept", "children", "doesnt", "fail", "constraintviolationexcept", "constraint", "violat", "except"]},
{"A_title": "Wicket generates invalid HTML by expanding col tagshi  I just noticed that wicket expands col tags even though the (x)html specifications forbids it.  take this markup as an example:  <table>     <colgroup>         <col width=20% />         <col width=80% />     </colgroup>     <tbody>         <tr>             <td>I take a fifth of the available space</td>             <td>I take four fifth of the available space</td>         </tr>     </tbody> </table>  Instead of return this as-is it gets converted to:  <table>     <colgroup>         <col width=20%></col>         <col width=80%></col>     </colgroup>     <tbody>         <tr>             <td>I take a fifth of the available space</td>             <td>I take four fifth of the available space</td>         </tr>     </tbody> </table>  But the specifications mention that col tags must not have end tags. This may be related to WICKET-2765 as this seems to be the point when col was added to the OpenCloseTagExpander class. Note that it is ok to have a non closing col tag in html (self-closing in xhtml). Its all about generating a separated end tag.  This happens in wicket 6.8 but I guess its relevant to all versions down to wicket 1.4.  Specs for reference:  http://www.w3.org/TR/1999/REC-html401-19991224/struct/tables.html#edef-COL http://www.w3.org/TR/html-markup/col.html  Kind regards  Konrad", "A_clean_title": ["wicket", "gener", "invalid", "html", "by", "expand", "col", "tagshi", "just", "notic", "that", "wicket", "expand", "col", "tag", "even", "though", "html", "specif", "forbid", "it", "take", "thi", "markup", "as", "exampl", "tabl", "colgroup", "col", "width=20", "col", "width=80", "colgroup", "tbodi", "tr", "td", "take", "fifth", "avail", "space", "td", "td", "take", "four", "fifth", "avail", "space", "td", "tr", "tbodi", "tabl", "instead", "return", "thi", "as", "it", "get", "convert", "tabl", "colgroup", "col", "width=20", "col", "col", "width=80", "col", "colgroup", "tbodi", "tr", "td", "take", "fifth", "avail", "space", "td", "td", "take", "four", "fifth", "avail", "space", "td", "tr", "tbodi", "tabl", "but", "specif", "mention", "that", "col", "tag", "must", "not", "have", "end", "tag", "thi", "may", "relat", "wicket", "2765", "as", "thi", "seem", "point", "when", "col", "wa", "ad", "openclosetagexpand", "open", "close", "tag", "expand", "class", "note", "that", "it", "ok", "have", "non", "close", "col", "tag", "html", "self", "close", "xhtml", "it", "all", "about", "gener", "separ", "end", "tag", "thi", "happen", "wicket", "but", "guess", "it", "relev", "all", "version", "down", "wicket", "spec", "refer", "http", "html401", "w3", "html", "www", "org", "tr", "1999", "rec", "19991224", "struct", "tabl", "edef", "col", "http", "w3", "html", "www", "org", "tr", "html", "markup", "col", "kind", "regard", "konrad"], "B_title": "Wicket generates invalid HTML by expanding col tags", "B_clean_title": ["wicket", "gener", "invalid", "html", "by", "expand", "col", "tag"]},
{"A_title": "g/apache/wicket/protocol/http/request/UserAgent matches method is not correctIn the UserAgent Enum matches method the loop over detectionStrings is at most executed once:      for (List<String> detectionGroup : detectionStrings)            for (String detectionString : detectionGroup)                if (!userAgent.contains(detectionString))                    return false;                        return true;       It returns true after only processing the first element in the detectionStrings list. It never looks at any of the other elements of the list.", "A_clean_title": ["apach", "wicket", "protocol", "http", "request", "userag", "user", "agent", "match", "method", "not", "correctin", "correct", "userag", "user", "agent", "enum", "match", "method", "loop", "over", "detectionstr", "detect", "string", "at", "most", "execut", "onc", "list", "string", "detectiongroup", "detect", "group", "detectionstr", "detect", "string", "string", "detectionstr", "detect", "string", "detectiongroup", "detect", "group", "userag", "contain", "user", "agent", "detectionstr", "detect", "string", "return", "fals", "return", "true", "it", "return", "true", "after", "onli", "process", "first", "element", "detectionstr", "detect", "string", "list", "it", "never", "look", "at", "ani", "other", "element", "list"], "B_title": "org/apache/wicket/protocol/http/request/UserAgent matches method is not correct", "B_clean_title": ["org", "apach", "wicket", "protocol", "http", "request", "userag", "user", "agent", "match", "method", "not", "correct"]},
{"A_title": "ClusterNodeInfo does not pick an existing entry on startupWhen the DocumentNodeStore starts up it attempts to find an entry that matches the current instance (which is defined by something based on network interface address and the current working directory).  However an additional check is done when the cluster lease end time hasnt been reached in which case the entry is skipped (assuming it belongs to a different instance) and the scan continues. When no other entry is found a new one is created.  So why would we *ever* consider instances with matching instance information to be different? As far as I can tell the answer is: for unit testing.  But...  With the current assignment very weird things can happen and I believe I see exactly this happening in a customer problem Im investigating. The sequence is:  1) First system startup cluster node id 1 is assigned  2) System crashes or was crashed  3) System restarts within the lease time (120s?) a new cluster node id is assigned  4) System shuts down and gets restarted after a longer interval: cluster id 1 is used again and system starts MissingLastRevRecovery despite the previous shutdown having been clean  So what we see is that the system starts up with varying cluster node ids and recovery processes may run with no correlation to what happened before.  Proposal:  a) Make ClusterNodeInfo.createInstance() much more verbose so that the default system log contains sufficient information to understand why a certain cluster node id was picked.  b) Drop the logic that skips entries with non-expired leases so that we get a one-to-one relation between instance ids and cluster node ids. For the unit tests that currently rely on this logic switch to APIs where the test setup picks the cluster node id.", "A_clean_title": ["clusternodeinfo", "cluster", "node", "info", "not", "pick", "exist", "entri", "startupwhen", "startup", "when", "documentnodestor", "document", "node", "store", "start", "up", "it", "attempt", "find", "entri", "that", "match", "current", "instanc", "which", "defin", "by", "someth", "base", "network", "interfac", "address", "current", "work", "directori", "howev", "addit", "check", "done", "when", "cluster", "leas", "end", "time", "hasnt", "been", "reach", "which", "case", "entri", "skip", "assum", "it", "belong", "differ", "instanc", "scan", "continu", "when", "no", "other", "entri", "found", "new", "one", "creat", "so", "whi", "would", "we", "ever", "consid", "instanc", "match", "instanc", "inform", "differ", "as", "far", "as", "tell", "answer", "unit", "test", "but", "current", "assign", "veri", "weird", "thing", "happen", "believ", "see", "exactli", "thi", "happen", "custom", "problem", "im", "investig", "sequenc", "first", "system", "startup", "cluster", "node", "id", "assign", "system", "crash", "or", "wa", "crash", "system", "restart", "within", "leas", "time", "120", "new", "cluster", "node", "id", "assign", "system", "shut", "down", "get", "restart", "after", "longer", "interv", "cluster", "id", "use", "again", "system", "start", "missinglastrevrecoveri", "miss", "last", "rev", "recoveri", "despit", "previou", "shutdown", "have", "been", "clean", "so", "what", "we", "see", "that", "system", "start", "up", "vari", "cluster", "node", "id", "recoveri", "process", "may", "run", "no", "correl", "what", "happen", "befor", "propos", "make", "clusternodeinfo", "createinst", "cluster", "node", "info", "creat", "instanc", "much", "more", "verbos", "so", "that", "default", "system", "log", "contain", "suffici", "inform", "understand", "whi", "certain", "cluster", "node", "id", "wa", "pick", "drop", "logic", "that", "skip", "entri", "non", "expir", "leas", "so", "that", "we", "get", "one", "one", "relat", "between", "instanc", "id", "cluster", "node", "id", "unit", "test", "that", "current", "reli", "thi", "logic", "switch", "api", "ap", "where", "test", "setup", "pick", "cluster", "node", "id"], "B_title": "change ClusterNodeInfo to potentially wait for an abandoned cluster id to become available", "B_clean_title": ["chang", "clusternodeinfo", "cluster", "node", "info", "potenti", "wait", "abandon", "cluster", "id", "becom", "avail"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables.  In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result.  The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values.  What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem.  The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L = l(1) l(2) ... l(R) (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Add additional heuristic for rare cases in pivotRow selection.", "B_clean_title": ["add", "addit", "heurist", "rare", "case", "pivotrow", "pivot", "row", "select"]},
{"A_title": "@SpringBean(name=something required=false) still throws org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named something is definedExample:  code public class TwitterLoginLink extends StatelessLink<Void>   @SpringBean(name=twitterMgr required=false) private TwitterManager twitterMgr; code  still throws:  code org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named twitterMgr is defined at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:641) at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1159) at org.springframework.beans.factory.support.AbstractBeanFactory.isSingleton(AbstractBeanFactory.java:418) at org.springframework.context.support.AbstractApplicationContext.isSingleton(AbstractApplicationContext.java:1002) at org.apache.wicket.spring.SpringBeanLocator.isSingletonBean(SpringBeanLocator.java) at org.apache.wicket.spring.injection.annot.AnnotProxyFieldValueFactory.getFieldValue(AnnotProxyFieldValueFactory.java:141) at org.apache.wicket.injection.Injector.inject(Injector.java:111) at org.apache.wicket.spring.injection.annot.SpringComponentInjector.inject(SpringComponentInjector.java:124) at org.apache.wicket.spring.injection.annot.SpringComponentInjector.onInstantiation(SpringComponentInjector.java:130) at org.apache.wicket.application.ComponentInstantiationListenerCollection 1.notify(ComponentInstantiationListenerCollection.java:38) at org.apache.wicket.application.ComponentInstantiationListenerCollection 1.notify(ComponentInstantiationListenerCollection.java:34) at org.apache.wicket.util.listener.ListenerCollection.notify(ListenerCollection.java:80) at org.apache.wicket.application.ComponentInstantiationListenerCollection.onInstantiation(ComponentInstantiationListenerCollection.java:33) at org.apache.wicket.Component.<init>(Component.java:686) at org.apache.wicket.MarkupContainer.<init>(MarkupContainer.java:121) at org.apache.wicket.markup.html.WebMarkupContainer.<init>(WebMarkupContainer.java:52) at org.apache.wicket.markup.html.link.AbstractLink.<init>(AbstractLink.java:57) at org.apache.wicket.markup.html.link.AbstractLink.<init>(AbstractLink.java:44) at org.apache.wicket.markup.html.link.Link.<init>(Link.java:105) at org.apache.wicket.markup.html.link.StatelessLink.<init>(StatelessLink.java:42) at org.soluvas.web.login.twitter.TwitterLoginLink.<init>(TwitterLoginLink.java:40) at org.soluvas.web.login.DedicatedLoginPanel FormSignIn.<init>(DedicatedLoginPanel.java:90) at org.soluvas.web.login.DedicatedLoginPanel.onInitialize(DedicatedLoginPanel.java:58) at org.apache.wicket.Component.fireInitialize(Component.java:876) at org.apache.wicket.MarkupContainer 3.component(MarkupContainer.java:967) at org.apache.wicket.MarkupContainer 3.component(MarkupContainer.java:963) at org.apache.wicket.util.visit.Visits.visitChildren(Visits.java:144) at org.apache.wicket.util.visit.Visits.visitChildren(Visits.java:123) at org.apache.wicket.util.visit.Visits.visitChildren(Visits.java:192) at org.apache.wicket.MarkupContainer.visitChildren(MarkupContainer.java:875) at org.apache.wicket.MarkupContainer.internalInitialize(MarkupContainer.java:962) at org.apache.wicket.Page.isPageStateless(Page.java:463) at org.apache.wicket.core.request.mapper.AbstractBookmarkableMapper.getPageInfo(AbstractBookmarkableMapper.java:447) at org.apache.wicket.core.request.mapper.AbstractBookmarkableMapper.mapHandler(AbstractBookmarkableMapper.java:391) at org.apache.wicket.core.request.mapper.MountedMapper.mapHandler(MountedMapper.java:395) at org.apache.wicket.request.mapper.CompoundRequestMapper.mapHandler(CompoundRequestMapper.java:215) at org.apache.wicket.request.cycle.RequestCycle.mapUrlFor(RequestCycle.java:429) at org.apache.wicket.request.handler.render.WebPageRenderer.respond(WebPageRenderer.java:273) at org.apache.wicket.core.request.handler.RenderPageRequestHandler.respond(RenderPageRequestHandler.java:175) at org.apache.wicket.request.cycle.RequestCycle HandlerExecutor.respond(RequestCycle.java:862) at org.apache.wicket.request.RequestHandlerStack.execute(RequestHandlerStack.java:64) at org.apache.wicket.request.cycle.RequestCycle.execute(RequestCycle.java:261) at org.apache.wicket.request.cycle.RequestCycle.processRequest(RequestCycle.java:218) at org.apache.wicket.request.cycle.RequestCycle.processRequestAndDetach(RequestCycle.java:289) at org.apache.wicket.protocol.http.WicketFilter.processRequestCycle(WicketFilter.java:259) at org.apache.wicket.protocol.http.WicketFilter.processRequest(WicketFilter.java:201) at org.apache.wicket.protocol.http.WicketFilter.doFilter(WicketFilter.java:282) at org.soluvas.web.site.SecuredWicketAtmosphereHandler CustomFilterChain.doFilter(SecuredWicketAtmosphereHandler.java:199) at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449) at org.apache.shiro.web.servlet.AbstractShiroFilter 1.call(AbstractShiroFilter.java:365) at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90) at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83) at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:383) at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:344) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:261) at org.soluvas.web.site.SecuredWicketAtmosphereHandler CustomFilterChain.doFilter(SecuredWicketAtmosphereHandler.java:199) at org.soluvas.web.site.SecuredWicketAtmosphereHandler CustomFilterChain.invokeFilterChain(SecuredWicketAtmosphereHandler.java:185) at org.soluvas.web.site.SecuredWicketAtmosphereHandler.onRequest(SecuredWicketAtmosphereHandler.java:91) at org.atmosphere.cpr.AsynchronousProcessor.action(AsynchronousProcessor.java:187) at org.atmosphere.cpr.AsynchronousProcessor.suspended(AsynchronousProcessor.java:98) at org.atmosphere.container.Tomcat7CometSupport.service(Tomcat7CometSupport.java:96) at org.atmosphere.cpr.AtmosphereFramework.doCometSupport(AtmosphereFramework.java:1809) at org.atmosphere.cpr.AtmosphereServlet.event(AtmosphereServlet.java:255) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilterEvent(ApplicationFilterChain.java:484) at org.apache.catalina.core.ApplicationFilterChain.doFilterEvent(ApplicationFilterChain.java:377) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:220) at org.apache.catalina.core.StandardContextValve.__invoke(StandardContextValve.java:123) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502) at org.apache.catalina.core.StandardHostValve.__invoke(StandardHostValve.java:171) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99) at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:953) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408) at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1023) at org.apache.coyote.AbstractProtocol AbstractConnectionHandler.process(AbstractProtocol.java:589) at org.apache.tomcat.util.net.AprEndpoint SocketWithOptionsProcessor.run(AprEndpoint.java:1810) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) code  Workaround:  code     @Autowire(required=false)     private TwitterManager twitterMgr; code", "A_clean_title": ["springbean", "spring", "bean", "name=someth", "required=fals", "still", "throw", "org", "springframework", "bean", "factori", "nosuchbeandefinitionexcept", "no", "such", "bean", "definit", "except", "no", "bean", "name", "someth", "definedexampl", "defin", "exampl", "code", "public", "class", "twitterloginlink", "twitter", "login", "link", "extend", "statelesslink", "stateless", "link", "void", "springbean", "spring", "bean", "name=twittermgr", "name=twitt", "mgr", "required=fals", "privat", "twittermanag", "twitter", "manag", "twittermgr", "twitter", "mgr", "code", "still", "throw", "code", "org", "springframework", "bean", "factori", "nosuchbeandefinitionexcept", "no", "such", "bean", "definit", "except", "no", "bean", "name", "twittermgr", "twitter", "mgr", "defin", "at", "org", "springframework", "bean", "factori", "support", "defaultlistablebeanfactori", "getbeandefinit", "default", "listabl", "bean", "factori", "get", "bean", "definit", "defaultlistablebeanfactori", "java:641", "default", "listabl", "bean", "factori", "at", "org", "springframework", "bean", "factori", "support", "abstractbeanfactori", "getmergedlocalbeandefinit", "abstract", "bean", "factori", "get", "merg", "local", "bean", "definit", "abstractbeanfactori", "java:1159", "abstract", "bean", "factori", "at", "org", "springframework", "bean", "factori", "support", "abstractbeanfactori", "issingleton", "abstract", "bean", "factori", "singleton", "abstractbeanfactori", "java:418", "abstract", "bean", "factori", "at", "org", "springframework", "context", "support", "abstractapplicationcontext", "issingleton", "abstract", "applic", "context", "singleton", "abstractapplicationcontext", "java:1002", "abstract", "applic", "context", "at", "org", "apach", "wicket", "spring", "springbeanloc", "issingletonbean", "spring", "bean", "locat", "singleton", "bean", "springbeanloc", "java", "spring", "bean", "locat", "at", "org", "apach", "wicket", "spring", "inject", "annot", "annotproxyfieldvaluefactori", "getfieldvalu", "annot", "proxi", "field", "valu", "factori", "get", "field", "valu", "annotproxyfieldvaluefactori", "java:141", "annot", "proxi", "field", "valu", "factori", "at", "org", "apach", "wicket", "inject", "injector", "inject", "injector", "java:111", "at", "org", "apach", "wicket", "spring", "inject", "annot", "springcomponentinjector", "inject", "spring", "compon", "injector", "springcomponentinjector", "java:124", "spring", "compon", "injector", "at", "org", "apach", "wicket", "spring", "inject", "annot", "springcomponentinjector", "oninstanti", "spring", "compon", "injector", "instanti", "springcomponentinjector", "java:130", "spring", "compon", "injector", "at", "org", "apach", "wicket", "applic", "componentinstantiationlistenercollect", "compon", "instanti", "listen", "collect", "notifi", "componentinstantiationlistenercollect", "java:38", "compon", "instanti", "listen", "collect", "at", "org", "apach", "wicket", "applic", "componentinstantiationlistenercollect", "compon", "instanti", "listen", "collect", "notifi", "componentinstantiationlistenercollect", "java:34", "compon", "instanti", "listen", "collect", "at", "org", "apach", "wicket", "util", "listen", "listenercollect", "notifi", "listen", "collect", "listenercollect", "java:80", "listen", "collect", "at", "org", "apach", "wicket", "applic", "componentinstantiationlistenercollect", "oninstanti", "compon", "instanti", "listen", "collect", "instanti", "componentinstantiationlistenercollect", "java:33", "compon", "instanti", "listen", "collect", "at", "org", "apach", "wicket", "compon", "init", "compon", "java:686", "at", "org", "apach", "wicket", "markupcontain", "markup", "contain", "init", "markupcontain", "java:121", "markup", "contain", "at", "org", "apach", "wicket", "markup", "html", "webmarkupcontain", "web", "markup", "contain", "init", "webmarkupcontain", "java:52", "web", "markup", "contain", "at", "org", "apach", "wicket", "markup", "html", "link", "abstractlink", "abstract", "link", "init", "abstractlink", "java:57", "abstract", "link", "at", "org", "apach", "wicket", "markup", "html", "link", "abstractlink", "abstract", "link", "init", "abstractlink", "java:44", "abstract", "link", "at", "org", "apach", "wicket", "markup", "html", "link", "link", "init", "link", "java:105", "at", "org", "apach", "wicket", "markup", "html", "link", "statelesslink", "stateless", "link", "init", "statelesslink", "java:42", "stateless", "link", "at", "org", "soluva", "web", "login", "twitter", "twitterloginlink", "twitter", "login", "link", "init", "twitterloginlink", "java:40", "twitter", "login", "link", "at", "org", "soluva", "web", "login", "dedicatedloginpanel", "dedic", "login", "panel", "formsignin", "form", "sign", "init", "dedicatedloginpanel", "java:90", "dedic", "login", "panel", "at", "org", "soluva", "web", "login", "dedicatedloginpanel", "oniniti", "dedic", "login", "panel", "initi", "dedicatedloginpanel", "java:58", "dedic", "login", "panel", "at", "org", "apach", "wicket", "compon", "fireiniti", "fire", "initi", "compon", "java:876", "at", "org", "apach", "wicket", "markupcontain", "markup", "contain", "compon", "markupcontain", "java:967", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "markup", "contain", "compon", "markupcontain", "java:963", "markup", "contain", "at", "org", "apach", "wicket", "util", "visit", "visit", "visitchildren", "visit", "children", "visit", "java:144", "at", "org", "apach", "wicket", "util", "visit", "visit", "visitchildren", "visit", "children", "visit", "java:123", "at", "org", "apach", "wicket", "util", "visit", "visit", "visitchildren", "visit", "children", "visit", "java:192", "at", "org", "apach", "wicket", "markupcontain", "visitchildren", "markup", "contain", "visit", "children", "markupcontain", "java:875", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "internaliniti", "markup", "contain", "intern", "initi", "markupcontain", "java:962", "markup", "contain", "at", "org", "apach", "wicket", "page", "ispagestateless", "page", "stateless", "page", "java:463", "at", "org", "apach", "wicket", "core", "request", "mapper", "abstractbookmarkablemapp", "getpageinfo", "abstract", "bookmark", "mapper", "get", "page", "info", "abstractbookmarkablemapp", "java:447", "abstract", "bookmark", "mapper", "at", "org", "apach", "wicket", "core", "request", "mapper", "abstractbookmarkablemapp", "maphandl", "abstract", "bookmark", "mapper", "map", "handler", "abstractbookmarkablemapp", "java:391", "abstract", "bookmark", "mapper", "at", "org", "apach", "wicket", "core", "request", "mapper", "mountedmapp", "maphandl", "mount", "mapper", "map", "handler", "mountedmapp", "java:395", "mount", "mapper", "at", "org", "apach", "wicket", "request", "mapper", "compoundrequestmapp", "maphandl", "compound", "request", "mapper", "map", "handler", "compoundrequestmapp", "java:215", "compound", "request", "mapper", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "mapurlfor", "request", "cycl", "map", "url", "requestcycl", "java:429", "request", "cycl", "at", "org", "apach", "wicket", "request", "handler", "render", "webpagerender", "respond", "web", "page", "render", "webpagerender", "java:273", "web", "page", "render", "at", "org", "apach", "wicket", "core", "request", "handler", "renderpagerequesthandl", "respond", "render", "page", "request", "handler", "renderpagerequesthandl", "java:175", "render", "page", "request", "handler", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "request", "cycl", "handlerexecutor", "respond", "handler", "executor", "requestcycl", "java:862", "request", "cycl", "at", "org", "apach", "wicket", "request", "requesthandlerstack", "execut", "request", "handler", "stack", "requesthandlerstack", "java:64", "request", "handler", "stack", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "execut", "request", "cycl", "requestcycl", "java:261", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "processrequest", "request", "cycl", "process", "request", "requestcycl", "java:218", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "processrequestanddetach", "request", "cycl", "process", "request", "detach", "requestcycl", "java:289", "request", "cycl", "at", "org", "apach", "wicket", "protocol", "http", "wicketfilt", "processrequestcycl", "wicket", "filter", "process", "request", "cycl", "wicketfilt", "java:259", "wicket", "filter", "at", "org", "apach", "wicket", "protocol", "http", "wicketfilt", "processrequest", "wicket", "filter", "process", "request", "wicketfilt", "java:201", "wicket", "filter", "at", "org", "apach", "wicket", "protocol", "http", "wicketfilt", "dofilt", "wicket", "filter", "filter", "wicketfilt", "java:282", "wicket", "filter", "at", "org", "soluva", "web", "site", "securedwicketatmospherehandl", "secur", "wicket", "atmospher", "handler", "customfilterchain", "dofilt", "custom", "filter", "chain", "filter", "securedwicketatmospherehandl", "java:199", "secur", "wicket", "atmospher", "handler", "at", "org", "apach", "shiro", "web", "servlet", "abstractshirofilt", "executechain", "abstract", "shiro", "filter", "execut", "chain", "abstractshirofilt", "java:449", "abstract", "shiro", "filter", "at", "org", "apach", "shiro", "web", "servlet", "abstractshirofilt", "abstract", "shiro", "filter", "call", "abstractshirofilt", "java:365", "abstract", "shiro", "filter", "at", "org", "apach", "shiro", "subject", "support", "subjectcal", "docal", "subject", "callabl", "call", "subjectcal", "java:90", "subject", "callabl", "at", "org", "apach", "shiro", "subject", "support", "subjectcal", "call", "subject", "callabl", "subjectcal", "java:83", "subject", "callabl", "at", "org", "apach", "shiro", "subject", "support", "delegatingsubject", "execut", "deleg", "subject", "delegatingsubject", "java:383", "deleg", "subject", "at", "org", "apach", "shiro", "web", "servlet", "abstractshirofilt", "dofilterintern", "abstract", "shiro", "filter", "filter", "intern", "abstractshirofilt", "java:362", "abstract", "shiro", "filter", "at", "org", "apach", "shiro", "web", "servlet", "onceperrequestfilt", "dofilt", "onc", "per", "request", "filter", "filter", "onceperrequestfilt", "java:125", "onc", "per", "request", "filter", "at", "org", "springframework", "web", "filter", "delegatingfilterproxi", "invokedeleg", "deleg", "filter", "proxi", "invok", "deleg", "delegatingfilterproxi", "java:344", "deleg", "filter", "proxi", "at", "org", "springframework", "web", "filter", "delegatingfilterproxi", "dofilt", "deleg", "filter", "proxi", "filter", "delegatingfilterproxi", "java:261", "deleg", "filter", "proxi", "at", "org", "soluva", "web", "site", "securedwicketatmospherehandl", "secur", "wicket", "atmospher", "handler", "customfilterchain", "dofilt", "custom", "filter", "chain", "filter", "securedwicketatmospherehandl", "java:199", "secur", "wicket", "atmospher", "handler", "at", "org", "soluva", "web", "site", "securedwicketatmospherehandl", "secur", "wicket", "atmospher", "handler", "customfilterchain", "invokefilterchain", "custom", "filter", "chain", "invok", "filter", "chain", "securedwicketatmospherehandl", "java:185", "secur", "wicket", "atmospher", "handler", "at", "org", "soluva", "web", "site", "securedwicketatmospherehandl", "onrequest", "secur", "wicket", "atmospher", "handler", "request", "securedwicketatmospherehandl", "java:91", "secur", "wicket", "atmospher", "handler", "at", "org", "atmospher", "cpr", "asynchronousprocessor", "action", "asynchron", "processor", "asynchronousprocessor", "java:187", "asynchron", "processor", "at", "org", "atmospher", "cpr", "asynchronousprocessor", "suspend", "asynchron", "processor", "asynchronousprocessor", "java:98", "asynchron", "processor", "at", "org", "atmospher", "contain", "tomcat7cometsupport", "servic", "tomcat7comet", "support", "tomcat7cometsupport", "java:96", "tomcat7comet", "support", "at", "org", "atmospher", "cpr", "atmosphereframework", "docometsupport", "atmospher", "framework", "comet", "support", "atmosphereframework", "java:1809", "atmospher", "framework", "at", "org", "atmospher", "cpr", "atmosphereservlet", "event", "atmospher", "servlet", "atmosphereservlet", "java:255", "atmospher", "servlet", "at", "org", "apach", "catalina", "core", "applicationfilterchain", "internaldofilterev", "applic", "filter", "chain", "intern", "filter", "event", "applicationfilterchain", "java:484", "applic", "filter", "chain", "at", "org", "apach", "catalina", "core", "applicationfilterchain", "dofilterev", "applic", "filter", "chain", "filter", "event", "applicationfilterchain", "java:377", "applic", "filter", "chain", "at", "org", "apach", "catalina", "core", "standardwrappervalv", "invok", "standard", "wrapper", "valv", "standardwrappervalv", "java:220", "standard", "wrapper", "valv", "at", "org", "apach", "catalina", "core", "standardcontextvalv", "standard", "context", "valv", "invok", "standardcontextvalv", "java:123", "standard", "context", "valv", "at", "org", "apach", "catalina", "core", "standardcontextvalv", "invok", "standard", "context", "valv", "standardcontextvalv", "java", "standard", "context", "valv", "at", "org", "apach", "catalina", "authent", "authenticatorbas", "invok", "authent", "base", "authenticatorbas", "java:502", "authent", "base", "at", "org", "apach", "catalina", "core", "standardhostvalv", "standard", "host", "valv", "invok", "standardhostvalv", "java:171", "standard", "host", "valv", "at", "org", "apach", "catalina", "core", "standardhostvalv", "invok", "standard", "host", "valv", "standardhostvalv", "java", "standard", "host", "valv", "at", "org", "apach", "catalina", "valv", "errorreportvalv", "invok", "error", "report", "valv", "errorreportvalv", "java:99", "error", "report", "valv", "at", "org", "apach", "catalina", "valv", "accesslogvalv", "invok", "access", "log", "valv", "accesslogvalv", "java:953", "access", "log", "valv", "at", "org", "apach", "catalina", "core", "standardenginevalv", "invok", "standard", "engin", "valv", "standardenginevalv", "java:118", "standard", "engin", "valv", "at", "org", "apach", "catalina", "connector", "coyoteadapt", "servic", "coyot", "adapt", "coyoteadapt", "java:408", "coyot", "adapt", "at", "org", "apach", "coyot", "http11", "abstracthttp11processor", "process", "abstract", "http11processor", "abstracthttp11processor", "java:1023", "abstract", "http11processor", "at", "org", "apach", "coyot", "abstractprotocol", "abstract", "protocol", "abstractconnectionhandl", "process", "abstract", "connect", "handler", "abstractprotocol", "java:589", "abstract", "protocol", "at", "org", "apach", "tomcat", "util", "net", "aprendpoint", "apr", "endpoint", "socketwithoptionsprocessor", "run", "socket", "option", "processor", "aprendpoint", "java:1810", "apr", "endpoint", "at", "java", "util", "concurr", "threadpoolexecutor", "runwork", "thread", "pool", "executor", "run", "worker", "threadpoolexecutor", "java:1142", "thread", "pool", "executor", "at", "java", "util", "concurr", "threadpoolexecutor", "thread", "pool", "executor", "worker", "run", "threadpoolexecutor", "java:617", "thread", "pool", "executor", "at", "java", "lang", "thread", "run", "thread", "java:745", "code", "workaround", "code", "autowir", "required=fals", "privat", "twittermanag", "twitter", "manag", "twittermgr", "twitter", "mgr", "code"], "B_title": "@SpringBean(name=something required=false) still throws org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named something is defined", "B_clean_title": ["springbean", "spring", "bean", "name=someth", "required=fals", "still", "throw", "org", "springframework", "bean", "factori", "nosuchbeandefinitionexcept", "no", "such", "bean", "definit", "except", "no", "bean", "name", "someth", "defin"]},
{"A_title": "The default exception mapper is replying cacheable exceptional responsesThe problem is that some common URLs in the application like to a page instance are responding the cached exception page rather than hitting the server for the page instance being requested. It happens because at some moment in the past a exception page were replied and cached for a request in this URL.", "A_clean_title": ["default", "except", "mapper", "repli", "cacheabl", "except", "responsesth", "respons", "problem", "that", "some", "common", "url", "ur", "ls", "applic", "like", "page", "instanc", "are", "respond", "cach", "except", "page", "rather", "than", "hit", "server", "page", "instanc", "be", "request", "it", "happen", "becaus", "at", "some", "moment", "past", "except", "page", "were", "repli", "cach", "request", "thi", "url"], "B_title": "preventing exceptional responses from being cached and overlay next requests replay on the same address", "B_clean_title": ["prevent", "except", "respons", "be", "cach", "overlay", "next", "request", "replay", "same", "address"]},
{"A_title": "A mapping service mapping error has its toString value inserted into an integrated datasetHow to Reproduce     Go to the mapping service  Create a new mapping project with  Add TypeTestRef as new source  Edit label attribute  Fill in  Create integrated dataset  Expected behaviour  Mapping fails because the validation for the label to label mapping contains script errors  Observed behaviour  The mapping is executed and the toString() value of the error is inserted as a label", "A_clean_title": ["map", "servic", "map", "error", "ha", "it", "tostr", "string", "valu", "insert", "into", "integr", "datasethow", "dataset", "how", "reproduc", "go", "map", "servic", "creat", "new", "map", "project", "add", "typetestref", "type", "test", "ref", "as", "new", "sourc", "edit", "label", "attribut", "fill", "creat", "integr", "dataset", "expect", "behaviour", "map", "fail", "becaus", "valid", "label", "label", "map", "contain", "script", "error", "observ", "behaviour", "map", "execut", "tostr", "string", "valu", "error", "insert", "as", "label"], "B_title": "Merge pull request #7125 from Mark-de-Haan/fix/7110  Fix #7110 A mapping service mapping error has its toString value inserted into an integrated dataset", "B_clean_title": ["merg", "pull", "request", "7125", "mark", "de", "haan", "fix", "7110", "fix", "7110", "map", "servic", "map", "error", "ha", "it", "tostr", "string", "valu", "insert", "into", "integr", "dataset"]},
{"A_title": "Fix case-insensitive string handlingString.to*Case() is locale-sensitive this is usually not intended for case-insensitive comparisions. Please see Common Bug #3 for details.", "A_clean_title": ["fix", "case", "insensit", "string", "handlingstr", "handl", "string", "case", "local", "sensit", "thi", "usual", "not", "intend", "case", "insensit", "comparis", "pleas", "see", "common", "bug", "detail"], "B_title": "Applying the final part of Benjamin Bentmanns patch to LANG-432 improving our handling of case-insensitive Strings", "B_clean_title": ["appli", "final", "part", "benjamin", "bentmann", "patch", "lang", "432", "improv", "our", "handl", "case", "insensit", "string"]},
{"A_title": "Allow @private top-level functions in goog.scopeNone", "A_clean_title": ["allow", "privat", "top", "level", "function", "goog", "scopenon", "scope", "none"], "B_title": "Handle function declarations in ScopedAliases. Fixes issue 1111 R=johnlenz", "B_clean_title": ["handl", "function", "declar", "scopedalias", "scope", "alias", "fix", "issu", "1111", "r=johnlenz"]},
{"A_title": "FastDateFormat.format() outputs incorrect week of year because locale isnt respectedFastDateFormat apparently doesnt respect the locale it was sent on creation when outputting week in year (e.g. ww) in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which (depending on the year) may result in the incorrect week number being output. Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right:  import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.text.SimpleDateFormat;  import org.apache.commons.lang.time.FastDateFormat;  public class FastDateFormatWeekBugDemo      public static void main(String args)          Locale.setDefault(new Locale(en US));         Locale locale = new Locale(sv SE);          Calendar cal = Calendar.getInstance(); // setting locale here doesnt change outcome         cal.set(2010 0 1 12 0 0);         Date d = cal.getTime();         System.out.println(Target date:  + d);          FastDateFormat fdf = FastDateFormat.getInstance(EEEE week ww locale);         SimpleDateFormat sdf = new SimpleDateFormat(EEEE week ww locale);         System.out.println(FastDateFormat:    + fdf.format(d)); // will output FastDateFormat:   fredag week 01         System.out.println(SimpleDateFormat:  + sdf.format(d)); // will output SimpleDateFormat: fredag week 53         If sv/SE is passed to Locale.setDefault() instead of en/US both FastDateFormat and SimpleDateFormat output the correct week number.", "A_clean_title": ["fastdateformat", "format", "fast", "date", "format", "output", "incorrect", "week", "year", "becaus", "local", "isnt", "respectedfastdateformat", "respect", "fast", "date", "format", "appar", "doesnt", "respect", "local", "it", "wa", "sent", "creation", "when", "output", "week", "year", "ww", "format", "it", "seem", "use", "set", "system", "local", "firstdayofweek", "first", "day", "week", "minimaldaysinfirstweek", "minim", "day", "first", "week", "which", "depend", "year", "may", "result", "incorrect", "week", "number", "be", "output", "here", "simpl", "test", "program", "demonstr", "problem", "by", "compar", "simpledateformat", "simpl", "date", "format", "which", "get", "week", "number", "right", "import", "java", "util", "calendar", "import", "java", "util", "date", "import", "java", "util", "local", "import", "java", "text", "simpledateformat", "simpl", "date", "format", "import", "org", "apach", "common", "lang", "time", "fastdateformat", "fast", "date", "format", "public", "class", "fastdateformatweekbugdemo", "fast", "date", "format", "week", "bug", "demo", "public", "static", "void", "main", "string", "arg", "local", "setdefault", "set", "default", "new", "local", "en", "us", "local", "local", "new", "local", "sv", "se", "calendar", "cal", "calendar", "getinst", "get", "instanc", "set", "local", "here", "doesnt", "chang", "outcom", "cal", "set", "2010", "12", "date", "cal", "gettim", "get", "time", "system", "out", "println", "target", "date", "fastdateformat", "fast", "date", "format", "fdf", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "eeee", "week", "ww", "local", "simpledateformat", "simpl", "date", "format", "sdf", "new", "simpledateformat", "simpl", "date", "format", "eeee", "week", "ww", "local", "system", "out", "println", "fastdateformat", "fast", "date", "format", "fdf", "format", "will", "output", "fastdateformat", "fast", "date", "format", "fredag", "week", "01", "system", "out", "println", "simpledateformat", "simpl", "date", "format", "sdf", "format", "will", "output", "simpledateformat", "simpl", "date", "format", "fredag", "week", "53", "sv", "se", "pass", "local", "setdefault", "set", "default", "instead", "en", "us", "both", "fastdateformat", "fast", "date", "format", "simpledateformat", "simpl", "date", "format", "output", "correct", "week", "number"], "B_title": "Applying my fix to LANG-645 and Mikaels test case; fixing the FastDateFormat to properly include the locale when formatting a Date", "B_clean_title": ["appli", "my", "fix", "lang", "645", "mikael", "test", "case", "fix", "fastdateformat", "fast", "date", "format", "properli", "includ", "local", "when", "format", "date"]},
{"A_title": "WizardStep FormValidatorWrapper.isActiveStep(WizardStep.java) causes NullPointerExceptionUsing the Wizard with a nested WizardModel (see RecursiveWizardModel implementation at the attached quickstart application) causes a NullPointerException. I was able to run the same test application with wicket 1.4.18 without any problems.  Caused by: java.lang.NullPointerException         at org.apache.wicket.extensions.wizard.WizardStep FormValidatorWrapper.isActiveStep(WizardStep.java:145)         at org.apache.wicket.extensions.wizard.WizardStep FormValidatorWrapper.getDependentFormComponents(WizardStep.java:109)         at org.apache.wicket.markup.html.form.validation.FormValidatorAdapter.getDependentFormComponents(FormValidatorAdapter.java:47)         at org.apache.wicket.markup.html.form.Form.validateFormValidator(Form.java:1782)         at org.apache.wicket.markup.html.form.Form.validateFormValidators(Form.java:1828)         at org.apache.wicket.markup.html.form.Form.validate(Form.java:1706)         at org.apache.wicket.markup.html.form.Form.process(Form.java:773)         at org.apache.wicket.markup.html.form.Form.onFormSubmitted(Form.java:728)         at org.apache.wicket.markup.html.form.Form.onFormSubmitted(Form.java:670)", "A_clean_title": ["wizardstep", "wizard", "step", "formvalidatorwrapp", "isactivestep", "form", "valid", "wrapper", "activ", "step", "wizardstep", "java", "wizard", "step", "caus", "nullpointerexceptionus", "null", "pointer", "except", "wizard", "nest", "wizardmodel", "wizard", "model", "see", "recursivewizardmodel", "recurs", "wizard", "model", "implement", "at", "attach", "quickstart", "applic", "caus", "nullpointerexcept", "null", "pointer", "except", "wa", "abl", "run", "same", "test", "applic", "wicket", "18", "without", "ani", "problem", "caus", "by", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "wicket", "extens", "wizard", "wizardstep", "wizard", "step", "formvalidatorwrapp", "isactivestep", "form", "valid", "wrapper", "activ", "step", "wizardstep", "java:145", "wizard", "step", "at", "org", "apach", "wicket", "extens", "wizard", "wizardstep", "wizard", "step", "formvalidatorwrapp", "getdependentformcompon", "form", "valid", "wrapper", "get", "depend", "form", "compon", "wizardstep", "java:109", "wizard", "step", "at", "org", "apach", "wicket", "markup", "html", "form", "valid", "formvalidatoradapt", "getdependentformcompon", "form", "valid", "adapt", "get", "depend", "form", "compon", "formvalidatoradapt", "java:47", "form", "valid", "adapt", "at", "org", "apach", "wicket", "markup", "html", "form", "form", "validateformvalid", "valid", "form", "valid", "form", "java:1782", "at", "org", "apach", "wicket", "markup", "html", "form", "form", "validateformvalid", "valid", "form", "valid", "form", "java:1828", "at", "org", "apach", "wicket", "markup", "html", "form", "form", "valid", "form", "java:1706", "at", "org", "apach", "wicket", "markup", "html", "form", "form", "process", "form", "java:773", "at", "org", "apach", "wicket", "markup", "html", "form", "form", "onformsubmit", "form", "submit", "form", "java:728", "at", "org", "apach", "wicket", "markup", "html", "form", "form", "onformsubmit", "form", "submit", "form", "java:670"], "B_title": "let wizard initialize its own steps", "B_clean_title": ["let", "wizard", "initi", "it", "own", "step"]},
{"A_title": "Error trying to build try-catch block (AST)None", "A_clean_title": ["error", "tri", "build", "tri", "catch", "block", "ast", "none"], "B_title": "Correct IR helpers for TRY nodes. Fixes issue 727.", "B_clean_title": ["correct", "ir", "helper", "tri", "node", "fix", "issu", "727"]},
{"A_title": "Oak Analyzer cant tokenize chinese phrasesIt looks like the _WhitespaceTokenizer_ cannot properly split Chinese phrases for example 美女衬衫. I could not find a reference to this issue other than LUCENE-5096.  The fix is to switch to the _ClassicTokenizer_ which seems better equipped for this kind of task.", "A_clean_title": ["oak", "analyz", "cant", "token", "chines", "phrasesit", "phrase", "it", "look", "like", "whitespacetoken", "whitespac", "token", "not", "properli", "split", "chines", "phrase", "exampl", "could", "not", "find", "refer", "thi", "issu", "other", "than", "lucen", "5096", "fix", "switch", "classictoken", "classic", "token", "which", "seem", "better", "equip", "thi", "kind", "task"], "B_title": "Oak Analyzer cant tokenize chinese phrases", "B_clean_title": ["oak", "analyz", "cant", "token", "chines", "phrase"]},
{"A_title": "Casting a function before calling it produces bad code and breaks plugin codeNone", "A_clean_title": ["cast", "function", "befor", "call", "it", "produc", "bad", "code", "break", "plugin", "codenon", "code", "none"], "B_title": "Look through CAST nodes when annotating CALL nodes as free calls. Fixes issue 937 ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=44143144", "B_clean_title": ["look", "through", "cast", "node", "when", "annot", "call", "node", "as", "free", "call", "fix", "issu", "937", "creat", "by", "moe", "http", "java", "googl", "code", "com", "moe", "moe", "migrat", "revid=44143144"]},
{"A_title": "Multiple events in AjaxEventBehavior with prefix onif multiple events are used and one starts with on it only works if it is the first one because of:  code if (event.startsWith(on))  event = event.substring(2);  code  Why are events possible to start with on ?   Is this legacy? Perhaps should be removed for Wicket 7 ?", "A_clean_title": ["multipl", "event", "ajaxeventbehavior", "ajax", "event", "behavior", "prefix", "onif", "multipl", "event", "are", "use", "one", "start", "it", "onli", "work", "it", "first", "one", "becaus", "code", "event", "startswith", "start", "event", "event", "substr", "code", "whi", "are", "event", "possibl", "start", "thi", "legaci", "perhap", "remov", "wicket"], "B_title": "Multiple events in AjaxEventBehavior with prefix on", "B_clean_title": ["multipl", "event", "ajaxeventbehavior", "ajax", "event", "behavior", "prefix"]},
{"A_title": "NPE in the TypeValidator when using the Lucene IndexNone", "A_clean_title": ["npe", "typevalid", "type", "valid", "when", "lucen", "indexnon", "index", "none"], "B_title": "NPE in the TypeValidator when using the Lucene Index", "B_clean_title": ["npe", "typevalid", "type", "valid", "when", "lucen", "index"]},
{"A_title": "When using Servlet 3.0 filter Wicket calculates filter path wrongWhen using a servlet 3.0 filter with annotations Wicket calculates the filter path wrong causing it to not match any pages other than the home page.  e.g.  code @WebFilter(value = /web/* initParams = @WebInitParam(name = applicationClassName value = com.example.CheesrApplication)) public class CheesrFilter extends WicketFilter   code  Will cause Wicket to create a filter path of /web/*/ instead of the expected /web.", "A_clean_title": ["when", "servlet", "filter", "wicket", "calcul", "filter", "path", "wrongwhen", "wrong", "when", "servlet", "filter", "annot", "wicket", "calcul", "filter", "path", "wrong", "caus", "it", "not", "match", "ani", "page", "other", "than", "home", "page", "code", "webfilt", "web", "filter", "valu", "web", "initparam", "init", "param", "webinitparam", "web", "init", "param", "name", "applicationclassnam", "applic", "class", "name", "valu", "com", "exampl", "cheesrappl", "cheesr", "applic", "public", "class", "cheesrfilt", "cheesr", "filter", "extend", "wicketfilt", "wicket", "filter", "code", "will", "caus", "wicket", "creat", "filter", "path", "web", "instead", "expect", "web"], "B_title": "Servlet 3 Filter path calculated wrong", "B_clean_title": ["servlet", "filter", "path", "calcul", "wrong"]},
{"A_title": "PropertyStates#createProperty ignores namespace mappings when creating states of type NAME and PATHas far as i saw we use PropertyStates#createProperty to create and set an OAK property from a given JCR value or a list of JCR values.  this works well for all types of values except for NAME PATH which  may contain values with remapped namespaces which will not be converted back to oak-values during the state creation:  code      List<String> vals = Lists.newArrayList();      for (Value value : values)           vals.add(value.getString());            return new MultiGenericPropertyState(name vals Type.fromTag(type true)); code  if am not mistaken codevalue.getString()code will return the JCR representation of the value instead of the oak representation as it would be needed here.  possible solutions include: - passing namepathmapper to the create method - only accept oak Value implementation that allows to retrieve the   internal representation which is present in the ValueImpl afaik.", "A_clean_title": ["propertyst", "properti", "state", "createproperti", "creat", "properti", "ignor", "namespac", "map", "when", "creat", "state", "type", "name", "patha", "pat", "ha", "far", "as", "saw", "we", "use", "propertyst", "properti", "state", "createproperti", "creat", "properti", "creat", "set", "oak", "properti", "given", "jcr", "valu", "or", "list", "jcr", "valu", "thi", "work", "well", "all", "type", "valu", "except", "name", "path", "which", "may", "contain", "valu", "remap", "namespac", "which", "will", "not", "convert", "back", "oak", "valu", "dure", "state", "creation", "code", "list", "string", "val", "list", "newarraylist", "new", "array", "list", "valu", "valu", "valu", "val", "add", "valu", "getstr", "get", "string", "return", "new", "multigenericpropertyst", "multi", "gener", "properti", "state", "name", "val", "type", "fromtag", "tag", "type", "true", "code", "am", "not", "mistaken", "codevalu", "getstr", "get", "string", "code", "will", "return", "jcr", "represent", "valu", "instead", "oak", "represent", "as", "it", "would", "need", "here", "possibl", "solut", "includ", "pass", "namepathmapp", "creat", "method", "onli", "accept", "oak", "valu", "implement", "that", "allow", "retriev", "intern", "represent", "which", "present", "valueimpl", "valu", "impl", "afaik"], "B_title": "PropertyStates#createProperty ignores namespace mappings when creating states of type NAME and PATH", "B_clean_title": ["propertyst", "properti", "state", "createproperti", "creat", "properti", "ignor", "namespac", "map", "when", "creat", "state", "type", "name", "path"]},
{"A_title": "Inconsistent result from Levenberg-MarquardtLevenberg-Marquardt (its method doOptimize) returns a VectorialPointValuePair.  However the class holds the optimum point the vector of the objective function the cost and residuals.  The value returns by doOptimize does not always corresponds to the point which leads to the residuals and cost", "A_clean_title": ["inconsist", "result", "levenberg", "marquardtlevenberg", "marquardt", "marquardt", "levenberg", "it", "method", "dooptim", "optim", "return", "vectorialpointvaluepair", "vectori", "point", "valu", "pair", "howev", "class", "hold", "optimum", "point", "vector", "object", "function", "cost", "residu", "valu", "return", "by", "dooptim", "optim", "not", "alway", "correspond", "point", "which", "lead", "residu", "cost"], "B_title": "corrected", "B_clean_title": ["correct"]},
{"A_title": "Query: UnsupportedOperationException for some combinations of or and and conditionsThe following query throws an UnsupportedOperationException:  noformat select * from nt:base    where a = 1 and b = 2 and b = 3 or c = 4 noformat", "A_clean_title": ["queri", "unsupportedoperationexcept", "unsupport", "oper", "except", "some", "combin", "or", "conditionsth", "condit", "follow", "queri", "throw", "unsupportedoperationexcept", "unsupport", "oper", "except", "noformat", "select", "nt", "base", "where", "or", "noformat"], "B_title": "Query: UnsupportedOperationException for some combinations of or and and conditions", "B_clean_title": ["queri", "unsupportedoperationexcept", "unsupport", "oper", "except", "some", "combin", "or", "condit"]},
{"A_title": "QueryParse exception when fulltext search performed with term having /Running the below query results in Exception pointed by 1  /jcr:root/content/dam//element(*dam:Asset)jcr:contains(jcr:content/metadata/@cq:tags stockphotography:business/business_abstract) order by @jcr:created descending  Also if you remove the node at /oak:index/damAssetLucene/indexRules/dam:Asset/properties/cqTags  and re-index the /oak:index/damAssetLucene index the query works.  Seems / is special character and needs to be escaped by Oak.  1 noformat Caused by: org.apache.lucene.queryparser.flexible.core.QueryNodeParseException: Syntax Error cannot parse stockphotography:business/business_abstract: Lexical error at line 1 column 45.  Encountered: <EOF> after : /business_abstract  at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser.parse(StandardSyntaxParser.java:74) at org.apache.lucene.queryparser.flexible.core.QueryParserHelper.parse(QueryParserHelper.java:250) at org.apache.lucene.queryparser.flexible.standard.StandardQueryParser.parse(StandardQueryParser.java:168) at org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.tokenToQuery(LucenePropertyIndex.java:1260) ... 138 common frames omitted Caused by: org.apache.lucene.queryparser.flexible.standard.parser.TokenMgrError: Lexical error at line 1 column 45.  Encountered: <EOF> after : /business_abstract at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParserTokenManager.getNextToken(StandardSyntaxParserTokenManager.java:937) at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser.jj_scan_token(StandardSyntaxParser.java:945) at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser.jj_3R_4(StandardSyntaxParser.java:827) at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser.jj_3_2(StandardSyntaxParser.java:739) at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser.jj_2_2(StandardSyntaxParser.java:730) at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser.Clause(StandardSyntaxParser.java:318) at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser.ModClause(StandardSyntaxParser.java:303) at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser.ConjQuery(StandardSyntaxParser.java:234) at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser.DisjQuery(StandardSyntaxParser.java:204) at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser.Query(StandardSyntaxParser.java:166) at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser.TopLevelQuery(StandardSyntaxParser.java:147) at org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser.parse(StandardSyntaxParser.java:65) ... 141 common frames omitted noformat", "A_clean_title": ["querypars", "queri", "pars", "except", "when", "fulltext", "search", "perform", "term", "have", "run", "below", "queri", "result", "except", "point", "by", "jcr", "root", "content", "dam", "element", "dam", "asset", "jcr", "contain", "jcr", "content", "metadata", "cq", "tag", "stockphotographi", "abstract", "busi", "busi", "order", "by", "jcr", "creat", "descend", "also", "you", "remov", "node", "at", "oak", "index", "damassetlucen", "indexrul", "dam", "dam", "asset", "lucen", "index", "rule", "asset", "properti", "cqtag", "cq", "tag", "re", "index", "oak", "index", "damassetlucen", "dam", "asset", "lucen", "index", "queri", "work", "seem", "special", "charact", "need", "escap", "by", "oak", "noformat", "caus", "by", "org", "apach", "lucen", "querypars", "flexibl", "core", "querynodeparseexcept", "queri", "node", "pars", "except", "syntax", "error", "not", "pars", "stockphotographi", "abstract", "busi", "busi", "lexic", "error", "at", "line", "column", "45", "encount", "eof", "after", "abstract", "busi", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxpars", "pars", "standard", "syntax", "parser", "standardsyntaxpars", "java:74", "standard", "syntax", "parser", "at", "org", "apach", "lucen", "querypars", "flexibl", "core", "queryparserhelp", "pars", "queri", "parser", "helper", "queryparserhelp", "java:250", "queri", "parser", "helper", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "standardquerypars", "pars", "standard", "queri", "parser", "standardquerypars", "java:168", "standard", "queri", "parser", "at", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "lucenepropertyindex", "tokentoqueri", "lucen", "properti", "index", "token", "queri", "lucenepropertyindex", "java:1260", "lucen", "properti", "index", "138", "common", "frame", "omit", "caus", "by", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "tokenmgrerror", "token", "mgr", "error", "lexic", "error", "at", "line", "column", "45", "encount", "eof", "after", "abstract", "busi", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxparsertokenmanag", "getnexttoken", "standard", "syntax", "parser", "token", "manag", "get", "next", "token", "standardsyntaxparsertokenmanag", "java:937", "standard", "syntax", "parser", "token", "manag", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxpars", "standard", "syntax", "parser", "jj", "scan", "token", "standardsyntaxpars", "java:945", "standard", "syntax", "parser", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxpars", "standard", "syntax", "parser", "jj", "3r", "standardsyntaxpars", "java:827", "standard", "syntax", "parser", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxpars", "standard", "syntax", "parser", "jj", "standardsyntaxpars", "java:739", "standard", "syntax", "parser", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxpars", "standard", "syntax", "parser", "jj", "standardsyntaxpars", "java:730", "standard", "syntax", "parser", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxpars", "claus", "standard", "syntax", "parser", "standardsyntaxpars", "java:318", "standard", "syntax", "parser", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxpars", "modclaus", "standard", "syntax", "parser", "mod", "claus", "standardsyntaxpars", "java:303", "standard", "syntax", "parser", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxpars", "conjqueri", "standard", "syntax", "parser", "conj", "queri", "standardsyntaxpars", "java:234", "standard", "syntax", "parser", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxpars", "disjqueri", "standard", "syntax", "parser", "disj", "queri", "standardsyntaxpars", "java:204", "standard", "syntax", "parser", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxpars", "queri", "standard", "syntax", "parser", "standardsyntaxpars", "java:166", "standard", "syntax", "parser", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxpars", "toplevelqueri", "standard", "syntax", "parser", "top", "level", "queri", "standardsyntaxpars", "java:147", "standard", "syntax", "parser", "at", "org", "apach", "lucen", "querypars", "flexibl", "standard", "parser", "standardsyntaxpars", "pars", "standard", "syntax", "parser", "standardsyntaxpars", "java:65", "standard", "syntax", "parser", "141", "common", "frame", "omit", "noformat"], "B_title": "- QueryParse exception when fulltext search performed with term having /", "B_clean_title": ["querypars", "queri", "pars", "except", "when", "fulltext", "search", "perform", "term", "have"]},
{"A_title": "CryptoMapper encrypts external URLs in ResourceReferences making the resources inaccessibleShort Description:   CryptoMapper encrypts links to resources with URLs of the form:  - http://domain/path/script.js  - /local/absolute/path/script.js  Additionally there might be some inconsistencies in handling URLs in instances of ResourceReference.  The problem occurs when JavaScript resources are included in the following way:  @Override public void renderHead(IHeaderResponse response)  super.renderHead(response);  UrlResourceReference reference = new UrlResourceReference(Url.parse(http://domain/path/script.js)); response.render(reference);   The resulting JavaScript links cant be loaded (404 is returned) when CryptoMapper is used.  This is a minor problem because the following always works for JavaScript files not served by Wicket (external JavaScript files):  response.render(new StringHeaderItem(<script type=text/javascript src=//domain/myPath/manual.js></script>);   Ways to reproduce:     A code example for wicket-examples is attached (example.zip)   Local URLs:      http://localhost:8080/enc/index      http://localhost:8080/unenc/index   Possible fix:    - disable encryption for URLs beginning with / <schema>:// and // and not served/filtered by Wicket   (  - define different reference classes for external files and files served/filtered by Wicket issue warnings when a wrong URL type is supplied by the user or treat URLs beginning with / <schema>:// and // differently  )  Thank you", "A_clean_title": ["cryptomapp", "crypto", "mapper", "encrypt", "extern", "url", "ur", "ls", "resourcerefer", "resourc", "refer", "make", "resourc", "inaccessibleshort", "inaccess", "short", "descript", "cryptomapp", "crypto", "mapper", "encrypt", "link", "resourc", "url", "ur", "ls", "form", "http", "js", "domain", "path", "script", "js", "local", "absolut", "path", "script", "addit", "there", "might", "some", "inconsist", "handl", "url", "ur", "ls", "instanc", "resourcerefer", "resourc", "refer", "problem", "occur", "when", "javascript", "java", "script", "resourc", "are", "includ", "follow", "way", "overrid", "public", "void", "renderhead", "render", "head", "iheaderrespons", "header", "respons", "respons", "super", "renderhead", "render", "head", "respons", "urlresourcerefer", "url", "resourc", "refer", "refer", "new", "urlresourcerefer", "url", "resourc", "refer", "url", "pars", "http", "js", "domain", "path", "script", "respons", "render", "refer", "result", "javascript", "java", "script", "link", "cant", "load", "404", "return", "when", "cryptomapp", "crypto", "mapper", "use", "thi", "minor", "problem", "becaus", "follow", "alway", "work", "javascript", "java", "script", "file", "not", "serv", "by", "wicket", "extern", "javascript", "java", "script", "file", "respons", "render", "new", "stringheaderitem", "string", "header", "item", "script", "type=text", "javascript", "js", "src=", "domain", "mypath", "manual", "my", "path", "script", "way", "reproduc", "code", "exampl", "wicket", "exampl", "attach", "exampl", "zip", "local", "url", "ur", "ls", "http", "localhost:8080", "enc", "index", "http", "localhost:8080", "unenc", "index", "possibl", "fix", "disabl", "encrypt", "url", "ur", "ls", "begin", "schema", "not", "serv", "filter", "by", "wicket", "defin", "differ", "refer", "class", "extern", "file", "file", "serv", "filter", "by", "wicket", "issu", "warn", "when", "wrong", "url", "type", "suppli", "by", "user", "or", "treat", "url", "ur", "ls", "begin", "schema", "differ", "thank", "you"], "B_title": "do not encrypt full urls", "B_clean_title": ["not", "encrypt", "full", "url"]},
{"A_title": "ShutdownTServer never sets requestedShutdownACCUMULO-1259 made ShutdownTServer a bit more sane WRT to what it was doing and the FATE repo interface.  One attempt it makes it to not repeatedly invoke shutdownTServer on the master..  Except requestedShutdown is never set to true.", "A_clean_title": ["shutdowntserv", "shutdown", "server", "never", "set", "requestedshutdownaccumulo", "1259", "request", "shutdown", "accumulo", "made", "shutdowntserv", "shutdown", "server", "bit", "more", "sane", "wrt", "what", "it", "wa", "do", "fate", "repo", "interfac", "one", "attempt", "it", "make", "it", "not", "repeatedli", "invok", "shutdowntserv", "shutdown", "server", "master", "except", "requestedshutdown", "request", "shutdown", "never", "set", "true"], "B_title": "Only request shutdown to master once for tserver", "B_clean_title": ["onli", "request", "shutdown", "master", "onc", "tserver"]},
{"A_title": "CancelTaskException leads to FAILED task stateThe CancelTaskException is thrown to trigger canceling of the executing task. It is intended to cause a cancelled status rather than a failed status.  Currently it leads to a FAILED state instead of the expected CANCELED state.", "A_clean_title": ["canceltaskexcept", "cancel", "task", "except", "lead", "fail", "task", "stateth", "state", "canceltaskexcept", "cancel", "task", "except", "thrown", "trigger", "cancel", "execut", "task", "it", "intend", "caus", "cancel", "statu", "rather", "than", "fail", "statu", "current", "it", "lead", "fail", "state", "instead", "expect", "cancel", "state"], "B_title": "runtime Fix CancelTaskException handling", "B_clean_title": ["runtim", "fix", "canceltaskexcept", "cancel", "task", "except", "handl"]},
{"A_title": "Lucene index not created if no node is indexedIf a Lucene property index is defined for a property which is not present in any of the nodes then LuceneIndexWriter would create any lucene index for that.  For eg if we have an index of foo and none of the node has property foo set in that case LuceneIndexWriter would not create an IndexWriter and hence no directory would be created. Later when system performs a query like select jcr:path from nt:base where foo = bar then LucenePropertyIndex would not participate in the query as no Lucene index would be found and system would revert to traversal.  As a fix Lucene index should still be created even if it does not contain any document", "A_clean_title": ["lucen", "index", "not", "creat", "no", "node", "indexedif", "index", "lucen", "properti", "index", "defin", "properti", "which", "not", "present", "ani", "node", "then", "luceneindexwrit", "lucen", "index", "writer", "would", "creat", "ani", "lucen", "index", "that", "eg", "we", "have", "index", "foo", "none", "node", "ha", "properti", "foo", "set", "that", "case", "luceneindexwrit", "lucen", "index", "writer", "would", "not", "creat", "indexwrit", "index", "writer", "henc", "no", "directori", "would", "creat", "later", "when", "system", "perform", "queri", "like", "select", "jcr", "path", "nt", "base", "where", "foo", "bar", "then", "lucenepropertyindex", "lucen", "properti", "index", "would", "not", "particip", "queri", "as", "no", "lucen", "index", "would", "found", "system", "would", "revert", "travers", "as", "fix", "lucen", "index", "still", "creat", "even", "it", "not", "contain", "ani", "document"], "B_title": "- Lucene index not created if no node is indexed", "B_clean_title": ["lucen", "index", "not", "creat", "no", "node", "index"]},
{"A_title": "Codepoint U+007f appears raw in outputNone", "A_clean_title": ["codepoint", "u+007f", "appear", "raw", "outputnon", "output", "none"], "B_title": "Codepoint U+007f should not appear raw in output Fixes issue 416 http://code.google.com/p/closure-compiler/issues/detail?id=416", "B_clean_title": ["codepoint", "u+007f", "not", "appear", "raw", "output", "fix", "issu", "416", "http", "googl", "compil", "issu", "detail", "code", "com", "closur", "id=416"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "Fixed NullPointerException in 2D and 3D sub-line intersections.", "B_clean_title": ["fix", "nullpointerexcept", "null", "pointer", "except", "2d", "3d", "sub", "line", "intersect"]},
{"A_title": "&amp; instead of & in javascriptthe non httpsessionstore part of: https://issues.apache.org/jira/browse/WICKET-1971  is that   in the  wicket:ignoreIfNotActive actually becomes  amp;wicket:ignoreIfNotActive=true  in:  protected CharSequence encode(RequestCycle requestCycle IListenerInterfaceRequestTarget requestTarget)  of WebRequestCodingStrategy on the line:  url.append(url.indexOf(?) > -1 ? &amp; : ?).append( IGNORE_IF_NOT_ACTIVE_PARAMETER_NAME).append(=true);   so when this happens in  public final RequestParameters decode(final Request request)   --- if (request.getParameter(IGNORE_IF_NOT_ACTIVE_PARAMETER_NAME) != null)  parameters.setOnlyProcessIfPathActive(true);  ---  this never actually happens.   then if you have a throttle ajaxlazyloadpanel etc with onlyprocessifpathactive set to true and you logout but go to another wicket page then the original session is destroyed and a new one is created  if this is worked around in the way the  guys on WICKET-1971 suggest WebRequestCycleProcessor  method  public IRequestTarget resolve(final RequestCycle requestCycle final RequestParameters requestParameters)   if (requestParameters.isOnlyProcessIfPathActive()) last branch falls through: else  // TODO also this should work..    and it throws PageExpiredException because the request component/page/behavior does not exist in this new session.   even though onlyprocessifpathactive was set to true and its purpose is precisely to avoid pageexpiredexception.", "A_clean_title": ["amp", "instead", "javascriptth", "non", "httpsessionstor", "part", "http", "1971", "apach", "issu", "org", "jira", "brows", "wicket", "that", "wicket", "ignoreifnotact", "ignor", "not", "activ", "actual", "becom", "amp", "wicket", "ignoreifnotactive=tru", "ignor", "not", "active=tru", "protect", "charsequ", "char", "sequenc", "encod", "requestcycl", "request", "cycl", "requestcycl", "request", "cycl", "ilistenerinterfacerequesttarget", "listen", "interfac", "request", "target", "requesttarget", "request", "target", "webrequestcodingstrategi", "web", "request", "code", "strategi", "line", "url", "append", "url", "indexof", "index", "amp", "append", "ignor", "not", "activ", "paramet", "name", "append", "=true", "so", "when", "thi", "happen", "public", "final", "requestparamet", "request", "paramet", "decod", "final", "request", "request", "request", "getparamet", "get", "paramet", "ignor", "not", "activ", "paramet", "name", "null", "paramet", "setonlyprocessifpathact", "set", "onli", "process", "path", "activ", "true", "thi", "never", "actual", "happen", "then", "you", "have", "throttl", "ajaxlazyloadpanel", "etc", "onlyprocessifpathact", "set", "true", "you", "logout", "but", "go", "anoth", "wicket", "page", "then", "origin", "session", "destroy", "new", "one", "creat", "thi", "work", "around", "way", "guy", "wicket", "1971", "suggest", "webrequestcycleprocessor", "web", "request", "cycl", "processor", "method", "public", "irequesttarget", "request", "target", "resolv", "final", "requestcycl", "request", "cycl", "requestcycl", "request", "cycl", "final", "requestparamet", "request", "paramet", "requestparamet", "request", "paramet", "requestparamet", "isonlyprocessifpathact", "request", "paramet", "onli", "process", "path", "activ", "last", "branch", "fall", "through", "todo", "also", "thi", "work", "it", "throw", "pageexpiredexcept", "page", "expir", "except", "becaus", "request", "compon", "page", "behavior", "not", "exist", "thi", "new", "session", "even", "though", "onlyprocessifpathact", "wa", "set", "true", "it", "purpos", "precis", "avoid", "pageexpiredexcept"], "B_title": "&amp; instead of & in javascript Issue: WICKET-2033", "B_clean_title": ["amp", "instead", "javascript", "issu", "wicket", "2033"]},
{"A_title": "SecuritySettings.setEnforceMounts() does not work when the mounted mapper is not in the root compound mapperBookmarkableMapper.isPageMounted() assumes that all mounted mappers are in Application.getRootRequestMapperAsCompound(). Sometimes the mappers make a tree structure with multiple compounds existing sometimes separated by wrappers like HttpsMapper and CryptoMapper.  Because of this BookmarkableMapper fails to realise that a page is mounted and so does not enforce mounting.", "A_clean_title": ["securityset", "setenforcemount", "secur", "set", "set", "enforc", "mount", "not", "work", "when", "mount", "mapper", "not", "root", "compound", "mapperbookmarkablemapp", "ispagemount", "mapper", "bookmark", "mapper", "page", "mount", "assum", "that", "all", "mount", "mapper", "are", "applic", "getrootrequestmapperascompound", "get", "root", "request", "mapper", "as", "compound", "sometim", "mapper", "make", "tree", "structur", "multipl", "compound", "exist", "sometim", "separ", "by", "wrapper", "like", "httpsmapper", "http", "mapper", "cryptomapp", "crypto", "mapper", "becaus", "thi", "bookmarkablemapp", "bookmark", "mapper", "fail", "realis", "that", "page", "mount", "so", "not", "enforc", "mount"], "B_title": "SecuritySettings.setEnforceMounts() does not work when the mounted mapper is not in the root compound mapper", "B_clean_title": ["securityset", "setenforcemount", "secur", "set", "set", "enforc", "mount", "not", "work", "when", "mount", "mapper", "not", "root", "compound", "mapper"]},
{"A_title": "Garbage collector deleted everything when given bad inputPatch v3 of the upgrade from ACCUMULO-2145 had a test that did the following before upgrade.  noformat root@testUp> table !METADATA root@testUp !METADATA> grant Table.WRITE -u root  root@testUp !METADATA> insert ~del testDel test valueTest noformat  This is a malformed delete entry.  Accumulo code should not delete such entries.  When the 1.5.1 garbage collector saw this it did the following.  noformat 2014-03-20 18:20:05359 gc.SimpleGarbageCollector DEBUG: Deleting /accumuloTest/tables 2014-03-20 18:20:05359 gc.SimpleGarbageCollector DEBUG: Deleting /accumuloTest/tables/!0/default_tablet/F0000009.rf 2014-03-20 18:20:05360 gc.SimpleGarbageCollector DEBUG: Deleting /accumuloTest/tables/!0/table_info/F000000b.rf noformat  GC should validate that delete entries are paths of the expected length.  I have confirmed this bug exist in 1.5.1.  I am assuming it exist in 1.4 and 1.6 branches.", "A_clean_title": ["garbag", "collector", "delet", "everyth", "when", "given", "bad", "inputpatch", "input", "patch", "v3", "upgrad", "accumulo", "2145", "had", "test", "that", "did", "follow", "befor", "upgrad", "noformat", "root", "testup", "test", "up", "tabl", "metadata", "root", "testup", "test", "up", "metadata", "grant", "tabl", "write", "root", "root", "testup", "test", "up", "metadata", "insert", "~del", "testdel", "test", "del", "test", "valuetest", "valu", "test", "noformat", "thi", "malform", "delet", "entri", "accumulo", "code", "not", "delet", "such", "entri", "when", "garbag", "collector", "saw", "thi", "it", "did", "follow", "noformat", "2014", "03", "20", "18:20:05359", "gc", "simplegarbagecollector", "simpl", "garbag", "collector", "debug", "delet", "accumulotest", "tabl", "accumulo", "test", "2014", "03", "20", "18:20:05359", "gc", "simplegarbagecollector", "simpl", "garbag", "collector", "debug", "delet", "accumulotest", "tabl", "accumulo", "test", "rf", "default", "tablet", "f0000009", "2014", "03", "20", "18:20:05360", "gc", "simplegarbagecollector", "simpl", "garbag", "collector", "debug", "delet", "accumulotest", "tabl", "accumulo", "test", "rf", "tabl", "info", "f000000b", "noformat", "gc", "valid", "that", "delet", "entri", "are", "path", "expect", "length", "have", "confirm", "thi", "bug", "exist", "am", "assum", "it", "exist", "branch"], "B_title": "GC changes : disallow a delete marker of hdfs://nn/ log a warning about invalid delete and add test for bad delete markers", "B_clean_title": ["gc", "chang", "disallow", "delet", "marker", "hdf", "nn", "log", "warn", "about", "invalid", "delet", "add", "test", "bad", "delet", "marker"]},
{"A_title": "Mounted bookmarkable Page not recreated on Session ExpiryWith the default true of org.apache.wicket.settings.IPageSettings#getRecreateMountedPagesAfterExpiry() PageExpiryException is thrown when a Link on a page is clicked.  I find it very useful and in fact indispensible to rely on RecreateMountedPagesAfterExpiry especially on logout links.  But it doesnt seem to work for me in 6.4.0. I think this is because Link#getUrl() calls Component#utlFor() which requires a stateless page for this to work:  if (page.isPageStateless())  handler = new BookmarkableListenerInterfaceRequestHandler(provider listener);  else  handler = new ListenerInterfaceRequestHandler(provider listener);   With a stateless page a url is:  http://localhost:8080/wicket/HomePage?-1.ILinkListener-toolBar-signout  With a non stateless but bookmarkable page a url is:  http://localhost:8080/wicket/page?1-1.ILinkListener-toolBar-signout  So I guess that a stateful page cannot be recovered because after session expiry Wicket cannot find out what the page is. It is not coded in the URL.  Looking at the semantics of UrlFor() I thought this might be a bug and I copied and changed the code in my Link subclass from  //if (page.isPageStateless())  to:         if (page.isBookmarkable())   It works as expected but I dont know whether it would break other things if implemented in Wicket.  I guess I am not the only one who needs recovery for bookmarkable pages in this way. Would it be possible to change Wicket to fix this so it becomes possible?", "A_clean_title": ["mount", "bookmark", "page", "not", "recreat", "session", "expirywith", "expiri", "default", "true", "org", "apach", "wicket", "set", "ipageset", "page", "set", "getrecreatemountedpagesafterexpiri", "get", "recreat", "mount", "page", "after", "expiri", "pageexpiryexcept", "page", "expiri", "except", "thrown", "when", "link", "page", "click", "find", "it", "veri", "use", "fact", "indispens", "reli", "recreatemountedpagesafterexpiri", "recreat", "mount", "page", "after", "expiri", "especi", "logout", "link", "but", "it", "doesnt", "seem", "work", "me", "think", "thi", "becaus", "link", "geturl", "get", "url", "call", "compon", "utlfor", "utl", "which", "requir", "stateless", "page", "thi", "work", "page", "ispagestateless", "page", "stateless", "handler", "new", "bookmarkablelistenerinterfacerequesthandl", "bookmark", "listen", "interfac", "request", "handler", "provid", "listen", "handler", "new", "listenerinterfacerequesthandl", "listen", "interfac", "request", "handler", "provid", "listen", "stateless", "page", "url", "http", "localhost:8080", "wicket", "homepag", "home", "page", "toolbar", "signout", "ilinklisten", "tool", "bar", "link", "listen", "non", "stateless", "but", "bookmark", "page", "url", "http", "localhost:8080", "wicket", "page", "toolbar", "signout", "ilinklisten", "tool", "bar", "link", "listen", "so", "guess", "that", "state", "page", "not", "recov", "becaus", "after", "session", "expiri", "wicket", "not", "find", "out", "what", "page", "it", "not", "code", "url", "look", "at", "semant", "urlfor", "url", "thought", "thi", "might", "bug", "copi", "chang", "code", "my", "link", "subclass", "page", "ispagestateless", "page", "stateless", "page", "isbookmark", "bookmark", "it", "work", "as", "expect", "but", "dont", "know", "whether", "it", "would", "break", "other", "thing", "implement", "wicket", "guess", "am", "not", "onli", "one", "who", "need", "recoveri", "bookmark", "page", "thi", "way", "would", "it", "possibl", "chang", "wicket", "fix", "thi", "so", "it", "becom", "possibl"], "B_title": "more restrictive condition for using bookmarkable urls", "B_clean_title": ["more", "restrict", "condit", "bookmark", "url"]},
{"A_title": "Lucene index / compatVersion 2: search for abc! does not workWhen using a Lucene fulltext index with compatVersion 2 then the following query does not return any results. When using compatVersion 1 the correct result is returned.  noformat SELECT * FROM nt:unstructured AS c  WHERE CONTAINS(c.jcr:description abc!)  AND ISDESCENDANTNODE(c /content) noformat  With compatVersion 1 and 2 searching for just abc works. Also searching with = instead of contains works.", "A_clean_title": ["lucen", "index", "compatvers", "compat", "version", "search", "abc", "not", "workwhen", "work", "when", "lucen", "fulltext", "index", "compatvers", "compat", "version", "then", "follow", "queri", "not", "return", "ani", "result", "when", "compatvers", "compat", "version", "correct", "result", "return", "noformat", "select", "nt", "unstructur", "as", "where", "contain", "jcr", "descript", "abc", "isdescendantnod", "content", "noformat", "compatvers", "compat", "version", "search", "just", "abc", "work", "also", "search", "instead", "contain", "work"], "B_title": "- Lucene index / compatVersion 2: search for abc! does not work", "B_clean_title": ["lucen", "index", "compatvers", "compat", "version", "search", "abc", "not", "work"]},
{"A_title": "Branch conflicts not detected by MongoMKMongoMK does not correctly detect conflicts when changes are committed into multiple branches concurrently and then merged back.  ConflictTest already covers conflict detection for non-branch commits and mixed branch/non-branch changes but is missing tests for conflicting branches. Ill commit an ignored test to illustrate the problem.", "A_clean_title": ["branch", "conflict", "not", "detect", "by", "mongomkmongomk", "mongo", "mk", "mongo", "mk", "not", "correctli", "detect", "conflict", "when", "chang", "are", "commit", "into", "multipl", "branch", "concurr", "then", "merg", "back", "conflicttest", "conflict", "test", "alreadi", "cover", "conflict", "detect", "non", "branch", "commit", "mix", "branch", "branch", "non", "chang", "but", "miss", "test", "conflict", "branch", "ill", "commit", "ignor", "test", "illustr", "problem"], "B_title": "Branch conflicts not detected by MongoMK", "B_clean_title": ["branch", "conflict", "not", "detect", "by", "mongomk", "mongo", "mk"]},
{"A_title": "fixed a verify() call example in @Captor javadoc.None", "A_clean_title": ["fix", "verifi", "call", "exampl", "captor", "javadoc", "none"], "B_title": "Fix for issue 229 in the describeTo phase of the Same matcher when match is failing", "B_clean_title": ["fix", "issu", "229", "describeto", "describ", "phase", "same", "matcher", "when", "match", "fail"]},
{"A_title": "Variable called java messes with the importsHello  Im Spooning the JUnit4 source code and in the following class  a variable has been named java:  String java = System.getProperty(java.home) + File.separator + bin + File.separator + java; I configured my launcher with  launcher.getEnvironment().setAutoImports(false);  after running the launcher the following code is generated:  java.lang.String java = ((((java.lang.System.getProperty(java.home)) + (java.io.File.separator)) + bin) + (java.io.File.separator)) + java; Which is completely normal but the compilation will fail because java.lang.System refers to the java String declared earlier which has no lang attribute (obviously).  Since my previous issue Im running Spoon using  launcher.getEnvironment().setAutoImports(false); . Since it is quite specific Im renaming the Java variable in the source code but it can be a bit time-consuming when theres multiple classes with a similar variable.  Thibault", "A_clean_title": ["variabl", "call", "java", "mess", "importshello", "import", "hello", "im", "spoon", "junit4", "unit4", "sourc", "code", "follow", "class", "variabl", "ha", "been", "name", "java", "string", "java", "system", "getproperti", "get", "properti", "java", "home", "file", "separ", "bin", "file", "separ", "java", "configur", "my", "launcher", "launcher", "getenviron", "get", "environ", "setautoimport", "set", "auto", "import", "fals", "after", "run", "launcher", "follow", "code", "gener", "java", "lang", "string", "java", "java", "lang", "system", "getproperti", "get", "properti", "java", "home", "java", "io", "file", "separ", "bin", "java", "io", "file", "separ", "java", "which", "complet", "normal", "but", "compil", "will", "fail", "becaus", "java", "lang", "system", "refer", "java", "string", "declar", "earlier", "which", "ha", "no", "lang", "attribut", "obvious", "sinc", "my", "previou", "issu", "im", "run", "spoon", "launcher", "getenviron", "get", "environ", "setautoimport", "set", "auto", "import", "fals", "sinc", "it", "quit", "specif", "im", "renam", "java", "variabl", "sourc", "code", "but", "it", "bit", "time", "consum", "when", "there", "multipl", "class", "similar", "variabl", "thibault"], "B_title": "fix: improve ImportScanner to support variables called java (#1321)  fix #1320", "B_clean_title": ["fix", "improv", "importscann", "import", "scanner", "support", "variabl", "call", "java", "1321", "fix", "1320"]},
{"A_title": "ConvergenceException in NormalDistributionImpl.cumulativeProbability()I get a ConvergenceException in  NormalDistributionImpl.cumulativeProbability() for very large/small parameters including Infinity -Infinity. For instance in the following code:  @Test public void testCumulative()  final NormalDistribution nd = new NormalDistributionImpl(); for (int i = 0; i < 500; i++)  final double val = Math.exp(i); try  System.out.println(val =  + val +  cumulative =  + nd.cumulativeProbability(val));  catch (MathException e)  e.printStackTrace(); fail();     In version 2.0 I get no exception.   My suggestion is to change in the implementation of cumulativeProbability(double) to catch all ConvergenceException (and return for very large and very small values) not just MaxIterationsExceededException.", "A_clean_title": ["convergenceexcept", "converg", "except", "normaldistributionimpl", "cumulativeprob", "normal", "distribut", "impl", "cumul", "probabl", "get", "convergenceexcept", "converg", "except", "normaldistributionimpl", "cumulativeprob", "normal", "distribut", "impl", "cumul", "probabl", "veri", "larg", "small", "paramet", "includ", "infin", "infin", "instanc", "follow", "code", "test", "public", "void", "testcumul", "test", "cumul", "final", "normaldistribut", "normal", "distribut", "nd", "new", "normaldistributionimpl", "normal", "distribut", "impl", "int", "500", "i++", "final", "doubl", "val", "math", "exp", "tri", "system", "out", "println", "val", "val", "cumul", "nd", "cumulativeprob", "cumul", "probabl", "val", "catch", "mathexcept", "math", "except", "printstacktrac", "print", "stack", "trace", "fail", "version", "get", "no", "except", "my", "suggest", "chang", "implement", "cumulativeprob", "cumul", "probabl", "doubl", "catch", "all", "convergenceexcept", "converg", "except", "return", "veri", "larg", "veri", "small", "valu", "not", "just", "maxiterationsexceededexcept", "max", "iter", "exceed", "except"], "B_title": "Modified NormalDistributionImpl.cumulativeProbability to return 0 or 1 respectively for values more than 40 standard deviations from the mean. For these values the actual probability is indistinguishable from 0 or 1 as a double.  Top coding improves performance for extreme values and prevents convergence exceptions.", "B_clean_title": ["modifi", "normaldistributionimpl", "cumulativeprob", "normal", "distribut", "impl", "cumul", "probabl", "return", "or", "respect", "valu", "more", "than", "40", "standard", "deviat", "mean", "these", "valu", "actual", "probabl", "indistinguish", "or", "as", "doubl", "top", "code", "improv", "perform", "extrem", "valu", "prevent", "converg", "except"]},
{"A_title": "RandomStringUtils.random(count 0 0 false false universe random) always throws java.lang.ArrayIndexOutOfBoundsExceptionIn commons-lang 2.6 line 250 :  ch = charsrandom.nextInt(gap) + start;  This line of code takes a random int to fetch a char in the chars array regardless of its size. (Besides start is useless here) Fixed version would be :  //ch = charsrandom.nextInt(gap)%chars.length;  When user pass 0 as end or when the array is not null but empty this line ends up with an exception", "A_clean_title": ["randomstringutil", "random", "random", "string", "util", "count", "fals", "fals", "univers", "random", "alway", "throw", "java", "lang", "arrayindexoutofboundsexceptionin", "array", "index", "out", "bound", "except", "common", "lang", "line", "250", "ch", "charsrandom", "nextint", "next", "int", "gap", "start", "thi", "line", "code", "take", "random", "int", "fetch", "char", "char", "array", "regardless", "it", "size", "besid", "start", "useless", "here", "fix", "version", "would", "ch", "charsrandom", "nextint", "next", "int", "gap", "char", "length", "when", "user", "pass", "as", "end", "or", "when", "array", "not", "null", "but", "empti", "thi", "line", "end", "up", "except"], "B_title": "RandomStringUtils.random(count 0 0 false false universe random) always throws java.lang.ArrayIndexOutOfBoundsException", "B_clean_title": ["randomstringutil", "random", "random", "string", "util", "count", "fals", "fals", "univers", "random", "alway", "throw", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except"]},
{"A_title": "Fixed DelegatingMethod.equals() so that its easier to extend Mockito by custom verification modesCurrently if you create a DelegatingMethod and compare it to itself using .equals() it will show as not equal because the .equals() method expects a java.lang.reflect.Method (without explicitly stating such). This has a knock on effect on the evaluation of InvocationImpl.equals() which at runtime may be using a DelegatingMethod in its .equals().", "A_clean_title": ["fix", "delegatingmethod", "equal", "deleg", "method", "so", "that", "it", "easier", "extend", "mockito", "by", "custom", "verif", "modescurr", "mode", "current", "you", "creat", "delegatingmethod", "deleg", "method", "compar", "it", "itself", "equal", "it", "will", "show", "as", "not", "equal", "becaus", "equal", "method", "expect", "java", "lang", "reflect", "method", "without", "explicitli", "state", "such", "thi", "ha", "knock", "effect", "evalu", "invocationimpl", "equal", "invoc", "impl", "which", "at", "runtim", "may", "delegatingmethod", "deleg", "method", "it", "equal"], "B_title": "Merge pull request #87 from hughwphamill/master", "B_clean_title": ["merg", "pull", "request", "87", "hughwphamil", "master"]},
{"A_title": "Bug propgated from v1.0.5 on to presentThe method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset (possibly zero).  The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.", "A_clean_title": ["bug", "propgat", "v1", "presentth", "present", "method", "getrowcount", "get", "row", "count", "class", "org", "jfree", "data", "categori", "defaultintervalcategorydataset", "default", "interv", "categori", "dataset", "say", "that", "it", "return", "number", "seri", "dataset", "possibl", "zero", "implement", "v1", "no", "longer", "check", "null", "condit", "which", "would", "then", "return", "zero", "serieskey", "seri", "key", "as", "it", "did", "v1", "previou", "thi", "now", "throw", "null", "pointer", "serieskey", "seri", "key", "never", "got", "initi", "getrowcount", "get", "row", "count", "method", "call"], "B_title": " source/org/jfree/data/DefaultIntervalCategoryDataset.java (DefaultIntervalCategoryDataset(Comparable Comparable Number Number): Initialise seriesKeys and categoryKeys to empty arrays instead of null for empty dataset(setCategoryKeys): Fixed argument check to handle empty dataset.", "B_clean_title": ["java", "sourc", "org", "jfree", "data", "defaultintervalcategorydataset", "default", "interv", "categori", "dataset", "defaultintervalcategorydataset", "default", "interv", "categori", "dataset", "compar", "compar", "number", "number", "initialis", "serieskey", "seri", "key", "categorykey", "categori", "key", "empti", "array", "instead", "null", "empti", "dataset", "setcategorykey", "set", "categori", "key", "fix", "argument", "check", "handl", "empti", "dataset"]},
{"A_title": "Upgraded version history has UUIDs as jcr:frozenUuid of non-referenceable nodesIn Jackrabbit Classic each node even non-referenceable ones has a UUID as its identifier and thus the jcr:frozenUuid properties of frozen nodes are always UUIDs. In contrast Oak uses path identifiers for non-referenceable frozen nodes (see OAK-1009) which presents a problem when dealing with version histories migrated from Jackrabbit Classic.  To avoid this mismatch the upgrade code should check each frozen node for referenceability and replace the frozen UUID with a path identifier if needed.", "A_clean_title": ["upgrad", "version", "histori", "ha", "uuid", "uui", "ds", "as", "jcr", "frozenuuid", "frozen", "uuid", "non", "referenc", "nodesin", "node", "jackrabbit", "classic", "each", "node", "even", "non", "referenc", "one", "ha", "uuid", "as", "it", "identifi", "thu", "jcr", "frozenuuid", "frozen", "uuid", "properti", "frozen", "node", "are", "alway", "uuid", "uui", "ds", "contrast", "oak", "use", "path", "identifi", "non", "referenc", "frozen", "node", "see", "oak", "1009", "which", "present", "problem", "when", "deal", "version", "histori", "migrat", "jackrabbit", "classic", "avoid", "thi", "mismatch", "upgrad", "code", "check", "each", "frozen", "node", "referenc", "replac", "frozen", "uuid", "path", "identifi", "need"], "B_title": "Upgraded version history has UUIDs as jcr:frozenUuid of non-referenceable nodes", "B_clean_title": ["upgrad", "version", "histori", "ha", "uuid", "uui", "ds", "as", "jcr", "frozenuuid", "frozen", "uuid", "non", "referenc", "node"]},
{"A_title": "History command incorrectly numbers commandsWhen you use the history command it will provide you with a list of previous commands that have been executed each with a command number. However if you try to use history expansion by number to invoke one of those commands you will be off by one.  I think this is because the history command in added to the list after it shows you the list and pushes everything else up by one. Uncertain if this is something we do wrong or if this is an upstream JLine bug.", "A_clean_title": ["histori", "command", "incorrectli", "number", "commandswhen", "command", "when", "you", "use", "histori", "command", "it", "will", "provid", "you", "list", "previou", "command", "that", "have", "been", "execut", "each", "command", "number", "howev", "you", "tri", "use", "histori", "expans", "by", "number", "invok", "one", "those", "command", "you", "will", "off", "by", "one", "think", "thi", "becaus", "histori", "command", "ad", "list", "after", "it", "show", "you", "list", "push", "everyth", "up", "by", "one", "uncertain", "thi", "someth", "we", "wrong", "or", "thi", "upstream", "jline", "line", "bug"], "B_title": "offset history command by one", "B_clean_title": ["offset", "histori", "command", "by", "one"]},
{"A_title": "IllegalStateException for ValueMap on _revisionsAn IllegalStateException may be thrown by the MergeSortedIterator when _revisions on the root document are read with the ValueMap implementation. It only happens when the local _revisions map has entries that are lower than the most recent split document.", "A_clean_title": ["illegalstateexcept", "illeg", "state", "except", "valuemap", "valu", "map", "revisionsan", "revis", "illegalstateexcept", "illeg", "state", "except", "may", "thrown", "by", "mergesortediter", "merg", "sort", "iter", "when", "revis", "root", "document", "are", "read", "valuemap", "valu", "map", "implement", "it", "onli", "happen", "when", "local", "revis", "map", "ha", "entri", "that", "are", "lower", "than", "most", "recent", "split", "document"], "B_title": "IllegalStateException for ValueMap on _revisions", "B_clean_title": ["illegalstateexcept", "illeg", "state", "except", "valuemap", "valu", "map", "revis"]},
{"A_title": "Division by zeroIn class Complex division by zero always returns NaN. I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF. See here.", "A_clean_title": ["divis", "by", "zeroin", "zero", "class", "complex", "divis", "by", "zero", "alway", "return", "nan", "na", "think", "that", "it", "return", "nan", "na", "onli", "when", "numer", "also", "zero", "otherwis", "result", "inf", "see", "here"], "B_title": "Reverting to previous behaviour as requested by P. Steitz.", "B_clean_title": ["revert", "previou", "behaviour", "as", "request", "by", "steitz"]},
{"A_title": "IllegalArgumentException on Row.getValues()Calling row.getValues() is throwing an IllegalArgumentException when called on the QueryResult of the query SELECT properties FROM nt:base WHERE sling:resourceType=cq/personalization/components/contextstores/surferinfo  quote java.lang.IllegalArgumentException at com.google.common.base.Preconditions.checkArgument(Preconditions.java:76) at org.apache.jackrabbit.oak.plugins.value.ValueImpl.checkSingleValued(ValueImpl.java:85) at org.apache.jackrabbit.oak.plugins.value.ValueImpl.<init>(ValueImpl.java:72) at org.apache.jackrabbit.oak.plugins.value.ValueFactoryImpl.createValue(ValueFactoryImpl.java:95) at org.apache.jackrabbit.oak.jcr.query.QueryResultImpl.createValue(QueryResultImpl.java:266) at org.apache.jackrabbit.oak.jcr.query.RowImpl.getValues(RowImpl.java:99) at com.day.cq.analytics.sitecatalyst.impl.FrameworkComponentImpl.getListProperty(FrameworkComponentImpl.java:128) at com.day.cq.analytics.sitecatalyst.impl.FrameworkComponentImpl.<init>(FrameworkComponentImpl.java:91) quote", "A_clean_title": ["illegalargumentexcept", "illeg", "argument", "except", "row", "getvalu", "get", "valu", "call", "row", "getvalu", "get", "valu", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "call", "queryresult", "queri", "result", "queri", "select", "properti", "nt", "base", "where", "sling", "resourcetype=cq", "person", "compon", "contextstor", "surferinfo", "resourc", "type=cq", "quot", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "at", "com", "googl", "common", "base", "precondit", "checkargu", "check", "argument", "precondit", "java:76", "at", "org", "apach", "jackrabbit", "oak", "plugin", "valu", "valueimpl", "checksinglevalu", "valu", "impl", "check", "singl", "valu", "valueimpl", "java:85", "valu", "impl", "at", "org", "apach", "jackrabbit", "oak", "plugin", "valu", "valueimpl", "valu", "impl", "init", "valueimpl", "java:72", "valu", "impl", "at", "org", "apach", "jackrabbit", "oak", "plugin", "valu", "valuefactoryimpl", "createvalu", "valu", "factori", "impl", "creat", "valu", "valuefactoryimpl", "java:95", "valu", "factori", "impl", "at", "org", "apach", "jackrabbit", "oak", "jcr", "queri", "queryresultimpl", "createvalu", "queri", "result", "impl", "creat", "valu", "queryresultimpl", "java:266", "queri", "result", "impl", "at", "org", "apach", "jackrabbit", "oak", "jcr", "queri", "rowimpl", "getvalu", "row", "impl", "get", "valu", "rowimpl", "java:99", "row", "impl", "at", "com", "day", "cq", "analyt", "sitecatalyst", "impl", "frameworkcomponentimpl", "getlistproperti", "framework", "compon", "impl", "get", "list", "properti", "frameworkcomponentimpl", "java:128", "framework", "compon", "impl", "at", "com", "day", "cq", "analyt", "sitecatalyst", "impl", "frameworkcomponentimpl", "framework", "compon", "impl", "init", "frameworkcomponentimpl", "java:91", "framework", "compon", "impl", "quot"], "B_title": "IllegalArgumentException on Row.getValues()  - null guard", "B_clean_title": ["illegalargumentexcept", "illeg", "argument", "except", "row", "getvalu", "get", "valu", "null", "guard"]},
{"A_title": "NodeDocument _modified may go back in timeIn a cluster with multiple DocumentMK instances the _modified field of a NodeDocument may go back in time. This will result in incorrect diff calculations when the DocumentNodeStore uses the _modified field to find changed nodes for a given revision range.", "A_clean_title": ["nodedocu", "node", "document", "modifi", "may", "go", "back", "timein", "time", "cluster", "multipl", "documentmk", "document", "mk", "instanc", "modifi", "field", "nodedocu", "node", "document", "may", "go", "back", "time", "thi", "will", "result", "incorrect", "diff", "calcul", "when", "documentnodestor", "document", "node", "store", "use", "modifi", "field", "find", "chang", "node", "given", "revis", "rang"], "B_title": "NodeDocument _modified may go back in time", "B_clean_title": ["nodedocu", "node", "document", "modifi", "may", "go", "back", "time"]},
{"A_title": "QueryManager does not have autorefreshHaving two sessions A and B. A writes something for example /content/page/text = text Accessing Bs QueryManager and exexcute a query for text nothing will be found. Triggering an explicit refresh on B before the query and the hit is found.  I assume that the autorefresh is missed for that case", "A_clean_title": ["querymanag", "queri", "manag", "not", "have", "autorefreshhav", "autorefresh", "have", "two", "session", "write", "someth", "exampl", "content", "page", "text", "text", "access", "bs", "querymanag", "queri", "manag", "exexcut", "queri", "text", "noth", "will", "found", "trigger", "explicit", "refresh", "befor", "queri", "hit", "found", "assum", "that", "autorefresh", "miss", "that", "case"], "B_title": "QueryManager does not have autorefresh  - fix and test", "B_clean_title": ["querymanag", "queri", "manag", "not", "have", "autorefresh", "fix", "test"]},
{"A_title": "Advanced compilations renames a function and then deletes it leaving a reference to a renamed but non-existent functionNone", "A_clean_title": ["advanc", "compil", "renam", "function", "then", "delet", "it", "leav", "refer", "renam", "but", "non", "exist", "functionnon", "function", "none"], "B_title": "Only remove prototype properties defined with simple assigment statements. Fixes issue 459.", "B_clean_title": ["onli", "remov", "prototyp", "properti", "defin", "simpl", "assig", "statement", "fix", "issu", "459"]},
{"A_title": "AbstractTransformerBehavior sets wrong namespaceAbstractTransformerBehaviour adds a wicket namespace (http://wicket.apache.org) to its tag which is different from that of the whole page (http://wicket.apache.org/dtds.data/wicket-xhtml1.4-strict.dtd).  This causes (at least) XPath queries for Wicket nodes to fail when matching the contents of components with an AbstractTransformerBehavior.", "A_clean_title": ["abstracttransformerbehavior", "abstract", "transform", "behavior", "set", "wrong", "namespaceabstracttransformerbehaviour", "namespac", "abstract", "transform", "behaviour", "add", "wicket", "namespac", "http", "apach", "org", "wicket", "it", "tag", "which", "differ", "that", "whole", "page", "http", "apach", "xhtml1", "strict", "dtd", "wicket", "org", "dtd", "data", "wicket", "thi", "caus", "at", "least", "xpath", "path", "queri", "wicket", "node", "fail", "when", "match", "content", "compon", "abstracttransformerbehavior", "abstract", "transform", "behavior"], "B_title": "fixed: AbstractTransformerBehavior sets wrong namespace Issue: WICKET-3861", "B_clean_title": ["fix", "abstracttransformerbehavior", "abstract", "transform", "behavior", "set", "wrong", "namespac", "issu", "wicket", "3861"]},
{"A_title": "String conversion optimization is incorrectNone", "A_clean_title": ["string", "convers", "optim", "incorrectnon", "incorrect", "none"], "B_title": "fix a bad String() optimization fixes issue 759", "B_clean_title": ["fix", "bad", "string", "optim", "fix", "issu", "759"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Fixed missing repair of a point that lies outside the boundaries. Thanks to Frank Hessen for the report and for pinpointing the cause of the problem.", "B_clean_title": ["fix", "miss", "repair", "point", "that", "lie", "outsid", "boundari", "thank", "frank", "hessen", "report", "pinpoint", "caus", "problem"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "source/org/jfree/chart/renderer/category/AbstractCategoryRenderer.java (getLegendItems): Fix null check.", "B_clean_title": ["java", "sourc", "org", "jfree", "chart", "render", "categori", "abstractcategoryrender", "abstract", "categori", "render", "getlegenditem", "get", "legend", "item", "fix", "null", "check"]},
{"A_title": "Overzealous optimization confuses variablesNone", "A_clean_title": ["overzeal", "optim", "confus", "variablesnon", "variabl", "none"], "B_title": "Fix inlining bug in https://code.google.com/p/closure-compiler/issues/detail?id=1053 ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=50726739", "B_clean_title": ["fix", "inlin", "bug", "http", "googl", "compil", "issu", "detail", "code", "com", "closur", "id=1053", "creat", "by", "moe", "http", "java", "googl", "code", "com", "moe", "moe", "migrat", "revid=50726739"]},
{"A_title": "When i use the parameters configured in the dubbo provider in the routing rules the rules can not be matched如果将参数添加到dubbo provider中，例如：   <dubbo:provider  serialization=fastjson /> 这样生成的url中会带有 default.serialization=fastjson 这样的参数。 如果路由规则设置为 => serialization=fastjson，是无法过滤出带有 default.serialization=fastjson 的提供者的。", "A_clean_title": ["when", "use", "paramet", "configur", "dubbo", "provid", "rout", "rule", "rule", "not", "matched如果将参数添加到dubbo", "provider中，例如：", "dubbo", "provid", "serialization=fastjson", "这样生成的url中会带有", "default", "serialization=fastjson", "serialization=fastjson，是无法过滤出带有", "default", "serialization=fastjson"], "B_title": "Merge pull request #1204 condition router match `default.xxx  Fixes #1201", "B_clean_title": ["merg", "pull", "request", "1204", "condit", "router", "match", "default", "xxx", "fix", "1201"]},
{"A_title": "Inconsistent result from Levenberg-MarquardtLevenberg-Marquardt (its method doOptimize) returns a VectorialPointValuePair.  However the class holds the optimum point the vector of the objective function the cost and residuals.  The value returns by doOptimize does not always corresponds to the point which leads to the residuals and cost", "A_clean_title": ["inconsist", "result", "levenberg", "marquardtlevenberg", "marquardt", "marquardt", "levenberg", "it", "method", "dooptim", "optim", "return", "vectorialpointvaluepair", "vectori", "point", "valu", "pair", "howev", "class", "hold", "optimum", "point", "vector", "object", "function", "cost", "residu", "valu", "return", "by", "dooptim", "optim", "not", "alway", "correspond", "point", "which", "lead", "residu", "cost"], "B_title": "corrected", "B_clean_title": ["correct"]},
{"A_title": "Dfp Dfp.multiply(int x) does not comply with the general contract FieldElement.multiply(int n)In class org.apache.commons.math3.Dfp  the method multiply(int n) is limited to 0 <= n <= 9999. This is not consistent with the general contract of FieldElement.multiply(int n) where there should be no limitation on the values of n.", "A_clean_title": ["dfp", "dfp", "multipli", "int", "not", "compli", "gener", "contract", "fieldel", "multipli", "field", "element", "int", "class", "org", "apach", "common", "math3", "dfp", "method", "multipli", "int", "limit", "9999", "thi", "not", "consist", "gener", "contract", "fieldel", "multipli", "field", "element", "int", "where", "there", "no", "limit", "valu"], "B_title": "Allow unlimited input values for Dfp#multiply.", "B_clean_title": ["allow", "unlimit", "input", "valu", "dfp", "multipli"]},
{"A_title": "Can not Return deep stubs from generic method that returns generic type.if I try to mock a generic method which a generic returntype where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it. When you dont use deep stubs and a raw Supplier mock to pass around it works:", "A_clean_title": ["not", "return", "deep", "stub", "gener", "method", "that", "return", "gener", "type", "tri", "mock", "gener", "method", "which", "gener", "returntyp", "where", "returntyp", "deriv", "gener", "type", "method", "deep", "stub", "get", "classcastexcept", "class", "cast", "except", "when", "call", "when", "it", "when", "you", "dont", "use", "deep", "stub", "raw", "supplier", "mock", "pass", "around", "it", "work"], "B_title": "Merge branch issue484-fix of git://github.com/MajA7jHbJYW2N/mockito into MajA7jHbJYW2N-issue484-fix", "B_clean_title": ["merg", "branch", "issue484", "fix", "git", "github", "com", "maja7jhbjyw2n", "mockito", "maj", "a7j", "hb", "jyw2n", "into", "maja7jhbjyw2n", "issue484", "fix", "maj", "a7j", "hb", "jyw2n"]},
{"A_title": "Matrixs OutOfBoundException in SimplexSolverHi all This bug is somehow related to incident MATH-286 but not necessarily...  Lets say I have an LP and I solve it using SimplexSolver. Then I create a second LP similar to the first one but with stronger constraints. The second LP has the following properties: * the only point in the feasible region for the second LP is the solution returned for the first LP * the solution returned for the first LP is also the (only possible) solution to the second LP  This shows the problem:  code:borderStyle=solid LinearObjectiveFunction f = new LinearObjectiveFunction(new double  0.8 0.2 0.7 0.3 0.4 0.6 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double  1 0 1 0 1 0  Relationship.EQ 30.0)); constraints.add(new LinearConstraint(new double  0 1 0 1 0 1  Relationship.EQ 30.0)); constraints.add(new LinearConstraint(new double  0.8 0.2 0.0 0.0 0.0 0.0  Relationship.GEQ 10.0)); constraints.add(new LinearConstraint(new double  0.0 0.0 0.7 0.3 0.0 0.0  Relationship.GEQ 10.0)); constraints.add(new LinearConstraint(new double  0.0 0.0 0.0 0.0 0.4 0.6  Relationship.GEQ 10.0));  RealPointValuePair solution = new SimplexSolver().optimize(f constraints GoalType.MAXIMIZE true);  double valA = 0.8 * solution.getPoint()0 + 0.2 * solution.getPoint()1; double valB = 0.7 * solution.getPoint()2 + 0.3 * solution.getPoint()3; double valC = 0.4 * solution.getPoint()4 + 0.6 * solution.getPoint()5;  f = new LinearObjectiveFunction(new double  0.8 0.2 0.7 0.3 0.4 0.6 0 ); constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double  1 0 1 0 1 0  Relationship.EQ 30.0)); constraints.add(new LinearConstraint(new double  0 1 0 1 0 1  Relationship.EQ 30.0)); constraints.add(new LinearConstraint(new double  0.8 0.2 0.0 0.0 0.0 0.0  Relationship.GEQ valA)); constraints.add(new LinearConstraint(new double  0.0 0.0 0.7 0.3 0.0 0.0  Relationship.GEQ valB)); constraints.add(new LinearConstraint(new double  0.0 0.0 0.0 0.0 0.4 0.6  Relationship.GEQ valC));  solution = new SimplexSolver().optimize(f constraints GoalType.MAXIMIZE true); code   Instead of returning the solution SimplexSolver throws an Exception:  noformat Exception in thread main org.apache.commons.math.linear.MatrixIndexException: no entry at indices (0 7) in a 6x7 matrix at org.apache.commons.math.linear.Array2DRowRealMatrix.getEntry(Array2DRowRealMatrix.java:356) at org.apache.commons.math.optimization.linear.SimplexTableau.getEntry(SimplexTableau.java:408) at org.apache.commons.math.optimization.linear.SimplexTableau.getBasicRow(SimplexTableau.java:258) at org.apache.commons.math.optimization.linear.SimplexTableau.getSolution(SimplexTableau.java:336) at org.apache.commons.math.optimization.linear.SimplexSolver.doOptimize(SimplexSolver.java:182) at org.apache.commons.math.optimization.linear.AbstractLinearOptimizer.optimize(AbstractLinearOptimizer.java:106)noformat   I was too optimistic with the bug MATH-286 ;-)", "A_clean_title": ["matrix", "outofboundexcept", "out", "bound", "except", "simplexsolverhi", "simplex", "solver", "hi", "all", "thi", "bug", "somehow", "relat", "incid", "math", "286", "but", "not", "necessarili", "let", "say", "have", "lp", "solv", "it", "simplexsolv", "simplex", "solver", "then", "creat", "second", "lp", "similar", "first", "one", "but", "stronger", "constraint", "second", "lp", "ha", "follow", "properti", "onli", "point", "feasibl", "region", "second", "lp", "solut", "return", "first", "lp", "solut", "return", "first", "lp", "also", "onli", "possibl", "solut", "second", "lp", "thi", "show", "problem", "code", "borderstyle=solid", "border", "style=solid", "linearobjectivefunct", "linear", "object", "function", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "constraint", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "eq", "30", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "eq", "30", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "geq", "10", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "geq", "10", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "geq", "10", "realpointvaluepair", "real", "point", "valu", "pair", "solut", "new", "simplexsolv", "simplex", "solver", "optim", "constraint", "goaltyp", "maxim", "goal", "type", "true", "doubl", "vala", "val", "solut", "getpoint", "get", "point", "solut", "getpoint", "get", "point", "doubl", "valb", "val", "solut", "getpoint", "get", "point", "solut", "getpoint", "get", "point", "doubl", "valc", "val", "solut", "getpoint", "get", "point", "solut", "getpoint", "get", "point", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "constraint", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "eq", "30", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "eq", "30", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "geq", "vala", "val", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "geq", "valb", "val", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "geq", "valc", "val", "solut", "new", "simplexsolv", "simplex", "solver", "optim", "constraint", "goaltyp", "maxim", "goal", "type", "true", "code", "instead", "return", "solut", "simplexsolv", "simplex", "solver", "throw", "except", "noformat", "except", "thread", "main", "org", "apach", "common", "math", "linear", "matrixindexexcept", "matrix", "index", "except", "no", "entri", "at", "indic", "6x7", "matrix", "at", "org", "apach", "common", "math", "linear", "array2drowrealmatrix", "getentri", "array2d", "row", "real", "matrix", "get", "entri", "array2drowrealmatrix", "java:356", "array2d", "row", "real", "matrix", "at", "org", "apach", "common", "math", "optim", "linear", "simplextableau", "getentri", "simplex", "tableau", "get", "entri", "simplextableau", "java:408", "simplex", "tableau", "at", "org", "apach", "common", "math", "optim", "linear", "simplextableau", "getbasicrow", "simplex", "tableau", "get", "basic", "row", "simplextableau", "java:258", "simplex", "tableau", "at", "org", "apach", "common", "math", "optim", "linear", "simplextableau", "getsolut", "simplex", "tableau", "get", "solut", "simplextableau", "java:336", "simplex", "tableau", "at", "org", "apach", "common", "math", "optim", "linear", "simplexsolv", "dooptim", "simplex", "solver", "optim", "simplexsolv", "java:182", "simplex", "solver", "at", "org", "apach", "common", "math", "optim", "linear", "abstractlinearoptim", "optim", "abstract", "linear", "optim", "abstractlinearoptim", "java:106", "abstract", "linear", "optim", "noformat", "wa", "too", "optimist", "bug", "math", "286"], "B_title": "Fixed a OutOfBoundException in simplex solver when some constraints are tight JIRA: MATH-293", "B_clean_title": ["fix", "outofboundexcept", "out", "bound", "except", "simplex", "solver", "when", "some", "constraint", "are", "tight", "jira", "math", "293"]},
{"A_title": "java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.StringException throws on verifyZeroInteractions when using mock with default answer.", "A_clean_title": ["java", "lang", "classcastexcept", "class", "cast", "except", "java", "lang", "class", "not", "cast", "java", "lang", "stringexcept", "string", "except", "throw", "verifyzerointeract", "verifi", "zero", "interact", "when", "mock", "default", "answer"], "B_title": "Fixes #187 : print mock name even when default answer is bogus", "B_clean_title": ["fix", "187", "print", "mock", "name", "even", "when", "default", "answer", "bogu"]},
{"A_title": "ACE merging not behaving correctly if not using managed principalsorg.apache.jackrabbit.api.security.JackrabbitAccessControlList#addEntry() does not work correctly if the given principal is not retrieved from the PrincipalManager.  Exception: noformat Caused by: org.apache.jackrabbit.oak.api.CommitFailedException: OakAccessControl0013: Duplicate ACE found in policy at org.apache.jackrabbit.oak.security.authorization.accesscontrol.AccessControlValidator.accessViolation(AccessControlValidator.java:278) at org.apache.jackrabbit.oak.security.authorization.accesscontrol.AccessControlValidator.checkValidPolicy(AccessControlValidator.java:188) noformat  this used to work in jackrabbit 2.x.  the problem is probably in org.apache.jackrabbit.oak.security.authorization.accesscontrol.ACL#internalAddEntry where the principals are equalled instead of comparing their names.  note that adding an ACE with such a principal works just the merging/overwriting detection doesnt.  test: code   Principal p1 = new Principal()  getName()return foo;   Principal p2 = new Principal()  getName()return foo;   acl.addEntry(p1 privileges true);   acl.addEntry(p2 privileges false);   ...   save(); // throws code", "A_clean_title": ["ace", "merg", "not", "behav", "correctli", "not", "manag", "principalsorg", "apach", "jackrabbit", "api", "secur", "jackrabbitaccesscontrollist", "jackrabbit", "access", "control", "list", "addentri", "add", "entri", "not", "work", "correctli", "given", "princip", "not", "retriev", "principalmanag", "princip", "manag", "except", "noformat", "caus", "by", "org", "apach", "jackrabbit", "oak", "api", "commitfailedexcept", "commit", "fail", "except", "oakaccesscontrol0013", "oak", "access", "control0013", "duplic", "ace", "found", "polici", "at", "org", "apach", "jackrabbit", "oak", "secur", "author", "accesscontrol", "accesscontrolvalid", "accessviol", "access", "control", "valid", "access", "violat", "accesscontrolvalid", "java:278", "access", "control", "valid", "at", "org", "apach", "jackrabbit", "oak", "secur", "author", "accesscontrol", "accesscontrolvalid", "checkvalidpolici", "access", "control", "valid", "check", "valid", "polici", "accesscontrolvalid", "java:188", "access", "control", "valid", "noformat", "thi", "use", "work", "jackrabbit", "problem", "probabl", "org", "apach", "jackrabbit", "oak", "secur", "author", "accesscontrol", "acl", "internaladdentri", "intern", "add", "entri", "where", "princip", "are", "equal", "instead", "compar", "their", "name", "note", "that", "ad", "ace", "such", "princip", "work", "just", "merg", "overwrit", "detect", "doesnt", "test", "code", "princip", "p1", "new", "princip", "getnam", "get", "name", "return", "foo", "princip", "p2", "new", "princip", "getnam", "get", "name", "return", "foo", "acl", "addentri", "add", "entri", "p1", "privileg", "true", "acl", "addentri", "add", "entri", "p2", "privileg", "fals", "save", "throw", "code"], "B_title": ": ACE merging not behaving correctly if not using managed principals", "B_clean_title": ["ace", "merg", "not", "behav", "correctli", "not", "manag", "princip"]}]