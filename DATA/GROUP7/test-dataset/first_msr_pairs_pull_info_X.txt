[{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing to BrentSolver. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "brentsolv", "brent", "solver"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added back missing betas. ", "B_clean_title": ["ad", "back", "miss", "beta"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "Remove unused if (. ", "B_clean_title": ["remov", "unus"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "Fix a false reporting of convergence. ", "B_clean_title": ["fix", "fals", "report", "converg"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "Fix a false reporting of convergence. ", "B_clean_title": ["fix", "fals", "report", "converg"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "Remove a redundant check. ", "B_clean_title": ["remov", "redund", "check"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "Fix a bug in the patch collection. ", "B_clean_title": ["fix", "bug", "patch", "collect"]},
{"A_title": "MathRuntimeException with simple ebeMultiply on OpenMapRealVectorThe following piece of code  import org.apache.commons.math.linear.OpenMapRealVector; import org.apache.commons.math.linear.RealVector;  public class DemoBugOpenMapRealVector      public static void main(String args)          final RealVector u = new OpenMapRealVector(3 1E-6);         u.setEntry(0 1.);         u.setEntry(1 0.);         u.setEntry(2 2.);         final RealVector v = new OpenMapRealVector(3 1E-6);         v.setEntry(0 0.);         v.setEntry(1 3.);         v.setEntry(2 0.);         System.out.println(u);         System.out.println(v);         System.out.println(u.ebeMultiply(v));         raises an exception  org.apache.commons.math.linear.OpenMapRealVector@7170a9b6 Exception in thread main org.apache.commons.math.MathRuntimeException 6: map has been modified while iterating at org.apache.commons.math.MathRuntimeException.createConcurrentModificationException(MathRuntimeException.java:373) at org.apache.commons.math.util.OpenIntToDoubleHashMap Iterator.advance(OpenIntToDoubleHashMap.java:564) at org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:372) at org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:1) at DemoBugOpenMapRealVector.main(DemoBugOpenMapRealVector.java:17)", "A_clean_title": ["mathruntimeexcept", "math", "runtim", "except", "simpl", "ebemultipli", "ebe", "multipli", "openmaprealvectorth", "open", "map", "real", "vector", "follow", "piec", "code", "import", "org", "apach", "common", "math", "linear", "openmaprealvector", "open", "map", "real", "vector", "import", "org", "apach", "common", "math", "linear", "realvector", "real", "vector", "public", "class", "demobugopenmaprealvector", "demo", "bug", "open", "map", "real", "vector", "public", "static", "void", "main", "string", "arg", "final", "realvector", "real", "vector", "new", "openmaprealvector", "open", "map", "real", "vector", "1e", "setentri", "set", "entri", "setentri", "set", "entri", "setentri", "set", "entri", "final", "realvector", "real", "vector", "new", "openmaprealvector", "open", "map", "real", "vector", "1e", "setentri", "set", "entri", "setentri", "set", "entri", "setentri", "set", "entri", "system", "out", "println", "system", "out", "println", "system", "out", "println", "ebemultipli", "ebe", "multipli", "rais", "except", "org", "apach", "common", "math", "linear", "openmaprealvector", "open", "map", "real", "vector", "7170a9b6", "except", "thread", "main", "org", "apach", "common", "math", "mathruntimeexcept", "math", "runtim", "except", "map", "ha", "been", "modifi", "while", "iter", "at", "org", "apach", "common", "math", "mathruntimeexcept", "createconcurrentmodificationexcept", "math", "runtim", "except", "creat", "concurr", "modif", "except", "mathruntimeexcept", "java:373", "math", "runtim", "except", "at", "org", "apach", "common", "math", "util", "openinttodoublehashmap", "open", "int", "doubl", "hash", "map", "iter", "advanc", "openinttodoublehashmap", "java:564", "open", "int", "doubl", "hash", "map", "at", "org", "apach", "common", "math", "linear", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "openmaprealvector", "java:372", "open", "map", "real", "vector", "at", "org", "apach", "common", "math", "linear", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "openmaprealvector", "java:1", "open", "map", "real", "vector", "at", "demobugopenmaprealvector", "main", "demo", "bug", "open", "map", "real", "vector", "demobugopenmaprealvector", "java:17", "demo", "bug", "open", "map", "real", "vector"], "B_title": "Fix bug in ebeDivide ( RealVector ). Fix bug in ebeDivide ( ). Updated patch. Fix bug in ebeMultiply ( ). ", "B_clean_title": ["fix", "bug", "ebedivid", "ebe", "divid", "realvector", "real", "vector", "fix", "bug", "ebedivid", "ebe", "divid", "updat", "patch", "fix", "bug", "ebemultipli", "ebe", "multipli"]},
{"A_title": "StringUtils.join throws NPE when toString returns null for one of objects in collectionTry    StringUtils.join(new Object         new Object()            @Override           public String toString()              return null;                          );   ToString should probably never return null but it does in javax.mail.internet.InternetAddress", "A_clean_title": ["stringutil", "join", "string", "util", "throw", "npe", "when", "tostr", "string", "return", "null", "one", "object", "collectiontri", "collect", "tri", "stringutil", "join", "string", "util", "new", "object", "new", "object", "overrid", "public", "string", "tostr", "string", "return", "null", "tostr", "string", "probabl", "never", "return", "null", "but", "it", "javax", "mail", "internet", "internetaddress", "internet", "address"], "B_title": "Bump the buffer size for the empty string builder .. Removed unnecessary copy of StringUtils. ", "B_clean_title": ["bump", "buffer", "size", "empti", "string", "builder", "remov", "unnecessari", "copi", "stringutil", "string", "util"]},
{"A_title": "StringUtils.join throws NPE when toString returns null for one of objects in collectionTry    StringUtils.join(new Object         new Object()            @Override           public String toString()              return null;                          );   ToString should probably never return null but it does in javax.mail.internet.InternetAddress", "A_clean_title": ["stringutil", "join", "string", "util", "throw", "npe", "when", "tostr", "string", "return", "null", "one", "object", "collectiontri", "collect", "tri", "stringutil", "join", "string", "util", "new", "object", "new", "object", "overrid", "public", "string", "tostr", "string", "return", "null", "tostr", "string", "probabl", "never", "return", "null", "but", "it", "javax", "mail", "internet", "internetaddress", "internet", "address"], "B_title": "fixed bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "StringUtils.join throws NPE when toString returns null for one of objects in collectionTry    StringUtils.join(new Object         new Object()            @Override           public String toString()              return null;                          );   ToString should probably never return null but it does in javax.mail.internet.InternetAddress", "A_clean_title": ["stringutil", "join", "string", "util", "throw", "npe", "when", "tostr", "string", "return", "null", "one", "object", "collectiontri", "collect", "tri", "stringutil", "join", "string", "util", "new", "object", "new", "object", "overrid", "public", "string", "tostr", "string", "return", "null", "tostr", "string", "probabl", "never", "return", "null", "but", "it", "javax", "mail", "internet", "internetaddress", "internet", "address"], "B_title": "fixed bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "Remove redundant code. ", "B_clean_title": ["remov", "redund", "code"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "fix merge issue. ", "B_clean_title": ["fix", "merg", "issu"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "Fix swapped diffs in patch. ", "B_clean_title": ["fix", "swap", "diff", "patch"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "added missing copy. ", "B_clean_title": ["ad", "miss", "copi"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "Add missing import. Fix test. ", "B_clean_title": ["add", "miss", "import", "fix", "test"]},
{"A_title": "Classify non-rightmost expressions as problematicNone", "A_clean_title": ["classifi", "non", "rightmost", "express", "as", "problematicnon", "problemat", "none"], "B_title": "Remove unused local variable .. ", "B_clean_title": ["remov", "unus", "local", "variabl"]},
{"A_title": "Classify non-rightmost expressions as problematicNone", "A_clean_title": ["classifi", "non", "rightmost", "express", "as", "problematicnon", "problemat", "none"], "B_title": "Fix bug in closure patch. ", "B_clean_title": ["fix", "bug", "closur", "patch"]},
{"A_title": "compiler crashes when  goog.provide used with non stringNone", "A_clean_title": ["compil", "crash", "when", "goog", "provid", "use", "non", "stringnon", "string", "none"], "B_title": "Fixing closure code conventions. ", "B_clean_title": ["fix", "closur", "code", "convent"]},
{"A_title": ".withHourOfDay() sets hour inconsistantly on DST transition.When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I cant find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.", "A_clean_title": ["withhourofday", "hour", "day", "set", "hour", "inconsistantli", "dst", "transit", "when", "hour", "day", "set", "ambigu", "hour", "daylight", "standard", "time", "transit", "given", "time", "zone", "result", "inconsist", "differ", "time", "zone", "shoul", "hour", "set", "daylight", "hour", "or", "standard", "hour", "all", "time", "zone", "cant", "find", "anyth", "that", "document", "thi", "behavior", "my", "test", "code", "below", "return", "differ", "result", "differ", "time", "zone", "veri", "last", "assert", "fail", "australia", "time", "zone", "cutov"], "B_title": "Fixed typo in Time - 26 - Hercules .. Fixed bug in Time - 26 - Hercules .. Fixed formatting mistake .. Fixed bug in Time - 26 - Hercules .. Fixed typo in patch1. Fixed formatting mistake in convertLocalToUTC ( long  boolean  boolean  boolean  boolean ). Fixed formatting mistake in convertLocalToUTC ( long  boolean  boolean  boolean ). ", "B_clean_title": ["fix", "typo", "time", "26", "hercul", "fix", "bug", "time", "26", "hercul", "fix", "format", "mistak", "fix", "bug", "time", "26", "hercul", "fix", "typo", "patch1", "fix", "format", "mistak", "convertlocaltoutc", "convert", "local", "utc", "long", "boolean", "boolean", "boolean", "boolean", "fix", "format", "mistak", "convertlocaltoutc", "convert", "local", "utc", "long", "boolean", "boolean", "boolean"]},
{"A_title": "RealMatrixImpl#operate gets result vector dimensions wrongorg.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix. Thus line 640 in RealMatrixImpl.java should read double out = new doublenRows; instead of double out = new doublev.length;", "A_clean_title": ["realmatriximpl", "real", "matrix", "impl", "oper", "get", "result", "vector", "dimens", "wrongorg", "apach", "common", "math", "linear", "realmatriximpl", "real", "matrix", "impl", "oper", "tri", "creat", "result", "vector", "that", "alway", "ha", "same", "length", "as", "input", "vector", "thi", "result", "runtim", "except", "matrix", "non", "squar", "it", "alway", "yield", "incorrect", "result", "matrix", "non", "squar", "correct", "behaviour", "would", "cours", "creat", "vector", "same", "length", "as", "row", "dimens", "matrix", "thu", "line", "640", "realmatriximpl", "java", "real", "matrix", "impl", "read", "doubl", "out", "new", "doublenrow", "doublen", "row", "instead", "doubl", "out", "new", "doublev", "length"], "B_title": "Fix array length. ", "B_clean_title": ["fix", "array", "length"]},
{"A_title": "RealMatrixImpl#operate gets result vector dimensions wrongorg.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix. Thus line 640 in RealMatrixImpl.java should read double out = new doublenRows; instead of double out = new doublev.length;", "A_clean_title": ["realmatriximpl", "real", "matrix", "impl", "oper", "get", "result", "vector", "dimens", "wrongorg", "apach", "common", "math", "linear", "realmatriximpl", "real", "matrix", "impl", "oper", "tri", "creat", "result", "vector", "that", "alway", "ha", "same", "length", "as", "input", "vector", "thi", "result", "runtim", "except", "matrix", "non", "squar", "it", "alway", "yield", "incorrect", "result", "matrix", "non", "squar", "correct", "behaviour", "would", "cours", "creat", "vector", "same", "length", "as", "row", "dimens", "matrix", "thu", "line", "640", "realmatriximpl", "java", "real", "matrix", "impl", "read", "doubl", "out", "new", "doublenrow", "doublen", "row", "instead", "doubl", "out", "new", "doublev", "length"], "B_title": "Fix the array to work properly. fix the bug. ", "B_clean_title": ["fix", "array", "work", "properli", "fix", "bug"]},
{"A_title": "RealMatrixImpl#operate gets result vector dimensions wrongorg.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix. Thus line 640 in RealMatrixImpl.java should read double out = new doublenRows; instead of double out = new doublev.length;", "A_clean_title": ["realmatriximpl", "real", "matrix", "impl", "oper", "get", "result", "vector", "dimens", "wrongorg", "apach", "common", "math", "linear", "realmatriximpl", "real", "matrix", "impl", "oper", "tri", "creat", "result", "vector", "that", "alway", "ha", "same", "length", "as", "input", "vector", "thi", "result", "runtim", "except", "matrix", "non", "squar", "it", "alway", "yield", "incorrect", "result", "matrix", "non", "squar", "correct", "behaviour", "would", "cours", "creat", "vector", "same", "length", "as", "row", "dimens", "matrix", "thu", "line", "640", "realmatriximpl", "java", "real", "matrix", "impl", "read", "doubl", "out", "new", "doublenrow", "doublen", "row", "instead", "doubl", "out", "new", "doublev", "length"], "B_title": "BigMatrixImpl copy constructor. Fix error in RealMatrixImpl .. ", "B_clean_title": ["bigmatriximpl", "big", "matrix", "impl", "copi", "constructor", "fix", "error", "realmatriximpl", "real", "matrix", "impl"]},
{"A_title": "RealMatrixImpl#operate gets result vector dimensions wrongorg.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix. Thus line 640 in RealMatrixImpl.java should read double out = new doublenRows; instead of double out = new doublev.length;", "A_clean_title": ["realmatriximpl", "real", "matrix", "impl", "oper", "get", "result", "vector", "dimens", "wrongorg", "apach", "common", "math", "linear", "realmatriximpl", "real", "matrix", "impl", "oper", "tri", "creat", "result", "vector", "that", "alway", "ha", "same", "length", "as", "input", "vector", "thi", "result", "runtim", "except", "matrix", "non", "squar", "it", "alway", "yield", "incorrect", "result", "matrix", "non", "squar", "correct", "behaviour", "would", "cours", "creat", "vector", "same", "length", "as", "row", "dimens", "matrix", "thu", "line", "640", "realmatriximpl", "java", "real", "matrix", "impl", "read", "doubl", "out", "new", "doublenrow", "doublen", "row", "instead", "doubl", "out", "new", "doublev", "length"], "B_title": "Fixed erroneous conversion to BigDecimal. Fix initial matrix lengths .. ", "B_clean_title": ["fix", "erron", "convers", "bigdecim", "big", "decim", "fix", "initi", "matrix", "length"]},
{"A_title": "RealMatrixImpl#operate gets result vector dimensions wrongorg.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix. Thus line 640 in RealMatrixImpl.java should read double out = new doublenRows; instead of double out = new doublev.length;", "A_clean_title": ["realmatriximpl", "real", "matrix", "impl", "oper", "get", "result", "vector", "dimens", "wrongorg", "apach", "common", "math", "linear", "realmatriximpl", "real", "matrix", "impl", "oper", "tri", "creat", "result", "vector", "that", "alway", "ha", "same", "length", "as", "input", "vector", "thi", "result", "runtim", "except", "matrix", "non", "squar", "it", "alway", "yield", "incorrect", "result", "matrix", "non", "squar", "correct", "behaviour", "would", "cours", "creat", "vector", "same", "length", "as", "row", "dimens", "matrix", "thu", "line", "640", "realmatriximpl", "java", "real", "matrix", "impl", "read", "doubl", "out", "new", "doublenrow", "doublen", "row", "instead", "doubl", "out", "new", "doublev", "length"], "B_title": "Fixed erroneous conversion to BigDecimal. Fix initial matrix length. ", "B_clean_title": ["fix", "erron", "convers", "bigdecim", "big", "decim", "fix", "initi", "matrix", "length"]},
{"A_title": "Fix for MultiplePiePlotWhen dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called.", "A_clean_title": ["fix", "multiplepieplotwhen", "multipl", "pie", "plot", "when", "dataset", "pass", "into", "constructor", "multiplepieplot", "multipl", "pie", "plot", "dataset", "not", "wire", "listen", "as", "it", "would", "setdataset", "set", "dataset", "call"], "B_title": "Fix 144 bug. ", "B_clean_title": ["fix", "144", "bug"]},
{"A_title": "Fix for MultiplePiePlotWhen dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called.", "A_clean_title": ["fix", "multiplepieplotwhen", "multipl", "pie", "plot", "when", "dataset", "pass", "into", "constructor", "multiplepieplot", "multipl", "pie", "plot", "dataset", "not", "wire", "listen", "as", "it", "would", "setdataset", "set", "dataset", "call"], "B_title": "Fixed a bug in MultiplePiePlot .. ", "B_clean_title": ["fix", "bug", "multiplepieplot", "multipl", "pie", "plot"]},
{"A_title": "Fix for MultiplePiePlotWhen dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called.", "A_clean_title": ["fix", "multiplepieplotwhen", "multipl", "pie", "plot", "when", "dataset", "pass", "into", "constructor", "multiplepieplot", "multipl", "pie", "plot", "dataset", "not", "wire", "listen", "as", "it", "would", "setdataset", "set", "dataset", "call"], "B_title": "Missing warning. ", "B_clean_title": ["miss", "warn"]},
{"A_title": "Fix for MultiplePiePlotWhen dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called.", "A_clean_title": ["fix", "multiplepieplotwhen", "multipl", "pie", "plot", "when", "dataset", "pass", "into", "constructor", "multiplepieplot", "multipl", "pie", "plot", "dataset", "not", "wire", "listen", "as", "it", "would", "setdataset", "set", "dataset", "call"], "B_title": "Set the dataset on the pie chart .. ", "B_clean_title": ["set", "dataset", "pie", "chart"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add the isNaN check to Complex . add ( ). ", "B_clean_title": ["add", "isnan", "na", "check", "complex", "add"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add the isNaN check to Complex . add ( ). ", "B_clean_title": ["add", "isnan", "na", "check", "complex", "add"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add NaN to Complex . add ( ). ", "B_clean_title": ["add", "nan", "na", "complex", "add"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add the isNaN check. ", "B_clean_title": ["add", "isnan", "na", "check"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add one - line ifs. ", "B_clean_title": ["add", "one", "line", "if"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add the isNaN check in Complex . add ( ). ", "B_clean_title": ["add", "isnan", "na", "check", "complex", "add"]},
{"A_title": "wrong result in eigen decompositionSome results computed by EigenDecompositionImpl are wrong. The following case computed by Fortran Lapack fails with version 2.0      public void testMathpbx02()           double mainTridiagonal =            7484.860960227216 18405.28129035345 13855.225609560746          10016.708722343366 559.8117399576674 6750.190788301587              71.21428769782159         ;         double secondaryTridiagonal =           -4175.0885704763661975.79558582419945193.178422374075            1995.28665916917975.34535882933804-234.0808002076056         ;          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double refEigenValues =          20654.74489030697441216828.208208485466457         6893.1559126349948206757.083016675340332         5887.79988568855878864.309089923240379         57.992628792736340         ;         RealVector refEigenVectors =          new ArrayRealVector(new double -0.270356342026904 0.852811091326997 0.399639490702077 0.198794657813990 0.019739323307666 0.000106983022327 -0.000001216636321)         new ArrayRealVector(new double 0.179995273578326-0.4028078481530420.7018709935257340.5550582110148880.0680791488982360.000509139115227-0.000007112235617)         new ArrayRealVector(new double -0.399582721284727-0.056629954519333-0.5144064885228270.7111681645185800.2255480812763670.125943999652923-0.004321507456014)         new ArrayRealVector(new double 0.0585157215728210.0102001300577390.063516274916536-0.090696087449378-0.0171484204325970.991318870265707-0.034707338554096)         new ArrayRealVector(new double 0.8552059955375640.327134656629775-0.2653823970605480.2826907290267060.105736068025572-0.0091381266220390.000367751821196)         new ArrayRealVector(new double -0.002913069901144-0.0051775157771010.041906334478672-0.1093159184162580.4361923054567410.0263073156395350.891797507436344)         new ArrayRealVector(new double -0.005738311176435-0.0102076116703780.082662420517928-0.2157338860943680.861606487840411-0.025478530652759-0.451080697503958)         ;          // the following line triggers the exception         EigenDecomposition decomposition =             new EigenDecompositionImpl(mainTridiagonal secondaryTridiagonal MathUtils.SAFE_MIN);          double eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i)              assertEquals(refEigenValuesi eigenValuesi 1.0e-3);             if (refEigenVectorsi.dotProduct(decomposition.getEigenvector(i)) < 0)                  assertEquals(0 refEigenVectorsi.add(decomposition.getEigenvector(i)).getNorm() 1.0e-5);              else                  assertEquals(0 refEigenVectorsi.subtract(decomposition.getEigenvector(i)).getNorm() 1.0e-5);                            ", "A_clean_title": ["wrong", "result", "eigen", "decompositionsom", "decomposit", "some", "result", "comput", "by", "eigendecompositionimpl", "eigen", "decomposit", "impl", "are", "wrong", "follow", "case", "comput", "by", "fortran", "lapack", "fail", "version", "public", "void", "testmathpbx02", "test", "mathpbx02", "doubl", "maintridiagon", "main", "tridiagon", "7484", "860960227216", "18405", "28129035345", "13855", "225609560746", "10016", "708722343366", "559", "8117399576674", "6750", "190788301587", "71", "21428769782159", "doubl", "secondarytridiagon", "secondari", "tridiagon", "4175", "0885704763661975", "79558582419945193", "178422374075", "1995", "28665916917975", "34535882933804", "234", "0808002076056", "refer", "valu", "have", "been", "comput", "routin", "dstemr", "fortran", "librari", "lapack", "version", "doubl", "refeigenvalu", "ref", "eigen", "valu", "20654", "74489030697441216828", "208208485466457", "6893", "1559126349948206757", "083016675340332", "5887", "79988568855878864", "309089923240379", "57", "992628792736340", "realvector", "real", "vector", "refeigenvector", "ref", "eigen", "vector", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "270356342026904", "852811091326997", "399639490702077", "198794657813990", "019739323307666", "000106983022327", "000001216636321", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "179995273578326", "4028078481530420", "7018709935257340", "5550582110148880", "0680791488982360", "000509139115227", "000007112235617", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "399582721284727", "056629954519333", "5144064885228270", "7111681645185800", "2255480812763670", "125943999652923", "004321507456014", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "0585157215728210", "0102001300577390", "063516274916536", "090696087449378", "0171484204325970", "991318870265707", "034707338554096", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "8552059955375640", "327134656629775", "2653823970605480", "2826907290267060", "105736068025572", "0091381266220390", "000367751821196", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "002913069901144", "0051775157771010", "041906334478672", "1093159184162580", "4361923054567410", "0263073156395350", "891797507436344", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "005738311176435", "0102076116703780", "082662420517928", "2157338860943680", "861606487840411", "025478530652759", "451080697503958", "follow", "line", "trigger", "except", "eigendecomposit", "eigen", "decomposit", "decomposit", "new", "eigendecompositionimpl", "eigen", "decomposit", "impl", "maintridiagon", "main", "tridiagon", "secondarytridiagon", "secondari", "tridiagon", "mathutil", "math", "util", "safe", "min", "doubl", "eigenvalu", "eigen", "valu", "decomposit", "getrealeigenvalu", "get", "real", "eigenvalu", "int", "refeigenvalu", "length", "ref", "eigen", "valu", "++i", "assertequ", "assert", "equal", "refeigenvaluesi", "ref", "eigen", "valuesi", "eigenvaluesi", "eigen", "valuesi", "0e", "refeigenvectorsi", "dotproduct", "ref", "eigen", "vectorsi", "dot", "product", "decomposit", "geteigenvector", "get", "eigenvector", "assertequ", "assert", "equal", "refeigenvectorsi", "add", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "assertequ", "assert", "equal", "refeigenvectorsi", "subtract", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e"], "B_title": "Fixed a bug in EigenDecompositionImpl . flipIfWarranted ( ) .. ", "B_clean_title": ["fix", "bug", "eigendecompositionimpl", "eigen", "decomposit", "impl", "flipifwarr", "flip", "warrant"]},
{"A_title": "wrong result in eigen decompositionSome results computed by EigenDecompositionImpl are wrong. The following case computed by Fortran Lapack fails with version 2.0      public void testMathpbx02()           double mainTridiagonal =            7484.860960227216 18405.28129035345 13855.225609560746          10016.708722343366 559.8117399576674 6750.190788301587              71.21428769782159         ;         double secondaryTridiagonal =           -4175.0885704763661975.79558582419945193.178422374075            1995.28665916917975.34535882933804-234.0808002076056         ;          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double refEigenValues =          20654.74489030697441216828.208208485466457         6893.1559126349948206757.083016675340332         5887.79988568855878864.309089923240379         57.992628792736340         ;         RealVector refEigenVectors =          new ArrayRealVector(new double -0.270356342026904 0.852811091326997 0.399639490702077 0.198794657813990 0.019739323307666 0.000106983022327 -0.000001216636321)         new ArrayRealVector(new double 0.179995273578326-0.4028078481530420.7018709935257340.5550582110148880.0680791488982360.000509139115227-0.000007112235617)         new ArrayRealVector(new double -0.399582721284727-0.056629954519333-0.5144064885228270.7111681645185800.2255480812763670.125943999652923-0.004321507456014)         new ArrayRealVector(new double 0.0585157215728210.0102001300577390.063516274916536-0.090696087449378-0.0171484204325970.991318870265707-0.034707338554096)         new ArrayRealVector(new double 0.8552059955375640.327134656629775-0.2653823970605480.2826907290267060.105736068025572-0.0091381266220390.000367751821196)         new ArrayRealVector(new double -0.002913069901144-0.0051775157771010.041906334478672-0.1093159184162580.4361923054567410.0263073156395350.891797507436344)         new ArrayRealVector(new double -0.005738311176435-0.0102076116703780.082662420517928-0.2157338860943680.861606487840411-0.025478530652759-0.451080697503958)         ;          // the following line triggers the exception         EigenDecomposition decomposition =             new EigenDecompositionImpl(mainTridiagonal secondaryTridiagonal MathUtils.SAFE_MIN);          double eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i)              assertEquals(refEigenValuesi eigenValuesi 1.0e-3);             if (refEigenVectorsi.dotProduct(decomposition.getEigenvector(i)) < 0)                  assertEquals(0 refEigenVectorsi.add(decomposition.getEigenvector(i)).getNorm() 1.0e-5);              else                  assertEquals(0 refEigenVectorsi.subtract(decomposition.getEigenvector(i)).getNorm() 1.0e-5);                            ", "A_clean_title": ["wrong", "result", "eigen", "decompositionsom", "decomposit", "some", "result", "comput", "by", "eigendecompositionimpl", "eigen", "decomposit", "impl", "are", "wrong", "follow", "case", "comput", "by", "fortran", "lapack", "fail", "version", "public", "void", "testmathpbx02", "test", "mathpbx02", "doubl", "maintridiagon", "main", "tridiagon", "7484", "860960227216", "18405", "28129035345", "13855", "225609560746", "10016", "708722343366", "559", "8117399576674", "6750", "190788301587", "71", "21428769782159", "doubl", "secondarytridiagon", "secondari", "tridiagon", "4175", "0885704763661975", "79558582419945193", "178422374075", "1995", "28665916917975", "34535882933804", "234", "0808002076056", "refer", "valu", "have", "been", "comput", "routin", "dstemr", "fortran", "librari", "lapack", "version", "doubl", "refeigenvalu", "ref", "eigen", "valu", "20654", "74489030697441216828", "208208485466457", "6893", "1559126349948206757", "083016675340332", "5887", "79988568855878864", "309089923240379", "57", "992628792736340", "realvector", "real", "vector", "refeigenvector", "ref", "eigen", "vector", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "270356342026904", "852811091326997", "399639490702077", "198794657813990", "019739323307666", "000106983022327", "000001216636321", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "179995273578326", "4028078481530420", "7018709935257340", "5550582110148880", "0680791488982360", "000509139115227", "000007112235617", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "399582721284727", "056629954519333", "5144064885228270", "7111681645185800", "2255480812763670", "125943999652923", "004321507456014", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "0585157215728210", "0102001300577390", "063516274916536", "090696087449378", "0171484204325970", "991318870265707", "034707338554096", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "8552059955375640", "327134656629775", "2653823970605480", "2826907290267060", "105736068025572", "0091381266220390", "000367751821196", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "002913069901144", "0051775157771010", "041906334478672", "1093159184162580", "4361923054567410", "0263073156395350", "891797507436344", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "005738311176435", "0102076116703780", "082662420517928", "2157338860943680", "861606487840411", "025478530652759", "451080697503958", "follow", "line", "trigger", "except", "eigendecomposit", "eigen", "decomposit", "decomposit", "new", "eigendecompositionimpl", "eigen", "decomposit", "impl", "maintridiagon", "main", "tridiagon", "secondarytridiagon", "secondari", "tridiagon", "mathutil", "math", "util", "safe", "min", "doubl", "eigenvalu", "eigen", "valu", "decomposit", "getrealeigenvalu", "get", "real", "eigenvalu", "int", "refeigenvalu", "length", "ref", "eigen", "valu", "++i", "assertequ", "assert", "equal", "refeigenvaluesi", "ref", "eigen", "valuesi", "eigenvaluesi", "eigen", "valuesi", "0e", "refeigenvectorsi", "dotproduct", "ref", "eigen", "vectorsi", "dot", "product", "decomposit", "geteigenvector", "get", "eigenvector", "assertequ", "assert", "equal", "refeigenvectorsi", "add", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "assertequ", "assert", "equal", "refeigenvectorsi", "subtract", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e"], "B_title": "Fixed a bug in EigenDecompositionImpl . flipIfWarranted ( ) .. ", "B_clean_title": ["fix", "bug", "eigendecompositionimpl", "eigen", "decomposit", "impl", "flipifwarr", "flip", "warrant"]},
{"A_title": "wrong result in eigen decompositionSome results computed by EigenDecompositionImpl are wrong. The following case computed by Fortran Lapack fails with version 2.0      public void testMathpbx02()           double mainTridiagonal =            7484.860960227216 18405.28129035345 13855.225609560746          10016.708722343366 559.8117399576674 6750.190788301587              71.21428769782159         ;         double secondaryTridiagonal =           -4175.0885704763661975.79558582419945193.178422374075            1995.28665916917975.34535882933804-234.0808002076056         ;          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double refEigenValues =          20654.74489030697441216828.208208485466457         6893.1559126349948206757.083016675340332         5887.79988568855878864.309089923240379         57.992628792736340         ;         RealVector refEigenVectors =          new ArrayRealVector(new double -0.270356342026904 0.852811091326997 0.399639490702077 0.198794657813990 0.019739323307666 0.000106983022327 -0.000001216636321)         new ArrayRealVector(new double 0.179995273578326-0.4028078481530420.7018709935257340.5550582110148880.0680791488982360.000509139115227-0.000007112235617)         new ArrayRealVector(new double -0.399582721284727-0.056629954519333-0.5144064885228270.7111681645185800.2255480812763670.125943999652923-0.004321507456014)         new ArrayRealVector(new double 0.0585157215728210.0102001300577390.063516274916536-0.090696087449378-0.0171484204325970.991318870265707-0.034707338554096)         new ArrayRealVector(new double 0.8552059955375640.327134656629775-0.2653823970605480.2826907290267060.105736068025572-0.0091381266220390.000367751821196)         new ArrayRealVector(new double -0.002913069901144-0.0051775157771010.041906334478672-0.1093159184162580.4361923054567410.0263073156395350.891797507436344)         new ArrayRealVector(new double -0.005738311176435-0.0102076116703780.082662420517928-0.2157338860943680.861606487840411-0.025478530652759-0.451080697503958)         ;          // the following line triggers the exception         EigenDecomposition decomposition =             new EigenDecompositionImpl(mainTridiagonal secondaryTridiagonal MathUtils.SAFE_MIN);          double eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i)              assertEquals(refEigenValuesi eigenValuesi 1.0e-3);             if (refEigenVectorsi.dotProduct(decomposition.getEigenvector(i)) < 0)                  assertEquals(0 refEigenVectorsi.add(decomposition.getEigenvector(i)).getNorm() 1.0e-5);              else                  assertEquals(0 refEigenVectorsi.subtract(decomposition.getEigenvector(i)).getNorm() 1.0e-5);                            ", "A_clean_title": ["wrong", "result", "eigen", "decompositionsom", "decomposit", "some", "result", "comput", "by", "eigendecompositionimpl", "eigen", "decomposit", "impl", "are", "wrong", "follow", "case", "comput", "by", "fortran", "lapack", "fail", "version", "public", "void", "testmathpbx02", "test", "mathpbx02", "doubl", "maintridiagon", "main", "tridiagon", "7484", "860960227216", "18405", "28129035345", "13855", "225609560746", "10016", "708722343366", "559", "8117399576674", "6750", "190788301587", "71", "21428769782159", "doubl", "secondarytridiagon", "secondari", "tridiagon", "4175", "0885704763661975", "79558582419945193", "178422374075", "1995", "28665916917975", "34535882933804", "234", "0808002076056", "refer", "valu", "have", "been", "comput", "routin", "dstemr", "fortran", "librari", "lapack", "version", "doubl", "refeigenvalu", "ref", "eigen", "valu", "20654", "74489030697441216828", "208208485466457", "6893", "1559126349948206757", "083016675340332", "5887", "79988568855878864", "309089923240379", "57", "992628792736340", "realvector", "real", "vector", "refeigenvector", "ref", "eigen", "vector", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "270356342026904", "852811091326997", "399639490702077", "198794657813990", "019739323307666", "000106983022327", "000001216636321", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "179995273578326", "4028078481530420", "7018709935257340", "5550582110148880", "0680791488982360", "000509139115227", "000007112235617", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "399582721284727", "056629954519333", "5144064885228270", "7111681645185800", "2255480812763670", "125943999652923", "004321507456014", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "0585157215728210", "0102001300577390", "063516274916536", "090696087449378", "0171484204325970", "991318870265707", "034707338554096", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "8552059955375640", "327134656629775", "2653823970605480", "2826907290267060", "105736068025572", "0091381266220390", "000367751821196", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "002913069901144", "0051775157771010", "041906334478672", "1093159184162580", "4361923054567410", "0263073156395350", "891797507436344", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "005738311176435", "0102076116703780", "082662420517928", "2157338860943680", "861606487840411", "025478530652759", "451080697503958", "follow", "line", "trigger", "except", "eigendecomposit", "eigen", "decomposit", "decomposit", "new", "eigendecompositionimpl", "eigen", "decomposit", "impl", "maintridiagon", "main", "tridiagon", "secondarytridiagon", "secondari", "tridiagon", "mathutil", "math", "util", "safe", "min", "doubl", "eigenvalu", "eigen", "valu", "decomposit", "getrealeigenvalu", "get", "real", "eigenvalu", "int", "refeigenvalu", "length", "ref", "eigen", "valu", "++i", "assertequ", "assert", "equal", "refeigenvaluesi", "ref", "eigen", "valuesi", "eigenvaluesi", "eigen", "valuesi", "0e", "refeigenvectorsi", "dotproduct", "ref", "eigen", "vectorsi", "dot", "product", "decomposit", "geteigenvector", "get", "eigenvector", "assertequ", "assert", "equal", "refeigenvectorsi", "add", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "assertequ", "assert", "equal", "refeigenvectorsi", "subtract", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e"], "B_title": "Fixed a bug in EigenDecompositionImpl . java. ", "B_clean_title": ["fix", "bug", "eigendecompositionimpl", "eigen", "decomposit", "impl", "java"]},
{"A_title": "wrong result in eigen decompositionSome results computed by EigenDecompositionImpl are wrong. The following case computed by Fortran Lapack fails with version 2.0      public void testMathpbx02()           double mainTridiagonal =            7484.860960227216 18405.28129035345 13855.225609560746          10016.708722343366 559.8117399576674 6750.190788301587              71.21428769782159         ;         double secondaryTridiagonal =           -4175.0885704763661975.79558582419945193.178422374075            1995.28665916917975.34535882933804-234.0808002076056         ;          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double refEigenValues =          20654.74489030697441216828.208208485466457         6893.1559126349948206757.083016675340332         5887.79988568855878864.309089923240379         57.992628792736340         ;         RealVector refEigenVectors =          new ArrayRealVector(new double -0.270356342026904 0.852811091326997 0.399639490702077 0.198794657813990 0.019739323307666 0.000106983022327 -0.000001216636321)         new ArrayRealVector(new double 0.179995273578326-0.4028078481530420.7018709935257340.5550582110148880.0680791488982360.000509139115227-0.000007112235617)         new ArrayRealVector(new double -0.399582721284727-0.056629954519333-0.5144064885228270.7111681645185800.2255480812763670.125943999652923-0.004321507456014)         new ArrayRealVector(new double 0.0585157215728210.0102001300577390.063516274916536-0.090696087449378-0.0171484204325970.991318870265707-0.034707338554096)         new ArrayRealVector(new double 0.8552059955375640.327134656629775-0.2653823970605480.2826907290267060.105736068025572-0.0091381266220390.000367751821196)         new ArrayRealVector(new double -0.002913069901144-0.0051775157771010.041906334478672-0.1093159184162580.4361923054567410.0263073156395350.891797507436344)         new ArrayRealVector(new double -0.005738311176435-0.0102076116703780.082662420517928-0.2157338860943680.861606487840411-0.025478530652759-0.451080697503958)         ;          // the following line triggers the exception         EigenDecomposition decomposition =             new EigenDecompositionImpl(mainTridiagonal secondaryTridiagonal MathUtils.SAFE_MIN);          double eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i)              assertEquals(refEigenValuesi eigenValuesi 1.0e-3);             if (refEigenVectorsi.dotProduct(decomposition.getEigenvector(i)) < 0)                  assertEquals(0 refEigenVectorsi.add(decomposition.getEigenvector(i)).getNorm() 1.0e-5);              else                  assertEquals(0 refEigenVectorsi.subtract(decomposition.getEigenvector(i)).getNorm() 1.0e-5);                            ", "A_clean_title": ["wrong", "result", "eigen", "decompositionsom", "decomposit", "some", "result", "comput", "by", "eigendecompositionimpl", "eigen", "decomposit", "impl", "are", "wrong", "follow", "case", "comput", "by", "fortran", "lapack", "fail", "version", "public", "void", "testmathpbx02", "test", "mathpbx02", "doubl", "maintridiagon", "main", "tridiagon", "7484", "860960227216", "18405", "28129035345", "13855", "225609560746", "10016", "708722343366", "559", "8117399576674", "6750", "190788301587", "71", "21428769782159", "doubl", "secondarytridiagon", "secondari", "tridiagon", "4175", "0885704763661975", "79558582419945193", "178422374075", "1995", "28665916917975", "34535882933804", "234", "0808002076056", "refer", "valu", "have", "been", "comput", "routin", "dstemr", "fortran", "librari", "lapack", "version", "doubl", "refeigenvalu", "ref", "eigen", "valu", "20654", "74489030697441216828", "208208485466457", "6893", "1559126349948206757", "083016675340332", "5887", "79988568855878864", "309089923240379", "57", "992628792736340", "realvector", "real", "vector", "refeigenvector", "ref", "eigen", "vector", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "270356342026904", "852811091326997", "399639490702077", "198794657813990", "019739323307666", "000106983022327", "000001216636321", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "179995273578326", "4028078481530420", "7018709935257340", "5550582110148880", "0680791488982360", "000509139115227", "000007112235617", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "399582721284727", "056629954519333", "5144064885228270", "7111681645185800", "2255480812763670", "125943999652923", "004321507456014", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "0585157215728210", "0102001300577390", "063516274916536", "090696087449378", "0171484204325970", "991318870265707", "034707338554096", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "8552059955375640", "327134656629775", "2653823970605480", "2826907290267060", "105736068025572", "0091381266220390", "000367751821196", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "002913069901144", "0051775157771010", "041906334478672", "1093159184162580", "4361923054567410", "0263073156395350", "891797507436344", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "005738311176435", "0102076116703780", "082662420517928", "2157338860943680", "861606487840411", "025478530652759", "451080697503958", "follow", "line", "trigger", "except", "eigendecomposit", "eigen", "decomposit", "decomposit", "new", "eigendecompositionimpl", "eigen", "decomposit", "impl", "maintridiagon", "main", "tridiagon", "secondarytridiagon", "secondari", "tridiagon", "mathutil", "math", "util", "safe", "min", "doubl", "eigenvalu", "eigen", "valu", "decomposit", "getrealeigenvalu", "get", "real", "eigenvalu", "int", "refeigenvalu", "length", "ref", "eigen", "valu", "++i", "assertequ", "assert", "equal", "refeigenvaluesi", "ref", "eigen", "valuesi", "eigenvaluesi", "eigen", "valuesi", "0e", "refeigenvectorsi", "dotproduct", "ref", "eigen", "vectorsi", "dot", "product", "decomposit", "geteigenvector", "get", "eigenvector", "assertequ", "assert", "equal", "refeigenvectorsi", "add", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "assertequ", "assert", "equal", "refeigenvectorsi", "subtract", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e"], "B_title": "Fixed a bug in EigenDecompositionImpl . java. ", "B_clean_title": ["fix", "bug", "eigendecompositionimpl", "eigen", "decomposit", "impl", "java"]},
{"A_title": "BSPTree class and recovery of a Euclidean 3D BRepNew to the work here. Thanks for your efforts on this code. I create a BSPTree from a BoundaryRep (Brep) my test Brep is a cube as represented by a float array containing 8 3D points in(xyz) order and an array of indices (12 triplets for the 12 faces of the cube). I construct a BSPMesh() as shown in the code below. I can construct the PolyhedronsSet() but have problems extracting the faces from the BSPTree to reconstruct the BRep. The attached code (BSPMesh2.java) shows that a small change to 1 of the vertex positions causes/corrects the problem. Any ideas?", "A_clean_title": ["bsptree", "bsp", "tree", "class", "recoveri", "euclidean", "3d", "brepnew", "rep", "new", "work", "here", "thank", "your", "effort", "thi", "code", "creat", "bsptree", "bsp", "tree", "boundaryrep", "boundari", "rep", "brep", "my", "test", "brep", "cube", "as", "repres", "by", "float", "array", "contain", "3d", "point", "xyz", "order", "array", "indic", "12", "triplet", "12", "face", "cube", "construct", "bspmesh", "bsp", "mesh", "as", "shown", "code", "below", "construct", "polyhedronsset", "polyhedron", "set", "but", "have", "problem", "extract", "face", "bsptree", "bsp", "tree", "reconstruct", "brep", "rep", "attach", "code", "bspmesh2", "java", "bsp", "mesh2", "show", "that", "small", "chang", "vertex", "posit", "caus", "correct", "problem", "ani", "idea"], "B_title": "removed debug code. ", "B_clean_title": ["remov", "debug", "code"]},
{"A_title": "FastDateParser does not handle white-space properlyThe SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properlyth", "properli", "simpledateformat", "simpl", "date", "format", "javadoc", "not", "treat", "white", "space", "special", "howev", "fastdatepars", "fast", "date", "parser", "treat", "singl", "white", "space", "as", "be", "ani", "number", "white", "space", "charact", "thi", "mean", "that", "fdp", "will", "pars", "date", "that", "fail", "when", "pars", "by", "sdp"], "B_title": "I don  t really see a justification for doing a whitespace in a string ( changed by the. ", "B_clean_title": ["don", "realli", "see", "justif", "do", "whitespac", "string", "chang", "by"]},
{"A_title": "FastDateParser does not handle white-space properlyThe SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properlyth", "properli", "simpledateformat", "simpl", "date", "format", "javadoc", "not", "treat", "white", "space", "special", "howev", "fastdatepars", "fast", "date", "parser", "treat", "singl", "white", "space", "as", "be", "ani", "number", "white", "space", "charact", "thi", "mean", "that", "fdp", "will", "pars", "date", "that", "fail", "when", "pars", "by", "sdp"], "B_title": "Remove redundant check. ", "B_clean_title": ["remov", "redund", "check"]},
{"A_title": "FastDateParser does not handle white-space properlyThe SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properlyth", "properli", "simpledateformat", "simpl", "date", "format", "javadoc", "not", "treat", "white", "space", "special", "howev", "fastdatepars", "fast", "date", "parser", "treat", "singl", "white", "space", "as", "be", "ani", "number", "white", "space", "charact", "thi", "mean", "that", "fdp", "will", "pars", "date", "that", "fail", "when", "pars", "by", "sdp"], "B_title": "FastDateParser ignores white space. ", "B_clean_title": ["fastdatepars", "fast", "date", "parser", "ignor", "white", "space"]},
{"A_title": "FastDateParser does not handle white-space properlyThe SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properlyth", "properli", "simpledateformat", "simpl", "date", "format", "javadoc", "not", "treat", "white", "space", "special", "howev", "fastdatepars", "fast", "date", "parser", "treat", "singl", "white", "space", "as", "be", "ani", "number", "white", "space", "charact", "thi", "mean", "that", "fdp", "will", "pars", "date", "that", "fail", "when", "pars", "by", "sdp"], "B_title": "FastDateParser copy ( ) didn  t ignore whitespace in date parsing. ", "B_clean_title": ["fastdatepars", "fast", "date", "parser", "copi", "didn", "ignor", "whitespac", "date", "pars"]},
{"A_title": "FastDateParser does not handle white-space properlyThe SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properlyth", "properli", "simpledateformat", "simpl", "date", "format", "javadoc", "not", "treat", "white", "space", "special", "howev", "fastdatepars", "fast", "date", "parser", "treat", "singl", "white", "space", "as", "be", "ani", "number", "white", "space", "charact", "thi", "mean", "that", "fdp", "will", "pars", "date", "that", "fail", "when", "pars", "by", "sdp"], "B_title": "don  t backslash backslash in regex so it won  t be backslashed. ", "B_clean_title": ["don", "backslash", "backslash", "regex", "so", "it", "won", "backslash"]},
{"A_title": "FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() wont changeThe FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null then it is not made part of the key but the stored object is created using the current default locale. If the Locale is changed subsequently then the wrong locale is applied. Patch for test case to follow.", "A_clean_title": ["fastdateformat", "fast", "date", "format", "getdateinst", "get", "date", "instanc", "getdatetimeinst", "get", "date", "time", "instanc", "assum", "local", "getdefault", "get", "default", "wont", "changeth", "chang", "fastdateformat", "fast", "date", "format", "getdateinst", "get", "date", "instanc", "getdatetimeinst", "get", "date", "time", "instanc", "method", "creat", "hashmap", "hash", "map", "key", "variou", "item", "includ", "local", "local", "null", "then", "it", "not", "made", "part", "key", "but", "store", "object", "creat", "current", "default", "local", "local", "chang", "subsequ", "then", "wrong", "local", "appli", "patch", "test", "case", "follow"], "B_title": "Fix FastDateFormat  s key value if locale is not null. Fix getLocaleKey exception in FastDateFormat. ", "B_clean_title": ["fix", "fastdateformat", "fast", "date", "format", "key", "valu", "local", "not", "null", "fix", "getlocalekey", "get", "local", "key", "except", "fastdateformat", "fast", "date", "format"]},
{"A_title": "NPE in  KMeansPlusPlusClusterer unittestWhen running this unittest I am facing this NPE: java.lang.NullPointerException at org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.assignPointsToClusters(KMeansPlusPlusClusterer.java:91) This is the unittest: package org.fao.fisheries.chronicles.calcuation.cluster; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import java.util.Arrays; import java.util.List; import java.util.Random; import org.apache.commons.math.stat.clustering.Cluster; import org.apache.commons.math.stat.clustering.EuclideanIntegerPoint; import org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer; import org.fao.fisheries.chronicles.input.CsvImportProcess; import org.fao.fisheries.chronicles.input.Top200Csv; import org.junit.Test; public class ClusterAnalysisTest  @Test public void testPerformClusterAnalysis2()  KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>( new Random(1746432956321l)); EuclideanIntegerPoint points = new EuclideanIntegerPoint  new EuclideanIntegerPoint(new int   1959 325100  ) new EuclideanIntegerPoint(new int   1960 373200  ) ; List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points) 1 1); assertEquals(1 clusters.size());  ", "A_clean_title": ["npe", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "unittestwhen", "unittest", "when", "run", "thi", "unittest", "am", "face", "thi", "npe", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math", "stat", "cluster", "kmeanspluspluscluster", "assignpointstoclust", "mean", "plu", "plu", "cluster", "assign", "point", "cluster", "kmeanspluspluscluster", "java:91", "mean", "plu", "plu", "cluster", "thi", "unittest", "packag", "org", "fao", "fisheri", "chronicl", "calcuat", "cluster", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "static", "org", "junit", "assert", "asserttru", "assert", "true", "import", "java", "util", "array", "import", "java", "util", "list", "import", "java", "util", "random", "import", "org", "apach", "common", "math", "stat", "cluster", "cluster", "import", "org", "apach", "common", "math", "stat", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "import", "org", "apach", "common", "math", "stat", "cluster", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "import", "org", "fao", "fisheri", "chronicl", "input", "csvimportprocess", "csv", "import", "process", "import", "org", "fao", "fisheri", "chronicl", "input", "top200csv", "import", "org", "junit", "test", "public", "class", "clusteranalysistest", "cluster", "analysi", "test", "test", "public", "void", "testperformclusteranalysis2", "test", "perform", "cluster", "analysis2", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "transform", "new", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "random", "1746432956321l", "euclideanintegerpoint", "euclidean", "integ", "point", "point", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "int", "1959", "325100", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "int", "1960", "373200", "list", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "cluster", "transform", "cluster", "array", "aslist", "as", "list", "point", "assertequ", "assert", "equal", "cluster", "size"], "B_title": "Fix MathUtils . distance ( )  reported by Marin Dzhigarov .. ", "B_clean_title": ["fix", "mathutil", "math", "util", "distanc", "report", "by", "marin", "dzhigarov"]},
{"A_title": "NPE in  KMeansPlusPlusClusterer unittestWhen running this unittest I am facing this NPE: java.lang.NullPointerException at org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.assignPointsToClusters(KMeansPlusPlusClusterer.java:91) This is the unittest: package org.fao.fisheries.chronicles.calcuation.cluster; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import java.util.Arrays; import java.util.List; import java.util.Random; import org.apache.commons.math.stat.clustering.Cluster; import org.apache.commons.math.stat.clustering.EuclideanIntegerPoint; import org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer; import org.fao.fisheries.chronicles.input.CsvImportProcess; import org.fao.fisheries.chronicles.input.Top200Csv; import org.junit.Test; public class ClusterAnalysisTest  @Test public void testPerformClusterAnalysis2()  KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>( new Random(1746432956321l)); EuclideanIntegerPoint points = new EuclideanIntegerPoint  new EuclideanIntegerPoint(new int   1959 325100  ) new EuclideanIntegerPoint(new int   1960 373200  ) ; List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points) 1 1); assertEquals(1 clusters.size());  ", "A_clean_title": ["npe", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "unittestwhen", "unittest", "when", "run", "thi", "unittest", "am", "face", "thi", "npe", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math", "stat", "cluster", "kmeanspluspluscluster", "assignpointstoclust", "mean", "plu", "plu", "cluster", "assign", "point", "cluster", "kmeanspluspluscluster", "java:91", "mean", "plu", "plu", "cluster", "thi", "unittest", "packag", "org", "fao", "fisheri", "chronicl", "calcuat", "cluster", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "static", "org", "junit", "assert", "asserttru", "assert", "true", "import", "java", "util", "array", "import", "java", "util", "list", "import", "java", "util", "random", "import", "org", "apach", "common", "math", "stat", "cluster", "cluster", "import", "org", "apach", "common", "math", "stat", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "import", "org", "apach", "common", "math", "stat", "cluster", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "import", "org", "fao", "fisheri", "chronicl", "input", "csvimportprocess", "csv", "import", "process", "import", "org", "fao", "fisheri", "chronicl", "input", "top200csv", "import", "org", "junit", "test", "public", "class", "clusteranalysistest", "cluster", "analysi", "test", "test", "public", "void", "testperformclusteranalysis2", "test", "perform", "cluster", "analysis2", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "transform", "new", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "random", "1746432956321l", "euclideanintegerpoint", "euclidean", "integ", "point", "point", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "int", "1959", "325100", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "int", "1960", "373200", "list", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "cluster", "transform", "cluster", "array", "aslist", "as", "list", "point", "assertequ", "assert", "equal", "cluster", "size"], "B_title": "removed int because it wasn  t working as expected. ", "B_clean_title": ["remov", "int", "becaus", "it", "wasn", "work", "as", "expect"]},
{"A_title": "NPE in DateTimeZoneBuilderWhen a DateTimeZone is build with duplicate-named recurring saving time in a first thread all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:", "A_clean_title": ["npe", "datetimezonebuilderwhen", "date", "time", "zone", "builder", "when", "datetimezon", "date", "time", "zone", "build", "duplic", "name", "recur", "save", "time", "first", "thread", "all", "goe", "ok", "warn", "messag", "gener", "identifi", "automat", "gener", "precalculatedzon", "creat", "precalcul", "zone", "when", "second", "thread", "same", "npe", "gener", "zoneinfocompil", "verbos", "zone", "info", "compil", "caus", "that", "cverbos", "verbos", "threadloc", "thread", "local", "incorrectli", "initi", "zoneinfocompil", "zone", "info", "compil", "will", "initi", "cverbos", "verbos", "onli", "first", "thread", "not", "subsequ", "one", "npe", "caus", "by", "autobox", "better", "approach", "could", "remov", "initi", "test", "null"], "B_title": "Stops verbose output. ", "B_clean_title": ["stop", "verbos", "output"]},
{"A_title": "bug in org.apache.wicket.validation.validator.UrlValidatorLooks like there is a bug in UrlValidator. It validates URLs like http://testhost.local/pages/index.php as invalid. But URL is valid! Try to execute new java.net.URL(http://testhost.local/pages/index.php); for example. It does not throws MalformedURLException because URL is valid.  In method: UrlValidator.isValidAuthority() there is code: if (topLevel.length() < 2 || topLevel.length() > 4)return false; Looks like this > 4 is a wrong constraint.", "A_clean_title": ["bug", "org", "apach", "wicket", "valid", "valid", "urlvalidatorlook", "url", "valid", "look", "like", "there", "bug", "urlvalid", "url", "valid", "it", "valid", "url", "ur", "ls", "like", "http", "php", "testhost", "local", "page", "index", "as", "invalid", "but", "url", "valid", "tri", "execut", "new", "java", "net", "url", "http", "php", "testhost", "local", "page", "index", "exampl", "it", "not", "throw", "malformedurlexcept", "malform", "url", "except", "becaus", "url", "valid", "method", "urlvalid", "isvalidauthor", "url", "valid", "valid", "author", "there", "code", "toplevel", "length", "top", "level", "toplevel", "length", "top", "level", "return", "fals", "look", "like", "thi", "wrong", "constraint"], "B_title": "allow longer authorities in the url such as local Issue: WICKET-4255", "B_clean_title": ["allow", "longer", "author", "url", "such", "as", "local", "issu", "wicket", "4255"]},
{"A_title": "Ordered index does not return relative properties for un-restricted indexesEven if we specify an index without any restriction to node type; the ordered index does not return any result for relative properties", "A_clean_title": ["order", "index", "not", "return", "rel", "properti", "un", "restrict", "indexeseven", "index", "even", "we", "specifi", "index", "without", "ani", "restrict", "node", "type", "order", "index", "not", "return", "ani", "result", "rel", "properti"], "B_title": "- Ordered index does not return relative properties for un-restricted indexes", "B_clean_title": ["order", "index", "not", "return", "rel", "properti", "un", "restrict", "index"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fixed a missing bracketing check of initial interval in Brent solver JIRA: MATH-343", "B_clean_title": ["fix", "miss", "bracket", "check", "initi", "interv", "brent", "solver", "jira", "math", "343"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "fixed a bracketing issue due to inconsistent checks JIRA: MATH-280", "B_clean_title": ["fix", "bracket", "issu", "due", "inconsist", "check", "jira", "math", "280"]},
{"A_title": "Incorrect URL for setResponsePage() within a Form#onSubmit( )If the WebApplication uses IRequestCycleSettings.RenderStrategy.ONE_PASS_RENDER the issue described and exemplified in the attached quickstart at  https://issues.apache.org/jira/browse/WICKET-3442  prevails.   Clicking the link on /pageone results in this URL: /pageone?0-1.IFormSubmitListener-form", "A_clean_title": ["incorrect", "url", "setresponsepag", "set", "respons", "page", "within", "form", "onsubmit", "submit", "webappl", "web", "applic", "use", "irequestcycleset", "renderstrategi", "request", "cycl", "set", "render", "strategi", "one", "pass", "render", "issu", "describ", "exemplifi", "attach", "quickstart", "at", "http", "3442", "apach", "issu", "org", "jira", "brows", "wicket", "prevail", "click", "link", "pageon", "result", "thi", "url", "pageon", "form", "iformsubmitlisten", "form", "submit", "listen"], "B_title": "Incorrect URL for setResponsePage() within a Form#onSubmit( )", "B_clean_title": ["incorrect", "url", "setresponsepag", "set", "respons", "page", "within", "form", "onsubmit", "submit"]},
{"A_title": "MathRuntimeException with simple ebeMultiply on OpenMapRealVectorThe following piece of code  import org.apache.commons.math.linear.OpenMapRealVector; import org.apache.commons.math.linear.RealVector;  public class DemoBugOpenMapRealVector      public static void main(String args)          final RealVector u = new OpenMapRealVector(3 1E-6);         u.setEntry(0 1.);         u.setEntry(1 0.);         u.setEntry(2 2.);         final RealVector v = new OpenMapRealVector(3 1E-6);         v.setEntry(0 0.);         v.setEntry(1 3.);         v.setEntry(2 0.);         System.out.println(u);         System.out.println(v);         System.out.println(u.ebeMultiply(v));         raises an exception  org.apache.commons.math.linear.OpenMapRealVector@7170a9b6 Exception in thread main org.apache.commons.math.MathRuntimeException 6: map has been modified while iterating at org.apache.commons.math.MathRuntimeException.createConcurrentModificationException(MathRuntimeException.java:373) at org.apache.commons.math.util.OpenIntToDoubleHashMap Iterator.advance(OpenIntToDoubleHashMap.java:564) at org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:372) at org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:1) at DemoBugOpenMapRealVector.main(DemoBugOpenMapRealVector.java:17)", "A_clean_title": ["mathruntimeexcept", "math", "runtim", "except", "simpl", "ebemultipli", "ebe", "multipli", "openmaprealvectorth", "open", "map", "real", "vector", "follow", "piec", "code", "import", "org", "apach", "common", "math", "linear", "openmaprealvector", "open", "map", "real", "vector", "import", "org", "apach", "common", "math", "linear", "realvector", "real", "vector", "public", "class", "demobugopenmaprealvector", "demo", "bug", "open", "map", "real", "vector", "public", "static", "void", "main", "string", "arg", "final", "realvector", "real", "vector", "new", "openmaprealvector", "open", "map", "real", "vector", "1e", "setentri", "set", "entri", "setentri", "set", "entri", "setentri", "set", "entri", "final", "realvector", "real", "vector", "new", "openmaprealvector", "open", "map", "real", "vector", "1e", "setentri", "set", "entri", "setentri", "set", "entri", "setentri", "set", "entri", "system", "out", "println", "system", "out", "println", "system", "out", "println", "ebemultipli", "ebe", "multipli", "rais", "except", "org", "apach", "common", "math", "linear", "openmaprealvector", "open", "map", "real", "vector", "7170a9b6", "except", "thread", "main", "org", "apach", "common", "math", "mathruntimeexcept", "math", "runtim", "except", "map", "ha", "been", "modifi", "while", "iter", "at", "org", "apach", "common", "math", "mathruntimeexcept", "createconcurrentmodificationexcept", "math", "runtim", "except", "creat", "concurr", "modif", "except", "mathruntimeexcept", "java:373", "math", "runtim", "except", "at", "org", "apach", "common", "math", "util", "openinttodoublehashmap", "open", "int", "doubl", "hash", "map", "iter", "advanc", "openinttodoublehashmap", "java:564", "open", "int", "doubl", "hash", "map", "at", "org", "apach", "common", "math", "linear", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "openmaprealvector", "java:372", "open", "map", "real", "vector", "at", "org", "apach", "common", "math", "linear", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "openmaprealvector", "java:1", "open", "map", "real", "vector", "at", "demobugopenmaprealvector", "main", "demo", "bug", "open", "map", "real", "vector", "demobugopenmaprealvector", "java:17", "demo", "bug", "open", "map", "real", "vector"], "B_title": "Iterate on the original vector not on the copy that is modified.", "B_clean_title": ["iter", "origin", "vector", "not", "copi", "that", "modifi"]},
{"A_title": "wicketTester.executeAjaxEvent(combo onchange); works with 1.4-rc1 but not anymore with 1.4-rc2Try the attached Unit Test.", "A_clean_title": ["wickettest", "executeajaxev", "wicket", "tester", "execut", "ajax", "event", "combo", "onchang", "work", "rc1", "but", "not", "anymor", "rc2tri", "attach", "unit", "test"], "B_title": "fixed and added test case: wicketTester.executeAjaxEvent(combo onchange); works with 1.4-rc1 but not anymore with 1.4-rc2 Issue: WICKET-2261", "B_clean_title": ["fix", "ad", "test", "case", "wickettest", "executeajaxev", "wicket", "tester", "execut", "ajax", "event", "combo", "onchang", "work", "rc1", "but", "not", "anymor", "rc2", "issu", "wicket", "2261"]},
{"A_title": "Context must read system properties to rewrite properties from file.Context must read system properties to rewrite properties from file.", "A_clean_title": ["context", "must", "read", "system", "properti", "rewrit", "properti", "file", "context", "must", "read", "system", "properti", "rewrit", "properti", "file"], "B_title": "Context must read system properties to rewrite properties from file.  Close #58", "B_clean_title": ["context", "must", "read", "system", "properti", "rewrit", "properti", "file", "close", "58"]},
{"A_title": "Bugs in RealVector.ebeMultiply(RealVector) and ebeDivide(RealVector)OpenMapRealVector.ebeMultiply(RealVector) and OpenMapRealVector.ebeDivide(RealVector) return wrong values when one entry of the specified RealVector is nan or infinity. The bug is easy to understand. Here is the current implementation of ebeMultiply      public OpenMapRealVector ebeMultiply(RealVector v)          checkVectorDimensions(v.getDimension());         OpenMapRealVector res = new OpenMapRealVector(this);         Iterator iter = entries.iterator();         while (iter.hasNext())              iter.advance();             res.setEntry(iter.key() iter.value() * v.getEntry(iter.key()));                  return res;        The assumption is that for any double x x * 0d == 0d holds which is not true. The bug is easy enough to identify but more complex to solve. The only solution I can come up with is to loop through all entries of v (instead of those entries which correspond to non-zero entries of this). Im afraid about performance losses.", "A_clean_title": ["bug", "realvector", "ebemultipli", "real", "vector", "ebe", "multipli", "realvector", "real", "vector", "ebedivid", "ebe", "divid", "realvector", "real", "vector", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "realvector", "real", "vector", "openmaprealvector", "ebedivid", "open", "map", "real", "vector", "ebe", "divid", "realvector", "real", "vector", "return", "wrong", "valu", "when", "one", "entri", "specifi", "realvector", "real", "vector", "nan", "or", "infin", "bug", "easi", "understand", "here", "current", "implement", "ebemultipli", "ebe", "multipli", "public", "openmaprealvector", "open", "map", "real", "vector", "ebemultipli", "ebe", "multipli", "realvector", "real", "vector", "checkvectordimens", "check", "vector", "dimens", "getdimens", "get", "dimens", "openmaprealvector", "open", "map", "real", "vector", "re", "new", "openmaprealvector", "open", "map", "real", "vector", "thi", "iter", "iter", "entri", "iter", "while", "iter", "hasnext", "ha", "next", "iter", "advanc", "re", "setentri", "set", "entri", "iter", "key", "iter", "valu", "getentri", "get", "entri", "iter", "key", "return", "re", "assumpt", "that", "ani", "doubl", "0d", "0d", "hold", "which", "not", "true", "bug", "easi", "enough", "identifi", "but", "more", "complex", "solv", "onli", "solut", "come", "up", "loop", "through", "all", "entri", "instead", "those", "entri", "which", "correspond", "non", "zero", "entri", "thi", "im", "afraid", "about", "perform", "loss"], "B_title": "  - modified OpenMapRealVector.ebeMultiply() and ebeDivide() to handle special cases  0d * NaN 0d * Infinity 0d / 0d and 0d / NaN.   - added implementation of isNaN() and isInfinite() to SparseRealVectorTest.SparseRealVectorTestImpl in order to allow for testing of OpenMapRealVector.ebeMultiply() and ebeDivide() with mixed types.", "B_clean_title": ["modifi", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "ebedivid", "ebe", "divid", "handl", "special", "case", "0d", "nan", "na", "0d", "infin", "0d", "0d", "0d", "nan", "na", "ad", "implement", "isnan", "na", "isinfinit", "infinit", "sparserealvectortest", "sparserealvectortestimpl", "spars", "real", "vector", "test", "spars", "real", "vector", "test", "impl", "order", "allow", "test", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "ebedivid", "ebe", "divid", "mix", "type"]},
{"A_title": "Using an IValidator on an AjaxEditableLabel causes ClassCastExceptionAjaxEditableLabel<Integer> label = new AjaxEditableLabel<Integer>(label new PropertyModel<Integer>(this value)); form.add(label); label.setRequired(true); label.add(new RangeValidator<Integer>(1 10));  Using a RangeValidator<Integer> on an AjaxEditableLabel<Integer>  causes an ClassCastException after editing the label.   java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String  This can be avoided by setting the type explicit on the AjaxEditableLabel.  label.setType(Integer.class);  But this wasnt necessary in Wicket 1.4.19. In this version all works fine without setting the type explicit.  I found out that AbstractTextComponent.resolveType() is not able to get the type of the DefaultModel of the AjaxEditableLabel in Wicket 1.5.3.  I will attach two QuickStarts to demonstrate the bug. One with wicket 1.4.19 and the other with Wicket 1.5.3", "A_clean_title": ["ivalid", "valid", "ajaxeditablelabel", "ajax", "edit", "label", "caus", "classcastexceptionajaxeditablelabel", "class", "cast", "except", "ajax", "edit", "label", "integ", "label", "new", "ajaxeditablelabel", "ajax", "edit", "label", "integ", "label", "new", "propertymodel", "properti", "model", "integ", "thi", "valu", "form", "add", "label", "label", "setrequir", "set", "requir", "true", "label", "add", "new", "rangevalid", "rang", "valid", "integ", "10", "rangevalid", "rang", "valid", "integ", "ajaxeditablelabel", "ajax", "edit", "label", "integ", "caus", "classcastexcept", "class", "cast", "except", "after", "edit", "label", "java", "lang", "classcastexcept", "class", "cast", "except", "java", "lang", "integ", "not", "cast", "java", "lang", "string", "thi", "avoid", "by", "set", "type", "explicit", "ajaxeditablelabel", "ajax", "edit", "label", "label", "settyp", "set", "type", "integ", "class", "but", "thi", "wasnt", "necessari", "wicket", "19", "thi", "version", "all", "work", "fine", "without", "set", "type", "explicit", "found", "out", "that", "abstracttextcompon", "resolvetyp", "abstract", "text", "compon", "resolv", "type", "not", "abl", "get", "type", "defaultmodel", "default", "model", "ajaxeditablelabel", "ajax", "edit", "label", "wicket", "will", "attach", "two", "quickstart", "quick", "start", "demonstr", "bug", "one", "wicket", "19", "other", "wicket"], "B_title": "Preventing the AjaxEditableLabel from loose its model object type when initializing its editor component Issue: WICKET-4259", "B_clean_title": ["prevent", "ajaxeditablelabel", "ajax", "edit", "label", "loos", "it", "model", "object", "type", "when", "initi", "it", "editor", "compon", "issu", "wicket", "4259"]},
{"A_title": "NPE during syncAllExternalUsers in LdapIdentityProvider.createUserWhen executing the JMX method syncAllExternalUsers the following NPE has been encountered. This likely indicates that - for a particular user - there is no attribute uid:  code java.lang.NullPointerException at org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider.createUser(LdapIdentityProvider.java:667) at org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider.access 000(LdapIdentityProvider.java:88) at org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider 1.getNext(LdapIdentityProvider.java:281) at org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider 1.getNext(LdapIdentityProvider.java:273) at org.apache.jackrabbit.commons.iterator.AbstractLazyIterator.hasNext(AbstractLazyIterator.java:39) at org.apache.jackrabbit.oak.spi.security.authentication.external.impl.jmx.SyncMBeanImpl Delegatee.syncAllExternalUsers(SyncMBeanImpl.java:245) at org.apache.jackrabbit.oak.spi.security.authentication.external.impl.jmx.SyncMBeanImpl.syncAllExternalUsers(SyncMBeanImpl.java:426) code", "A_clean_title": ["npe", "dure", "syncallexternalus", "sync", "all", "extern", "user", "ldapidentityprovid", "createuserwhen", "ldap", "ident", "provid", "creat", "user", "when", "execut", "jmx", "method", "syncallexternalus", "sync", "all", "extern", "user", "follow", "npe", "ha", "been", "encount", "thi", "like", "indic", "that", "particular", "user", "there", "no", "attribut", "uid", "code", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "jackrabbit", "oak", "secur", "authent", "ldap", "impl", "ldapidentityprovid", "createus", "ldap", "ident", "provid", "creat", "user", "ldapidentityprovid", "java:667", "ldap", "ident", "provid", "at", "org", "apach", "jackrabbit", "oak", "secur", "authent", "ldap", "impl", "ldapidentityprovid", "access", "ldap", "ident", "provid", "000", "ldapidentityprovid", "java:88", "ldap", "ident", "provid", "at", "org", "apach", "jackrabbit", "oak", "secur", "authent", "ldap", "impl", "ldapidentityprovid", "ldap", "ident", "provid", "getnext", "get", "next", "ldapidentityprovid", "java:281", "ldap", "ident", "provid", "at", "org", "apach", "jackrabbit", "oak", "secur", "authent", "ldap", "impl", "ldapidentityprovid", "ldap", "ident", "provid", "getnext", "get", "next", "ldapidentityprovid", "java:273", "ldap", "ident", "provid", "at", "org", "apach", "jackrabbit", "common", "iter", "abstractlazyiter", "hasnext", "abstract", "lazi", "iter", "ha", "next", "abstractlazyiter", "java:39", "abstract", "lazi", "iter", "at", "org", "apach", "jackrabbit", "oak", "spi", "secur", "authent", "extern", "impl", "jmx", "syncmbeanimpl", "sync", "bean", "impl", "delegate", "syncallexternalus", "sync", "all", "extern", "user", "syncmbeanimpl", "java:245", "sync", "bean", "impl", "at", "org", "apach", "jackrabbit", "oak", "spi", "secur", "authent", "extern", "impl", "jmx", "syncmbeanimpl", "syncallexternalus", "sync", "bean", "impl", "sync", "all", "extern", "user", "syncmbeanimpl", "java:426", "sync", "bean", "impl", "code"], "B_title": "NPE during syncAllExternalUsers in LdapIdentityProvider.createUser", "B_clean_title": ["npe", "dure", "syncallexternalus", "sync", "all", "extern", "user", "ldapidentityprovid", "createus", "ldap", "ident", "provid", "creat", "user"]},
{"A_title": "NodeDocument.getNewestRevision() incorrect when there are previous documentsThe method may incorrectly return null when there are previous documents and the base revision is lower than all local changes.  This is most likely caused by changes done for OAK-3388.", "A_clean_title": ["nodedocu", "getnewestrevis", "node", "document", "get", "newest", "revis", "incorrect", "when", "there", "are", "previou", "documentsth", "document", "method", "may", "incorrectli", "return", "null", "when", "there", "are", "previou", "document", "base", "revis", "lower", "than", "all", "local", "chang", "thi", "most", "like", "caus", "by", "chang", "done", "oak", "3388"], "B_title": "NodeDocument.getNewestRevision() incorrect when there are previous documents", "B_clean_title": ["nodedocu", "getnewestrevis", "node", "document", "get", "newest", "revis", "incorrect", "when", "there", "are", "previou", "document"]},
{"A_title": "StringUtils.join throws NPE when toString returns null for one of objects in collectionTry    StringUtils.join(new Object         new Object()            @Override           public String toString()              return null;                          );   ToString should probably never return null but it does in javax.mail.internet.InternetAddress", "A_clean_title": ["stringutil", "join", "string", "util", "throw", "npe", "when", "tostr", "string", "return", "null", "one", "object", "collectiontri", "collect", "tri", "stringutil", "join", "string", "util", "new", "object", "new", "object", "overrid", "public", "string", "tostr", "string", "return", "null", "tostr", "string", "probabl", "never", "return", "null", "but", "it", "javax", "mail", "internet", "internetaddress", "internet", "address"], "B_title": "Applying Ilyas patch from LANG-703 fixing an NPE when toString returns null", "B_clean_title": ["appli", "ilya", "patch", "lang", "703", "fix", "npe", "when", "tostr", "string", "return", "null"]},
{"A_title": "bug in removeStatementIn this example if you want to remove the second i++ with  block.removeStatement(block.getStatement(3));  Spoon removes the first one.  (found by  @martinezmatias thanks!)", "A_clean_title": ["bug", "removestatementin", "remov", "statement", "thi", "exampl", "you", "want", "remov", "second", "i++", "block", "removestat", "remov", "statement", "block", "getstat", "get", "statement", "spoon", "remov", "first", "one", "found", "by", "martinezmatia", "thank"], "B_title": "fix: fix wrong behavior for special cases in removeStatement. Closes #1221. (#1224)", "B_clean_title": ["fix", "fix", "wrong", "behavior", "special", "case", "removestat", "remov", "statement", "close", "1221", "1224"]},
{"A_title": "PageParameters#set not follow INamedParameters#set behaviorCouple of problems to work with page parameters: Major - The PageParameters#set(final String name final Object value final int index) used remove/add pattern instead of set parameter value by specified index. Minor - Inposible to get the index of key in elegant way to use obtained index in #set operation", "A_clean_title": ["pageparamet", "page", "paramet", "set", "not", "follow", "inamedparamet", "name", "paramet", "set", "behaviorcoupl", "behavior", "coupl", "problem", "work", "page", "paramet", "major", "pageparamet", "page", "paramet", "set", "final", "string", "name", "final", "object", "valu", "final", "int", "index", "use", "remov", "add", "pattern", "instead", "set", "paramet", "valu", "by", "specifi", "index", "minor", "inpos", "get", "index", "key", "eleg", "way", "use", "obtain", "index", "set", "oper"], "B_title": "PageParameters#set not follow INamedParameters#set behavior", "B_clean_title": ["pageparamet", "page", "paramet", "set", "not", "follow", "inamedparamet", "name", "paramet", "set", "behavior"]},
{"A_title": "Inconsistent handling of non-JSDoc commentsNone", "A_clean_title": ["inconsist", "handl", "non", "jsdoc", "js", "doc", "commentsnon", "comment", "none"], "B_title": "Improve detection of suspicious block comments.", "B_clean_title": ["improv", "detect", "suspici", "block", "comment"]},
{"A_title": "Wrong constructor picked up when deserializing objectI discovered an issue with Jackson 2.7.8 (and Jackson 2.8.4) when several constructors have parameters annotated with  @JsonProperty but only one is annotated with @JsonCreator . Heres a test case to reproduce it:   This test throws an the following exception:   After some debugging it looks like that  BasicDeserializerFactory#_addDeserializerConstructors(...) is looping over all the constructors and is not favoring an explicit constructor over a non-explicit one. I actually dont know what should be the expected behavior: should jackson fail when two constructors are annotated or should jackson favor the one annotated with  @JsonCreator . Both options look reasonable to me (and Im actually removing one of the constructors).", "A_clean_title": ["wrong", "constructor", "pick", "up", "when", "deseri", "objecti", "object", "discov", "issu", "jackson", "jackson", "when", "sever", "constructor", "have", "paramet", "annot", "jsonproperti", "json", "properti", "but", "onli", "one", "annot", "jsoncreat", "json", "creator", "here", "test", "case", "reproduc", "it", "thi", "test", "throw", "follow", "except", "after", "some", "debug", "it", "look", "like", "that", "basicdeserializerfactori", "basic", "deseri", "factori", "adddeserializerconstructor", "add", "deseri", "constructor", "loop", "over", "all", "constructor", "not", "favor", "explicit", "constructor", "over", "non", "explicit", "one", "actual", "dont", "know", "what", "expect", "behavior", "jackson", "fail", "when", "two", "constructor", "are", "annot", "or", "jackson", "favor", "one", "annot", "jsoncreat", "json", "creator", "both", "option", "look", "reason", "me", "im", "actual", "remov", "one", "constructor"], "B_title": "Fix #1476", "B_clean_title": ["fix", "1476"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "source/org/jfree/chart/util/SerialUtilities.java (readShape): Handle SEG_CLOSE for GeneralPath Use correct path for comparison.", "B_clean_title": ["java", "sourc", "org", "jfree", "chart", "util", "serialutil", "serial", "util", "readshap", "read", "shape", "handl", "seg", "close", "generalpath", "gener", "path", "use", "correct", "path", "comparison"]},
{"A_title": "ProxyingHandlerMethodArgumentResolver handles interfaces not intended for projection DATACMNS-776opened and commented A Spring Boot application that depends on  spring-boot-starter-data-pa and uses Spring Mobile will create a proxy for Spring Mobiles Device interface when its injected into a handler method. Calling isMobile on this proxy fails as follows:  The culprit is  ProxyingHandlerMethodArgumentResolver which takes responsibility for any argument thats an interface. I can work around the problem by ensuring that Spring Mobiles DeviceHandlerMethodArgumentResolver appears before ProxyingHandlerMethodArgumentResolver in Spring MVCs list of argument resolvers but Id prefer not to have to do so. Can ProxyingHandlerMethodArgumentResolver be fixed so that it either doesnt claim responsibility for anything thats an interface or so that it returns a working proxy?   Affects: 1.10.2 (Fowler SR2) 1.11 GA (Gosling)  Issue Links:     Backported to:  1.13 GA (Ingalls)  1.12.7 (Hopper SR7)  1.11.7 (Gosling SR7) 4 votes 8 watchers", "A_clean_title": ["proxyinghandlermethodargumentresolv", "proxi", "handler", "method", "argument", "resolv", "handl", "interfac", "not", "intend", "project", "datacmn", "776open", "comment", "spring", "boot", "applic", "that", "depend", "spring", "boot", "starter", "data", "pa", "use", "spring", "mobil", "will", "creat", "proxi", "spring", "mobil", "devic", "interfac", "when", "it", "inject", "into", "handler", "method", "call", "ismobil", "mobil", "thi", "proxi", "fail", "as", "follow", "culprit", "proxyinghandlermethodargumentresolv", "proxi", "handler", "method", "argument", "resolv", "which", "take", "respons", "ani", "argument", "that", "interfac", "work", "around", "problem", "by", "ensur", "that", "spring", "mobil", "devicehandlermethodargumentresolv", "devic", "handler", "method", "argument", "resolv", "appear", "befor", "proxyinghandlermethodargumentresolv", "proxi", "handler", "method", "argument", "resolv", "spring", "mvc", "mv", "cs", "list", "argument", "resolv", "but", "id", "prefer", "not", "have", "so", "proxyinghandlermethodargumentresolv", "proxi", "handler", "method", "argument", "resolv", "fix", "so", "that", "it", "either", "doesnt", "claim", "respons", "anyth", "that", "interfac", "or", "so", "that", "it", "return", "work", "proxi", "affect", "10", "fowler", "sr2", "11", "ga", "gosl", "issu", "link", "backport", "13", "ga", "ingal", "12", "hopper", "sr7", "11", "gosl", "sr7", "vote", "watcher"], "B_title": "DATACMNS-776 - Made ProxyingHandlerMethodArgumentResolver to only support user types or annotated ones.  ProxyingHandlerMethodArgumentResolver is now more lenient when it comes to which types to support for proxying. As indicated in the ticket weve been to aggressive opting in for all interfaces which - depending on the order of converter registrations - caused us interfering with other interface based resolutions (e.g. in Spring Mobile Security etc.).  We now only aggressively kick in if either the type or parameter is annotated with @ProjectedPayload or the type itself is not a Spring Framework or native Java one. This should leave user defined types still be accepted whereas the types we previously erroneously interfered with should now be ignored.", "B_clean_title": ["datacmn", "776", "made", "proxyinghandlermethodargumentresolv", "proxi", "handler", "method", "argument", "resolv", "onli", "support", "user", "type", "or", "annot", "one", "proxyinghandlermethodargumentresolv", "proxi", "handler", "method", "argument", "resolv", "now", "more", "lenient", "when", "it", "come", "which", "type", "support", "proxi", "as", "indic", "ticket", "weve", "been", "aggress", "opt", "all", "interfac", "which", "depend", "order", "convert", "registr", "caus", "us", "interf", "other", "interfac", "base", "resolut", "spring", "mobil", "secur", "etc", "we", "now", "onli", "aggress", "kick", "either", "type", "or", "paramet", "annot", "projectedpayload", "project", "payload", "or", "type", "itself", "not", "spring", "framework", "or", "nativ", "java", "one", "thi", "leav", "user", "defin", "type", "still", "accept", "wherea", "type", "we", "previous", "erron", "interf", "now", "ignor"]},
{"A_title": "ArgumentCaptor no longer working for varargsWhen upgrading 1.10.8 the verify passes but the getValue() fails with this error. One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables. That is remove var1 from target and test code then the test runs fine under 1.9.5 and 1.10.8. Also it doesnt matter that the captor is for a Date. The same issue occurs if the parameter is of another type such as Integer.", "A_clean_title": ["argumentcaptor", "argument", "captor", "no", "longer", "work", "varargswhen", "vararg", "when", "upgrad", "10", "verifi", "pass", "but", "getvalu", "get", "valu", "fail", "thi", "error", "one", "other", "piec", "info", "came", "light", "as", "result", "creat", "mcve", "test", "work", "fine", "date", "onli", "element", "pass", "bindvari", "bind", "variabl", "that", "remov", "var1", "target", "test", "code", "then", "test", "run", "fine", "under", "10", "also", "it", "doesnt", "matter", "that", "captor", "date", "same", "issu", "occur", "paramet", "anoth", "type", "such", "as", "integ"], "B_title": "Fix for issue 211", "B_clean_title": ["fix", "issu", "211"]},
{"A_title": "MultidimensionalCounter does not throw NoSuchElementExceptionThe iterator should throw when next() is called even though hasNext() would return false.", "A_clean_title": ["multidimensionalcount", "multidimension", "counter", "not", "throw", "nosuchelementexceptionth", "no", "such", "element", "except", "iter", "throw", "when", "next", "call", "even", "though", "hasnext", "ha", "next", "would", "return", "fals"], "B_title": "Ensure that bad usage will raise an exception.", "B_clean_title": ["ensur", "that", "bad", "usag", "will", "rais", "except"]},
{"A_title": "Classify non-rightmost expressions as problematicNone", "A_clean_title": ["classifi", "non", "rightmost", "express", "as", "problematicnon", "problemat", "none"], "B_title": "Automated g4 rollback", "B_clean_title": ["autom", "g4", "rollback"]},
{"A_title": "compiler crashes when  goog.provide used with non stringNone", "A_clean_title": ["compil", "crash", "when", "goog", "provid", "use", "non", "stringnon", "string", "none"], "B_title": "Handle bad goog.require/goog.provide calls more gracefully. Fixes issue 530.", "B_clean_title": ["handl", "bad", "goog", "provid", "requir", "goog", "call", "more", "grace", "fix", "issu", "530"]},
{"A_title": ":childOrder out of sync when node is made orderable concurrentlyThe ChildOrderConflictHandler does not merge the :childOrder when an addExistingProperty conflict occurs.", "A_clean_title": ["childord", "child", "order", "out", "sync", "when", "node", "made", "order", "concurrentlyth", "concurr", "childorderconflicthandl", "child", "order", "conflict", "handler", "not", "merg", "childord", "child", "order", "when", "addexistingproperti", "add", "exist", "properti", "conflict", "occur"], "B_title": ":childOrder out of sync when node is made orderable concurrently", "B_clean_title": ["childord", "child", "order", "out", "sync", "when", "node", "made", "order", "concurr"]},
{"A_title": "Async Update fails after IllegalArgumentExceptionThe async index update can fail due to a mismatch between an index definition and the actual content. If that is the case it seems that it can no longer make any progress. Instead it re-indexes the latest changes over and over again until it hits the problematic property.  Discussion at http://markmail.org/thread/42bixzkrkwv4s6tq  Stacktrace attached.", "A_clean_title": ["async", "updat", "fail", "after", "illegalargumentexceptionth", "illeg", "argument", "except", "async", "index", "updat", "fail", "due", "mismatch", "between", "index", "definit", "actual", "content", "that", "case", "it", "seem", "that", "it", "no", "longer", "make", "ani", "progress", "instead", "it", "re", "index", "latest", "chang", "over", "over", "again", "until", "it", "hit", "problemat", "properti", "discuss", "at", "http", "markmail", "org", "thread", "42bixzkrkwv4s6tq", "stacktrac", "attach"], "B_title": "Async Update fails after IllegalArgumentException", "B_clean_title": ["async", "updat", "fail", "after", "illegalargumentexcept", "illeg", "argument", "except"]},
{"A_title": "BlockedOutputStream can hit a StackOverflowErrorThis issue mostly came up after a resolution to ACCUMULO-2668 that allows a byte to be passed directly to the underlying stream from the NoFlushOutputStream.  The problem appears to be due to the BlockedOutputStream.write(byte int int) implementation that recursively writes out blocks/buffers out. When the stream is passed a large mutation (128MB was sufficient to trigger the error for me) this will cause a StackOverflowError.   This is appears to be specifically with encryption at rest turned on.  A simple fix would be to unroll the recursion.", "A_clean_title": ["blockedoutputstream", "block", "output", "stream", "hit", "stackoverflowerrorthi", "stack", "overflow", "error", "thi", "issu", "mostli", "came", "up", "after", "resolut", "accumulo", "2668", "that", "allow", "byte", "pass", "directli", "underli", "stream", "noflushoutputstream", "no", "flush", "output", "stream", "problem", "appear", "due", "blockedoutputstream", "write", "block", "output", "stream", "byte", "int", "int", "implement", "that", "recurs", "write", "out", "block", "buffer", "out", "when", "stream", "pass", "larg", "mutat", "128mb", "wa", "suffici", "trigger", "error", "me", "thi", "will", "caus", "stackoverflowerror", "stack", "overflow", "error", "thi", "appear", "specif", "encrypt", "at", "rest", "turn", "simpl", "fix", "would", "unrol", "recurs"], "B_title": "Refactoring BlockedOutputStream to not recurse. With test", "B_clean_title": ["refactor", "blockedoutputstream", "block", "output", "stream", "not", "recurs", "test"]},
{"A_title": "Fixing AjaxTimerBehaviorTestThis is an attempt to fix failing testcase:  target/surefire-reports/wicket.ajax.AjaxTimerBehaviorTest.txt ------------------------------------------------------------------------------- Test set: wicket.ajax.AjaxTimerBehaviorTest ------------------------------------------------------------------------------- Tests run: 2 Failures: 2 Errors: 0 Skipped: 0 Time elapsed: 0.113 sec <<< FAILURE! testAddToAjaxUpdate(wicket.ajax.AjaxTimerBehaviorTest)  Time elapsed: 0.063 sec  <<< FAILURE! junit.framework.AssertionFailedError: There should be 1 and only 1 script in the markup for this behaviorbut 0 were found exp ected:<1> but was:<0>         at junit.framework.Assert.fail(Assert.java:47)         at junit.framework.Assert.failNotEquals(Assert.java:282)         at junit.framework.Assert.assertEquals(Assert.java:64)         at junit.framework.Assert.assertEquals(Assert.java:201)         at wicket.ajax.AjaxTimerBehaviorTest.validateTimerScript(AjaxTimerBehaviorTest.java:178)         at wicket.ajax.AjaxTimerBehaviorTest.validate(AjaxTimerBehaviorTest.java:143)         at wicket.ajax.AjaxTimerBehaviorTest.testAddToAjaxUpdate(AjaxTimerBehaviorTest.java:99)  testAddToWebPage(wicket.ajax.AjaxTimerBehaviorTest)  Time elapsed: 0.026 sec  <<< FAILURE! junit.framework.AssertionFailedError: There should be 1 and only 1 script in the markup for this behaviorbut 0 were found exp ected:<1> but was:<0>         at junit.framework.Assert.fail(Assert.java:47)         at junit.framework.Assert.failNotEquals(Assert.java:282)         at junit.framework.Assert.assertEquals(Assert.java:64)         at junit.framework.Assert.assertEquals(Assert.java:201)         at wicket.ajax.AjaxTimerBehaviorTest.validateTimerScript(AjaxTimerBehaviorTest.java:178)         at wicket.ajax.AjaxTimerBehaviorTest.validate(AjaxTimerBehaviorTest.java:155)         at wicket.ajax.AjaxTimerBehaviorTest.testAddToWebPage(AjaxTimerBehaviorTest.java:127)  The attached patch properly handles the case when the callback script is added in body onload.  Also AbstractAjaxTimerBehavior needs to handle AjaxRequestTarget properly because adding a body onload has no effect in an ajax request.", "A_clean_title": ["fix", "ajaxtimerbehaviortestthi", "ajax", "timer", "behavior", "test", "thi", "attempt", "fix", "fail", "testcas", "target", "surefir", "ajax", "ajaxtimerbehaviortest", "txt", "report", "wicket", "ajax", "timer", "behavior", "test", "test", "set", "wicket", "ajax", "ajaxtimerbehaviortest", "ajax", "timer", "behavior", "test", "test", "run", "failur", "error", "skip", "time", "elaps", "113", "sec", "failur", "testaddtoajaxupd", "test", "add", "ajax", "updat", "wicket", "ajax", "ajaxtimerbehaviortest", "ajax", "timer", "behavior", "test", "time", "elaps", "063", "sec", "failur", "junit", "framework", "assertionfailederror", "assert", "fail", "error", "there", "onli", "script", "markup", "thi", "behaviorbut", "were", "found", "exp", "ect", "but", "wa", "at", "junit", "framework", "assert", "fail", "assert", "java:47", "at", "junit", "framework", "assert", "failnotequ", "fail", "not", "equal", "assert", "java:282", "at", "junit", "framework", "assert", "assertequ", "assert", "equal", "assert", "java:64", "at", "junit", "framework", "assert", "assertequ", "assert", "equal", "assert", "java:201", "at", "wicket", "ajax", "ajaxtimerbehaviortest", "validatetimerscript", "ajax", "timer", "behavior", "test", "valid", "timer", "script", "ajaxtimerbehaviortest", "java:178", "ajax", "timer", "behavior", "test", "at", "wicket", "ajax", "ajaxtimerbehaviortest", "valid", "ajax", "timer", "behavior", "test", "ajaxtimerbehaviortest", "java:143", "ajax", "timer", "behavior", "test", "at", "wicket", "ajax", "ajaxtimerbehaviortest", "testaddtoajaxupd", "ajax", "timer", "behavior", "test", "test", "add", "ajax", "updat", "ajaxtimerbehaviortest", "java:99", "ajax", "timer", "behavior", "test", "testaddtowebpag", "test", "add", "web", "page", "wicket", "ajax", "ajaxtimerbehaviortest", "ajax", "timer", "behavior", "test", "time", "elaps", "026", "sec", "failur", "junit", "framework", "assertionfailederror", "assert", "fail", "error", "there", "onli", "script", "markup", "thi", "behaviorbut", "were", "found", "exp", "ect", "but", "wa", "at", "junit", "framework", "assert", "fail", "assert", "java:47", "at", "junit", "framework", "assert", "failnotequ", "fail", "not", "equal", "assert", "java:282", "at", "junit", "framework", "assert", "assertequ", "assert", "equal", "assert", "java:64", "at", "junit", "framework", "assert", "assertequ", "assert", "equal", "assert", "java:201", "at", "wicket", "ajax", "ajaxtimerbehaviortest", "validatetimerscript", "ajax", "timer", "behavior", "test", "valid", "timer", "script", "ajaxtimerbehaviortest", "java:178", "ajax", "timer", "behavior", "test", "at", "wicket", "ajax", "ajaxtimerbehaviortest", "valid", "ajax", "timer", "behavior", "test", "ajaxtimerbehaviortest", "java:155", "ajax", "timer", "behavior", "test", "at", "wicket", "ajax", "ajaxtimerbehaviortest", "testaddtowebpag", "ajax", "timer", "behavior", "test", "test", "add", "web", "page", "ajaxtimerbehaviortest", "java:127", "ajax", "timer", "behavior", "test", "attach", "patch", "properli", "handl", "case", "when", "callback", "script", "ad", "bodi", "onload", "also", "abstractajaxtimerbehavior", "abstract", "ajax", "timer", "behavior", "need", "handl", "ajaxrequesttarget", "ajax", "request", "target", "properli", "becaus", "ad", "bodi", "onload", "ha", "no", "effect", "ajax", "request"], "B_title": "Fixing AjaxTimerBehaviorTest. It looks ok. The rendered outputs in both an AJAX and NOT-AJAX situation looks fine (escaping of  is correct). JBQ please use Java1.4 in any wicket1.x projects which requires this (String.replace(String String) doesnt exist in 1.4)", "B_clean_title": ["fix", "ajaxtimerbehaviortest", "ajax", "timer", "behavior", "test", "it", "look", "ok", "render", "output", "both", "ajax", "not", "ajax", "situat", "look", "fine", "escap", "correct", "jbq", "pleas", "use", "java1", "ani", "wicket1", "project", "which", "requir", "thi", "string", "replac", "string", "string", "doesnt", "exist"]},
{"A_title": "Last warning or error in output is truncatedNone", "A_clean_title": ["last", "warn", "or", "error", "output", "truncatednon", "truncat", "none"], "B_title": "When getting a line from the source code according to the line number if it happens to be the last line and n character is missing in the end of the file we should still return the last line.", "B_clean_title": ["when", "get", "line", "sourc", "code", "accord", "line", "number", "it", "happen", "last", "line", "charact", "miss", "end", "file", "we", "still", "return", "last", "line"]},
{"A_title": "StdDateFormat deserializes dates with no tz/offset as UTC instead of configured timezonePrior to version  2.8.9  dates without time zone or time offset (eg 1970-01-01T00:00:00.000 ) were deserialised in the TimeZone set on the ObjectMapper. Starting from 2.8.9  these dates are deserialised in UTC - which is a major (breaking) change in behaviour... Example:", "A_clean_title": ["stddateformat", "std", "date", "format", "deseri", "date", "no", "tz", "offset", "as", "utc", "instead", "configur", "timezoneprior", "timezon", "prior", "version", "date", "without", "time", "zone", "or", "time", "offset", "eg", "1970", "01", "01t00:00:00", "000", "were", "deserialis", "timezon", "time", "zone", "set", "objectmapp", "object", "mapper", "start", "these", "date", "are", "deserialis", "utc", "which", "major", "break", "chang", "behaviour", "exampl"], "B_title": "Fix #1657 (I hope)", "B_clean_title": ["fix", "1657", "hope"]},
{"A_title": "LevenbergMarquardtOptimizer reports 0 iterationsThe method LevenbergMarquardtOptimizer.getIterations() does not report the correct number of iterations; It always returns 0. A quick look at the code shows that only SimplexOptimizer calls BaseOptimizer.incrementEvaluationsCount()  Ive put a test case below. Notice how the evaluations count is correctly incremented but the iterations count is not.  noformat     @Test     public void testGetIterations()          // setup         LevenbergMarquardtOptimizer otim = new LevenbergMarquardtOptimizer();          // action         otim.optimize(new MaxEval(100) new Target(new double  1 )                 new Weight(new double  1 ) new InitialGuess(                         new double  3 ) new ModelFunction(                         new MultivariateVectorFunction()                              @Override                             public double value(double point)                                     throws IllegalArgumentException                                  return new double  FastMath.pow(point0 4) ;                                                      ) new ModelFunctionJacobian(                         new MultivariateMatrixFunction()                              @Override                             public double value(double point)                                     throws IllegalArgumentException                                  return new double   0.25 * FastMath.pow(                                         point0 3)  ;                                                      ));          // verify         assertThat(otim.getEvaluations() greaterThan(1));         assertThat(otim.getIterations() greaterThan(1));       noformat", "A_clean_title": ["levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "report", "iterationsth", "iter", "method", "levenbergmarquardtoptim", "getiter", "levenberg", "marquardt", "optim", "get", "iter", "not", "report", "correct", "number", "iter", "it", "alway", "return", "quick", "look", "at", "code", "show", "that", "onli", "simplexoptim", "simplex", "optim", "call", "baseoptim", "incrementevaluationscount", "base", "optim", "increment", "evalu", "count", "ive", "put", "test", "case", "below", "notic", "how", "evalu", "count", "correctli", "increment", "but", "iter", "count", "not", "noformat", "test", "public", "void", "testgetiter", "test", "get", "iter", "setup", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "otim", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "action", "otim", "optim", "new", "maxev", "max", "eval", "100", "new", "target", "new", "doubl", "new", "weight", "new", "doubl", "new", "initialguess", "initi", "guess", "new", "doubl", "new", "modelfunct", "model", "function", "new", "multivariatevectorfunct", "multivari", "vector", "function", "overrid", "public", "doubl", "valu", "doubl", "point", "throw", "illegalargumentexcept", "illeg", "argument", "except", "return", "new", "doubl", "fastmath", "pow", "fast", "math", "point0", "new", "modelfunctionjacobian", "model", "function", "jacobian", "new", "multivariatematrixfunct", "multivari", "matrix", "function", "overrid", "public", "doubl", "valu", "doubl", "point", "throw", "illegalargumentexcept", "illeg", "argument", "except", "return", "new", "doubl", "25", "fastmath", "pow", "fast", "math", "point0", "verifi", "assertthat", "assert", "that", "otim", "getevalu", "get", "evalu", "greaterthan", "greater", "than", "assertthat", "assert", "that", "otim", "getiter", "get", "iter", "greaterthan", "greater", "than", "noformat"], "B_title": "Increment iteration counter. By default the maximum number of iterations is Integer.MAX_VALUE.", "B_clean_title": ["increment", "iter", "counter", "by", "default", "maximum", "number", "iter", "integ", "max", "valu"]},
{"A_title": "event state not updated if an unrelated event triggers a RESET_STATE during ODE integrationWhen an ODE solver manages several different event types there are some unwanted side effects. If one event handler asks for a RESET_STATE (for integration state) when its eventOccurred method is called the other event handlers that did not trigger an event in the same step are not updated correctly due to an early return. As a result when the next step is processed with a reset integration state the forgotten event still refer to the start date of the previous state. This implies that when these event handlers will be checked for In some cases the function defining an event g(double t double y) is called with state parameters y that are completely wrong. In one case when the y array should have contained values between -1 and +1 one function call got values up to 1.0e20. The attached file reproduces the problem.", "A_clean_title": ["event", "state", "not", "updat", "unrel", "event", "trigger", "reset", "state", "dure", "ode", "integrationwhen", "integr", "when", "ode", "solver", "manag", "sever", "differ", "event", "type", "there", "are", "some", "unwant", "side", "effect", "one", "event", "handler", "ask", "reset", "state", "integr", "state", "when", "it", "eventoccur", "event", "occur", "method", "call", "other", "event", "handler", "that", "did", "not", "trigger", "event", "same", "step", "are", "not", "updat", "correctli", "due", "earli", "return", "as", "result", "when", "next", "step", "process", "reset", "integr", "state", "forgotten", "event", "still", "refer", "start", "date", "previou", "state", "thi", "impli", "that", "when", "these", "event", "handler", "will", "check", "some", "case", "function", "defin", "event", "doubl", "doubl", "call", "state", "paramet", "that", "are", "complet", "wrong", "one", "case", "when", "array", "have", "contain", "valu", "between", "+1", "one", "function", "call", "got", "valu", "up", "0e20", "attach", "file", "reproduc", "problem"], "B_title": "Fixed missing update in ODE event handlers.", "B_clean_title": ["fix", "miss", "updat", "ode", "event", "handler"]},
{"A_title": "Argument matcher anyXxx() (i.e. anyString() anyList()) should not match nullsNote that the function is called with an integer (not a string) and still the mocked function return the value which it should return only when a string is passed. The same works when using anyBoolean() or any other methof from any* family.", "A_clean_title": ["argument", "matcher", "anyxxx", "ani", "xxx", "anystr", "ani", "string", "anylist", "ani", "list", "not", "match", "nullsnot", "null", "note", "that", "function", "call", "integ", "not", "string", "still", "mock", "function", "return", "valu", "which", "it", "return", "onli", "when", "string", "pass", "same", "work", "when", "anyboolean", "ani", "boolean", "or", "ani", "other", "methof", "ani", "famili"], "B_title": "Stop anyX() methods matching null inputs", "B_clean_title": ["stop", "anyx", "ani", "method", "match", "null", "input"]},
{"A_title": "Tree.getStatus() and Tree.getPropertyStatus() fail for items whose parent has been removedNone", "A_clean_title": ["tree", "getstatu", "get", "statu", "tree", "getpropertystatu", "get", "properti", "statu", "fail", "item", "whose", "parent", "ha", "been", "removednon", "remov", "none"], "B_title": "Tree.getStatus() and Tree.getPropertyStatus() fail for items whose parent has been removed", "B_clean_title": ["tree", "getstatu", "get", "statu", "tree", "getpropertystatu", "get", "properti", "statu", "fail", "item", "whose", "parent", "ha", "been", "remov"]},
{"A_title": "Quaternion not normalized after constructionThe use of the Rotation(Vector3D u1Vector3D u2Vector3D v1Vector3D v2) constructor with normalized angle can apparently lead to un-normalized quaternion. This case appeared to me with the following data : u1 = (0.9999988431610581 -0.0015210774290851095 0.0) u2 = (0.0 0.0 1.0) and  v1 = (0.9999999999999999 0.0 0.0) v2 = (0.0 0.0 -1.0)  This lead to the following quaternion : q0 = 225783.35177064248 q1 = 0.0 q2 = 0.0 q3 = -3.3684446110762543E-9  I was expecting to have a normalized quaternion as input vectors are normalized. Does the quaternion shouldnt be normalized ? Ive joined the corresponding piece of code as JUnit Test case", "A_clean_title": ["quaternion", "not", "normal", "after", "constructionth", "construct", "use", "rotat", "vector3d", "u1vector3d", "u2vector3d", "v1vector3d", "v2", "constructor", "normal", "angl", "appar", "lead", "un", "normal", "quaternion", "thi", "case", "appear", "me", "follow", "data", "u1", "9999988431610581", "0015210774290851095", "u2", "v1", "9999999999999999", "v2", "thi", "lead", "follow", "quaternion", "q0", "225783", "35177064248", "q1", "q2", "q3", "3684446110762543e", "wa", "expect", "have", "normal", "quaternion", "as", "input", "vector", "are", "normal", "quaternion", "shouldnt", "normal", "ive", "join", "correspond", "piec", "code", "as", "junit", "unit", "test", "case"], "B_title": "Fixed a problem when building rotations from two pairs of vectors. In very rare cases due to numerical inaccuracies the computed quaternion was not normalized (some examples went as high as 1.0e8) and even after normalization the quaternion was plain wrong.", "B_clean_title": ["fix", "problem", "when", "build", "rotat", "two", "pair", "vector", "veri", "rare", "case", "due", "numer", "inaccuraci", "comput", "quaternion", "wa", "not", "normal", "some", "exampl", "went", "as", "high", "as", "0e8", "even", "after", "normal", "quaternion", "wa", "plain", "wrong"]},
{"A_title": "MonotoneChain handling of collinear points drops low points in a near-columnThis code code val points = List(   new Vector2D(     16.078200000000184     -36.52519999989808   )   new Vector2D(     19.164300000000186     -36.52519999989808   )   new Vector2D(     19.1643     -25.28136477910407   )   new Vector2D(     19.1643     -17.678400000004157   ) ) new hull.MonotoneChain().generate(points.asJava) code  results in the exception: code org.apache.commons.math3.exception.ConvergenceException: illegal state: convergence failed at org.apache.commons.math3.geometry.euclidean.twod.hull.AbstractConvexHullGenerator2D.generate(AbstractConvexHullGenerator2D.java:106) at org.apache.commons.math3.geometry.euclidean.twod.hull.MonotoneChain.generate(MonotoneChain.java:50) at .<init>(<console>:13) at .<clinit>(<console>) at .<init>(<console>:11) at .<clinit>(<console>) at  print(<console>) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at scala.tools.nsc.interpreter.IMain ReadEvalPrint.call(IMain.scala:704) at scala.tools.nsc.interpreter.IMain Request  anonfun 14.apply(IMain.scala:920) at scala.tools.nsc.interpreter.Line  anonfun 1.apply mcV sp(Line.scala:43) at scala.tools.nsc.io.package  anon 2.run(package.scala:25) at java.lang.Thread.run(Thread.java:662) code  This will be tricky to fix. Not only is the point (19.164300000000186 -36.52519999989808) is being dropped incorrectly but any point dropped in one hull risks creating a kink when combined with the other hull.", "A_clean_title": ["monotonechain", "monoton", "chain", "handl", "collinear", "point", "drop", "low", "point", "near", "columnthi", "column", "thi", "code", "code", "val", "point", "list", "new", "vector2d", "16", "078200000000184", "36", "52519999989808", "new", "vector2d", "19", "164300000000186", "36", "52519999989808", "new", "vector2d", "19", "1643", "25", "28136477910407", "new", "vector2d", "19", "1643", "17", "678400000004157", "new", "hull", "monotonechain", "monoton", "chain", "gener", "point", "asjava", "as", "java", "code", "result", "except", "code", "org", "apach", "common", "math3", "except", "convergenceexcept", "converg", "except", "illeg", "state", "converg", "fail", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "twod", "hull", "abstractconvexhullgenerator2d", "gener", "abstract", "convex", "hull", "generator2d", "abstractconvexhullgenerator2d", "java:106", "abstract", "convex", "hull", "generator2d", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "twod", "hull", "monotonechain", "gener", "monoton", "chain", "monotonechain", "java:50", "monoton", "chain", "at", "init", "consol", ":13", "at", "clinit", "consol", "at", "init", "consol", ":11", "at", "clinit", "consol", "at", "print", "consol", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:597", "at", "scala", "tool", "nsc", "interpret", "imain", "main", "readevalprint", "call", "read", "eval", "print", "imain", "scala:704", "main", "at", "scala", "tool", "nsc", "interpret", "imain", "main", "request", "anonfun", "14", "appli", "imain", "scala:920", "main", "at", "scala", "tool", "nsc", "interpret", "line", "anonfun", "appli", "mcv", "mc", "sp", "line", "scala:43", "at", "scala", "tool", "nsc", "io", "packag", "anon", "run", "packag", "scala:25", "at", "java", "lang", "thread", "run", "thread", "java:662", "code", "thi", "will", "tricki", "fix", "not", "onli", "point", "19", "164300000000186", "36", "52519999989808", "be", "drop", "incorrectli", "but", "ani", "point", "drop", "one", "hull", "risk", "creat", "kink", "when", "combin", "other", "hull"], "B_title": "Fix MonotoneChain with collinear points as input: take tolerance factor into account when initially sorting the input points. Thanks to Guillaume Marceau for the report.", "B_clean_title": ["fix", "monotonechain", "monoton", "chain", "collinear", "point", "as", "input", "take", "toler", "factor", "into", "account", "when", "initi", "sort", "input", "point", "thank", "guillaum", "marceau", "report"]},
{"A_title": "DropDownChoice no selection valueThis problem came from this topic: http://apache-wicket.1842946.n4.nabble.com/DropDownChoice-no-selection-value-td3160661.html  Ive noticed that the method AbstractSingleSelectChoice.getNoSelectionValue() returns the value for no selection. In AbstractSingleSelectChoice.getDefaultChoice(final Object selected) on line 314:        return n<option selected=selected value=> + option + </option>;   and on line 296:        buffer.append( value=>).append(option).append(</option>);   In those cases the null value option has empty value attribute. Wouldnt it be more consistent for this option to have the value attribute with the result provided from getNoSelectionValue()?", "A_clean_title": ["dropdownchoic", "drop", "down", "choic", "no", "select", "valuethi", "valu", "thi", "problem", "came", "thi", "topic", "http", "no", "select", "valu", "apach", "wicket", "1842946", "n4", "nabbl", "td3160661", "html", "com", "dropdownchoic", "drop", "down", "choic", "ive", "notic", "that", "method", "abstractsingleselectchoic", "getnoselectionvalu", "abstract", "singl", "select", "choic", "get", "no", "select", "valu", "return", "valu", "no", "select", "abstractsingleselectchoic", "getdefaultchoic", "abstract", "singl", "select", "choic", "get", "default", "choic", "final", "object", "select", "line", "314", "return", "option", "selected=select", "value=", "option", "option", "line", "296", "buffer", "append", "value=", "append", "option", "append", "option", "those", "case", "null", "valu", "option", "ha", "empti", "valu", "attribut", "wouldnt", "it", "more", "consist", "thi", "option", "have", "valu", "attribut", "result", "provid", "getnoselectionvalu", "get", "no", "select", "valu"], "B_title": "DropDownChoice no selection value", "B_clean_title": ["dropdownchoic", "drop", "down", "choic", "no", "select", "valu"]},
{"A_title": "RootImplFuzzIT test failuresAs seen in the CI build RootImplFuzzIT fails every now and then. This might be because of OAK-174 but theres been quite a bit of other work on the same area so this could be caused also by something else.  The troublesome seeds as seen in failing CI builds are 1437930918 206057576 1638075186 1705736349 -1856261793 and 569172885.", "A_clean_title": ["rootimplfuzzit", "root", "impl", "fuzz", "it", "test", "failuresa", "failur", "as", "seen", "ci", "build", "rootimplfuzzit", "root", "impl", "fuzz", "it", "fail", "everi", "now", "then", "thi", "might", "becaus", "oak", "174", "but", "there", "been", "quit", "bit", "other", "work", "same", "area", "so", "thi", "could", "caus", "also", "by", "someth", "troublesom", "seed", "as", "seen", "fail", "ci", "build", "are", "1437930918", "206057576", "1638075186", "1705736349", "1856261793", "569172885"], "B_title": "RootImplFuzzIT test failures", "B_clean_title": ["rootimplfuzzit", "root", "impl", "fuzz", "it", "test", "failur"]},
{"A_title": "Adding a component in Component#onInitialize() leads to StackOverflowErrorAdding a component in Page#onInitialize() leads to StackOverflowError:   at org.apache.wicket.MarkupContainer.addedComponent(MarkupContainer.java:978)      at org.apache.wicket.MarkupContainer.add(MarkupContainer.java:168)      at org.apache.wicket.examples.WicketExamplePage.onInitialize(WicketExamplePage.java:67)      at org.apache.wicket.Component.initialize(Component.java:970)      at org.apache.wicket.MarkupContainer.initialize(MarkupContainer.java:992)      at org.apache.wicket.Page.componentAdded(Page.java:1130)      at org.apache.wicket.MarkupContainer.addedComponent(MarkupContainer.java:978)      at org.apache.wicket.MarkupContainer.add(MarkupContainer.java:168)      at org.apache.wicket.examples.WicketExamplePage.onInitialize(WicketExamplePage.java:67)      at org.apache.wicket.Component.initialize(Component.java:970)      at org.apache.wicket.MarkupContainer.initialize(MarkupContainer.java:992)      at org.apache.wicket.Page.componentAdded(Page.java:1130)      at org.apache.wicket.MarkupContainer.addedComponent(MarkupContainer.java:978)      at org.apache.wicket.MarkupContainer.add(MarkupContainer.java:168)      at org.apache.wicket.examples.WicketExamplePage.onInitialize(WicketExamplePage.java:67)      at org.apache.wicket.Component.initialize(Component.java:970)      at org.apache.wicket.MarkupContainer.initialize(MarkupContainer.java:992)      at org.apache.wicket.Page.componentAdded(Page.java:1130)      at org.apache.wicket.MarkupContainer.addedComponent(MarkupContainer.java:978)      at org.apache.wicket.MarkupContainer.add(MarkupContainer.java:168)      at org.apache.wicket.examples.WicketExamplePage.onInitialize(WicketExamplePage.java:67)      at org.apache.wicket.Component.initialize(Component.java:970)      at org.apache.wicket.MarkupContainer.initialize(MarkupContainer.java:992)      at org.apache.wicket.Page.componentAdded(Page.java:1130)      at org.apache.wicket.MarkupContainer.addedComponent(MarkupContainer.java:978)      at org.apache.wicket.MarkupContainer.add(MarkupContainer.java:168)      at org.apache.wicket.examples.WicketExamplePage.onInitialize(WicketExamplePage.java:67)      at org.apache.wicket.Component.initialize(Component.java:970) ...", "A_clean_title": ["ad", "compon", "compon", "oniniti", "initi", "lead", "stackoverflowerrorad", "stack", "overflow", "error", "ad", "compon", "page", "oniniti", "initi", "lead", "stackoverflowerror", "stack", "overflow", "error", "at", "org", "apach", "wicket", "markupcontain", "addedcompon", "markup", "contain", "ad", "compon", "markupcontain", "java:978", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "add", "markup", "contain", "markupcontain", "java:168", "markup", "contain", "at", "org", "apach", "wicket", "exampl", "wicketexamplepag", "oniniti", "wicket", "exampl", "page", "initi", "wicketexamplepag", "java:67", "wicket", "exampl", "page", "at", "org", "apach", "wicket", "compon", "initi", "compon", "java:970", "at", "org", "apach", "wicket", "markupcontain", "initi", "markup", "contain", "markupcontain", "java:992", "markup", "contain", "at", "org", "apach", "wicket", "page", "componentad", "compon", "ad", "page", "java:1130", "at", "org", "apach", "wicket", "markupcontain", "addedcompon", "markup", "contain", "ad", "compon", "markupcontain", "java:978", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "add", "markup", "contain", "markupcontain", "java:168", "markup", "contain", "at", "org", "apach", "wicket", "exampl", "wicketexamplepag", "oniniti", "wicket", "exampl", "page", "initi", "wicketexamplepag", "java:67", "wicket", "exampl", "page", "at", "org", "apach", "wicket", "compon", "initi", "compon", "java:970", "at", "org", "apach", "wicket", "markupcontain", "initi", "markup", "contain", "markupcontain", "java:992", "markup", "contain", "at", "org", "apach", "wicket", "page", "componentad", "compon", "ad", "page", "java:1130", "at", "org", "apach", "wicket", "markupcontain", "addedcompon", "markup", "contain", "ad", "compon", "markupcontain", "java:978", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "add", "markup", "contain", "markupcontain", "java:168", "markup", "contain", "at", "org", "apach", "wicket", "exampl", "wicketexamplepag", "oniniti", "wicket", "exampl", "page", "initi", "wicketexamplepag", "java:67", "wicket", "exampl", "page", "at", "org", "apach", "wicket", "compon", "initi", "compon", "java:970", "at", "org", "apach", "wicket", "markupcontain", "initi", "markup", "contain", "markupcontain", "java:992", "markup", "contain", "at", "org", "apach", "wicket", "page", "componentad", "compon", "ad", "page", "java:1130", "at", "org", "apach", "wicket", "markupcontain", "addedcompon", "markup", "contain", "ad", "compon", "markupcontain", "java:978", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "add", "markup", "contain", "markupcontain", "java:168", "markup", "contain", "at", "org", "apach", "wicket", "exampl", "wicketexamplepag", "oniniti", "wicket", "exampl", "page", "initi", "wicketexamplepag", "java:67", "wicket", "exampl", "page", "at", "org", "apach", "wicket", "compon", "initi", "compon", "java:970", "at", "org", "apach", "wicket", "markupcontain", "initi", "markup", "contain", "markupcontain", "java:992", "markup", "contain", "at", "org", "apach", "wicket", "page", "componentad", "compon", "ad", "page", "java:1130", "at", "org", "apach", "wicket", "markupcontain", "addedcompon", "markup", "contain", "ad", "compon", "markupcontain", "java:978", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "add", "markup", "contain", "markupcontain", "java:168", "markup", "contain", "at", "org", "apach", "wicket", "exampl", "wicketexamplepag", "oniniti", "wicket", "exampl", "page", "initi", "wicketexamplepag", "java:67", "wicket", "exampl", "page", "at", "org", "apach", "wicket", "compon", "initi", "compon", "java:970"], "B_title": "Adding a component in Component#onInitialize() leads to StackOverflowError", "B_clean_title": ["ad", "compon", "compon", "oniniti", "initi", "lead", "stackoverflowerror", "stack", "overflow", "error"]},
{"A_title": "encodeUrl fails parsing jsessionid when using root contextWe are using Selenium 2.26.0 to test our Wicket application using Jetty 6.1.25 (also tried 7.0.0.pre5) and Firefox 12 as client browser.  With Wicket 1.5.8 everything worked fine but updating to 1.5.9 the following error occurs on first request:  java.lang.NumberFormatException: For input string: 56704;jsessionid=t3j8z4tsuazh1jfbcnjr8ryg at java.lang.NumberFormatException.forInputString(NumberFormatException.java:48) at java.lang.Integer.parseInt(Integer.java:458) at java.lang.Integer.parseInt(Integer.java:499) at org.apache.wicket.request.Url.parse(Url.java:195) at org.apache.wicket.request.Url.parse(Url.java:121) at org.apache.wicket.protocol.http.servlet.ServletWebResponse.encodeURL(ServletWebResponse.java:194) at org.apache.wicket.protocol.http.HeaderBufferingWebResponse.encodeURL(HeaderBufferingWebResponse.java:161) at org.apache.wicket.request.cycle.RequestCycle.renderUrl(RequestCycle.java:524) at org.apache.wicket.request.cycle.RequestCycle.urlFor(RequestCycle.java:492) at org.apache.wicket.request.cycle.RequestCycle.urlFor(RequestCycle.java:477) at org.apache.wicket.Component.urlFor(Component.java:3319) at org.apache.wicket.markup.html.link.BookmarkablePageLink.getURL(BookmarkablePageLink.java:209) at org.apache.wicket.markup.html.link.Link.onComponentTag(Link.java:361) at org.apache.wicket.Component.internalRenderComponent(Component.java:2530) at org.apache.wicket.MarkupContainer.onRender(MarkupContainer.java:1530) at org.apache.wicket.Component.internalRender(Component.java:2389) at org.apache.wicket.Component.render(Component.java:2317) at org.apache.wicket.MarkupContainer.renderNext(MarkupContainer.java:1428) at org.apache.wicket.MarkupContainer.renderAll(MarkupContainer.java:1592) at org.apache.wicket.Page.onRender(Page.java:907) at org.apache.wicket.markup.html.WebPage.onRender(WebPage.java:140) at org.apache.wicket.Component.internalRender(Component.java:2389) at org.apache.wicket.Component.render(Component.java:2317) at org.apache.wicket.Page.renderPage(Page.java:1035) at org.apache.wicket.request.handler.render.WebPageRenderer.renderPage(WebPageRenderer.java:118) at org.apache.wicket.request.handler.render.WebPageRenderer.respond(WebPageRenderer.java:246) at org.apache.wicket.request.handler.RenderPageRequestHandler.respond(RenderPageRequestHandler.java:167) at org.apache.wicket.request.cycle.RequestCycle HandlerExecutor.respond(RequestCycle.java:784) at org.apache.wicket.request.RequestHandlerStack.execute(RequestHandlerStack.java:64) at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:304) at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:313) at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:313) at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:313) at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:313) at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:313) at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:313) at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:313) at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:313) at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:313) at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:313) at org.apache.wicket.request.cycle.RequestCycle.processRequest(RequestCycle.java:227) at org.apache.wicket.request.cycle.RequestCycle.processRequestAndDetach(RequestCycle.java:283) at org.apache.wicket.protocol.http.WicketFilter.processRequest(WicketFilter.java:188) at org.apache.wicket.protocol.http.WicketFilter.doFilter(WicketFilter.java:244)  Using debugger the encodeUrl method has variables   fullUrl = http://localhost:56704 encodedFullUrl = http://localhost:56704;jsessionid=8kxeo3reannw1qjtxgkju8yiu  before the exception occurs. I believe this is related to https://issues.apache.org/jira/browse/WICKET-4645.", "A_clean_title": ["encodeurl", "encod", "url", "fail", "pars", "jsessionid", "when", "root", "contextw", "context", "we", "are", "selenium", "26", "test", "our", "wicket", "applic", "jetti", "25", "also", "tri", "pre5", "firefox", "12", "as", "client", "browser", "wicket", "everyth", "work", "fine", "but", "updat", "follow", "error", "occur", "first", "request", "java", "lang", "numberformatexcept", "number", "format", "except", "input", "string", "56704", "jsessionid=t3j8z4tsuazh1jfbcnjr8ryg", "at", "java", "lang", "numberformatexcept", "forinputstr", "number", "format", "except", "input", "string", "numberformatexcept", "java:48", "number", "format", "except", "at", "java", "lang", "integ", "parseint", "pars", "int", "integ", "java:458", "at", "java", "lang", "integ", "parseint", "pars", "int", "integ", "java:499", "at", "org", "apach", "wicket", "request", "url", "pars", "url", "java:195", "at", "org", "apach", "wicket", "request", "url", "pars", "url", "java:121", "at", "org", "apach", "wicket", "protocol", "http", "servlet", "servletwebrespons", "encodeurl", "servlet", "web", "respons", "encod", "url", "servletwebrespons", "java:194", "servlet", "web", "respons", "at", "org", "apach", "wicket", "protocol", "http", "headerbufferingwebrespons", "encodeurl", "header", "buffer", "web", "respons", "encod", "url", "headerbufferingwebrespons", "java:161", "header", "buffer", "web", "respons", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "renderurl", "request", "cycl", "render", "url", "requestcycl", "java:524", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "urlfor", "request", "cycl", "url", "requestcycl", "java:492", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "urlfor", "request", "cycl", "url", "requestcycl", "java:477", "request", "cycl", "at", "org", "apach", "wicket", "compon", "urlfor", "url", "compon", "java:3319", "at", "org", "apach", "wicket", "markup", "html", "link", "bookmarkablepagelink", "geturl", "bookmark", "page", "link", "get", "url", "bookmarkablepagelink", "java:209", "bookmark", "page", "link", "at", "org", "apach", "wicket", "markup", "html", "link", "link", "oncomponenttag", "compon", "tag", "link", "java:361", "at", "org", "apach", "wicket", "compon", "internalrendercompon", "intern", "render", "compon", "compon", "java:2530", "at", "org", "apach", "wicket", "markupcontain", "onrend", "markup", "contain", "render", "markupcontain", "java:1530", "markup", "contain", "at", "org", "apach", "wicket", "compon", "internalrend", "intern", "render", "compon", "java:2389", "at", "org", "apach", "wicket", "compon", "render", "compon", "java:2317", "at", "org", "apach", "wicket", "markupcontain", "rendernext", "markup", "contain", "render", "next", "markupcontain", "java:1428", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "renderal", "markup", "contain", "render", "all", "markupcontain", "java:1592", "markup", "contain", "at", "org", "apach", "wicket", "page", "onrend", "render", "page", "java:907", "at", "org", "apach", "wicket", "markup", "html", "webpag", "onrend", "web", "page", "render", "webpag", "java:140", "web", "page", "at", "org", "apach", "wicket", "compon", "internalrend", "intern", "render", "compon", "java:2389", "at", "org", "apach", "wicket", "compon", "render", "compon", "java:2317", "at", "org", "apach", "wicket", "page", "renderpag", "render", "page", "page", "java:1035", "at", "org", "apach", "wicket", "request", "handler", "render", "webpagerender", "renderpag", "web", "page", "render", "render", "page", "webpagerender", "java:118", "web", "page", "render", "at", "org", "apach", "wicket", "request", "handler", "render", "webpagerender", "respond", "web", "page", "render", "webpagerender", "java:246", "web", "page", "render", "at", "org", "apach", "wicket", "request", "handler", "renderpagerequesthandl", "respond", "render", "page", "request", "handler", "renderpagerequesthandl", "java:167", "render", "page", "request", "handler", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "request", "cycl", "handlerexecutor", "respond", "handler", "executor", "requestcycl", "java:784", "request", "cycl", "at", "org", "apach", "wicket", "request", "requesthandlerstack", "execut", "request", "handler", "stack", "requesthandlerstack", "java:64", "request", "handler", "stack", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:304", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:313", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:313", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:313", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:313", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:313", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:313", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:313", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:313", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:313", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:313", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "processrequest", "request", "cycl", "process", "request", "requestcycl", "java:227", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "processrequestanddetach", "request", "cycl", "process", "request", "detach", "requestcycl", "java:283", "request", "cycl", "at", "org", "apach", "wicket", "protocol", "http", "wicketfilt", "processrequest", "wicket", "filter", "process", "request", "wicketfilt", "java:188", "wicket", "filter", "at", "org", "apach", "wicket", "protocol", "http", "wicketfilt", "dofilt", "wicket", "filter", "filter", "wicketfilt", "java:244", "wicket", "filter", "debugg", "encodeurl", "encod", "url", "method", "ha", "variabl", "fullurl", "full", "url", "http", "localhost:56704", "encodedfullurl", "encod", "full", "url", "http", "localhost:56704", "jsessionid=8kxeo3reannw1qjtxgkju8yiu", "befor", "except", "occur", "believ", "thi", "relat", "http", "4645", "apach", "issu", "org", "jira", "brows", "wicket"], "B_title": "semicolon (;) starts segments if no slash is present", "B_clean_title": ["semicolon", "start", "segment", "no", "slash", "present"]},
{"A_title": "Indexes: re-index automatically when adding an indexWhen adding an index via import of content the index is not automatically re-built. This is problematic because subsequent queries will return no data because of that. Currently the only way to re-index is to set the reindex property to true.  I suggest that indexes are automatically re-indexes if the hidden child node (:data I believe) is missing. This is in addition to the reindex property.", "A_clean_title": ["index", "re", "index", "automat", "when", "ad", "indexwhen", "index", "when", "ad", "index", "via", "import", "content", "index", "not", "automat", "re", "built", "thi", "problemat", "becaus", "subsequ", "queri", "will", "return", "no", "data", "becaus", "that", "current", "onli", "way", "re", "index", "set", "reindex", "properti", "true", "suggest", "that", "index", "are", "automat", "re", "index", "hidden", "child", "node", "data", "believ", "miss", "thi", "addit", "reindex", "properti"], "B_title": "Indexes: re-index automatically when adding an index", "B_clean_title": ["index", "re", "index", "automat", "when", "ad", "index"]},
{"A_title": "Query test failures on buildbotSince revision 1398915 various query tests fail on buildbot|http://ci.apache.org/builders/oak-trunk/builds/784:  code sql1(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest): No LoginModules configured for jackrabbit.oak sql2(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest): No LoginModules configured for jackrabbit.oak xpath(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest): No LoginModules configured for jackrabbit.oak bindVariableTest(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest): No LoginModules configured for jackrabbit.oak sql1(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): No LoginModules configured for jackrabbit.oak sql2(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): No LoginModules configured for jackrabbit.oak xpath(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): No LoginModules configured for jackrabbit.oak bindVariableTest(org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest): No LoginModules configured for jackrabbit.oak sql2Explain(org.apache.jackrabbit.oak.plugins.index.old.QueryTest): No LoginModules configured for jackrabbit.oak sql1(org.apache.jackrabbit.oak.plugins.index.old.QueryTest): No LoginModules configured for jackrabbit.oak xpath(org.apache.jackrabbit.oak.plugins.index.old.QueryTest): No LoginModules configured for jackrabbit.oak bindVariableTest(org.apache.jackrabbit.oak.plugins.index.old.QueryTest): No LoginModules configured for jackrabbit.oak sql1(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): No LoginModules configured for jackrabbit.oak sql2(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): No LoginModules configured for jackrabbit.oak xpath(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): No LoginModules configured for jackrabbit.oak bindVariableTest(org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest): No LoginModules configured for jackrabbit.oak code", "A_clean_title": ["queri", "test", "failur", "buildbotsinc", "buildbot", "sinc", "revis", "1398915", "variou", "queri", "test", "fail", "buildbot|http", "apach", "trunk", "build", "784", "ci", "org", "builder", "oak", "code", "sql1", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "luceneindexquerytest", "lucen", "index", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "sql2", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "luceneindexquerytest", "lucen", "index", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "xpath", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "luceneindexquerytest", "lucen", "index", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "bindvariabletest", "bind", "variabl", "test", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "luceneindexquerytest", "lucen", "index", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "sql1", "org", "apach", "jackrabbit", "oak", "plugin", "index", "properti", "propertyindexquerytest", "properti", "index", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "sql2", "org", "apach", "jackrabbit", "oak", "plugin", "index", "properti", "propertyindexquerytest", "properti", "index", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "xpath", "org", "apach", "jackrabbit", "oak", "plugin", "index", "properti", "propertyindexquerytest", "properti", "index", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "bindvariabletest", "bind", "variabl", "test", "org", "apach", "jackrabbit", "oak", "plugin", "index", "properti", "propertyindexquerytest", "properti", "index", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "sql2explain", "org", "apach", "jackrabbit", "oak", "plugin", "index", "old", "querytest", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "sql1", "org", "apach", "jackrabbit", "oak", "plugin", "index", "old", "querytest", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "xpath", "org", "apach", "jackrabbit", "oak", "plugin", "index", "old", "querytest", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "bindvariabletest", "bind", "variabl", "test", "org", "apach", "jackrabbit", "oak", "plugin", "index", "old", "querytest", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "sql1", "org", "apach", "jackrabbit", "oak", "queri", "index", "traversingindexquerytest", "travers", "index", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "sql2", "org", "apach", "jackrabbit", "oak", "queri", "index", "traversingindexquerytest", "travers", "index", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "xpath", "org", "apach", "jackrabbit", "oak", "queri", "index", "traversingindexquerytest", "travers", "index", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "bindvariabletest", "bind", "variabl", "test", "org", "apach", "jackrabbit", "oak", "queri", "index", "traversingindexquerytest", "travers", "index", "queri", "test", "no", "loginmodul", "login", "modul", "configur", "jackrabbit", "oak", "code"], "B_title": "Query test failures on buildbot - revert changes from revision 1399172 - use default login module configuration when none is given", "B_clean_title": ["queri", "test", "failur", "buildbot", "revert", "chang", "revis", "1399172", "use", "default", "login", "modul", "configur", "when", "none", "given"]},
{"A_title": "HarmonicFitter.ParameterGuesser sometimes fails to return sensible valuesThe inner class ParameterGuesser in HarmonicFitter (package o.a.c.m.optimization.fitting) fails to compute a usable guess for the amplitude parameter.", "A_clean_title": ["harmonicfitt", "parameterguess", "harmon", "fitter", "paramet", "guesser", "sometim", "fail", "return", "sensibl", "valuesth", "valu", "inner", "class", "parameterguess", "paramet", "guesser", "harmonicfitt", "harmon", "fitter", "packag", "optim", "fit", "fail", "comput", "usabl", "guess", "amplitud", "paramet"], "B_title": "Generate an exception when the parameter guessing procedure cannot perform correctly (in rare ill-conditioned cases).", "B_clean_title": ["gener", "except", "when", "paramet", "guess", "procedur", "not", "perform", "correctli", "rare", "ill", "condit", "case"]},
{"A_title": "Changes to SourcePosition in 5.5.0 ?Hello  according to #1081 I dont find any mentions of changes to the SourcePosition. In our use case we want to calculate the size of constructors and methods. Which worked just fine in 5.4.  Now with the 5.5 Snapshot I want to analyze a file which has a inner private class with no constructors. Spoon generates a default private constructor with one statement -> super() . The start line of this constructor is 1 and getPosition().getFile() returns null while the statements (super()) line is 383 and it has a file. My method throws a NP as my method size calculation now is wrong and gets passed the threshold and I try to access the file of the generated private constructor.  I always can implement the case to ignore generated constructors but I just want to make sure this is intented or not.", "A_clean_title": ["chang", "sourceposit", "sourc", "posit", "hello", "accord", "1081", "dont", "find", "ani", "mention", "chang", "sourceposit", "sourc", "posit", "our", "use", "case", "we", "want", "calcul", "size", "constructor", "method", "which", "work", "just", "fine", "now", "snapshot", "want", "analyz", "file", "which", "ha", "inner", "privat", "class", "no", "constructor", "spoon", "gener", "default", "privat", "constructor", "one", "statement", "super", "start", "line", "thi", "constructor", "getposit", "get", "posit", "getfil", "get", "file", "return", "null", "while", "statement", "super", "line", "383", "it", "ha", "file", "my", "method", "throw", "np", "as", "my", "method", "size", "calcul", "now", "wrong", "get", "pass", "threshold", "tri", "access", "file", "gener", "privat", "constructor", "alway", "implement", "case", "ignor", "gener", "constructor", "but", "just", "want", "make", "sure", "thi", "intent", "or", "not"], "B_title": "fix(position): implicit elements do not have position (#1086)  Fix #1084", "B_clean_title": ["fix", "posit", "implicit", "element", "not", "have", "posit", "1086", "fix", "1084"]},
{"A_title": "Ajax update renders parent/child JS in different order than initial Page renderSee attached quickstart.  On initial page load the child Javascripts are rendered and executed first followed by the parents JS - in this case a Datatables.net JS. Everything works fine.  However if you click on a link in the DefaultDataTable we trigger a DDT refresh via Ajax and then you can see that the parents JS is executed first before the child JS - this causes a problem since the parent JS modifies the visible rows in the table and Wicket can no longer find some of the child rows.  I expected the order of JS contributions to be the same for initial page render and any Ajax updates.", "A_clean_title": ["ajax", "updat", "render", "parent", "child", "js", "differ", "order", "than", "initi", "page", "renderse", "render", "see", "attach", "quickstart", "initi", "page", "load", "child", "javascript", "are", "render", "execut", "first", "follow", "by", "parent", "js", "thi", "case", "datat", "net", "js", "everyth", "work", "fine", "howev", "you", "click", "link", "defaultdatat", "default", "data", "tabl", "we", "trigger", "ddt", "refresh", "via", "ajax", "then", "you", "see", "that", "parent", "js", "execut", "first", "befor", "child", "js", "thi", "caus", "problem", "sinc", "parent", "js", "modifi", "visibl", "row", "tabl", "wicket", "no", "longer", "find", "some", "child", "row", "expect", "order", "js", "contribut", "same", "initi", "page", "render", "ani", "ajax", "updat"], "B_title": "ensure consistent JavaScript ordering with Wickets IHeaderRenderStrategy for Ajax responses and removing special handling of Ajax response in AjaxEventBehavior i.e. not calling appendJavaScript()", "B_clean_title": ["ensur", "consist", "javascript", "java", "script", "order", "wicket", "iheaderrenderstrategi", "header", "render", "strategi", "ajax", "respons", "remov", "special", "handl", "ajax", "respons", "ajaxeventbehavior", "ajax", "event", "behavior", "not", "call", "appendjavascript", "append", "java", "script"]},
{"A_title": "Interaction betwen IAjaxRegionMarkupIdProvider renderPlaceholderTag and visibilityIve just discovered what I think is a bug with IAjaxRegionMarkupIdProvider. We are using it on a Behavior that provides a border to form components (label mandatory marker etc) which for the most part works great.  We have encountered a problem when toggling the visibility of a form component with this behavior via ajax.   The component is first sent out visible and the markup is all correct.  A change elsewhere on the page causes the component to be set to not visible and redrawn via ajax. The ajax response contains a tag with a markupid generated via renderPlaceholderTag. This does not take into account the  IAjaxRegionMarkupIdProvider behaviour.  Another change happens on the page causing the component to become visible and the ajax replace cant happen because the component with the correct markupId is not present.", "A_clean_title": ["interact", "betwen", "iajaxregionmarkupidprovid", "ajax", "region", "markup", "id", "provid", "renderplaceholdertag", "render", "placehold", "tag", "visibility", "visibl", "ive", "just", "discov", "what", "think", "bug", "iajaxregionmarkupidprovid", "ajax", "region", "markup", "id", "provid", "we", "are", "it", "behavior", "that", "provid", "border", "form", "compon", "label", "mandatori", "marker", "etc", "which", "most", "part", "work", "great", "we", "have", "encount", "problem", "when", "toggl", "visibl", "form", "compon", "thi", "behavior", "via", "ajax", "compon", "first", "sent", "out", "visibl", "markup", "all", "correct", "chang", "elsewher", "page", "caus", "compon", "set", "not", "visibl", "redrawn", "via", "ajax", "ajax", "respons", "contain", "tag", "markupid", "gener", "via", "renderplaceholdertag", "render", "placehold", "tag", "thi", "not", "take", "into", "account", "iajaxregionmarkupidprovid", "ajax", "region", "markup", "id", "provid", "behaviour", "anoth", "chang", "happen", "page", "caus", "compon", "becom", "visibl", "ajax", "replac", "cant", "happen", "becaus", "compon", "correct", "markupid", "markup", "id", "not", "present"], "B_title": "Interaction betwen IAjaxRegionMarkupIdProvider renderPlaceholderTag and visibility", "B_clean_title": ["interact", "betwen", "iajaxregionmarkupidprovid", "ajax", "region", "markup", "id", "provid", "renderplaceholdertag", "render", "placehold", "tag", "visibl"]},
{"A_title": ".withHourOfDay() sets hour inconsistantly on DST transition.When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I cant find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.", "A_clean_title": ["withhourofday", "hour", "day", "set", "hour", "inconsistantli", "dst", "transit", "when", "hour", "day", "set", "ambigu", "hour", "daylight", "standard", "time", "transit", "given", "time", "zone", "result", "inconsist", "differ", "time", "zone", "shoul", "hour", "set", "daylight", "hour", "or", "standard", "hour", "all", "time", "zone", "cant", "find", "anyth", "that", "document", "thi", "behavior", "my", "test", "code", "below", "return", "differ", "result", "differ", "time", "zone", "veri", "last", "assert", "fail", "australia", "time", "zone", "cutov"], "B_title": "bugs 310276021824442553453 New method now retains the offset wherever possible during calculations This affects higher methods like withHourOfDay/withMinuteOfHour/withSecondOfMinute/withMillisOfSecond which now do not change offset when called within a DST overlap", "B_clean_title": ["bug", "310276021824442553453", "new", "method", "now", "retain", "offset", "wherev", "possibl", "dure", "calcul", "thi", "affect", "higher", "method", "like", "withhourofday", "withminuteofhour", "withsecondofminut", "withmillisofsecond", "hour", "day", "minut", "hour", "second", "minut", "milli", "second", "which", "now", "not", "chang", "offset", "when", "call", "within", "dst", "overlap"]},
{"A_title": "DateTimeFormatter.parseInto broken when no year in formatIn Joda Time 2.0 the default year was set to 2000 so that Feb 29 could be parsed correctly. However parseInto now overwrites the given instants year with 2000 (or whatever iDefaultYear is set to). The correct behavior would seem to be to use the given instants year instead of iDefaultYear. This does mean that Feb 29 might not be parseable if the instants year is not a leap year but in this case the caller asked for that in a sense.", "A_clean_title": ["datetimeformatt", "parseinto", "date", "time", "formatt", "pars", "into", "broken", "when", "no", "year", "formatin", "format", "joda", "time", "default", "year", "wa", "set", "2000", "so", "that", "feb", "29", "could", "pars", "correctli", "howev", "parseinto", "pars", "into", "now", "overwrit", "given", "instant", "year", "2000", "or", "whatev", "idefaultyear", "default", "year", "set", "correct", "behavior", "would", "seem", "use", "given", "instant", "year", "instead", "idefaultyear", "default", "year", "thi", "mean", "that", "feb", "29", "might", "not", "parseabl", "instant", "year", "not", "leap", "year", "but", "thi", "case", "caller", "ask", "that", "sens"], "B_title": "Fix DateTimeFormatter.parseInto() 3522138", "B_clean_title": ["fix", "datetimeformatt", "parseinto", "date", "time", "formatt", "pars", "into", "3522138"]},
{"A_title": "stacking combiners produces a strange resultPaste the following into your shell:  noformat deletetable test createtable test setiter -t test -p 16 -scan -n test_1 -class org.apache.accumulo.core.iterators.user.SummingCombiner  count:a  STRING setiter -t test -p 17 -scan -n test_2 -class org.apache.accumulo.core.iterators.user.SummingCombiner  count:a  STRING setiter -t test -p 18 -scan -n test_3 -class org.apache.accumulo.core.iterators.user.SummingCombiner  count:a  STRING setiter -t test -p 10 -scan -n test_4 -class org.apache.accumulo.core.iterators.user.SummingCombiner  count  STRING insert row count a 1 insert row count a 1 insert row count b 1 insert row count b 1 insert row count b 1 insert row count c 1 scan noformat  I expect:  noformat row count:a     2 row count:b     3 row count:c     1 noformat  But instead I get this: noformat row count:a     12 noformat", "A_clean_title": ["stack", "combin", "produc", "strang", "resultpast", "result", "past", "follow", "into", "your", "shell", "noformat", "deletet", "test", "createt", "test", "setit", "test", "16", "scan", "test", "class", "org", "apach", "accumulo", "core", "iter", "user", "summingcombin", "sum", "combin", "count", "string", "setit", "test", "17", "scan", "test", "class", "org", "apach", "accumulo", "core", "iter", "user", "summingcombin", "sum", "combin", "count", "string", "setit", "test", "18", "scan", "test", "class", "org", "apach", "accumulo", "core", "iter", "user", "summingcombin", "sum", "combin", "count", "string", "setit", "test", "10", "scan", "test", "class", "org", "apach", "accumulo", "core", "iter", "user", "summingcombin", "sum", "combin", "count", "string", "insert", "row", "count", "insert", "row", "count", "insert", "row", "count", "insert", "row", "count", "insert", "row", "count", "insert", "row", "count", "scan", "noformat", "expect", "noformat", "row", "count", "row", "count", "row", "count", "noformat", "but", "instead", "get", "thi", "noformat", "row", "count", "12", "noformat"], "B_title": "fix combiners over iterators that mutate their top key", "B_clean_title": ["fix", "combin", "over", "iter", "that", "mutat", "their", "top", "key"]},
{"A_title": "MockAccumulo doesnt throw informative errorsUsers are unable to tell if an error has occurred and whether it is due to unimplemented features in MockAccumulo.", "A_clean_title": ["mockaccumulo", "mock", "accumulo", "doesnt", "throw", "inform", "errorsus", "error", "user", "are", "unabl", "tell", "error", "ha", "occur", "whether", "it", "due", "unimpl", "featur", "mockaccumulo", "mock", "accumulo"], "B_title": "employed more TableNotFound / TableExists Exceptions in TableOperations - merged to trunk", "B_clean_title": ["employ", "more", "tablenotfound", "tabl", "not", "found", "tableexist", "tabl", "exist", "except", "tableoper", "tabl", "oper", "merg", "trunk"]},
{"A_title": "Prototype method incorrectly removedNone", "A_clean_title": ["prototyp", "method", "incorrectli", "removednon", "remov", "none"], "B_title": "Fix DisambiguateProperties handling of quoted properties", "B_clean_title": ["fix", "disambiguateproperti", "disambigu", "properti", "handl", "quot", "properti"]},
{"A_title": "MultidimensionalCounter.getCounts(int) returns wrong array of indicesMultidimensionalCounter counter = new MultidimensionalCounter(2 4); for (Integer i : counter)      int x = counter.getCounts;     System.out.println(i +   + Arrays.toString);  Output is: 0 0 0 1 0 1 2 0 2 3 0 2   <=== should be 0 3 4 1 0 5 1 1 6 1 2 7 1 2   <=== should be 1 3", "A_clean_title": ["multidimensionalcount", "getcount", "multidimension", "counter", "get", "count", "int", "return", "wrong", "array", "indicesmultidimensionalcount", "indic", "multidimension", "counter", "counter", "new", "multidimensionalcount", "multidimension", "counter", "integ", "counter", "int", "counter", "getcount", "get", "count", "system", "out", "println", "array", "tostr", "string", "output"], "B_title": "Fixed bug in MultidimensionalCounter. Thanks to James Bence.", "B_clean_title": ["fix", "bug", "multidimensionalcount", "multidimension", "counter", "thank", "jame", "benc"]},
{"A_title": "SimplexSolver returning wrong answer from optimizeSimplexSolver fails for the following linear program:  min 2x1 +15x2 +18x3  Subject to    -x1 +2x2  -6x3 <=-10             x2  +2x3 <= 6    2x1      +10x3 <= 19     -x1  +x2       <= -2     x1x2x3 >= 0  Solution should be x1 = 7 x2 = 0 x3 = 1/2 Objective function = 23  Instead it is returning x1 = 9.5 x2 = 1/8 x3 = 0 Objective function = 20.875  Constraint number 1 is violated by this answer", "A_clean_title": ["simplexsolv", "simplex", "solver", "return", "wrong", "answer", "optimizesimplexsolv", "optim", "simplex", "solver", "fail", "follow", "linear", "program", "min", "2x1", "+15x2", "+18x3", "subject", "x1", "+2x2", "6x3", "10", "x2", "+2x3", "2x1", "+10x3", "19", "x1", "+x2", "x1x2x3", "solut", "x1", "x2", "x3", "object", "function", "23", "instead", "it", "return", "x1", "x2", "x3", "object", "function", "20", "875", "constraint", "number", "violat", "by", "thi", "answer"], "B_title": "Throw a DimensionMismatchException if dimension of constraints and objective function does not match in SimplexSolver.", "B_clean_title": ["throw", "dimensionmismatchexcept", "dimens", "mismatch", "except", "dimens", "constraint", "object", "function", "not", "match", "simplexsolv", "simplex", "solver"]},
{"A_title": "AbstractPersistentProperty.getRawType() does not consider generics DATACMNS-1139opened and commented  AbstractPersistentProperty.getRawType() currently uses the fields or property descriptors type which in turn doesnt use our generics resolution mechanism which means for generic fields youll get different results if you call .getTypeInformation().getType() and .getRawType()   Affects: 1.12.11 (Hopper SR11) 1.13.6 (Ingalls SR6) 2.0 RC2 (Kay)  Backported to:  1.13.7 (Ingalls SR7)  1.12.12 (Hopper SR12)", "A_clean_title": ["abstractpersistentproperti", "getrawtyp", "abstract", "persist", "properti", "get", "raw", "type", "not", "consid", "gener", "datacmn", "1139open", "comment", "abstractpersistentproperti", "getrawtyp", "abstract", "persist", "properti", "get", "raw", "type", "current", "use", "field", "or", "properti", "descriptor", "type", "which", "turn", "doesnt", "use", "our", "gener", "resolut", "mechan", "which", "mean", "gener", "field", "youll", "get", "differ", "result", "you", "call", "gettypeinform", "get", "type", "inform", "gettyp", "get", "type", "getrawtyp", "get", "raw", "type", "affect", "12", "11", "hopper", "sr11", "13", "ingal", "sr6", "rc2", "kay", "backport", "13", "ingal", "sr7", "12", "12", "hopper", "sr12"], "B_title": "DATACMNS-1139 - AbstractPersistentProperty.getRawType() now correctly resolves generics.  Were now favoring the generic TypeInformation over trying to resolve the property type via field or PropertyDescriptor as only the former does proper generic type resolution.", "B_clean_title": ["datacmn", "1139", "abstractpersistentproperti", "getrawtyp", "abstract", "persist", "properti", "get", "raw", "type", "now", "correctli", "resolv", "gener", "were", "now", "favor", "gener", "typeinform", "type", "inform", "over", "tri", "resolv", "properti", "type", "via", "field", "or", "propertydescriptor", "properti", "descriptor", "as", "onli", "former", "proper", "gener", "type", "resolut"]},
{"A_title": "StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters. For example define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as uD840uDC00 private static final String CharU20000 = uD840uDC00; private static final String CharU20001 = uD840uDC01; You can see Unicode supplementary characters correctly implemented in the JRE call: assertEquals(-1 CharU20000.indexOf(CharU20001)); But this is broken: assertEquals(false StringUtils.containsAny(CharU20000 CharU20001)); assertEquals(false StringUtils.containsAny(CharU20001 CharU20000)); This is fine: assertEquals(true StringUtils.contains(CharU20000 + CharU20001 CharU20000)); assertEquals(true StringUtils.contains(CharU20000 + CharU20001 CharU20001)); assertEquals(true StringUtils.contains(CharU20000 CharU20000)); assertEquals(false StringUtils.contains(CharU20000 CharU20001)); because the method calls the JRE to perform the match. More than you want to know:  http://java.sun.com/developer/technicalArticles/Intl/Supplementary/", "A_clean_title": ["stringutil", "string", "util", "method", "not", "handl", "unicod", "0+", "supplementari", "charact", "correctli", "stringutil", "containsani", "string", "util", "contain", "ani", "method", "incorrectli", "match", "unicod", "0+", "supplementari", "charact", "exampl", "defin", "test", "fixtur", "unicod", "charact", "u+20000", "where", "u+20000", "written", "java", "sourc", "as", "ud840udc00", "d840u", "dc00", "privat", "static", "final", "string", "charu20000", "char", "u20000", "ud840udc00", "d840u", "dc00", "privat", "static", "final", "string", "charu20001", "char", "u20001", "ud840udc01", "d840u", "dc01", "you", "see", "unicod", "supplementari", "charact", "correctli", "implement", "jre", "call", "assertequ", "assert", "equal", "charu20000", "indexof", "char", "u20000", "index", "charu20001", "char", "u20001", "but", "thi", "broken", "assertequ", "assert", "equal", "fals", "stringutil", "containsani", "string", "util", "contain", "ani", "charu20000", "char", "u20000", "charu20001", "char", "u20001", "assertequ", "assert", "equal", "fals", "stringutil", "containsani", "string", "util", "contain", "ani", "charu20001", "char", "u20001", "charu20000", "char", "u20000", "thi", "fine", "assertequ", "assert", "equal", "true", "stringutil", "contain", "string", "util", "charu20000", "char", "u20000", "charu20001", "char", "u20001", "charu20000", "char", "u20000", "assertequ", "assert", "equal", "true", "stringutil", "contain", "string", "util", "charu20000", "char", "u20000", "charu20001", "char", "u20001", "charu20001", "char", "u20001", "assertequ", "assert", "equal", "true", "stringutil", "contain", "string", "util", "charu20000", "char", "u20000", "charu20000", "char", "u20000", "assertequ", "assert", "equal", "fals", "stringutil", "contain", "string", "util", "charu20000", "char", "u20000", "charu20001", "char", "u20001", "becaus", "method", "call", "jre", "perform", "match", "more", "than", "you", "want", "know", "http", "sun", "java", "com", "develop", "technicalarticl", "intl", "supplementari", "technic", "articl"], "B_title": "StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters.", "B_clean_title": ["stringutil", "containsani", "string", "util", "contain", "ani", "method", "incorrectli", "match", "unicod", "0+", "supplementari", "charact"]},
{"A_title": "Basic variable is not found correctly in simplex tableauThe last patch to SimplexTableau caused an automated test suite Im running at work to go down a new code path and uncover what is hopefully the last bug remaining in the Simplex code. SimplexTableau was assuming an entry in the tableau had to be nonzero to indicate a basic variable which is incorrect - the entry should have a value equal to 1.", "A_clean_title": ["basic", "variabl", "not", "found", "correctli", "simplex", "tableauth", "tableau", "last", "patch", "simplextableau", "simplex", "tableau", "caus", "autom", "test", "suit", "im", "run", "at", "work", "go", "down", "new", "code", "path", "uncov", "what", "hope", "last", "bug", "remain", "simplex", "code", "simplextableau", "simplex", "tableau", "wa", "assum", "entri", "tableau", "had", "nonzero", "indic", "basic", "variabl", "which", "incorrect", "entri", "have", "valu", "equal"], "B_title": "Fixed a wrong check for basic variables JIRA: MATH-273", "B_clean_title": ["fix", "wrong", "check", "basic", "variabl", "jira", "math", "273"]},
{"A_title": "RealMatrixImpl#operate gets result vector dimensions wrongorg.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix. Thus line 640 in RealMatrixImpl.java should read double out = new doublenRows; instead of double out = new doublev.length;", "A_clean_title": ["realmatriximpl", "real", "matrix", "impl", "oper", "get", "result", "vector", "dimens", "wrongorg", "apach", "common", "math", "linear", "realmatriximpl", "real", "matrix", "impl", "oper", "tri", "creat", "result", "vector", "that", "alway", "ha", "same", "length", "as", "input", "vector", "thi", "result", "runtim", "except", "matrix", "non", "squar", "it", "alway", "yield", "incorrect", "result", "matrix", "non", "squar", "correct", "behaviour", "would", "cours", "creat", "vector", "same", "length", "as", "row", "dimens", "matrix", "thu", "line", "640", "realmatriximpl", "java", "real", "matrix", "impl", "read", "doubl", "out", "new", "doublenrow", "doublen", "row", "instead", "doubl", "out", "new", "doublev", "length"], "B_title": "fixed dimension error in operate method for RealMatrixImpl and BigMatrixImpl JIRA: MATH-209", "B_clean_title": ["fix", "dimens", "error", "oper", "method", "realmatriximpl", "real", "matrix", "impl", "bigmatriximpl", "big", "matrix", "impl", "jira", "math", "209"]},
{"A_title": "master killed a tablet serverMaster killed a tablet server for having long hold times.  The tablet server had this error during minor compaction:  noformat 01 23:57:20073 security.ZKAuthenticator ERROR: org.apache.zookeeper.KeeperException NoNodeException: KeeperErrorCode = NoNode for /accumulo/88cd0f63-a36a-4218-86b1-9ba1d2cccf08/users/user004 org.apache.zookeeper.KeeperException NoNodeException: KeeperErrorCode = NoNode for /accumulo/88cd0f63-a36a-4218-86b1-9ba1d2cccf08/users/user004         at org.apache.zookeeper.KeeperException.create(KeeperException.java:102)         at org.apache.zookeeper.KeeperException.create(KeeperException.java:42)         at org.apache.zookeeper.ZooKeeper.getChildren(ZooKeeper.java:1243)         at org.apache.zookeeper.ZooKeeper.getChildren(ZooKeeper.java:1271)         at org.apache.accumulo.core.zookeeper.ZooUtil.recursiveDelete(ZooUtil.java:103)         at org.apache.accumulo.core.zookeeper.ZooUtil.recursiveDelete(ZooUtil.java:117)         at org.apache.accumulo.server.zookeeper.ZooReaderWriter.recursiveDelete(ZooReaderWriter.java:67)         at sun.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)         at java.lang.reflect.Method.invoke(Method.java:597)         at org.apache.accumulo.server.zookeeper.ZooReaderWriter 1.invoke(ZooReaderWriter.java:169)         at  Proxy4.recursiveDelete(Unknown Source)         at org.apache.accumulo.server.security.ZKAuthenticator.dropUser(ZKAuthenticator.java:252)         at org.apache.accumulo.server.security.Auditor.dropUser(Auditor.java:104)         at org.apache.accumulo.server.client.ClientServiceHandler.dropUser(ClientServiceHandler.java:136)         at sun.reflect.GeneratedMethodAccessor52.invoke(Unknown Source)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)         at java.lang.reflect.Method.invoke(Method.java:597)         at cloudtrace.instrument.thrift.TraceWrap 1.invoke(TraceWrap.java:58)         at  Proxy2.dropUser(Unknown Source)         at org.apache.accumulo.core.client.impl.thrift.ClientService Processor dropUser.process(ClientService.java:2257)         at org.apache.accumulo.core.tabletserver.thrift.TabletClientService Processor.process(TabletClientService.java:2037)         at org.apache.accumulo.server.util.TServerUtils TimedProcessor.process(TServerUtils.java:151)         at org.apache.thrift.server.TNonblockingServer FrameBuffer.invoke(TNonblockingServer.java:631)         at org.apache.accumulo.server.util.TServerUtils THsHaServer Invocation.run(TServerUtils.java:199)         at java.util.concurrent.ThreadPoolExecutor Worker.runTask(ThreadPoolExecutor.java:886)         at java.util.concurrent.ThreadPoolExecutor Worker.run(ThreadPoolExecutor.java:908)         at org.apache.accumulo.core.util.LoggingRunnable.run(LoggingRunnable.java:34)         at java.lang.Thread.run(Thread.java:662)  noformat  This tablet was the result of a split that occurred during a delete.  The master missed this tablet when taking tablets offline.  We need to do a consistency check on the offline tablets before deleting the table information in zookeeper.", "A_clean_title": ["master", "kill", "tablet", "servermast", "server", "master", "kill", "tablet", "server", "have", "long", "hold", "time", "tablet", "server", "had", "thi", "error", "dure", "minor", "compact", "noformat", "01", "23:57:20073", "secur", "zkauthent", "zk", "authent", "error", "org", "apach", "zookeep", "keeperexcept", "keeper", "except", "nonodeexcept", "no", "node", "except", "keepererrorcod", "keeper", "error", "code", "nonod", "no", "node", "a36a", "4218", "86b1", "accumulo", "88cd0f63", "9ba1d2cccf08", "user", "user004", "org", "apach", "zookeep", "keeperexcept", "keeper", "except", "nonodeexcept", "no", "node", "except", "keepererrorcod", "keeper", "error", "code", "nonod", "no", "node", "a36a", "4218", "86b1", "accumulo", "88cd0f63", "9ba1d2cccf08", "user", "user004", "at", "org", "apach", "zookeep", "keeperexcept", "creat", "keeper", "except", "keeperexcept", "java:102", "keeper", "except", "at", "org", "apach", "zookeep", "keeperexcept", "creat", "keeper", "except", "keeperexcept", "java:42", "keeper", "except", "at", "org", "apach", "zookeep", "zookeep", "getchildren", "zoo", "keeper", "get", "children", "zookeep", "java:1243", "zoo", "keeper", "at", "org", "apach", "zookeep", "zookeep", "getchildren", "zoo", "keeper", "get", "children", "zookeep", "java:1271", "zoo", "keeper", "at", "org", "apach", "accumulo", "core", "zookeep", "zooutil", "recursivedelet", "zoo", "util", "recurs", "delet", "zooutil", "java:103", "zoo", "util", "at", "org", "apach", "accumulo", "core", "zookeep", "zooutil", "recursivedelet", "zoo", "util", "recurs", "delet", "zooutil", "java:117", "zoo", "util", "at", "org", "apach", "accumulo", "server", "zookeep", "zooreaderwrit", "recursivedelet", "zoo", "reader", "writer", "recurs", "delet", "zooreaderwrit", "java:67", "zoo", "reader", "writer", "at", "sun", "reflect", "generatedmethodaccessor53", "invok", "gener", "method", "accessor53", "unknown", "sourc", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:597", "at", "org", "apach", "accumulo", "server", "zookeep", "zooreaderwrit", "zoo", "reader", "writer", "invok", "zooreaderwrit", "java:169", "zoo", "reader", "writer", "at", "proxy4", "recursivedelet", "recurs", "delet", "unknown", "sourc", "at", "org", "apach", "accumulo", "server", "secur", "zkauthent", "dropus", "zk", "authent", "drop", "user", "zkauthent", "java:252", "zk", "authent", "at", "org", "apach", "accumulo", "server", "secur", "auditor", "dropus", "drop", "user", "auditor", "java:104", "at", "org", "apach", "accumulo", "server", "client", "clientservicehandl", "dropus", "client", "servic", "handler", "drop", "user", "clientservicehandl", "java:136", "client", "servic", "handler", "at", "sun", "reflect", "generatedmethodaccessor52", "invok", "gener", "method", "accessor52", "unknown", "sourc", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:597", "at", "cloudtrac", "instrument", "thrift", "tracewrap", "trace", "wrap", "invok", "tracewrap", "java:58", "trace", "wrap", "at", "proxy2", "dropus", "drop", "user", "unknown", "sourc", "at", "org", "apach", "accumulo", "core", "client", "impl", "thrift", "clientservic", "client", "servic", "processor", "dropus", "process", "drop", "user", "clientservic", "java:2257", "client", "servic", "at", "org", "apach", "accumulo", "core", "tabletserv", "thrift", "tabletclientservic", "tablet", "client", "servic", "processor", "process", "tabletclientservic", "java:2037", "tablet", "client", "servic", "at", "org", "apach", "accumulo", "server", "util", "tserverutil", "server", "util", "timedprocessor", "process", "time", "processor", "tserverutil", "java:151", "server", "util", "at", "org", "apach", "thrift", "server", "tnonblockingserv", "nonblock", "server", "framebuff", "invok", "frame", "buffer", "tnonblockingserv", "java:631", "nonblock", "server", "at", "org", "apach", "accumulo", "server", "util", "tserverutil", "server", "util", "thshaserv", "hs", "server", "invoc", "run", "tserverutil", "java:199", "server", "util", "at", "java", "util", "concurr", "threadpoolexecutor", "thread", "pool", "executor", "worker", "runtask", "run", "task", "threadpoolexecutor", "java:886", "thread", "pool", "executor", "at", "java", "util", "concurr", "threadpoolexecutor", "thread", "pool", "executor", "worker", "run", "threadpoolexecutor", "java:908", "thread", "pool", "executor", "at", "org", "apach", "accumulo", "core", "util", "loggingrunn", "run", "log", "runnabl", "loggingrunn", "java:34", "log", "runnabl", "at", "java", "lang", "thread", "run", "thread", "java:662", "noformat", "thi", "tablet", "wa", "result", "split", "that", "occur", "dure", "delet", "master", "miss", "thi", "tablet", "when", "take", "tablet", "offlin", "we", "need", "consist", "check", "offlin", "tablet", "befor", "delet", "tabl", "inform", "zookeep"], "B_title": "ACCUMULO-379 ACCUMULO-375 merged from 1.4", "B_clean_title": ["accumulo", "379", "accumulo", "375", "merg"]},
{"A_title": "Keyed State does not work with DOP=1When changing the DOP from 3 to 1 in StatefulOperatorTest.apiTest() the test fails. The reason seems to be that the element is not properly set when chaining is happening.  Also requiring this: code headContext.setNextInput(nextRecord); streamOperator.processElement(nextRecord); code  to be called seems rather fragile. Why not set the element in processElement(). This would also make for cleaner encapsulation since now all outside code must assume that operators have a StreamingRuntimeContext on which they set the next element.  The state/keyed state machinery seems dangerously undertested.", "A_clean_title": ["key", "state", "not", "work", "dop=1when", "chang", "dop", "statefuloperatortest", "apitest", "state", "oper", "test", "api", "test", "test", "fail", "reason", "seem", "that", "element", "not", "properli", "set", "when", "chain", "happen", "also", "requir", "thi", "code", "headcontext", "setnextinput", "head", "context", "set", "next", "input", "nextrecord", "next", "record", "streamoper", "processel", "stream", "oper", "process", "element", "nextrecord", "next", "record", "code", "call", "seem", "rather", "fragil", "whi", "not", "set", "element", "processel", "process", "element", "thi", "would", "also", "make", "cleaner", "encapsul", "sinc", "now", "all", "outsid", "code", "must", "assum", "that", "oper", "have", "streamingruntimecontext", "stream", "runtim", "context", "which", "they", "set", "next", "element", "state", "key", "state", "machineri", "seem", "danger", "undertest"], "B_title": "streaming Fix partitioned state next-input setting for copying chained collectors", "B_clean_title": ["stream", "fix", "partit", "state", "next", "input", "set", "copi", "chain", "collector"]},
{"A_title": "Wildcards in relative property paths dont work in search expressionsA search XPath of the form: code /jcr:root/etc/commerce/products//*@size=M or */@size=M code returns: code Invalid path: * code (This works fine in Jackrabbit.)", "A_clean_title": ["wildcard", "rel", "properti", "path", "dont", "work", "search", "expressionsa", "express", "search", "xpath", "path", "form", "code", "jcr", "root", "etc", "commerc", "product", "size=m", "or", "size=m", "code", "return", "code", "invalid", "path", "code", "thi", "work", "fine", "jackrabbit"], "B_title": "Wildcards in relative property paths dont work in search expressions", "B_clean_title": ["wildcard", "rel", "properti", "path", "dont", "work", "search", "express"]},
{"A_title": "CompactCommand description is incorrectThe compact command has the following description  code root@accumulo> compact -? usage: compact <table> <table> -? -b <begin-row> --cancel -e <end-row> -nf -ns <namespace> | -p <pattern> | -t <tableName>  -pn <profile>  -w description: sets all tablets for a table to major compact as soon as possible (based on current time)   -?--help                       display this help   -b--begin-row <begin-row>      begin row (inclusive)      --cancel                     cancel user initiated compactions   -e--end-row <end-row>          end row (inclusive)   -nf--noFlush                   do not flush table data in memory before compacting.   -ns--namespace <namespace>     name of a namespace to operate on   -p--pattern <pattern>          regex pattern of table names to operate on   -pn--profile <profile>         iterator profile name   -t--table <tableName>          name of a table to operate on   -w--wait                       wait for compact to finish code  However the --begin-row is not inclusive.  Here is a simple demonstration. code createtable compacttest addsplits a b c insert a 1   insert a 2   insert b 3   insert b 4   insert c 5   insert c 6   flush -w scan -t accumulo.metadata -np compact -b a -e c -t compacttest -w scan -t accumulo.metadata -np deletetable compacttest -f code  You will see that file associated with the a split is still a F flush file which the files in the b and c split are A files.  Not sure if the fix is to update the commands description which would be easy or to make the begin row actually inclusive.", "A_clean_title": ["compactcommand", "compact", "command", "descript", "incorrectth", "incorrect", "compact", "command", "ha", "follow", "descript", "code", "root", "accumulo", "compact", "usag", "compact", "tabl", "tabl", "begin", "row", "cancel", "end", "row", "nf", "ns", "namespac", "pattern", "tablenam", "tabl", "name", "pn", "profil", "descript", "set", "all", "tablet", "tabl", "major", "compact", "as", "soon", "as", "possibl", "base", "current", "time", "help", "display", "thi", "help", "begin", "row", "begin", "row", "begin", "row", "inclus", "cancel", "cancel", "user", "initi", "compact", "end", "row", "end", "row", "end", "row", "inclus", "nf", "noflush", "no", "flush", "not", "flush", "tabl", "data", "memori", "befor", "compact", "ns", "namespac", "namespac", "name", "namespac", "oper", "pattern", "pattern", "regex", "pattern", "tabl", "name", "oper", "pn", "profil", "profil", "iter", "profil", "name", "tabl", "tablenam", "tabl", "name", "name", "tabl", "oper", "wait", "wait", "compact", "finish", "code", "howev", "begin", "row", "not", "inclus", "here", "simpl", "demonstr", "code", "createt", "compacttest", "addsplit", "insert", "insert", "insert", "insert", "insert", "insert", "flush", "scan", "accumulo", "metadata", "np", "compact", "compacttest", "scan", "accumulo", "metadata", "np", "deletet", "compacttest", "code", "you", "will", "see", "that", "file", "associ", "split", "still", "flush", "file", "which", "file", "split", "are", "file", "not", "sure", "fix", "updat", "command", "descript", "which", "would", "easi", "or", "make", "begin", "row", "actual", "inclus"], "B_title": "Fix the description of -b options", "B_clean_title": ["fix", "descript", "option"]},
{"A_title": "Link always causes Page to become stateful regardless of visibilityDespite the changes made in WICKET-4468  an invisible Link still causes a Page to become stateful.   The problem seems to be that Component#isStateless does this before even checking the visibility:   if (!getStatelessHint())  return false;    ... and Link#getStatelessHint() just contains just return false .", "A_clean_title": ["link", "alway", "caus", "page", "becom", "state", "regardless", "visibilitydespit", "visibl", "despit", "chang", "made", "wicket", "4468", "invis", "link", "still", "caus", "page", "becom", "state", "problem", "seem", "that", "compon", "isstateless", "stateless", "thi", "befor", "even", "check", "visibl", "getstatelesshint", "get", "stateless", "hint", "return", "fals", "link", "getstatelesshint", "get", "stateless", "hint", "just", "contain", "just", "return", "fals"], "B_title": "Link always causes Page to become stateful regardless of visibility", "B_clean_title": ["link", "alway", "caus", "page", "becom", "state", "regardless", "visibl"]},
{"A_title": "bracket function gives up too earlyIn UnivariateSolverUtils.bracket(...) the search ends prematurely if a = lowerBound which ignores some roots in the interval.", "A_clean_title": ["bracket", "function", "give", "up", "too", "earlyin", "earli", "univariatesolverutil", "bracket", "univari", "solver", "util", "search", "end", "prematur", "lowerbound", "lower", "bound", "which", "ignor", "some", "root", "interv"], "B_title": "bracket function gives up too early", "B_clean_title": ["bracket", "function", "give", "up", "too", "earli"]},
{"A_title": "NPE when using ComponentRenderer.renderComponent on a panel with <wicket:enclosure>Hi  Consider this example: <wicket:panel> <wicket:enclosure child=externalLink> <a wicket:id=externalLink>Link</a> </wicket:enclosure> </wicket:panel>  When trying to render such a panel with ComponentRenderer.renderComponent a NPE is thrown because Wicket try to render Enclosure without initializing it.  Root cause: java.lang.NullPointerException at org.apache.wicket.markup.html.internal.Enclosure.isVisible(Enclosure.java:143) at org.apache.wicket.Component.determineVisibility(Component.java:4363) at org.apache.wicket.Component.internalBeforeRender(Component.java:916) at org.apache.wicket.Component.beforeRender(Component.java:991) at org.apache.wicket.Component.internalPrepareForRender(Component.java:2214) at org.apache.wicket.Component.render(Component.java:2303) at org.apache.wicket.MarkupContainer.renderNext(MarkupContainer.java:1390) at org.apache.wicket.MarkupContainer.renderAll(MarkupContainer.java:1554) at org.apache.wicket.MarkupContainer.renderComponentTagBody(MarkupContainer.java:1529) at org.apache.wicket.MarkupContainer.renderAssociatedMarkup(MarkupContainer.java:689) at org.apache.wicket.markup.html.panel.AssociatedMarkupSourcingStrategy.renderAssociatedMarkup(AssociatedMarkupSourcingStrategy.java:76) at org.apache.wicket.markup.html.panel.PanelMarkupSourcingStrategy.onComponentTagBody(PanelMarkupSourcingStrategy.java:112) at org.apache.wicket.Component.internalRenderComponent(Component.java:2549) ... 29 more  See the attached quickstart.  Ive looked a little into it and it seems that RenderPage (used by ComponentRenderer to render components) is never initialized. Therefore the panels children are never initialized too (see MarkupContainer l.930) and this causes Enclosure to have a null childComponent.  Thanks.", "A_clean_title": ["npe", "when", "componentrender", "rendercompon", "compon", "render", "render", "compon", "panel", "wicket", "enclosur", "hi", "consid", "thi", "exampl", "wicket", "panel", "wicket", "enclosur", "child=externallink", "child=extern", "link", "wicket", "id=externallink", "id=extern", "link", "link", "wicket", "enclosur", "wicket", "panel", "when", "tri", "render", "such", "panel", "componentrender", "rendercompon", "compon", "render", "render", "compon", "npe", "thrown", "becaus", "wicket", "tri", "render", "enclosur", "without", "initi", "it", "root", "caus", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "wicket", "markup", "html", "intern", "enclosur", "isvis", "visibl", "enclosur", "java:143", "at", "org", "apach", "wicket", "compon", "determinevis", "determin", "visibl", "compon", "java:4363", "at", "org", "apach", "wicket", "compon", "internalbeforerend", "intern", "befor", "render", "compon", "java:916", "at", "org", "apach", "wicket", "compon", "beforerend", "befor", "render", "compon", "java:991", "at", "org", "apach", "wicket", "compon", "internalprepareforrend", "intern", "prepar", "render", "compon", "java:2214", "at", "org", "apach", "wicket", "compon", "render", "compon", "java:2303", "at", "org", "apach", "wicket", "markupcontain", "rendernext", "markup", "contain", "render", "next", "markupcontain", "java:1390", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "renderal", "markup", "contain", "render", "all", "markupcontain", "java:1554", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "rendercomponenttagbodi", "markup", "contain", "render", "compon", "tag", "bodi", "markupcontain", "java:1529", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "renderassociatedmarkup", "markup", "contain", "render", "associ", "markup", "markupcontain", "java:689", "markup", "contain", "at", "org", "apach", "wicket", "markup", "html", "panel", "associatedmarkupsourcingstrategi", "renderassociatedmarkup", "associ", "markup", "sourc", "strategi", "render", "associ", "markup", "associatedmarkupsourcingstrategi", "java:76", "associ", "markup", "sourc", "strategi", "at", "org", "apach", "wicket", "markup", "html", "panel", "panelmarkupsourcingstrategi", "oncomponenttagbodi", "panel", "markup", "sourc", "strategi", "compon", "tag", "bodi", "panelmarkupsourcingstrategi", "java:112", "panel", "markup", "sourc", "strategi", "at", "org", "apach", "wicket", "compon", "internalrendercompon", "intern", "render", "compon", "compon", "java:2549", "29", "more", "see", "attach", "quickstart", "ive", "look", "littl", "into", "it", "it", "seem", "that", "renderpag", "render", "page", "use", "by", "componentrender", "compon", "render", "render", "compon", "never", "initi", "therefor", "panel", "children", "are", "never", "initi", "too", "see", "markupcontain", "markup", "contain", "930", "thi", "caus", "enclosur", "have", "null", "childcompon", "child", "compon", "thank"], "B_title": "NPE when using ComponentRenderer.renderComponent on a panel with <wicket:enclosure>", "B_clean_title": ["npe", "when", "componentrender", "rendercompon", "compon", "render", "render", "compon", "panel", "wicket", "enclosur"]},
{"A_title": "LookupTranslator accepts CharSequence as input but fails to work with implementations other than StringThe core of org.apache.commons.lang3.text.translate is a HashMap<CharSequence CharSequence> lookupMap. From the Javadoc of CharSequence (emphasis mine):  This interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore in general undefined. Each object may be implemented by a different class and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map. The current implementation causes code such as the following to not work as expected:  CharSequence cs1 = 1 < 2; CharSequence cs2 = CharBuffer.wrap(1 < 2.toCharArray());  System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs1)); System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2));   ... which gives the following results (but should be identical):  1 &lt; 2 1 < 2   The problem at a minimum is that CharBuffer.equals is even documented in the Javadoc that:  A char buffer is not equal to any other type of object. ... so a lookup on a CharBuffer in the Map will always fail when compared against the String implementations that it contains. An obvious work-around is to instead use something along the lines of either of the following:  System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2.toString())); System.out.println(StringEscapeUtils.escapeHtml4(cs2.toString()));   ... which forces everything back to a String.  However this is not practical when working with large sets of data which would require significant heap allocations and garbage collection concerns.  (As such I was actually trying to use the translate method that outputs to a Writer - but simplified the above examples to omit this.) Another option that Im considering is to use a custom CharSequence wrapper around a char that implements hashCode() and equals() to work with those implemented on String.  (However this will be interesting due to the symmetric assumption - which is further interesting that String.equals is currently implemented using instanceof - even though String is final...)", "A_clean_title": ["lookuptransl", "lookup", "translat", "accept", "charsequ", "char", "sequenc", "as", "input", "but", "fail", "work", "implement", "other", "than", "stringth", "string", "core", "org", "apach", "common", "lang3", "text", "translat", "hashmap", "hash", "map", "charsequ", "char", "sequenc", "charsequ", "char", "sequenc", "lookupmap", "lookup", "map", "javadoc", "charsequ", "char", "sequenc", "emphasi", "mine", "thi", "interfac", "not", "refin", "gener", "contract", "equal", "hashcod", "hash", "code", "method", "result", "compar", "two", "object", "that", "implement", "charsequ", "char", "sequenc", "therefor", "gener", "undefin", "each", "object", "may", "implement", "by", "differ", "class", "there", "no", "guarante", "that", "each", "class", "will", "capabl", "test", "it", "instanc", "equal", "those", "other", "it", "therefor", "inappropri", "use", "arbitrari", "charsequ", "char", "sequenc", "instanc", "as", "element", "set", "or", "as", "key", "map", "current", "implement", "caus", "code", "such", "as", "follow", "not", "work", "as", "expect", "charsequ", "char", "sequenc", "cs1", "charsequ", "char", "sequenc", "cs2", "charbuff", "wrap", "char", "buffer", "tochararray", "char", "array", "system", "out", "println", "stringescapeutil", "translat", "string", "escap", "util", "escap", "html4", "cs1", "system", "out", "println", "stringescapeutil", "translat", "string", "escap", "util", "escap", "html4", "cs2", "which", "give", "follow", "result", "but", "ident", "lt", "problem", "at", "minimum", "that", "charbuff", "equal", "char", "buffer", "even", "document", "javadoc", "that", "char", "buffer", "not", "equal", "ani", "other", "type", "object", "so", "lookup", "charbuff", "char", "buffer", "map", "will", "alway", "fail", "when", "compar", "against", "string", "implement", "that", "it", "contain", "obviou", "work", "around", "instead", "use", "someth", "along", "line", "either", "follow", "system", "out", "println", "stringescapeutil", "translat", "string", "escap", "util", "escap", "html4", "cs2", "tostr", "string", "system", "out", "println", "stringescapeutil", "escapehtml4", "string", "escap", "util", "escap", "html4", "cs2", "tostr", "string", "which", "forc", "everyth", "back", "string", "howev", "thi", "not", "practic", "when", "work", "larg", "set", "data", "which", "would", "requir", "signific", "heap", "alloc", "garbag", "collect", "concern", "as", "such", "wa", "actual", "tri", "use", "translat", "method", "that", "output", "writer", "but", "simplifi", "abov", "exampl", "omit", "thi", "anoth", "option", "that", "im", "consid", "use", "custom", "charsequ", "char", "sequenc", "wrapper", "around", "char", "that", "implement", "hashcod", "hash", "code", "equal", "work", "those", "implement", "string", "howev", "thi", "will", "interest", "due", "symmetr", "assumpt", "which", "further", "interest", "that", "string", "equal", "current", "implement", "instanceof", "even", "though", "string", "final"], "B_title": "Allow LookupTranslator to support CharSequence properly; previously it was working only for CharSequences that implemented hashCode and equals(Object). LANG-882", "B_clean_title": ["allow", "lookuptransl", "lookup", "translat", "support", "charsequ", "char", "sequenc", "properli", "previous", "it", "wa", "work", "onli", "charsequ", "char", "sequenc", "that", "implement", "hashcod", "hash", "code", "equal", "object", "lang", "882"]},
{"A_title": "wicket:border: inconsistency between add() and remove()Assuming c1 is a Border and c2 is some component the following sequence crashes with duplicate addition:  c1.add(c2); c1.remove(c2); c1.add(c2);  The reason for this is that remove() doesnt remove the object from the bodycontainer. The sequence can be made to work by changing the middle line to:  c1.getBodyContainer().remove(c2);  That remove() doesnt look the component from the same container as add() adds it to seems to violate the principle of least astonishment. Unfortunately the Component structure manipulation API has more methods such as swap() size() get() etc. which are final and cant be overridden by Border as they are. It could be best to force all users to use c1.getBodyContainer().add() instead of c1.add() because consistent operation is probably easier to deal with in the long run than behavior that conforms to initial assumptions but has flaws elsewhere.  This ticket suggests removing the overload of add() and documenting the difference in migration guide.", "A_clean_title": ["wicket", "border", "inconsist", "between", "add", "remov", "assum", "c1", "border", "c2", "some", "compon", "follow", "sequenc", "crash", "duplic", "addit", "c1", "add", "c2", "c1", "remov", "c2", "c1", "add", "c2", "reason", "thi", "that", "remov", "doesnt", "remov", "object", "bodycontain", "sequenc", "made", "work", "by", "chang", "middl", "line", "c1", "getbodycontain", "get", "bodi", "contain", "remov", "c2", "that", "remov", "doesnt", "look", "compon", "same", "contain", "as", "add", "add", "it", "seem", "violat", "principl", "least", "astonish", "unfortun", "compon", "structur", "manipul", "api", "ha", "more", "method", "such", "as", "swap", "size", "get", "etc", "which", "are", "final", "cant", "overridden", "by", "border", "as", "they", "are", "it", "could", "best", "forc", "all", "user", "use", "c1", "getbodycontain", "get", "bodi", "contain", "add", "instead", "c1", "add", "becaus", "consist", "oper", "probabl", "easier", "deal", "long", "run", "than", "behavior", "that", "conform", "initi", "assumpt", "but", "ha", "flaw", "elsewher", "thi", "ticket", "suggest", "remov", "overload", "add", "document", "differ", "migrat", "guid"], "B_title": "quickie test fix need to think some more about this :/ Issue: WICKET-3702", "B_clean_title": ["quicki", "test", "fix", "need", "think", "some", "more", "about", "thi", "issu", "wicket", "3702"]},
{"A_title": "StackOverflowError exception when running closure compiler (javascript attached)None", "A_clean_title": ["stackoverflowerror", "stack", "overflow", "error", "except", "when", "run", "closur", "compil", "javascript", "attach", "none"], "B_title": "More recursion unrolling Fixes issue 691", "B_clean_title": ["more", "recurs", "unrol", "fix", "issu", "691"]},
{"A_title": "Optimizer does not push properties out of bulk iterationsFlinks optimizer should be able to reuse interesting properties from outside the loop. In order to do that it is sometimes necessary to append a NoOp node to the step function which recomputes the required properties.  This is currently not working for BulkIterations because the plans with the appended NoOp nodes are not added to the overall list of candidates.  This not only leads to sub-optimal plan selection but sometimes to the rejection of valid jobs. The following job for example will be falsely rejected by flink.  code ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();  DataSet<Tuple1<Long>> input1 = env.generateSequence(1 10).map(new MapFunction<Long Tuple1<Long>>()  @Override public Tuple1<Long> map(Long value) throws Exception  return new Tuple1<>(value);  );  DataSet<Tuple1<Long>> input2 = env.generateSequence(1 10).map(new MapFunction<Long Tuple1<Long>>()  @Override public Tuple1<Long> map(Long value) throws Exception  return new Tuple1<>(value);  );  DataSet<Tuple1<Long>> distinctInput = input1.distinct();  IterativeDataSet<Tuple1<Long>> iteration = distinctInput.iterate(10);  DataSet<Tuple1<Long>> iterationStep = iteration .coGroup(input2) .where(0) .equalTo(0) .with(new CoGroupFunction<Tuple1<Long> Tuple1<Long> Tuple1<Long>>()  @Override public void coGroup( Iterable<Tuple1<Long>> first Iterable<Tuple1<Long>> second Collector<Tuple1<Long>> out) throws Exception  Iterator<Tuple1<Long>> it = first.iterator();  if (it.hasNext())  out.collect(it.next());   );  DataSet<Tuple1<Long>> iterationResult = iteration.closeWith(iterationStep);  iterationResult.output(new DiscardingOutputFormat<Tuple1<Long>>()); code", "A_clean_title": ["optim", "not", "push", "properti", "out", "bulk", "iterationsflink", "iter", "flink", "optim", "abl", "reus", "interest", "properti", "outsid", "loop", "order", "that", "it", "sometim", "necessari", "append", "noop", "no", "op", "node", "step", "function", "which", "recomput", "requir", "properti", "thi", "current", "not", "work", "bulkiter", "bulk", "iter", "becaus", "plan", "append", "noop", "no", "op", "node", "are", "not", "ad", "overal", "list", "candid", "thi", "not", "onli", "lead", "sub", "optim", "plan", "select", "but", "sometim", "reject", "valid", "job", "follow", "job", "exampl", "will", "fals", "reject", "by", "flink", "code", "executionenviron", "execut", "environ", "env", "executionenviron", "getexecutionenviron", "execut", "environ", "get", "execut", "environ", "dataset", "data", "set", "tuple1", "long", "input1", "env", "generatesequ", "gener", "sequenc", "10", "map", "new", "mapfunct", "map", "function", "long", "tuple1", "long", "overrid", "public", "tuple1", "long", "map", "long", "valu", "throw", "except", "return", "new", "tuple1", "valu", "dataset", "data", "set", "tuple1", "long", "input2", "env", "generatesequ", "gener", "sequenc", "10", "map", "new", "mapfunct", "map", "function", "long", "tuple1", "long", "overrid", "public", "tuple1", "long", "map", "long", "valu", "throw", "except", "return", "new", "tuple1", "valu", "dataset", "data", "set", "tuple1", "long", "distinctinput", "distinct", "input", "input1", "distinct", "iterativedataset", "iter", "data", "set", "tuple1", "long", "iter", "distinctinput", "iter", "distinct", "input", "10", "dataset", "data", "set", "tuple1", "long", "iterationstep", "iter", "step", "iter", "cogroup", "co", "group", "input2", "where", "equalto", "equal", "new", "cogroupfunct", "co", "group", "function", "tuple1", "long", "tuple1", "long", "tuple1", "long", "overrid", "public", "void", "cogroup", "co", "group", "iter", "tuple1", "long", "first", "iter", "tuple1", "long", "second", "collector", "tuple1", "long", "out", "throw", "except", "iter", "tuple1", "long", "it", "first", "iter", "it", "hasnext", "ha", "next", "out", "collect", "it", "next", "dataset", "data", "set", "tuple1", "long", "iterationresult", "iter", "result", "iter", "closewith", "close", "iterationstep", "iter", "step", "iterationresult", "output", "iter", "result", "new", "discardingoutputformat", "discard", "output", "format", "tuple1", "long", "code"], "B_title": "optimizer Fix instantiation of bulk iteration candidates", "B_clean_title": ["optim", "fix", "instanti", "bulk", "iter", "candid"]},
{"A_title": "CMAESOptimizer with bounds fits finely near lower bound and coarsely near upper bound.When fitting with bounds the CMAESOptimizer fits finely near the lower bound and coarsely near the upper bound.  This is because it internally maps the fitted parameter range into the interval 01.  The unit of least precision (ulp) between floating point numbers is much smaller near zero than near one.  Thus fits have much better resolution near the lower bound (which is mapped to zero) than the upper bound (which is mapped to one).  I will attach a example program to demonstrate.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "bound", "fit", "fine", "near", "lower", "bound", "coars", "near", "upper", "bound", "when", "fit", "bound", "cmaesoptim", "cmae", "optim", "fit", "fine", "near", "lower", "bound", "coars", "near", "upper", "bound", "thi", "becaus", "it", "intern", "map", "fit", "paramet", "rang", "into", "interv", "01", "unit", "least", "precis", "ulp", "between", "float", "point", "number", "much", "smaller", "near", "zero", "than", "near", "one", "thu", "fit", "have", "much", "better", "resolut", "near", "lower", "bound", "which", "map", "zero", "than", "upper", "bound", "which", "map", "one", "will", "attach", "exampl", "program", "demonstr"], "B_title": "Previous commit was missing a crucial modification (in the repair method) an inconsistency which entailed the failing of some tests. With that modification (thanks to Nikolaus Hansen) it was established that the encode and decode steps were indeed useless. This commit thus removes them and all the code that was necessary only because of those two methods. Finite and infinite can now be freely mixed. Unit tests that depended on those limitations were also removed (thus also the one that was added following MATH-865).", "B_clean_title": ["previou", "commit", "wa", "miss", "crucial", "modif", "repair", "method", "inconsist", "which", "entail", "fail", "some", "test", "that", "modif", "thank", "nikolau", "hansen", "it", "wa", "establish", "that", "encod", "decod", "step", "were", "inde", "useless", "thi", "commit", "thu", "remov", "them", "all", "code", "that", "wa", "necessari", "onli", "becaus", "those", "two", "method", "finit", "infinit", "now", "freeli", "mix", "unit", "test", "that", "depend", "those", "limit", "were", "also", "remov", "thu", "also", "one", "that", "wa", "ad", "follow", "math", "865"]},
{"A_title": "Fix for MultiplePiePlotWhen dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called.", "A_clean_title": ["fix", "multiplepieplotwhen", "multipl", "pie", "plot", "when", "dataset", "pass", "into", "constructor", "multiplepieplot", "multipl", "pie", "plot", "dataset", "not", "wire", "listen", "as", "it", "would", "setdataset", "set", "dataset", "call"], "B_title": "source/org/jfree/chart/plot/MultiplePiePlot.java (MultiplePiePlot(CategoryDataset)): Call setDataset() to ensure that plot registers as a dataset listener.", "B_clean_title": ["java", "sourc", "org", "jfree", "chart", "plot", "multiplepieplot", "multipl", "pie", "plot", "multiplepieplot", "multipl", "pie", "plot", "categorydataset", "categori", "dataset", "call", "setdataset", "set", "dataset", "ensur", "that", "plot", "regist", "as", "dataset", "listen"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Fixed add method to match javadoc contract when one or both addends has NaN parts.", "B_clean_title": ["fix", "add", "method", "match", "javadoc", "contract", "when", "one", "or", "both", "addend", "ha", "nan", "na", "part"]},
{"A_title": "When I upload data with one row data is not uploadedHow to Reproduce  Upload with advanced importer add mode:   eric_de_test_model.xlsx Upload csv in this zip:  eu_bbmri_eric_DE_biobanks.csv.zip Expected behavior  1 row is added to the biobanks table  Observed behavior  Import succeeds 0 rows imported", "A_clean_title": ["when", "upload", "data", "one", "row", "data", "not", "uploadedhow", "upload", "how", "reproduc", "upload", "advanc", "import", "add", "mode", "xlsx", "eric", "de", "test", "model", "upload", "csv", "thi", "zip", "csv", "zip", "eu", "bbmri", "eric", "de", "biobank", "expect", "behavior", "row", "ad", "biobank", "tabl", "observ", "behavior", "import", "succe", "row", "import"], "B_title": "Merge pull request #7274 from dennishendriksen/fix/7183-csvImportRowMissing  Fix #7183 CSV read exception on #values mismatch with #headers", "B_clean_title": ["merg", "pull", "request", "7274", "csvimportrowmiss", "dennishendriksen", "fix", "7183", "csv", "import", "row", "miss", "fix", "7183", "csv", "read", "except", "valu", "mismatch", "header"]},
{"A_title": "FastDateFormats z pattern does not respect timezone of Calendar instances passed to format()The work on LANG-462 has introduced a time zone formatting bug in FastDateFormat in commons-lang3. The problem can be seen by this snippet:  // Always prints timezone name of machines default timezone ignoring TZ // set on calendar even though the printed time itself respects calendars TZ. Calendar myCal = Calendar.getInstance(TimeZone.getTimeZone(US/Central)); System.out.println(FastDateFormat.getInstance(h:mma z).format(myCal));   If you happen to be in US/Central this will print the right thing but just try it with US/Eastern US/Pacific etc.  It will print the time in the correct timezone but the timezone name at the end (the z pattern) will always be the system default timezone.  This is a regression against commons-lang 2.x. Basically when the forced time zone code was removed the TimeZoneNameRule class stopped respecting the Calendar instances timezone and instead now always uses the mTimeZone of the FastDateFormat instance itself (which is only supposed to be used when formatting timezone-less objects such as Date or long). The removal of the forced time zone stuff is surely the right thing to do (it was a mess).  I think the fix is to change the TimeZoneNameRule inner class to not take a TimeZone instance but rather to use the TimeZone on the Calendar instance passed into appendTo() just like TimeZoneNumberRule does.  Presumably then for efficiency one would use the getTimeZoneDisplay() package-static method to quickly retrieve the required timezones display name.", "A_clean_title": ["fastdateformat", "fast", "date", "format", "pattern", "not", "respect", "timezon", "calendar", "instanc", "pass", "format", "work", "lang", "462", "ha", "introduc", "time", "zone", "format", "bug", "fastdateformat", "fast", "date", "format", "common", "lang3", "problem", "seen", "by", "thi", "snippet", "alway", "print", "timezon", "name", "machin", "default", "timezon", "ignor", "tz", "set", "calendar", "even", "though", "print", "time", "itself", "respect", "calendar", "tz", "calendar", "mycal", "my", "cal", "calendar", "getinst", "get", "instanc", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "us", "central", "system", "out", "println", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "mma", "format", "mycal", "my", "cal", "you", "happen", "us", "central", "thi", "will", "print", "right", "thing", "but", "just", "tri", "it", "us", "eastern", "us", "pacif", "etc", "it", "will", "print", "time", "correct", "timezon", "but", "timezon", "name", "at", "end", "pattern", "will", "alway", "system", "default", "timezon", "thi", "regress", "against", "common", "lang", "basic", "when", "forc", "time", "zone", "code", "wa", "remov", "timezonenamerul", "time", "zone", "name", "rule", "class", "stop", "respect", "calendar", "instanc", "timezon", "instead", "now", "alway", "use", "mtimezon", "time", "zone", "fastdateformat", "fast", "date", "format", "instanc", "itself", "which", "onli", "suppos", "use", "when", "format", "timezon", "less", "object", "such", "as", "date", "or", "long", "remov", "forc", "time", "zone", "stuff", "sure", "right", "thing", "it", "wa", "mess", "think", "fix", "chang", "timezonenamerul", "time", "zone", "name", "rule", "inner", "class", "not", "take", "timezon", "time", "zone", "instanc", "but", "rather", "use", "timezon", "time", "zone", "calendar", "instanc", "pass", "into", "appendto", "append", "just", "like", "timezonenumberrul", "time", "zone", "number", "rule", "presum", "then", "effici", "one", "would", "use", "gettimezonedisplay", "get", "time", "zone", "display", "packag", "static", "method", "quickli", "retriev", "requir", "timezon", "display", "name"], "B_title": "FastDateFormats z pattern does not respect timezone of Calendar instances passed to format()", "B_clean_title": ["fastdateformat", "fast", "date", "format", "pattern", "not", "respect", "timezon", "calendar", "instanc", "pass", "format"]},
{"A_title": "IndexCopier might create empty files in case of error occuring while copyingOn some of the setups following logs are seen noformat error.log:12.03.2015 03:53:59.785 *WARN* pool-5-thread-90 org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier Found local copy for _2uv.cfs in MMapDirectory@/mnt/installation/crx-quickstart/repository/index/e5a943cdec3000bd8ce54924fd2070ab5d1d35b9ecf530963a3583d43bf28293/1 lockFactory=NativeFSLockFactory@/mnt/installation/crx-quickstart/repository/index/e5a943cdec3000bd8ce54924fd2070ab5d1d35b9ecf530963a3583d43bf28293/1 but size of local 0 differs from remote 1070972. Content would be read from remote file only error.log:12.03.2015 03:54:02.883 *WARN* pool-5-thread-125 org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier Found local copy for _2rr.si in MMapDirectory@/mnt/installation/crx-quickstart/repository/index/43b36b107f8ce7e162c15b22508aa457ff6ae0083ed3e12d14a7dab67f886def/1 lockFactory=NativeFSLockFactory@/mnt/installation/crx-quickstart/repository/index/43b36b107f8ce7e162c15b22508aa457ff6ae0083ed3e12d14a7dab67f886def/1 but size of local 0 differs from remote 240. Content would be read from remote file only error.log:12.03.2015 03:54:03.467 *WARN* pool-5-thread-132 org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier Found local copy for _2ro_3.del in MMapDirectory@/mnt/installation/crx-quickstart/repository/index/43b36b107f8ce7e162c15b22508aa457ff6ae0083ed3e12d14a7dab67f886def/1 lockFactory=NativeFSLockFactory@/mnt/installation/crx-quickstart/repository/index/43b36b107f8ce7e162c15b22508aa457ff6ae0083ed3e12d14a7dab67f886def/1 but size of local 0 differs from remote 42. Content would be read from remote file only error.log:12.03.2015 03:54:03.737 *WARN* pool-5-thread-135 org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier Found local copy for _2rm_2.del in MMapDirectory@/mnt/installation/crx-quickstart/repository/index/43b36b107f8ce7e162c15b22508aa457ff6ae0083ed3e12d14a7dab67f886def/1 lockFactory=NativeFSLockFactory@/mnt/installation/crx-quickstart/repository/index/43b36b107f8ce7e162c15b22508aa457ff6ae0083ed3e12d14a7dab67f886def/1 but size of local 0 differs from remote 35. Content would be read from remote file only noformat  They indicate that copier has created files of size 0. Looking at the code flow this can happen in case while starting copying some error occurs in between. org.apache.lucene.store.Directory#copy do take care of removing the file in case of error but that is done only for IOException and not for other cases.  As a fix the logic should ensure that local file gets deleted if the copy was not successful", "A_clean_title": ["indexcopi", "index", "copier", "might", "creat", "empti", "file", "case", "error", "occur", "while", "copyingon", "copi", "some", "setup", "follow", "log", "are", "seen", "noformat", "error", "log:12", "03", "2015", "03:53:59", "785", "warn", "pool", "thread", "90", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "indexcopi", "index", "copier", "found", "local", "copi", "cf", "2uv", "mmapdirectori", "map", "directori", "mnt", "instal", "crx", "quickstart", "repositori", "index", "e5a943cdec3000bd8ce54924fd2070ab5d1d35b9ecf530963a3583d43bf28293", "lockfactory=nativefslockfactori", "lock", "factory=n", "fs", "lock", "factori", "mnt", "instal", "crx", "quickstart", "repositori", "index", "e5a943cdec3000bd8ce54924fd2070ab5d1d35b9ecf530963a3583d43bf28293", "but", "size", "local", "differ", "remot", "1070972", "content", "would", "read", "remot", "file", "onli", "error", "log:12", "03", "2015", "03:54:02", "883", "warn", "pool", "thread", "125", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "indexcopi", "index", "copier", "found", "local", "copi", "si", "2rr", "mmapdirectori", "map", "directori", "mnt", "instal", "crx", "quickstart", "repositori", "index", "43b36b107f8ce7e162c15b22508aa457ff6ae0083ed3e12d14a7dab67f886def", "lockfactory=nativefslockfactori", "lock", "factory=n", "fs", "lock", "factori", "mnt", "instal", "crx", "quickstart", "repositori", "index", "43b36b107f8ce7e162c15b22508aa457ff6ae0083ed3e12d14a7dab67f886def", "but", "size", "local", "differ", "remot", "240", "content", "would", "read", "remot", "file", "onli", "error", "log:12", "03", "2015", "03:54:03", "467", "warn", "pool", "thread", "132", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "indexcopi", "index", "copier", "found", "local", "copi", "del", "2ro", "mmapdirectori", "map", "directori", "mnt", "instal", "crx", "quickstart", "repositori", "index", "43b36b107f8ce7e162c15b22508aa457ff6ae0083ed3e12d14a7dab67f886def", "lockfactory=nativefslockfactori", "lock", "factory=n", "fs", "lock", "factori", "mnt", "instal", "crx", "quickstart", "repositori", "index", "43b36b107f8ce7e162c15b22508aa457ff6ae0083ed3e12d14a7dab67f886def", "but", "size", "local", "differ", "remot", "42", "content", "would", "read", "remot", "file", "onli", "error", "log:12", "03", "2015", "03:54:03", "737", "warn", "pool", "thread", "135", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "indexcopi", "index", "copier", "found", "local", "copi", "del", "2rm", "mmapdirectori", "map", "directori", "mnt", "instal", "crx", "quickstart", "repositori", "index", "43b36b107f8ce7e162c15b22508aa457ff6ae0083ed3e12d14a7dab67f886def", "lockfactory=nativefslockfactori", "lock", "factory=n", "fs", "lock", "factori", "mnt", "instal", "crx", "quickstart", "repositori", "index", "43b36b107f8ce7e162c15b22508aa457ff6ae0083ed3e12d14a7dab67f886def", "but", "size", "local", "differ", "remot", "35", "content", "would", "read", "remot", "file", "onli", "noformat", "they", "indic", "that", "copier", "ha", "creat", "file", "size", "look", "at", "code", "flow", "thi", "happen", "case", "while", "start", "copi", "some", "error", "occur", "between", "org", "apach", "lucen", "store", "directori", "copi", "take", "care", "remov", "file", "case", "error", "but", "that", "done", "onli", "ioexcept", "io", "except", "not", "other", "case", "as", "fix", "logic", "ensur", "that", "local", "file", "get", "delet", "copi", "wa", "not", "success"], "B_title": "- IndexCopier might create empty files in case of error occuring while copying", "B_clean_title": ["indexcopi", "index", "copier", "might", "creat", "empti", "file", "case", "error", "occur", "while", "copi"]},
{"A_title": "Regression: Could not find child with id: <ID> in the wicket:enclosure for non-component tagAttached testcase passes with wicket-1.4.1 but fails with 1.4.2 saying:  org.apache.wicket.WicketRuntimeException: Could not find child with id: radio in the wicket:enclosure at org.apache.wicket.markup.html.internal.Enclosure.checkChildComponent(Enclosure.java:210) at org.apache.wicket.markup.html.internal.Enclosure.ensureAllChildrenPresent(Enclosure.java:249) at org.apache.wicket.markup.html.internal.Enclosure.onComponentTagBody(Enclosure.java:169) at org.apache.wicket.Component.renderComponent(Component.java:2626) at org.apache.wicket.MarkupContainer.onRender(MarkupContainer.java:1512) at org.apache.wicket.Component.render(Component.java:2457) at org.apache.wicket.MarkupContainer.autoAdd(MarkupContainer.java:229) at org.apache.wicket.markup.resolver.EnclosureResolver.resolve(EnclosureResolver.java:61) at org.apache.wicket.markup.resolver.ComponentResolvers.resolve(ComponentResolvers.java:81) at org.apache.wicket.MarkupContainer.renderNext(MarkupContainer.java:1418) at org.apache.wicket.MarkupContainer.renderComponentTagBody(MarkupContainer.java:1577) at org.apache.wicket.MarkupContainer.onComponentTagBody(MarkupContainer.java:1501) at org.apache.wicket.Component.renderComponent(Component.java:2626) at org.apache.wicket.MarkupContainer.onRender(MarkupContainer.java:1512) at org.apache.wicket.Component.render(Component.java:2457) at org.apache.wicket.MarkupContainer.renderNext(MarkupContainer.java:1414) at org.apache.wicket.MarkupContainer.renderAll(MarkupContainer.java:1528) at org.apache.wicket.Page.onRender(Page.java:1545) at org.apache.wicket.Component.render(Component.java:2457) at org.apache.wicket.Page.renderPage(Page.java:914) at org.apache.wicket.request.target.component.BookmarkablePageRequestTarget.respond(BookmarkablePageRequestTarget.java:262) at org.apache.wicket.request.AbstractRequestCycleProcessor.respond(AbstractRequestCycleProcessor.java:105) at org.apache.wicket.RequestCycle.processEventsAndRespond(RequestCycle.java:1258) at org.apache.wicket.RequestCycle.step(RequestCycle.java:1329) at org.apache.wicket.RequestCycle.steps(RequestCycle.java:1428) at org.apache.wicket.RequestCycle.request(RequestCycle.java:594) at org.apache.wicket.protocol.http.MockWebApplication.processRequestCycle(MockWebApplication.java:478) at org.apache.wicket.protocol.http.MockWebApplication.processRequestCycle(MockWebApplication.java:390) at org.apache.wicket.util.tester.BaseWicketTester.startPage(BaseWicketTester.java:300) at org.apache.wicket.EnclosurePageTest.testRender(EnclosurePageTest.java:23) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:213) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:140) at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:127) at org.apache.maven.surefire.Surefire.run(Surefire.java:177) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:345) at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1009)", "A_clean_title": ["regress", "could", "not", "find", "child", "id", "id", "wicket", "enclosur", "non", "compon", "tagattach", "tag", "attach", "testcas", "pass", "wicket", "but", "fail", "say", "org", "apach", "wicket", "wicketruntimeexcept", "wicket", "runtim", "except", "could", "not", "find", "child", "id", "radio", "wicket", "enclosur", "at", "org", "apach", "wicket", "markup", "html", "intern", "enclosur", "checkchildcompon", "check", "child", "compon", "enclosur", "java:210", "at", "org", "apach", "wicket", "markup", "html", "intern", "enclosur", "ensureallchildrenpres", "ensur", "all", "children", "present", "enclosur", "java:249", "at", "org", "apach", "wicket", "markup", "html", "intern", "enclosur", "oncomponenttagbodi", "compon", "tag", "bodi", "enclosur", "java:169", "at", "org", "apach", "wicket", "compon", "rendercompon", "render", "compon", "compon", "java:2626", "at", "org", "apach", "wicket", "markupcontain", "onrend", "markup", "contain", "render", "markupcontain", "java:1512", "markup", "contain", "at", "org", "apach", "wicket", "compon", "render", "compon", "java:2457", "at", "org", "apach", "wicket", "markupcontain", "autoadd", "markup", "contain", "auto", "add", "markupcontain", "java:229", "markup", "contain", "at", "org", "apach", "wicket", "markup", "resolv", "enclosureresolv", "resolv", "enclosur", "resolv", "enclosureresolv", "java:61", "enclosur", "resolv", "at", "org", "apach", "wicket", "markup", "resolv", "componentresolv", "resolv", "compon", "resolv", "componentresolv", "java:81", "compon", "resolv", "at", "org", "apach", "wicket", "markupcontain", "rendernext", "markup", "contain", "render", "next", "markupcontain", "java:1418", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "rendercomponenttagbodi", "markup", "contain", "render", "compon", "tag", "bodi", "markupcontain", "java:1577", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "oncomponenttagbodi", "markup", "contain", "compon", "tag", "bodi", "markupcontain", "java:1501", "markup", "contain", "at", "org", "apach", "wicket", "compon", "rendercompon", "render", "compon", "compon", "java:2626", "at", "org", "apach", "wicket", "markupcontain", "onrend", "markup", "contain", "render", "markupcontain", "java:1512", "markup", "contain", "at", "org", "apach", "wicket", "compon", "render", "compon", "java:2457", "at", "org", "apach", "wicket", "markupcontain", "rendernext", "markup", "contain", "render", "next", "markupcontain", "java:1414", "markup", "contain", "at", "org", "apach", "wicket", "markupcontain", "renderal", "markup", "contain", "render", "all", "markupcontain", "java:1528", "markup", "contain", "at", "org", "apach", "wicket", "page", "onrend", "render", "page", "java:1545", "at", "org", "apach", "wicket", "compon", "render", "compon", "java:2457", "at", "org", "apach", "wicket", "page", "renderpag", "render", "page", "page", "java:914", "at", "org", "apach", "wicket", "request", "target", "compon", "bookmarkablepagerequesttarget", "respond", "bookmark", "page", "request", "target", "bookmarkablepagerequesttarget", "java:262", "bookmark", "page", "request", "target", "at", "org", "apach", "wicket", "request", "abstractrequestcycleprocessor", "respond", "abstract", "request", "cycl", "processor", "abstractrequestcycleprocessor", "java:105", "abstract", "request", "cycl", "processor", "at", "org", "apach", "wicket", "requestcycl", "processeventsandrespond", "request", "cycl", "process", "event", "respond", "requestcycl", "java:1258", "request", "cycl", "at", "org", "apach", "wicket", "requestcycl", "step", "request", "cycl", "requestcycl", "java:1329", "request", "cycl", "at", "org", "apach", "wicket", "requestcycl", "step", "request", "cycl", "requestcycl", "java:1428", "request", "cycl", "at", "org", "apach", "wicket", "requestcycl", "request", "request", "cycl", "requestcycl", "java:594", "request", "cycl", "at", "org", "apach", "wicket", "protocol", "http", "mockwebappl", "processrequestcycl", "mock", "web", "applic", "process", "request", "cycl", "mockwebappl", "java:478", "mock", "web", "applic", "at", "org", "apach", "wicket", "protocol", "http", "mockwebappl", "processrequestcycl", "mock", "web", "applic", "process", "request", "cycl", "mockwebappl", "java:390", "mock", "web", "applic", "at", "org", "apach", "wicket", "util", "tester", "basewickettest", "startpag", "base", "wicket", "tester", "start", "page", "basewickettest", "java:300", "base", "wicket", "tester", "at", "org", "apach", "wicket", "enclosurepagetest", "testrend", "enclosur", "page", "test", "test", "render", "enclosurepagetest", "java:23", "enclosur", "page", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:597", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:597", "at", "org", "apach", "maven", "surefir", "junit", "junittestset", "execut", "unit", "test", "set", "junittestset", "java:213", "unit", "test", "set", "at", "org", "apach", "maven", "surefir", "suit", "abstractdirectorytestsuit", "executetestset", "abstract", "directori", "test", "suit", "execut", "test", "set", "abstractdirectorytestsuit", "java:140", "abstract", "directori", "test", "suit", "at", "org", "apach", "maven", "surefir", "suit", "abstractdirectorytestsuit", "execut", "abstract", "directori", "test", "suit", "abstractdirectorytestsuit", "java:127", "abstract", "directori", "test", "suit", "at", "org", "apach", "maven", "surefir", "surefir", "run", "surefir", "java:177", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:597", "at", "org", "apach", "maven", "surefir", "booter", "surefireboot", "runsuitesinprocess", "surefir", "booter", "run", "suit", "process", "surefireboot", "java:345", "surefir", "booter", "at", "org", "apach", "maven", "surefir", "booter", "surefireboot", "main", "surefir", "booter", "surefireboot", "java:1009", "surefir", "booter"], "B_title": "fixed:  Regression: Could not find child with id: <ID> in the wicket:enclosure for non-component tag Issue: WICKET-2506", "B_clean_title": ["fix", "regress", "could", "not", "find", "child", "id", "id", "wicket", "enclosur", "non", "compon", "tag", "issu", "wicket", "2506"]},
{"A_title": "AsyncIndexUpdate may resurrect nodesThere is a race condition in the AsyncIndexUpdate.run() method. The implementation creates a checkpoint used as the after node state for the comparison with the previous checkpoint. In a next step a builder is created from the current root state of the node store. Node removed between the checkpoint call and retrieving the root state may get resurrected by the AsyncIndexUpdate.", "A_clean_title": ["asyncindexupd", "async", "index", "updat", "may", "resurrect", "nodesther", "node", "there", "race", "condit", "asyncindexupd", "run", "async", "index", "updat", "method", "implement", "creat", "checkpoint", "use", "as", "after", "node", "state", "comparison", "previou", "checkpoint", "next", "step", "builder", "creat", "current", "root", "state", "node", "store", "node", "remov", "between", "checkpoint", "call", "retriev", "root", "state", "may", "get", "resurrect", "by", "asyncindexupd", "async", "index", "updat"], "B_title": "AsyncIndexUpdate may resurrect nodes", "B_clean_title": ["asyncindexupd", "async", "index", "updat", "may", "resurrect", "node"]},
{"A_title": "Incorrect boundry matching for MockTableOperations.deleteRowsThe api for deleteRows specifies: Delete rows between (start end but the current implementation for MockTableOperations.deleteRows is implemented as (start end)  Here is the failing test case  code:java public class TestDelete    private static final String INSTANCE = mock;   private static final String TABLE = foo;   private static final String USER = user;   private static final String PASS = password;   private static final Authorizations AUTHS = new Authorizations();    @Test   public void testDelete() throws TableNotFoundException AccumuloException       AccumuloSecurityException TableExistsException       MockInstance mockAcc = new MockInstance(INSTANCE);     Connector conn = mockAcc.getConnector(USER new PasswordToken(PASS));     conn.tableOperations().create(TABLE);     conn.securityOperations().grantTablePermission(USER TABLE TablePermission.READ);     conn.securityOperations().grantTablePermission(USER TABLE TablePermission.WRITE);      Mutation mut = new Mutation(2);     mut.put(colfam colqual value);     BatchWriter writer = conn.createBatchWriter(TABLE new BatchWriterConfig());     writer.addMutation(mut);      Scanner scan = conn.createScanner(TABLE AUTHS);     scan.setRange(new Range(2 2));      assertEquals(1 countRecords(scan));          // this should delete (12      conn.tableOperations().deleteRows(TABLE new Text(1) new Text(2));      scan = conn.createScanner(TABLE AUTHS);     scan.setRange(new Range(2 2));          // this will fail if row 2 exists     assertEquals(0 countRecords(scan));       private int countRecords(Scanner scan)      int cnt = 0;     for (Entry<Key Value> entry : scan)        cnt++;          scan.close();     return cnt;     code", "A_clean_title": ["incorrect", "boundri", "match", "mocktableoper", "deleterowsth", "mock", "tabl", "oper", "delet", "row", "api", "deleterow", "delet", "row", "specifi", "delet", "row", "between", "start", "end", "but", "current", "implement", "mocktableoper", "deleterow", "mock", "tabl", "oper", "delet", "row", "implement", "as", "start", "end", "here", "fail", "test", "case", "code", "java", "public", "class", "testdelet", "test", "delet", "privat", "static", "final", "string", "instanc", "mock", "privat", "static", "final", "string", "tabl", "foo", "privat", "static", "final", "string", "user", "user", "privat", "static", "final", "string", "pass", "password", "privat", "static", "final", "author", "auth", "new", "author", "test", "public", "void", "testdelet", "test", "delet", "throw", "tablenotfoundexcept", "tabl", "not", "found", "except", "accumuloexcept", "accumulo", "except", "accumulosecurityexcept", "accumulo", "secur", "except", "tableexistsexcept", "tabl", "exist", "except", "mockinst", "mock", "instanc", "mockacc", "mock", "acc", "new", "mockinst", "mock", "instanc", "instanc", "connector", "conn", "mockacc", "getconnector", "mock", "acc", "get", "connector", "user", "new", "passwordtoken", "password", "token", "pass", "conn", "tableoper", "tabl", "oper", "creat", "tabl", "conn", "securityoper", "secur", "oper", "granttablepermiss", "grant", "tabl", "permiss", "user", "tabl", "tablepermiss", "read", "tabl", "permiss", "conn", "securityoper", "secur", "oper", "granttablepermiss", "grant", "tabl", "permiss", "user", "tabl", "tablepermiss", "write", "tabl", "permiss", "mutat", "mut", "new", "mutat", "mut", "put", "colfam", "colqual", "valu", "batchwrit", "batch", "writer", "writer", "conn", "createbatchwrit", "creat", "batch", "writer", "tabl", "new", "batchwriterconfig", "batch", "writer", "config", "writer", "addmut", "add", "mutat", "mut", "scanner", "scan", "conn", "createscann", "creat", "scanner", "tabl", "auth", "scan", "setrang", "set", "rang", "new", "rang", "assertequ", "assert", "equal", "countrecord", "count", "record", "scan", "thi", "delet", "12", "conn", "tableoper", "tabl", "oper", "deleterow", "delet", "row", "tabl", "new", "text", "new", "text", "scan", "conn", "createscann", "creat", "scanner", "tabl", "auth", "scan", "setrang", "set", "rang", "new", "rang", "thi", "will", "fail", "row", "exist", "assertequ", "assert", "equal", "countrecord", "count", "record", "scan", "privat", "int", "countrecord", "count", "record", "scanner", "scan", "int", "cnt", "entri", "key", "valu", "entri", "scan", "cnt++", "scan", "close", "return", "cnt", "code"], "B_title": "Fix match boundaries for MockTableOperations.deleteRows to be consistent with actual accumulo instance", "B_clean_title": ["fix", "match", "boundari", "mocktableoper", "deleterow", "mock", "tabl", "oper", "delet", "row", "consist", "actual", "accumulo", "instanc"]},
{"A_title": "Cannot see version with --versionNone", "A_clean_title": ["not", "see", "version", "versionnon", "version", "none"], "B_title": "fix a bug in open-source args parsing. Fixes issue 319.", "B_clean_title": ["fix", "bug", "open", "sourc", "arg", "pars", "fix", "issu", "319"]},
{"A_title": "ArrayUtils.addAll(T array1 T... array2) does not handle mixed types very wellArrayUtils.addAll(T array1 T... array2) does not handle mixed array types very well. The stack trace for  Number st = ArrayUtils.addAll(new Integer 1  new Long 2L ); starts: java.lang.ArrayStoreException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang3.ArrayUtils.addAll(ArrayUtils.java:2962) which is not all that obvious. It would be a lot clearer if the method threw an IlegalArgumentException or similar.", "A_clean_title": ["arrayutil", "addal", "array", "util", "add", "all", "array1", "array2", "not", "handl", "mix", "type", "veri", "wellarrayutil", "addal", "well", "array", "util", "add", "all", "array1", "array2", "not", "handl", "mix", "array", "type", "veri", "well", "stack", "trace", "number", "st", "arrayutil", "addal", "array", "util", "add", "all", "new", "integ", "new", "long", "2l", "start", "java", "lang", "arraystoreexcept", "array", "store", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang3", "arrayutil", "addal", "array", "util", "add", "all", "arrayutil", "java:2962", "array", "util", "which", "not", "all", "that", "obviou", "it", "would", "lot", "clearer", "method", "threw", "ilegalargumentexcept", "ileg", "argument", "except", "or", "similar"], "B_title": "- ArrayUtils.addAll(T array1 T... array2) does not handle mixed types very well Also remove unnecessary main() and suite() from test class", "B_clean_title": ["arrayutil", "addal", "array", "util", "add", "all", "array1", "array2", "not", "handl", "mix", "type", "veri", "well", "also", "remov", "unnecessari", "main", "suit", "test", "class"]},
{"A_title": "Problem with WICKET-4441 and RestartResponseAtInterceptPageExceptionWICKET-4441 introduced an issue when our app has an authorization strategy and user is logged out. If user tries to access a protected url/page RestartResponseAtInterceptPageException is handled by DefaultExceptionMapper and leads to exception page instead of redirecting user.", "A_clean_title": ["problem", "wicket", "4441", "restartresponseatinterceptpageexceptionwicket", "4441", "restart", "respons", "at", "intercept", "page", "except", "wicket", "introduc", "issu", "when", "our", "app", "ha", "author", "strategi", "user", "log", "out", "user", "tri", "access", "protect", "url", "page", "restartresponseatinterceptpageexcept", "restart", "respons", "at", "intercept", "page", "except", "handl", "by", "defaultexceptionmapp", "default", "except", "mapper", "lead", "except", "page", "instead", "redirect", "user"], "B_title": "Problem with WICKET-4441 and RestartResponseAtInterceptPageException", "B_clean_title": ["problem", "wicket", "4441", "restartresponseatinterceptpageexcept", "restart", "respons", "at", "intercept", "page", "except"]},
{"A_title": "Localization messages stops working with validators since 1.4-rc2With the previous 1.3.6 and 1.4-rc1 releases I was capable to restrict a localization message for a validation to only one wicket id e.g. :  in foobar.java RequiredTextField nameTF = new RequiredTextField(name); nameTF.add(StringValidator.lengthBetween(2 255)); nameTF.add(new PatternValidator(^|:*));  and in foobar.properties name.Required=some text name.StringValidator.range=some other text name.PatternValidator=some other text again  So like this I could have to create an another RequiredTextField named password and attach to it a different localization message (for example password.Required=blabla).  But somehow with the 1.4-rc2-5 it looks like that this function is broken it only recognizes the localization text when I remove the name. prefix from my property.", "A_clean_title": ["local", "messag", "stop", "work", "valid", "sinc", "rc2with", "previou", "rc1", "releas", "wa", "capabl", "restrict", "local", "messag", "valid", "onli", "one", "wicket", "id", "foobar", "java", "requiredtextfield", "requir", "text", "field", "nametf", "name", "tf", "new", "requiredtextfield", "requir", "text", "field", "name", "nametf", "add", "name", "tf", "stringvalid", "lengthbetween", "string", "valid", "length", "between", "255", "nametf", "add", "name", "tf", "new", "patternvalid", "pattern", "valid", "foobar", "properti", "name", "required=som", "text", "name", "stringvalid", "range=som", "string", "valid", "other", "text", "name", "patternvalidator=som", "pattern", "validator=som", "other", "text", "again", "so", "like", "thi", "could", "have", "creat", "anoth", "requiredtextfield", "requir", "text", "field", "name", "password", "attach", "it", "differ", "local", "messag", "exampl", "password", "required=blabla", "but", "somehow", "rc2", "it", "look", "like", "that", "thi", "function", "broken", "it", "onli", "recogn", "local", "text", "when", "remov", "name", "prefix", "my", "properti"], "B_title": "Localization messages stops working with validators since 1.4-rc2 Issue: WICKET-2350", "B_clean_title": ["local", "messag", "stop", "work", "valid", "sinc", "rc2", "issu", "wicket", "2350"]},
{"A_title": "BitsStreamGenerator#nextBytes(byte) is wrongSequential calls to the BitsStreamGenerator#nextBytes(byte) must generate the same sequence of bytes no matter by chunks of which size it was divided. This is also how java.util.Random#nextBytes(byte) works.  When nextBytes(byte) is called with a bytes array of length multiple of 4 it makes one unneeded call to next(int) method. This is wrong and produces an inconsistent behavior of classes like MersenneTwister.  I made a new implementation of the BitsStreamGenerator#nextBytes(byte) see attached code.", "A_clean_title": ["bitsstreamgener", "bit", "stream", "gener", "nextbyt", "next", "byte", "byte", "wrongsequenti", "wrong", "sequenti", "call", "bitsstreamgener", "bit", "stream", "gener", "nextbyt", "next", "byte", "byte", "must", "gener", "same", "sequenc", "byte", "no", "matter", "by", "chunk", "which", "size", "it", "wa", "divid", "thi", "also", "how", "java", "util", "random", "nextbyt", "next", "byte", "byte", "work", "when", "nextbyt", "next", "byte", "byte", "call", "byte", "array", "length", "multipl", "it", "make", "one", "unneed", "call", "next", "int", "method", "thi", "wrong", "produc", "inconsist", "behavior", "class", "like", "mersennetwist", "mersenn", "twister", "made", "new", "implement", "bitsstreamgener", "bit", "stream", "gener", "nextbyt", "next", "byte", "byte", "see", "attach", "code"], "B_title": "", "B_clean_title": []},
{"A_title": "Special functions not very accurateThe Gamma and Beta functions return values in double precision but the default epsilon is set to 10e-9. I think that the default should be set to the highest possible accuracy as this is what Id expect to be returned by a double precision routine. Note that the erf function already uses a call to Gamma.regularizedGammaP with an epsilon of 1.0e-15.", "A_clean_title": ["special", "function", "not", "veri", "accurateth", "accur", "gamma", "beta", "function", "return", "valu", "doubl", "precis", "but", "default", "epsilon", "set", "10e", "think", "that", "default", "set", "highest", "possibl", "accuraci", "as", "thi", "what", "id", "expect", "return", "by", "doubl", "precis", "routin", "note", "that", "erf", "function", "alreadi", "use", "call", "gamma", "regularizedgammap", "regular", "gamma", "epsilon", "15", "0e"], "B_title": "Increased default epsilon for Gamma Beta function evaluation. JIRA: MATH-166 Reported and patched by Lukas Theussl", "B_clean_title": ["increas", "default", "epsilon", "gamma", "beta", "function", "evalu", "jira", "math", "166", "report", "patch", "by", "luka", "theussl"]},
{"A_title": "FileMonitoring function throws NPE when location is emptyStreamExecutionEnvironment.readFileStream() does not handle a missing location properly. I would suggest to log that the location is empty and continue running the job.  A test covering the correct behavior is also needed.", "A_clean_title": ["filemonitor", "file", "monitor", "function", "throw", "npe", "when", "locat", "emptystreamexecutionenviron", "readfilestream", "empti", "stream", "execut", "environ", "read", "file", "stream", "not", "handl", "miss", "locat", "properli", "would", "suggest", "log", "that", "locat", "empti", "continu", "run", "job", "test", "cover", "correct", "behavior", "also", "need"], "B_title": "streaming FileMonitoring function logs on empty location", "B_clean_title": ["stream", "filemonitor", "file", "monitor", "function", "log", "empti", "locat"]},
{"A_title": "wrong result in eigen decompositionSome results computed by EigenDecompositionImpl are wrong. The following case computed by Fortran Lapack fails with version 2.0      public void testMathpbx02()           double mainTridiagonal =            7484.860960227216 18405.28129035345 13855.225609560746          10016.708722343366 559.8117399576674 6750.190788301587              71.21428769782159         ;         double secondaryTridiagonal =           -4175.0885704763661975.79558582419945193.178422374075            1995.28665916917975.34535882933804-234.0808002076056         ;          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double refEigenValues =          20654.74489030697441216828.208208485466457         6893.1559126349948206757.083016675340332         5887.79988568855878864.309089923240379         57.992628792736340         ;         RealVector refEigenVectors =          new ArrayRealVector(new double -0.270356342026904 0.852811091326997 0.399639490702077 0.198794657813990 0.019739323307666 0.000106983022327 -0.000001216636321)         new ArrayRealVector(new double 0.179995273578326-0.4028078481530420.7018709935257340.5550582110148880.0680791488982360.000509139115227-0.000007112235617)         new ArrayRealVector(new double -0.399582721284727-0.056629954519333-0.5144064885228270.7111681645185800.2255480812763670.125943999652923-0.004321507456014)         new ArrayRealVector(new double 0.0585157215728210.0102001300577390.063516274916536-0.090696087449378-0.0171484204325970.991318870265707-0.034707338554096)         new ArrayRealVector(new double 0.8552059955375640.327134656629775-0.2653823970605480.2826907290267060.105736068025572-0.0091381266220390.000367751821196)         new ArrayRealVector(new double -0.002913069901144-0.0051775157771010.041906334478672-0.1093159184162580.4361923054567410.0263073156395350.891797507436344)         new ArrayRealVector(new double -0.005738311176435-0.0102076116703780.082662420517928-0.2157338860943680.861606487840411-0.025478530652759-0.451080697503958)         ;          // the following line triggers the exception         EigenDecomposition decomposition =             new EigenDecompositionImpl(mainTridiagonal secondaryTridiagonal MathUtils.SAFE_MIN);          double eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i)              assertEquals(refEigenValuesi eigenValuesi 1.0e-3);             if (refEigenVectorsi.dotProduct(decomposition.getEigenvector(i)) < 0)                  assertEquals(0 refEigenVectorsi.add(decomposition.getEigenvector(i)).getNorm() 1.0e-5);              else                  assertEquals(0 refEigenVectorsi.subtract(decomposition.getEigenvector(i)).getNorm() 1.0e-5);", "A_clean_title": ["wrong", "result", "eigen", "decompositionsom", "decomposit", "some", "result", "comput", "by", "eigendecompositionimpl", "eigen", "decomposit", "impl", "are", "wrong", "follow", "case", "comput", "by", "fortran", "lapack", "fail", "version", "public", "void", "testmathpbx02", "test", "mathpbx02", "doubl", "maintridiagon", "main", "tridiagon", "7484", "860960227216", "18405", "28129035345", "13855", "225609560746", "10016", "708722343366", "559", "8117399576674", "6750", "190788301587", "71", "21428769782159", "doubl", "secondarytridiagon", "secondari", "tridiagon", "4175", "0885704763661975", "79558582419945193", "178422374075", "1995", "28665916917975", "34535882933804", "234", "0808002076056", "refer", "valu", "have", "been", "comput", "routin", "dstemr", "fortran", "librari", "lapack", "version", "doubl", "refeigenvalu", "ref", "eigen", "valu", "20654", "74489030697441216828", "208208485466457", "6893", "1559126349948206757", "083016675340332", "5887", "79988568855878864", "309089923240379", "57", "992628792736340", "realvector", "real", "vector", "refeigenvector", "ref", "eigen", "vector", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "270356342026904", "852811091326997", "399639490702077", "198794657813990", "019739323307666", "000106983022327", "000001216636321", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "179995273578326", "4028078481530420", "7018709935257340", "5550582110148880", "0680791488982360", "000509139115227", "000007112235617", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "399582721284727", "056629954519333", "5144064885228270", "7111681645185800", "2255480812763670", "125943999652923", "004321507456014", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "0585157215728210", "0102001300577390", "063516274916536", "090696087449378", "0171484204325970", "991318870265707", "034707338554096", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "8552059955375640", "327134656629775", "2653823970605480", "2826907290267060", "105736068025572", "0091381266220390", "000367751821196", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "002913069901144", "0051775157771010", "041906334478672", "1093159184162580", "4361923054567410", "0263073156395350", "891797507436344", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "005738311176435", "0102076116703780", "082662420517928", "2157338860943680", "861606487840411", "025478530652759", "451080697503958", "follow", "line", "trigger", "except", "eigendecomposit", "eigen", "decomposit", "decomposit", "new", "eigendecompositionimpl", "eigen", "decomposit", "impl", "maintridiagon", "main", "tridiagon", "secondarytridiagon", "secondari", "tridiagon", "mathutil", "math", "util", "safe", "min", "doubl", "eigenvalu", "eigen", "valu", "decomposit", "getrealeigenvalu", "get", "real", "eigenvalu", "int", "refeigenvalu", "length", "ref", "eigen", "valu", "++i", "assertequ", "assert", "equal", "refeigenvaluesi", "ref", "eigen", "valuesi", "eigenvaluesi", "eigen", "valuesi", "0e", "refeigenvectorsi", "dotproduct", "ref", "eigen", "vectorsi", "dot", "product", "decomposit", "geteigenvector", "get", "eigenvector", "assertequ", "assert", "equal", "refeigenvectorsi", "add", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "assertequ", "assert", "equal", "refeigenvectorsi", "subtract", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e"], "B_title": "Fixed an index computation error in eigen decomposition. Once again kudos to Dimitri for debugging this. JIRA: MATH-318", "B_clean_title": ["fix", "index", "comput", "error", "eigen", "decomposit", "onc", "again", "kudo", "dimitri", "debug", "thi", "jira", "math", "318"]},
{"A_title": "CtTypeReferenceImpl#getSuperClass() fails in noClasspath modeThe method has the following implementation:   As you can see it doesnt check for noClasspath and thus may fail when calling  getActualClass() .", "A_clean_title": ["cttypereferenceimpl", "ct", "type", "refer", "impl", "getsuperclass", "get", "super", "class", "fail", "noclasspath", "no", "classpath", "modeth", "mode", "method", "ha", "follow", "implement", "as", "you", "see", "it", "doesnt", "check", "noclasspath", "no", "classpath", "thu", "may", "fail", "when", "call", "getactualclass", "get", "actual", "class"], "B_title": "fix: getSuperClass does not throw exception in noClassPath mode. (#1128)  Fix #1125", "B_clean_title": ["fix", "getsuperclass", "get", "super", "class", "not", "throw", "except", "noclasspath", "no", "class", "path", "mode", "1128", "fix", "1125"]},
{"A_title": "ParentNotInitializedException when processing comments with -cI am aware that comments can be processed using the command -c  since Spoon 5.2.0. Thanks for this feature.  When using Spoon to process comments in either code snippet below ParentNotInitializedException will be thrown. An empty processor can be used to reproduce this issue. This happens in both Spoon 5.2 and 5.4.  public class Comment_1      public class Comment2      Details of the exception are as follows.  spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/home/jifeng/workspace/Temp4/src/main/java/example/Comment1.java:17)  at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:284) at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:377) at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:131) at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:96) at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:387) at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:116) at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:99) at spoon.Launcher.buildModel(Launcher.java:712) at spoon.Launcher.run(Launcher.java:663) at spoon.Launcher.run(Launcher.java:106) at spoon.Launcher.main(Launcher.java:99)", "A_clean_title": ["parentnotinitializedexcept", "parent", "not", "initi", "except", "when", "process", "comment", "ci", "am", "awar", "that", "comment", "process", "command", "sinc", "spoon", "thank", "thi", "featur", "when", "spoon", "process", "comment", "either", "code", "snippet", "below", "parentnotinitializedexcept", "parent", "not", "initi", "except", "will", "thrown", "empti", "processor", "use", "reproduc", "thi", "issu", "thi", "happen", "both", "spoon", "public", "class", "comment", "public", "class", "comment2", "detail", "except", "are", "as", "follow", "spoon", "reflect", "declar", "parentnotinitializedexcept", "parent", "not", "initi", "except", "parent", "not", "initi", "class", "spoon", "support", "reflect", "code", "ctcommentimpl", "ct", "comment", "impl", "java:17", "home", "jifeng", "workspac", "temp4", "src", "main", "java", "exampl", "comment1", "at", "spoon", "support", "reflect", "declar", "ctelementimpl", "getpar", "ct", "element", "impl", "get", "parent", "ctelementimpl", "java:284", "ct", "element", "impl", "at", "spoon", "support", "compil", "jdt", "jdtcommentbuild", "insertcommentinast", "jdt", "comment", "builder", "insert", "comment", "ast", "jdtcommentbuild", "java:377", "jdt", "comment", "builder", "at", "spoon", "support", "compil", "jdt", "jdtcommentbuild", "buildcom", "jdt", "comment", "builder", "build", "comment", "jdtcommentbuild", "java:131", "jdt", "comment", "builder", "at", "spoon", "support", "compil", "jdt", "jdtcommentbuild", "build", "jdt", "comment", "builder", "jdtcommentbuild", "java:96", "jdt", "comment", "builder", "at", "spoon", "support", "compil", "jdt", "jdtbasedspooncompil", "buildsourc", "jdt", "base", "spoon", "compil", "build", "sourc", "jdtbasedspooncompil", "java:387", "jdt", "base", "spoon", "compil", "at", "spoon", "support", "compil", "jdt", "jdtbasedspooncompil", "build", "jdt", "base", "spoon", "compil", "jdtbasedspooncompil", "java:116", "jdt", "base", "spoon", "compil", "at", "spoon", "support", "compil", "jdt", "jdtbasedspooncompil", "build", "jdt", "base", "spoon", "compil", "jdtbasedspooncompil", "java:99", "jdt", "base", "spoon", "compil", "at", "spoon", "launcher", "buildmodel", "build", "model", "launcher", "java:712", "at", "spoon", "launcher", "run", "launcher", "java:663", "at", "spoon", "launcher", "run", "launcher", "java:106", "at", "spoon", "launcher", "main", "launcher", "java:99"], "B_title": "fix(comment): fix bug in comments in array initialization (#1088)  Closes #1073", "B_clean_title": ["fix", "comment", "fix", "bug", "comment", "array", "initi", "1088", "close", "1073"]},
{"A_title": "MoveDetector does not detect moved nodes that have been moved in an earlier commit alreadyNone", "A_clean_title": ["movedetector", "move", "detector", "not", "detect", "move", "node", "that", "have", "been", "move", "earlier", "commit", "alreadynon", "alreadi", "none"], "B_title": "MoveDetector does not detect moved nodes that have been moved in an earlier commit already Properly annotate moved node in the face of moves from earlier commits", "B_clean_title": ["movedetector", "move", "detector", "not", "detect", "move", "node", "that", "have", "been", "move", "earlier", "commit", "alreadi", "properli", "annot", "move", "node", "face", "move", "earlier", "commit"]},
{"A_title": "goog.addSingletonGetter prevents unused class removalNone", "A_clean_title": ["goog", "addsingletongett", "add", "singleton", "getter", "prevent", "unus", "class", "removalnon", "remov", "none"], "B_title": "Remove addSingletonGetter stragglers. Fixes issue 668", "B_clean_title": ["remov", "addsingletongett", "add", "singleton", "getter", "straggler", "fix", "issu", "668"]},
{"A_title": "ResourceUtils.getLocaleFromFilename cant handle minimized resources wellI think the ResourceUtils.getLocaleFromFilename(String path) has the order of locale and minimization wrong: It currently parses: File.min_Lang_Coun_Var.ext while the typical convention is File_Lang_Coun_Var.min.ext Surely considering the ResourceUtils.getMinifiedName() method which does work according to convention.", "A_clean_title": ["resourceutil", "getlocalefromfilenam", "resourc", "util", "get", "local", "filenam", "cant", "handl", "minim", "resourc", "welli", "well", "think", "resourceutil", "getlocalefromfilenam", "resourc", "util", "get", "local", "filenam", "string", "path", "ha", "order", "local", "minim", "wrong", "it", "current", "pars", "file", "ext", "min", "lang", "coun", "var", "while", "typic", "convent", "min", "ext", "file", "lang", "coun", "var", "sure", "consid", "resourceutil", "getminifiednam", "resourc", "util", "get", "minifi", "name", "method", "which", "work", "accord", "convent"], "B_title": "Fixed locale from resource filename", "B_clean_title": ["fix", "local", "resourc", "filenam"]},
{"A_title": "WebSocketRequestHandler is not set as a scheduled and thus RequestCycle#find(AjaxRequestTarget.class) doesnt workAs discussed at https://groups.google.com/d/topic/wicket-jquery-ui/fw6TdyO5o18/discussion AbstractWebSocketProcessor doesnt schedules the WebSocketRequestHandler in the request cycle and thus it is not reachable for user code via RequestCycle#find(Class) API.  Additionally the configured application RequestCycle listeners are not notified.", "A_clean_title": ["websocketrequesthandl", "web", "socket", "request", "handler", "not", "set", "as", "schedul", "thu", "requestcycl", "request", "cycl", "find", "ajaxrequesttarget", "class", "ajax", "request", "target", "doesnt", "worka", "work", "as", "discuss", "at", "http", "jqueri", "googl", "ui", "fw6tdyo5o18", "discuss", "group", "com", "topic", "wicket", "fw6tdi", "o5o18", "abstractwebsocketprocessor", "abstract", "web", "socket", "processor", "doesnt", "schedul", "websocketrequesthandl", "web", "socket", "request", "handler", "request", "cycl", "thu", "it", "not", "reachabl", "user", "code", "via", "requestcycl", "request", "cycl", "find", "class", "api", "addit", "configur", "applic", "requestcycl", "request", "cycl", "listen", "are", "not", "notifi"], "B_title": "WebSocketRequestHandler is not set as a scheduled and thus RequestCycle#find(AjaxRequestTarget.class) doesnt work", "B_clean_title": ["websocketrequesthandl", "web", "socket", "request", "handler", "not", "set", "as", "schedul", "thu", "requestcycl", "request", "cycl", "find", "ajaxrequesttarget", "class", "ajax", "request", "target", "doesnt", "work"]},
{"A_title": "ServletWebResponse#encodeUrl() makes absolute Urls relativeWhen an absolute (full) URL is passed to ServletWebResponse#encodeUrl() it will be returned relative if the container encodes a session ID.", "A_clean_title": ["servletwebrespons", "servlet", "web", "respons", "encodeurl", "encod", "url", "make", "absolut", "url", "relativewhen", "rel", "when", "absolut", "full", "url", "pass", "servletwebrespons", "servlet", "web", "respons", "encodeurl", "encod", "url", "it", "will", "return", "rel", "contain", "encod", "session", "id"], "B_title": "absolute URLs stay absolute after encoding", "B_clean_title": ["absolut", "url", "ur", "ls", "stay", "absolut", "after", "encod"]},
{"A_title": "DataStoreBlobStore does not take into maxLastModifiedTime when fetching all chunksCurrently the DataStoreBlobStore has a pending TODO  code  @Override     public Iterator<String> getAllChunkIds(long maxLastModifiedTime) throws Exception          //TODO Ignores the maxLastModifiedTime currently.         return Iterators.transform(delegate.getAllIdentifiers() new Function<DataIdentifier String>()              @Nullable             @Override             public String apply(@Nullable DataIdentifier input)                  return input.toString();                      );      code  Due to this it currently returns all blobId. This would issue when new binary gets created while a blob gc is running as such binaries might be considered orphan and deleted", "A_clean_title": ["datastoreblobstor", "data", "store", "blob", "store", "not", "take", "into", "maxlastmodifiedtim", "max", "last", "modifi", "time", "when", "fetch", "all", "chunkscurr", "chunk", "current", "datastoreblobstor", "data", "store", "blob", "store", "ha", "pend", "todo", "code", "overrid", "public", "iter", "string", "getallchunkid", "get", "all", "chunk", "id", "long", "maxlastmodifiedtim", "max", "last", "modifi", "time", "throw", "except", "todo", "ignor", "maxlastmodifiedtim", "max", "last", "modifi", "time", "current", "return", "iter", "transform", "deleg", "getallidentifi", "get", "all", "identifi", "new", "function", "dataidentifi", "data", "identifi", "string", "nullabl", "overrid", "public", "string", "appli", "nullabl", "dataidentifi", "data", "identifi", "input", "return", "input", "tostr", "string", "code", "due", "thi", "it", "current", "return", "all", "blobid", "blob", "id", "thi", "would", "issu", "when", "new", "binari", "get", "creat", "while", "blob", "gc", "run", "as", "such", "binari", "might", "consid", "orphan", "delet"], "B_title": "- DataStoreBlobStore does not take into maxLastModifiedTime when fetching all chunks", "B_clean_title": ["datastoreblobstor", "data", "store", "blob", "store", "not", "take", "into", "maxlastmodifiedtim", "max", "last", "modifi", "time", "when", "fetch", "all", "chunk"]},
{"A_title": "Failing HTTPS redirect to RequireHttps annotated pages with ONE_PASS_RENDER strategyActivated JS: Start the quickstart -> Press the submit buttons -> See the secured page with https!  Deactivates JS: (NoScript Firefox Plugin): Start the quickstart -> Press the submit buttons -> See the secured page BUT with HTTP!  There was no proper https redirect.  If I change the rendering strategy to REDIRECT_TO_BUFFER everything works fine but if I change the strategy to ONE_PASS_RENDER the https forwarding doest work anymore. But only if I deactivate all scripts...  Regards Dmitriy", "A_clean_title": ["fail", "http", "redirect", "requirehttp", "requir", "http", "annot", "page", "one", "pass", "render", "strategyactiv", "strategi", "activ", "js", "start", "quickstart", "press", "submit", "button", "see", "secur", "page", "http", "deactiv", "js", "noscript", "no", "script", "firefox", "plugin", "start", "quickstart", "press", "submit", "button", "see", "secur", "page", "but", "http", "there", "wa", "no", "proper", "http", "redirect", "chang", "render", "strategi", "redirect", "buffer", "everyth", "work", "fine", "but", "chang", "strategi", "one", "pass", "render", "http", "forward", "doest", "work", "anymor", "but", "onli", "deactiv", "all", "script", "regard", "dmitriy"], "B_title": "Failing HTTPS redirect to RequireHttps annotated pages with ONE_PASS_RENDER strategy", "B_clean_title": ["fail", "http", "redirect", "requirehttp", "requir", "http", "annot", "page", "one", "pass", "render", "strategi"]},
{"A_title": "BSPTree class and recovery of a Euclidean 3D BRepNew to the work here. Thanks for your efforts on this code. I create a BSPTree from a BoundaryRep (Brep) my test Brep is a cube as represented by a float array containing 8 3D points in(xyz) order and an array of indices (12 triplets for the 12 faces of the cube). I construct a BSPMesh() as shown in the code below. I can construct the PolyhedronsSet() but have problems extracting the faces from the BSPTree to reconstruct the BRep. The attached code (BSPMesh2.java) shows that a small change to 1 of the vertex positions causes/corrects the problem. Any ideas?", "A_clean_title": ["bsptree", "bsp", "tree", "class", "recoveri", "euclidean", "3d", "brepnew", "rep", "new", "work", "here", "thank", "your", "effort", "thi", "code", "creat", "bsptree", "bsp", "tree", "boundaryrep", "boundari", "rep", "brep", "my", "test", "brep", "cube", "as", "repres", "by", "float", "array", "contain", "3d", "point", "xyz", "order", "array", "indic", "12", "triplet", "12", "face", "cube", "construct", "bspmesh", "bsp", "mesh", "as", "shown", "code", "below", "construct", "polyhedronsset", "polyhedron", "set", "but", "have", "problem", "extract", "face", "bsptree", "bsp", "tree", "reconstruct", "brep", "rep", "attach", "code", "bspmesh2", "java", "bsp", "mesh2", "show", "that", "small", "chang", "vertex", "posit", "caus", "correct", "problem", "ani", "idea"], "B_title": "Fixed a wrong assumption on BSP tree attributes.", "B_clean_title": ["fix", "wrong", "assumpt", "bsp", "tree", "attribut"]},
{"A_title": "AjaxRequestAttributes extra parameters arent properly handled in getCallbackFunction()extra parameters of an Ajax behaviour can be accessed by getRequest().getRequestParameters().getParameterValue(key)  but if one uses getCallbackFunction() of an AbstractDefaultAjaxBehavior these parameters get screwed and can no longer be accessed in the same manner.   the problem seems to be the merge in attrs.ep = Wicket.merge(attrs.ep params);", "A_clean_title": ["ajaxrequestattribut", "ajax", "request", "attribut", "extra", "paramet", "arent", "properli", "handl", "getcallbackfunct", "get", "callback", "function", "extra", "paramet", "ajax", "behaviour", "access", "by", "getrequest", "get", "request", "getrequestparamet", "get", "request", "paramet", "getparametervalu", "get", "paramet", "valu", "key", "but", "one", "use", "getcallbackfunct", "get", "callback", "function", "abstractdefaultajaxbehavior", "abstract", "default", "ajax", "behavior", "these", "paramet", "get", "screw", "no", "longer", "access", "same", "manner", "problem", "seem", "merg", "attr", "ep", "wicket", "merg", "attr", "ep", "param"], "B_title": "AjaxRequestAttributes extra parameters arent properly handled in getCallbackFunction()", "B_clean_title": ["ajaxrequestattribut", "ajax", "request", "attribut", "extra", "paramet", "arent", "properli", "handl", "getcallbackfunct", "get", "callback", "function"]},
{"A_title": "IndexOutOfBoundsException when PropertyResolver is using an invalid list indexWhen using  PropertyResolver.getValue(myList1 myBean)  the PropertyResolver ListGetSet.getValue() (line 762) unconditionally does: return ((List)object).get(index); which throws an   java.lang.IndexOutOfBoundsException: Index: 1 Size: 1  if the backing list contains only one element (at index 0). Shouldnt the implementation rather return null like with every other property not found? Like when using bla.bli.blo as a lookup string and there is no bla field and no getBla() method?  So this method should rather be:  org.apache.wicket.util.lang.PropertyResolver ListGetSet.getValue():  /**  * @see org.apache.wicket.util.lang.PropertyResolver.IGetAndSet#getValue(java.lang.Object)  */ public Object getValue(Object object)  List list = (List) object; if (index >= list.size())  return null;  return list.get(index);", "A_clean_title": ["indexoutofboundsexcept", "index", "out", "bound", "except", "when", "propertyresolv", "properti", "resolv", "invalid", "list", "indexwhen", "index", "when", "propertyresolv", "getvalu", "properti", "resolv", "get", "valu", "mylist1", "my", "list1", "mybean", "my", "bean", "propertyresolv", "properti", "resolv", "listgetset", "getvalu", "list", "get", "set", "get", "valu", "line", "762", "uncondit", "return", "list", "object", "get", "index", "which", "throw", "java", "lang", "indexoutofboundsexcept", "index", "out", "bound", "except", "index", "size", "back", "list", "contain", "onli", "one", "element", "at", "index", "shouldnt", "implement", "rather", "return", "null", "like", "everi", "other", "properti", "not", "found", "like", "when", "bla", "bli", "blo", "as", "lookup", "string", "there", "no", "bla", "field", "no", "getbla", "get", "bla", "method", "so", "thi", "method", "rather", "org", "apach", "wicket", "util", "lang", "propertyresolv", "properti", "resolv", "listgetset", "getvalu", "list", "get", "set", "get", "valu", "see", "org", "apach", "wicket", "util", "lang", "propertyresolv", "igetandset", "properti", "resolv", "get", "set", "getvalu", "get", "valu", "java", "lang", "object", "public", "object", "getvalu", "get", "valu", "object", "object", "list", "list", "list", "object", "index", "list", "size", "return", "null", "return", "list", "get", "index"], "B_title": "IndexOutOfBoundsException when PropertyResolver is using an invalid list index PropertyModel does not support index only property (0) Issue: WICKET-23372354", "B_clean_title": ["indexoutofboundsexcept", "index", "out", "bound", "except", "when", "propertyresolv", "properti", "resolv", "invalid", "list", "index", "propertymodel", "properti", "model", "not", "support", "index", "onli", "properti", "issu", "wicket", "23372354"]},
{"A_title": "Item names starting with X cause RepositoryExceptionThe exception is RepositoryException: Invalid name or path: 0 foo  E.g. for an item named 0 foo.  I guess oak-jcr tries to interpret it as a name in expanded form but does not find a namespace uri for 0. IIRC these names are valid in Jackrabbit 2.x.", "A_clean_title": ["item", "name", "start", "caus", "repositoryexceptionth", "repositori", "except", "except", "repositoryexcept", "repositori", "except", "invalid", "name", "or", "path", "foo", "item", "name", "foo", "guess", "oak", "jcr", "tri", "interpret", "it", "as", "name", "expand", "form", "but", "not", "find", "namespac", "uri", "iirc", "these", "name", "are", "valid", "jackrabbit"], "B_title": "Item names starting with X cause RepositoryException", "B_clean_title": ["item", "name", "start", "caus", "repositoryexcept", "repositori", "except"]},
{"A_title": "fix proposal for #114None", "A_clean_title": ["fix", "propos", "114none"], "B_title": "Fixed issue 138 again hopefully this time forever :)", "B_clean_title": ["fix", "issu", "138", "again", "hope", "thi", "time", "forev"]},
{"A_title": "FileResourceStream returns unknown content typeSee http://apache-wicket.1842946.n4.nabble.com/PackageResourceReference-and-Doctype-in-Markup-file-tp3889467p3889587.html  The response for FileResourceStreams returns an unknown content type for css- and image-files. Correct content types should be text/css and image/png (see also attached quickstart).", "A_clean_title": ["fileresourcestream", "file", "resourc", "stream", "return", "unknown", "content", "typese", "type", "see", "http", "doctyp", "markup", "file", "apach", "wicket", "1842946", "n4", "nabbl", "tp3889467p3889587", "html", "com", "packageresourcerefer", "packag", "resourc", "refer", "respons", "fileresourcestream", "file", "resourc", "stream", "return", "unknown", "content", "type", "css", "imag", "file", "correct", "content", "type", "text", "css", "imag", "png", "see", "also", "attach", "quickstart"], "B_title": "FileResourceStream returns unknown content type", "B_clean_title": ["fileresourcestream", "file", "resourc", "stream", "return", "unknown", "content", "type"]},
{"A_title": "fieldsGrouping for multiple output streams failsIf a Spout or Bolt declares multiple output streams and another Bolt connects to one of those streams via fieldsGrouping  the call to FlinkTopologyBuilder.createTopology() fails with the following exception:  noformat org.apache.flink.api.common.InvalidProgramException: Specifying keys via field positions is only valid for tuple data types. Type: PojoType<org.apache.flink.stormcompatibility.util.SplitStreamType fields = streamId: String value: GenericType<java.lang.Object>> at org.apache.flink.api.java.operators.Keys ExpressionKeys.<init>(Keys.java:209) at org.apache.flink.api.java.operators.Keys ExpressionKeys.<init>(Keys.java:203) at org.apache.flink.streaming.api.datastream.DataStream.groupBy(DataStream.java:285) at org.apache.flink.stormcompatibility.api.FlinkTopologyBuilder.createTopology(FlinkTopologyBuilder.java:200) at org.apache.flink.stormcompatibility.api.FlinkTopologyBuilderTest.testFieldsGroupingOnMultipleBoltOutputStreams(FlinkTopologyBuilderTest.java:73) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.junit.runners.model.FrameworkMethod 1.runReflectiveCall(FrameworkMethod.java:47) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50) at org.junit.runners.ParentRunner 3.run(ParentRunner.java:238) at org.junit.runners.ParentRunner 1.schedule(ParentRunner.java:63) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236) at org.junit.runners.ParentRunner.access 000(ParentRunner.java:53) at org.junit.runners.ParentRunner 2.evaluate(ParentRunner.java:229) at org.junit.runners.ParentRunner.run(ParentRunner.java:309) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197) noformat  Fix: either introduce a mapper that flattens the SplitStreamType in to regular tuple type that is nested inside or provide a custom KeySelector.", "A_clean_title": ["fieldsgroup", "field", "group", "multipl", "output", "stream", "failsif", "fail", "spout", "or", "bolt", "declar", "multipl", "output", "stream", "anoth", "bolt", "connect", "one", "those", "stream", "via", "fieldsgroup", "field", "group", "call", "flinktopologybuild", "createtopolog", "flink", "topolog", "builder", "creat", "topolog", "fail", "follow", "except", "noformat", "org", "apach", "flink", "api", "common", "invalidprogramexcept", "invalid", "program", "except", "specifi", "key", "via", "field", "posit", "onli", "valid", "tupl", "data", "type", "type", "pojotyp", "pojo", "type", "org", "apach", "flink", "stormcompat", "util", "splitstreamtyp", "split", "stream", "type", "field", "streamid", "stream", "id", "string", "valu", "generictyp", "gener", "type", "java", "lang", "object", "at", "org", "apach", "flink", "api", "java", "oper", "key", "expressionkey", "express", "key", "init", "key", "java:209", "at", "org", "apach", "flink", "api", "java", "oper", "key", "expressionkey", "express", "key", "init", "key", "java:203", "at", "org", "apach", "flink", "stream", "api", "datastream", "datastream", "groupbi", "data", "stream", "group", "by", "datastream", "java:285", "data", "stream", "at", "org", "apach", "flink", "stormcompat", "api", "flinktopologybuild", "createtopolog", "flink", "topolog", "builder", "creat", "topolog", "flinktopologybuild", "java:200", "flink", "topolog", "builder", "at", "org", "apach", "flink", "stormcompat", "api", "flinktopologybuildertest", "testfieldsgroupingonmultipleboltoutputstream", "flink", "topolog", "builder", "test", "test", "field", "group", "multipl", "bolt", "output", "stream", "flinktopologybuildertest", "java:73", "flink", "topolog", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:57", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:43", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:606", "at", "org", "junit", "runner", "model", "frameworkmethod", "framework", "method", "runreflectivecal", "run", "reflect", "call", "frameworkmethod", "java:47", "framework", "method", "at", "org", "junit", "intern", "runner", "model", "reflectivecal", "run", "reflect", "callabl", "reflectivecal", "java:12", "reflect", "callabl", "at", "org", "junit", "runner", "model", "frameworkmethod", "invokeexplos", "framework", "method", "invok", "explos", "frameworkmethod", "java:44", "framework", "method", "at", "org", "junit", "intern", "runner", "statement", "invokemethod", "evalu", "invok", "method", "invokemethod", "java:17", "invok", "method", "at", "org", "junit", "runner", "parentrunn", "runleaf", "parent", "runner", "run", "leaf", "parentrunn", "java:271", "parent", "runner", "at", "org", "junit", "runner", "blockjunit4classrunn", "runchild", "block", "unit4class", "runner", "run", "child", "blockjunit4classrunn", "java:70", "block", "unit4class", "runner", "at", "org", "junit", "runner", "blockjunit4classrunn", "runchild", "block", "unit4class", "runner", "run", "child", "blockjunit4classrunn", "java:50", "block", "unit4class", "runner", "at", "org", "junit", "runner", "parentrunn", "parent", "runner", "run", "parentrunn", "java:238", "parent", "runner", "at", "org", "junit", "runner", "parentrunn", "parent", "runner", "schedul", "parentrunn", "java:63", "parent", "runner", "at", "org", "junit", "runner", "parentrunn", "runchildren", "parent", "runner", "run", "children", "parentrunn", "java:236", "parent", "runner", "at", "org", "junit", "runner", "parentrunn", "access", "parent", "runner", "000", "parentrunn", "java:53", "parent", "runner", "at", "org", "junit", "runner", "parentrunn", "parent", "runner", "evalu", "parentrunn", "java:229", "parent", "runner", "at", "org", "junit", "runner", "parentrunn", "run", "parent", "runner", "parentrunn", "java:309", "parent", "runner", "at", "org", "eclips", "jdt", "intern", "junit4", "runner", "junit4testrefer", "run", "unit4test", "refer", "junit4testrefer", "java:50", "unit4test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:467", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:683", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:390", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:197", "remot", "test", "runner", "noformat", "fix", "either", "introduc", "mapper", "that", "flatten", "splitstreamtyp", "split", "stream", "type", "regular", "tupl", "type", "that", "nest", "insid", "or", "provid", "custom", "keyselector", "key", "selector"], "B_title": "fieldsGrouping for multiple output streams fails  - added SplitStreamTypeKeySelector and JUnit tests", "B_clean_title": ["fieldsgroup", "field", "group", "multipl", "output", "stream", "fail", "ad", "splitstreamtypekeyselector", "split", "stream", "type", "key", "selector", "junit", "unit", "test"]},
{"A_title": "FastDateParser does not handle white-space properlyThe SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properlyth", "properli", "simpledateformat", "simpl", "date", "format", "javadoc", "not", "treat", "white", "space", "special", "howev", "fastdatepars", "fast", "date", "parser", "treat", "singl", "white", "space", "as", "be", "ani", "number", "white", "space", "charact", "thi", "mean", "that", "fdp", "will", "pars", "date", "that", "fail", "when", "pars", "by", "sdp"], "B_title": "FastDateParser does not handle white-space properly", "B_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properli"]},
{"A_title": "404 Error on Nested ModalWindows in IE7 and IE8When opening a ModalWindow inside a ModalWindow the inner ModalWindow generates a 404 error.  Both windows use a PageCreator for content.  To replicate you must use an actual IE 7 or IE 8 browser as this does not replicate using developer tools and setting the document and brower to IE 7.  The problem can be seen at http://www.wicket-library.com/wicket-examples/ajax/modal-window.  I will attach a Quickstart as well.", "A_clean_title": ["404", "error", "nest", "modalwindow", "modal", "window", "ie7", "ie8when", "open", "modalwindow", "modal", "window", "insid", "modalwindow", "modal", "window", "inner", "modalwindow", "modal", "window", "gener", "404", "error", "both", "window", "use", "pagecr", "page", "creator", "content", "replic", "you", "must", "use", "actual", "ie", "or", "ie", "browser", "as", "thi", "not", "replic", "develop", "tool", "set", "document", "brower", "ie", "problem", "seen", "at", "http", "window", "wicket", "librari", "exampl", "ajax", "modal", "www", "com", "wicket", "will", "attach", "quickstart", "as", "well"], "B_title": "404 Error on Nested ModalWindows in IE7 and IE8", "B_clean_title": ["404", "error", "nest", "modalwindow", "modal", "window", "ie7", "ie8"]},
{"A_title": "CtElementImpl.getMetadataKeys() throws NPEI get NPE when invoking method getMetadataKeys() on CtElement. Looking through source code it looks like metadata can be null. It should have null check and return null like getMetadata() method or return empty set.", "A_clean_title": ["ctelementimpl", "getmetadatakey", "ct", "element", "impl", "get", "metadata", "key", "throw", "npei", "get", "npe", "when", "invok", "method", "getmetadatakey", "get", "metadata", "key", "ctelement", "ct", "element", "look", "through", "sourc", "code", "it", "look", "like", "metadata", "null", "it", "have", "null", "check", "return", "null", "like", "getmetadata", "get", "metadata", "method", "or", "return", "empti", "set"], "B_title": "fix: fix NPE in CtElement#getMetadataKeys. Closes #1239 (#1240)", "B_clean_title": ["fix", "fix", "npe", "ctelement", "ct", "element", "getmetadatakey", "get", "metadata", "key", "close", "1239", "1240"]},
{"A_title": "compiler assumes that arguments can be shadowedNone", "A_clean_title": ["compil", "assum", "that", "argument", "shadowednon", "shadow", "none"], "B_title": "var arguments never shadows the built-in arguments array. Fixes issue 115.", "B_clean_title": ["var", "argument", "never", "shadow", "built", "argument", "array", "fix", "issu", "115"]},
{"A_title": "Null model for AttributeAppender should not render empty attributeI cant think of a reason this would be valid but passing in null model renders <span class=>Test</span>.  If previous and new attribute are both null the component should render cleanly like <span>Test</span>.", "A_clean_title": ["null", "model", "attributeappend", "attribut", "append", "not", "render", "empti", "attributei", "attribut", "cant", "think", "reason", "thi", "would", "valid", "but", "pass", "null", "model", "render", "span", "class=", "test", "span", "previou", "new", "attribut", "are", "both", "null", "compon", "render", "cleanli", "like", "span", "test", "span"], "B_title": "Null model for AttributeAppender should not render empty attribute", "B_clean_title": ["null", "model", "attributeappend", "attribut", "append", "not", "render", "empti", "attribut"]},
{"A_title": "ResizableDoubleArray does not work with double array of size 1When attempting to create a ResizableDoubleArray with an array of a single value (e.g. 4.0) the constructor creates an internal array with 16 entries that are all 0.0  Bug looks like it might be on line 414 of ResizableDoubleArray.java:          if (data != null && data.length > 1)", "A_clean_title": ["resizabledoublearray", "resiz", "doubl", "array", "not", "work", "doubl", "array", "size", "1when", "attempt", "creat", "resizabledoublearray", "resiz", "doubl", "array", "array", "singl", "valu", "constructor", "creat", "intern", "array", "16", "entri", "that", "are", "all", "bug", "look", "like", "it", "might", "line", "414", "resizabledoublearray", "java", "resiz", "doubl", "array", "data", "null", "data", "length"], "B_title": "Changed data size check to be positive length not > 1 to fix ResizableDoubleArray constructor failure on input array of length 1.", "B_clean_title": ["chang", "data", "size", "check", "posit", "length", "not", "fix", "resizabledoublearray", "resiz", "doubl", "array", "constructor", "failur", "input", "array", "length"]},
{"A_title": "In RealVector dotProduct and outerProduct return wrong results due to misuse of sparse iteratorsIn class RealVector the default implementation of RealMatrix outerProduct(RealVector) uses sparse iterators on the entries of the two vectors. The rationale behind this is that 0d * x == 0d is true for all double x. This assumption is in fact false since 0d * NaN == NaN.  Proposed fix is to loop through *all* entries of both vectors. This can have a significant impact on the CPU cost but robustness should probably be preferred over speed in default implementations.  Same issue occurs with double dotProduct(RealVector) which uses sparse iterators for this only.  Another option would be to through an exception if isNaN() is true in which case caching could be used for both isNaN() and isInfinite().", "A_clean_title": ["realvector", "real", "vector", "dotproduct", "dot", "product", "outerproduct", "outer", "product", "return", "wrong", "result", "due", "misus", "spars", "iteratorsin", "iter", "class", "realvector", "real", "vector", "default", "implement", "realmatrix", "real", "matrix", "outerproduct", "outer", "product", "realvector", "real", "vector", "use", "spars", "iter", "entri", "two", "vector", "rational", "behind", "thi", "that", "0d", "0d", "true", "all", "doubl", "thi", "assumpt", "fact", "fals", "sinc", "0d", "nan", "na", "nan", "na", "propos", "fix", "loop", "through", "all", "entri", "both", "vector", "thi", "have", "signific", "impact", "cpu", "cost", "but", "robust", "probabl", "prefer", "over", "speed", "default", "implement", "same", "issu", "occur", "doubl", "dotproduct", "dot", "product", "realvector", "real", "vector", "which", "use", "spars", "iter", "thi", "onli", "anoth", "option", "would", "through", "except", "isnan", "na", "true", "which", "case", "cach", "could", "use", "both", "isnan", "na", "isinfinit", "infinit"], "B_title": "fixed a bug in RealVector.dotProduct(RealVector). Now loops through *all* entries of the vectors.", "B_clean_title": ["fix", "bug", "realvector", "dotproduct", "real", "vector", "dot", "product", "realvector", "real", "vector", "now", "loop", "through", "all", "entri", "vector"]},
{"A_title": "ByteArrayResource throws error if data is nullWhen ByteArrayResource#getData(org.apache.wicket.request.resource.IResource.Attributes) returns null the class throws a WicketRuntimeException.  This behavior differs from DynamicImageResource and ResourceStreamResource which instead issue the following call: response.setError(HttpServletResponse.SC_NOT_FOUND);  ByteArrayResource should follow the same behavior. This would allow for instance to use it for resources which depend on the contents of attributes.getParameters(). When the parameters are invalid a 404 should be issued instead of an exception.", "A_clean_title": ["bytearrayresourc", "byte", "array", "resourc", "throw", "error", "data", "nullwhen", "null", "when", "bytearrayresourc", "byte", "array", "resourc", "getdata", "get", "data", "org", "apach", "wicket", "request", "resourc", "iresourc", "attribut", "resourc", "return", "null", "class", "throw", "wicketruntimeexcept", "wicket", "runtim", "except", "thi", "behavior", "differ", "dynamicimageresourc", "dynam", "imag", "resourc", "resourcestreamresourc", "resourc", "stream", "resourc", "which", "instead", "issu", "follow", "call", "respons", "seterror", "set", "error", "httpservletrespons", "http", "servlet", "respons", "sc", "not", "found", "bytearrayresourc", "byte", "array", "resourc", "follow", "same", "behavior", "thi", "would", "allow", "instanc", "use", "it", "resourc", "which", "depend", "content", "attribut", "getparamet", "get", "paramet", "when", "paramet", "are", "invalid", "404", "issu", "instead", "except"], "B_title": "ByteArrayResource throws error if data is null", "B_clean_title": ["bytearrayresourc", "byte", "array", "resourc", "throw", "error", "data", "null"]},
{"A_title": "java.lang.IllegalArgumentException when running FlatTreeWithAceForSamePrincipalTestRunning  code java -jar oak-run*.jar benchmark FlatTreeWithAceForSamePrincipalTest Oak-Tar code will end with code java.lang.IllegalArgumentException at com.google.common.base.Preconditions.checkArgument(Preconditions.java:77) at org.apache.jackrabbit.oak.plugins.segment.ListRecord.<init>(ListRecord.java:37) at org.apache.jackrabbit.oak.plugins.segment.ListRecord.getEntries(ListRecord.java:80) at org.apache.jackrabbit.oak.plugins.segment.SegmentPropertyState.getValue(SegmentPropertyState.java:130) at org.apache.jackrabbit.oak.util.PropertyBuilder.assignFrom(PropertyBuilder.java:225) at org.apache.jackrabbit.oak.util.PropertyBuilder.copy(PropertyBuilder.java:136) at org.apache.jackrabbit.oak.core.MutableTree.addChild(MutableTree.java:216) at org.apache.jackrabbit.oak.util.TreeUtil.addChild(TreeUtil.java:190) at org.apache.jackrabbit.oak.jcr.delegate.NodeDelegate.internalAddChild(NodeDelegate.java:841) at org.apache.jackrabbit.oak.jcr.delegate.NodeDelegate.addChild(NodeDelegate.java:684) at org.apache.jackrabbit.oak.jcr.session.NodeImpl 5.perform(NodeImpl.java:288) at org.apache.jackrabbit.oak.jcr.session.NodeImpl 5.perform(NodeImpl.java:253) at org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate.perform(SessionDelegate.java:125) at org.apache.jackrabbit.oak.jcr.session.ItemImpl.perform(ItemImpl.java:111) at org.apache.jackrabbit.oak.jcr.session.NodeImpl.addNode(NodeImpl.java:253) at org.apache.jackrabbit.oak.jcr.session.NodeImpl.addNode(NodeImpl.java:238) at org.apache.jackrabbit.oak.benchmark.FlatTreeWithAceForSamePrincipalTest.beforeSuite(FlatTreeWithAceForSamePrincipalTest.java:56) at org.apache.jackrabbit.oak.benchmark.AbstractTest.setUp(AbstractTest.java:113) at org.apache.jackrabbit.oak.benchmark.FlatTreeWithAceForSamePrincipalTest.setUp(FlatTreeWithAceForSamePrincipalTest.java:31) at org.apache.jackrabbit.oak.benchmark.AbstractTest.runTest(AbstractTest.java:151) at org.apache.jackrabbit.oak.benchmark.AbstractTest.run(AbstractTest.java:138) at org.apache.jackrabbit.oak.benchmark.FlatTreeWithAceForSamePrincipalTest.run(FlatTreeWithAceForSamePrincipalTest.java:31) at org.apache.jackrabbit.oak.benchmark.BenchmarkRunner.main(BenchmarkRunner.java:195) at org.apache.jackrabbit.oak.run.Main.main(Main.java:81)  code", "A_clean_title": ["java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "when", "run", "flattreewithaceforsameprincipaltestrun", "flat", "tree", "ace", "same", "princip", "test", "run", "code", "java", "jar", "oak", "run", "jar", "benchmark", "flattreewithaceforsameprincipaltest", "flat", "tree", "ace", "same", "princip", "test", "oak", "tar", "code", "will", "end", "code", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "at", "com", "googl", "common", "base", "precondit", "checkargu", "check", "argument", "precondit", "java:77", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "listrecord", "list", "record", "init", "listrecord", "java:37", "list", "record", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "listrecord", "getentri", "list", "record", "get", "entri", "listrecord", "java:80", "list", "record", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentpropertyst", "getvalu", "segment", "properti", "state", "get", "valu", "segmentpropertyst", "java:130", "segment", "properti", "state", "at", "org", "apach", "jackrabbit", "oak", "util", "propertybuild", "assignfrom", "properti", "builder", "assign", "propertybuild", "java:225", "properti", "builder", "at", "org", "apach", "jackrabbit", "oak", "util", "propertybuild", "copi", "properti", "builder", "propertybuild", "java:136", "properti", "builder", "at", "org", "apach", "jackrabbit", "oak", "core", "mutabletre", "addchild", "mutabl", "tree", "add", "child", "mutabletre", "java:216", "mutabl", "tree", "at", "org", "apach", "jackrabbit", "oak", "util", "treeutil", "addchild", "tree", "util", "add", "child", "treeutil", "java:190", "tree", "util", "at", "org", "apach", "jackrabbit", "oak", "jcr", "deleg", "nodedeleg", "internaladdchild", "node", "deleg", "intern", "add", "child", "nodedeleg", "java:841", "node", "deleg", "at", "org", "apach", "jackrabbit", "oak", "jcr", "deleg", "nodedeleg", "addchild", "node", "deleg", "add", "child", "nodedeleg", "java:684", "node", "deleg", "at", "org", "apach", "jackrabbit", "oak", "jcr", "session", "nodeimpl", "node", "impl", "perform", "nodeimpl", "java:288", "node", "impl", "at", "org", "apach", "jackrabbit", "oak", "jcr", "session", "nodeimpl", "node", "impl", "perform", "nodeimpl", "java:253", "node", "impl", "at", "org", "apach", "jackrabbit", "oak", "jcr", "deleg", "sessiondeleg", "perform", "session", "deleg", "sessiondeleg", "java:125", "session", "deleg", "at", "org", "apach", "jackrabbit", "oak", "jcr", "session", "itemimpl", "perform", "item", "impl", "itemimpl", "java:111", "item", "impl", "at", "org", "apach", "jackrabbit", "oak", "jcr", "session", "nodeimpl", "addnod", "node", "impl", "add", "node", "nodeimpl", "java:253", "node", "impl", "at", "org", "apach", "jackrabbit", "oak", "jcr", "session", "nodeimpl", "addnod", "node", "impl", "add", "node", "nodeimpl", "java:238", "node", "impl", "at", "org", "apach", "jackrabbit", "oak", "benchmark", "flattreewithaceforsameprincipaltest", "beforesuit", "flat", "tree", "ace", "same", "princip", "test", "befor", "suit", "flattreewithaceforsameprincipaltest", "java:56", "flat", "tree", "ace", "same", "princip", "test", "at", "org", "apach", "jackrabbit", "oak", "benchmark", "abstracttest", "setup", "abstract", "test", "set", "up", "abstracttest", "java:113", "abstract", "test", "at", "org", "apach", "jackrabbit", "oak", "benchmark", "flattreewithaceforsameprincipaltest", "setup", "flat", "tree", "ace", "same", "princip", "test", "set", "up", "flattreewithaceforsameprincipaltest", "java:31", "flat", "tree", "ace", "same", "princip", "test", "at", "org", "apach", "jackrabbit", "oak", "benchmark", "abstracttest", "runtest", "abstract", "test", "run", "test", "abstracttest", "java:151", "abstract", "test", "at", "org", "apach", "jackrabbit", "oak", "benchmark", "abstracttest", "run", "abstract", "test", "abstracttest", "java:138", "abstract", "test", "at", "org", "apach", "jackrabbit", "oak", "benchmark", "flattreewithaceforsameprincipaltest", "run", "flat", "tree", "ace", "same", "princip", "test", "flattreewithaceforsameprincipaltest", "java:31", "flat", "tree", "ace", "same", "princip", "test", "at", "org", "apach", "jackrabbit", "oak", "benchmark", "benchmarkrunn", "main", "benchmark", "runner", "benchmarkrunn", "java:195", "benchmark", "runner", "at", "org", "apach", "jackrabbit", "oak", "run", "main", "main", "main", "java:81", "code"], "B_title": "java.lang.IllegalArgumentException when running FlatTreeWithAceForSamePrincipalTest", "B_clean_title": ["java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "when", "run", "flattreewithaceforsameprincipaltest", "flat", "tree", "ace", "same", "princip", "test"]},
{"A_title": "FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() wont changeThe FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null then it is not made part of the key but the stored object is created using the current default locale. If the Locale is changed subsequently then the wrong locale is applied. Patch for test case to follow.", "A_clean_title": ["fastdateformat", "fast", "date", "format", "getdateinst", "get", "date", "instanc", "getdatetimeinst", "get", "date", "time", "instanc", "assum", "local", "getdefault", "get", "default", "wont", "changeth", "chang", "fastdateformat", "fast", "date", "format", "getdateinst", "get", "date", "instanc", "getdatetimeinst", "get", "date", "time", "instanc", "method", "creat", "hashmap", "hash", "map", "key", "variou", "item", "includ", "local", "local", "null", "then", "it", "not", "made", "part", "key", "but", "store", "object", "creat", "current", "default", "local", "local", "chang", "subsequ", "then", "wrong", "local", "appli", "patch", "test", "case", "follow"], "B_title": "Applying Sebbs test and fix from LANG-368 - fixing it so that FastDateFormat getDateInstance and getDateTimeInstance continue to work if Locale.getDefault() changes", "B_clean_title": ["appli", "sebb", "test", "fix", "lang", "368", "fix", "it", "so", "that", "fastdateformat", "fast", "date", "format", "getdateinst", "get", "date", "instanc", "getdatetimeinst", "get", "date", "time", "instanc", "continu", "work", "local", "getdefault", "get", "default", "chang"]},
{"A_title": "The compiler quotes the 0 keys in object literalsNone", "A_clean_title": ["compil", "quot", "key", "object", "literalsnon", "liter", "none"], "B_title": "Dont quote 0 object literal keys. Fixes issue 942 ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=44143868", "B_clean_title": ["dont", "quot", "object", "liter", "key", "fix", "issu", "942", "creat", "by", "moe", "http", "java", "googl", "code", "com", "moe", "moe", "migrat", "revid=44143868"]},
{"A_title": "404 Error on Nested ModalWindows in IE7 and IE8When opening a ModalWindow inside a ModalWindow the inner ModalWindow generates a 404 error.  Both windows use a PageCreator for content.  To replicate you must use an actual IE 7 or IE 8 browser as this does not replicate using developer tools and setting the document and brower to IE 7.  The problem can be seen at http://www.wicket-library.com/wicket-examples/ajax/modal-window.  I will attach a Quickstart as well.", "A_clean_title": ["404", "error", "nest", "modalwindow", "modal", "window", "ie7", "ie8when", "open", "modalwindow", "modal", "window", "insid", "modalwindow", "modal", "window", "inner", "modalwindow", "modal", "window", "gener", "404", "error", "both", "window", "use", "pagecr", "page", "creator", "content", "replic", "you", "must", "use", "actual", "ie", "or", "ie", "browser", "as", "thi", "not", "replic", "develop", "tool", "set", "document", "brower", "ie", "problem", "seen", "at", "http", "window", "wicket", "librari", "exampl", "ajax", "modal", "www", "com", "wicket", "will", "attach", "quickstart", "as", "well"], "B_title": "404 Error on Nested ModalWindows in IE7 and IE8", "B_clean_title": ["404", "error", "nest", "modalwindow", "modal", "window", "ie7", "ie8"]},
{"A_title": "Different behaviour of PeriodFormatterWhen the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I cant find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.", "A_clean_title": ["differ", "behaviour", "periodformatterwhen", "period", "formatt", "when", "hour", "day", "set", "ambigu", "hour", "daylight", "standard", "time", "transit", "given", "time", "zone", "result", "inconsist", "differ", "time", "zone", "shoul", "hour", "set", "daylight", "hour", "or", "standard", "hour", "all", "time", "zone", "cant", "find", "anyth", "that", "document", "thi", "behavior", "my", "test", "code", "below", "return", "differ", "result", "differ", "time", "zone", "veri", "last", "assert", "fail", "australia", "time", "zone", "cutov"], "B_title": "Period formatter builder append(PeriodFormatter) did not handle some case 2495455 test from Bjoern Ricks", "B_clean_title": ["period", "formatt", "builder", "append", "periodformatt", "period", "formatt", "did", "not", "handl", "some", "case", "2495455", "test", "bjoern", "rick"]},
{"A_title": "Calling  blacklistLibOrExtJars without arguments causes an ExceptionCalling  blacklistLibOrExtJars() without arguments throws java.lang.IllegalArgumentException: Can only blacklist jars by leafname: /System/Library/Java/Extensions/MRJToolkit.jar while whitelistLibOrExtJars() without arguments works fine.", "A_clean_title": ["call", "blacklistliborextjar", "blacklist", "lib", "or", "ext", "jar", "without", "argument", "caus", "exceptioncal", "except", "call", "blacklistliborextjar", "blacklist", "lib", "or", "ext", "jar", "without", "argument", "throw", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "onli", "blacklist", "jar", "by", "leafnam", "jar", "system", "librari", "java", "extens", "mrjtoolkit", "mrj", "toolkit", "while", "whitelistliborextjar", "whitelist", "lib", "or", "ext", "jar", "without", "argument", "work", "fine"], "B_title": "Merge pull request #278 from larsgrefer/fix/gh-277  Fix #277", "B_clean_title": ["merg", "pull", "request", "278", "277", "larsgref", "fix", "gh", "fix", "277"]},
{"A_title": "Preserve doesnt preserve whitespace at start of lineNone", "A_clean_title": ["preserv", "doesnt", "preserv", "whitespac", "at", "start", "linenon", "line", "none"], "B_title": "preserve whitespace at the beginning of license blocks makes the <code> in closure docs look a lot better fixes issue 701", "B_clean_title": ["preserv", "whitespac", "at", "begin", "licens", "block", "make", "code", "closur", "doc", "look", "lot", "better", "fix", "issu", "701"]},
{"A_title": "NPE in  KMeansPlusPlusClusterer unittestWhen running this unittest I am facing this NPE: java.lang.NullPointerException at org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.assignPointsToClusters(KMeansPlusPlusClusterer.java:91) This is the unittest: package org.fao.fisheries.chronicles.calcuation.cluster; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import java.util.Arrays; import java.util.List; import java.util.Random; import org.apache.commons.math.stat.clustering.Cluster; import org.apache.commons.math.stat.clustering.EuclideanIntegerPoint; import org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer; import org.fao.fisheries.chronicles.input.CsvImportProcess; import org.fao.fisheries.chronicles.input.Top200Csv; import org.junit.Test; public class ClusterAnalysisTest  @Test public void testPerformClusterAnalysis2()  KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>( new Random(1746432956321l)); EuclideanIntegerPoint points = new EuclideanIntegerPoint  new EuclideanIntegerPoint(new int   1959 325100  ) new EuclideanIntegerPoint(new int   1960 373200  ) ; List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points) 1 1); assertEquals(1 clusters.size());", "A_clean_title": ["npe", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "unittestwhen", "unittest", "when", "run", "thi", "unittest", "am", "face", "thi", "npe", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math", "stat", "cluster", "kmeanspluspluscluster", "assignpointstoclust", "mean", "plu", "plu", "cluster", "assign", "point", "cluster", "kmeanspluspluscluster", "java:91", "mean", "plu", "plu", "cluster", "thi", "unittest", "packag", "org", "fao", "fisheri", "chronicl", "calcuat", "cluster", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "static", "org", "junit", "assert", "asserttru", "assert", "true", "import", "java", "util", "array", "import", "java", "util", "list", "import", "java", "util", "random", "import", "org", "apach", "common", "math", "stat", "cluster", "cluster", "import", "org", "apach", "common", "math", "stat", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "import", "org", "apach", "common", "math", "stat", "cluster", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "import", "org", "fao", "fisheri", "chronicl", "input", "csvimportprocess", "csv", "import", "process", "import", "org", "fao", "fisheri", "chronicl", "input", "top200csv", "import", "org", "junit", "test", "public", "class", "clusteranalysistest", "cluster", "analysi", "test", "test", "public", "void", "testperformclusteranalysis2", "test", "perform", "cluster", "analysis2", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "transform", "new", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "random", "1746432956321l", "euclideanintegerpoint", "euclidean", "integ", "point", "point", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "int", "1959", "325100", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "int", "1960", "373200", "list", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "cluster", "transform", "cluster", "array", "aslist", "as", "list", "point", "assertequ", "assert", "equal", "cluster", "size"], "B_title": "Fixed an overflow error in MathUtils.distance that was causing KMeansPlusPlusClusterer to fail with a NullPointerException when component distances between points exceeded Integer.MAXVALUE. JIRA: MATH-305 Reported by Erik van Ingen", "B_clean_title": ["fix", "overflow", "error", "mathutil", "distanc", "math", "util", "that", "wa", "caus", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "fail", "nullpointerexcept", "null", "pointer", "except", "when", "compon", "distanc", "between", "point", "exceed", "integ", "maxvalu", "jira", "math", "305", "report", "by", "erik", "van", "ingen"]},
{"A_title": "Ensure there is a max/min valid offsetDateTimeZone does not apply a max/min value for an offset. However the parse method is limited to 23:59. Make 23:59:59.999 the maximum.", "A_clean_title": ["ensur", "there", "max", "min", "valid", "offsetdatetimezon", "offset", "date", "time", "zone", "not", "appli", "max", "min", "valu", "offset", "howev", "pars", "method", "limit", "23:59", "make", "23:59:59", "999", "maximum"], "B_title": "Ensure there is a max/min valid offset in DateTimeZone", "B_clean_title": ["ensur", "there", "max", "min", "valid", "offset", "datetimezon", "date", "time", "zone"]},
{"A_title": "Exception thrown from com.google.javascript.jscomp.CollapseProperties.addStubsForUndeclaredPropertiesNone", "A_clean_title": ["except", "thrown", "com", "googl", "javascript", "jscomp", "collapseproperti", "addstubsforundeclaredpropertiesnon", "collaps", "properti", "add", "stub", "undeclar", "properti", "none"], "B_title": "- Fix issue #19 - attach jsdoc comments without annotations to nodes", "B_clean_title": ["fix", "issu", "19", "attach", "jsdoc", "comment", "without", "annot", "node"]},
{"A_title": "Debug settings / serialize session attributes option not workingSession attributes are serialized even if this debug setting is turned off. Ive noticed that the code that serializes attributes and logs their serialized size in HttpSessionStore#setAttribute is duplicated in Session#setAttribute - but without the debug settings condition. This code was added by the recent patch resolving WICKET-100 and only in the trunk not in the wicket-1.x branch... why???  Regards Bendis", "A_clean_title": ["debug", "set", "serial", "session", "attribut", "option", "not", "workingsess", "work", "session", "attribut", "are", "serial", "even", "thi", "debug", "set", "turn", "off", "ive", "notic", "that", "code", "that", "serial", "attribut", "log", "their", "serial", "size", "httpsessionstor", "http", "session", "store", "setattribut", "set", "attribut", "duplic", "session", "setattribut", "set", "attribut", "but", "without", "debug", "set", "condit", "thi", "code", "wa", "ad", "by", "recent", "patch", "resolv", "wicket", "100", "onli", "trunk", "not", "wicket", "branch", "whi", "regard", "bendi"], "B_title": "", "B_clean_title": []},
{"A_title": "The Urls query parameters are not properly URL encodedIf page parameter has a value with special characters like  then it is rendered as it is in the produced markup and is only XML encoded but never URL encoded. This causes broken html for example in the case when a Link is attached to a non- a|area|link tag:   <html><body><span wicket:id=link onclick=var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; if (win == window)  window.location.href=&#039;bookmarkable/org.apache.wicket.MockPageWithLink?urlEscapeNeeded=someone&#039;s+ba+parameter&#039;;  ;return false></span></body></html>  Notice that &#039; after someone closes the location.href string too early and breaks the app.", "A_clean_title": ["url", "queri", "paramet", "are", "not", "properli", "url", "encodedif", "encod", "page", "paramet", "ha", "valu", "special", "charact", "like", "then", "it", "render", "as", "it", "produc", "markup", "onli", "xml", "encod", "but", "never", "url", "encod", "thi", "caus", "broken", "html", "exampl", "case", "when", "link", "attach", "non", "a|area|link", "tag", "html", "bodi", "span", "wicket", "id=link", "onclick=var", "win", "thi", "ownerdocu", "defaultview", "owner", "document", "default", "view", "thi", "ownerdocu", "parentwindow", "owner", "document", "parent", "window", "win", "window", "window", "locat", "href=", "039", "apach", "wicket", "mockpagewithlink", "bookmark", "org", "mock", "page", "link", "urlescapeneeded=someon", "url", "escap", "needed=someon", "039", "s+ba+paramet", "039", "return", "fals", "span", "bodi", "html", "notic", "that", "039", "after", "someon", "close", "locat", "href", "string", "too", "earli", "break", "app"], "B_title": "The Urls query parameters are not properly URL encoded", "B_clean_title": ["url", "queri", "paramet", "are", "not", "properli", "url", "encod"]},
{"A_title": "Inline enclosure doesnt work if wicket:message attribute is used on the same tagMarkup like:          <div wicket:enclosure=child wicket:message=title:something>         <div>Inner div         <span wicket:id=child>Blah</span>         </div>         </div>  doesnt work (Inner div is visible no matter whether child is visible or not) because the auto component created for wicket:message breaks somehow wicket:enclosure.", "A_clean_title": ["inlin", "enclosur", "doesnt", "work", "wicket", "messag", "attribut", "use", "same", "tagmarkup", "tag", "markup", "like", "div", "wicket", "enclosure=child", "wicket", "message=titl", "someth", "div", "inner", "div", "span", "wicket", "id=child", "blah", "span", "div", "div", "doesnt", "work", "inner", "div", "visibl", "no", "matter", "whether", "child", "visibl", "or", "not", "becaus", "auto", "compon", "creat", "wicket", "messag", "break", "somehow", "wicket", "enclosur"], "B_title": "Inline enclosure doesnt work if wicket:message attribute is used on the same tag", "B_clean_title": ["inlin", "enclosur", "doesnt", "work", "wicket", "messag", "attribut", "use", "same", "tag"]},
{"A_title": "Sling I18N queries not supported by OakThe Sling I18N component issues XPath queries like the following:  code:none //element(*mix:language)fn:lower-case(@jcr:language)=en//element(*sling:Message)@sling:message/(@sling:key|@sling:message) code  Such queries currently fail with the following exception:  code:none javax.jcr.query.InvalidQueryException: java.text.ParseException: Query: //element(*mix:language)fn:lower-(*)case(@jcr:language)=en//element(*sling:Message)@sling:message/(@sling:key|@sling:message); expected: (         at org.apache.jackrabbit.oak.jcr.query.QueryManagerImpl.executeQuery(QueryManagerImpl.java:115)         at org.apache.jackrabbit.oak.jcr.query.QueryImpl.execute(QueryImpl.java:85)         at org.apache.sling.jcr.resource.JcrResourceUtil.query(JcrResourceUtil.java:52)         at org.apache.sling.jcr.resource.internal.helper.jcr.JcrResourceProvider.queryResources(JcrResourceProvider.java:262)         ... 54 more Caused by: java.text.ParseException: Query: //element(*mix:language)fn:lower-(*)case(@jcr:language)=en//element(*sling:Message)@sling:message/(@sling:key|@sling:message); expected: (         at org.apache.jackrabbit.oak.query.XPathToSQL2Converter.getSyntaxError(XPathToSQL2Converter.java:704)         at org.apache.jackrabbit.oak.query.XPathToSQL2Converter.read(XPathToSQL2Converter.java:410)         at org.apache.jackrabbit.oak.query.XPathToSQL2Converter.parseExpression(XPathToSQL2Converter.java:336)         at org.apache.jackrabbit.oak.query.XPathToSQL2Converter.parseCondition(XPathToSQL2Converter.java:279)         at org.apache.jackrabbit.oak.query.XPathToSQL2Converter.parseAnd(XPathToSQL2Converter.java:252)         at org.apache.jackrabbit.oak.query.XPathToSQL2Converter.parseConstraint(XPathToSQL2Converter.java:244)         at org.apache.jackrabbit.oak.query.XPathToSQL2Converter.convert(XPathToSQL2Converter.java:153)         at org.apache.jackrabbit.oak.query.QueryEngineImpl.parseQuery(QueryEngineImpl.java:86)         at org.apache.jackrabbit.oak.query.QueryEngineImpl.executeQuery(QueryEngineImpl.java:99)         at org.apache.jackrabbit.oak.query.QueryEngineImpl.executeQuery(QueryEngineImpl.java:39)         at org.apache.jackrabbit.oak.jcr.query.QueryManagerImpl.executeQuery(QueryManagerImpl.java:110) code", "A_clean_title": ["sling", "i18n", "queri", "not", "support", "by", "oakth", "oak", "sling", "i18n", "compon", "issu", "xpath", "path", "queri", "like", "follow", "code", "none", "element", "mix", "languag", "fn", "lower", "case", "jcr", "languag", "=en", "element", "sling", "messag", "sling", "messag", "sling", "key|", "sling", "messag", "code", "such", "queri", "current", "fail", "follow", "except", "code", "none", "javax", "jcr", "queri", "invalidqueryexcept", "invalid", "queri", "except", "java", "text", "parseexcept", "pars", "except", "queri", "element", "mix", "languag", "fn", "lower", "case", "jcr", "languag", "=en", "element", "sling", "messag", "sling", "messag", "sling", "key|", "sling", "messag", "expect", "at", "org", "apach", "jackrabbit", "oak", "jcr", "queri", "querymanagerimpl", "executequeri", "queri", "manag", "impl", "execut", "queri", "querymanagerimpl", "java:115", "queri", "manag", "impl", "at", "org", "apach", "jackrabbit", "oak", "jcr", "queri", "queryimpl", "execut", "queri", "impl", "queryimpl", "java:85", "queri", "impl", "at", "org", "apach", "sling", "jcr", "resourc", "jcrresourceutil", "queri", "jcr", "resourc", "util", "jcrresourceutil", "java:52", "jcr", "resourc", "util", "at", "org", "apach", "sling", "jcr", "resourc", "intern", "helper", "jcr", "jcrresourceprovid", "queryresourc", "jcr", "resourc", "provid", "queri", "resourc", "jcrresourceprovid", "java:262", "jcr", "resourc", "provid", "54", "more", "caus", "by", "java", "text", "parseexcept", "pars", "except", "queri", "element", "mix", "languag", "fn", "lower", "case", "jcr", "languag", "=en", "element", "sling", "messag", "sling", "messag", "sling", "key|", "sling", "messag", "expect", "at", "org", "apach", "jackrabbit", "oak", "queri", "xpathtosql2convert", "getsyntaxerror", "path", "sql2convert", "get", "syntax", "error", "xpathtosql2convert", "java:704", "path", "sql2convert", "at", "org", "apach", "jackrabbit", "oak", "queri", "xpathtosql2convert", "read", "path", "sql2convert", "xpathtosql2convert", "java:410", "path", "sql2convert", "at", "org", "apach", "jackrabbit", "oak", "queri", "xpathtosql2convert", "parseexpress", "path", "sql2convert", "pars", "express", "xpathtosql2convert", "java:336", "path", "sql2convert", "at", "org", "apach", "jackrabbit", "oak", "queri", "xpathtosql2convert", "parsecondit", "path", "sql2convert", "pars", "condit", "xpathtosql2convert", "java:279", "path", "sql2convert", "at", "org", "apach", "jackrabbit", "oak", "queri", "xpathtosql2convert", "parseand", "path", "sql2convert", "pars", "xpathtosql2convert", "java:252", "path", "sql2convert", "at", "org", "apach", "jackrabbit", "oak", "queri", "xpathtosql2convert", "parseconstraint", "path", "sql2convert", "pars", "constraint", "xpathtosql2convert", "java:244", "path", "sql2convert", "at", "org", "apach", "jackrabbit", "oak", "queri", "xpathtosql2convert", "convert", "path", "sql2convert", "xpathtosql2convert", "java:153", "path", "sql2convert", "at", "org", "apach", "jackrabbit", "oak", "queri", "queryengineimpl", "parsequeri", "queri", "engin", "impl", "pars", "queri", "queryengineimpl", "java:86", "queri", "engin", "impl", "at", "org", "apach", "jackrabbit", "oak", "queri", "queryengineimpl", "executequeri", "queri", "engin", "impl", "execut", "queri", "queryengineimpl", "java:99", "queri", "engin", "impl", "at", "org", "apach", "jackrabbit", "oak", "queri", "queryengineimpl", "executequeri", "queri", "engin", "impl", "execut", "queri", "queryengineimpl", "java:39", "queri", "engin", "impl", "at", "org", "apach", "jackrabbit", "oak", "jcr", "queri", "querymanagerimpl", "executequeri", "queri", "manag", "impl", "execut", "queri", "querymanagerimpl", "java:110", "queri", "manag", "impl", "code"], "B_title": "Sling I18N queries not supported by Oak (partial fix)", "B_clean_title": ["sling", "i18n", "queri", "not", "support", "by", "oak", "partial", "fix"]},
{"A_title": "XPath queries: compatibility for missing @ in front of property namesXPath queries with conditions of the form noformatid=testnoformat are not problematic. Jackrabbit 2.x interpreted such conditions as noformat@id=testnoformat and Oak currently interprets them as noformat@id/* = testnoformat as this is the expected behavior for conditions of the form noformatjcr:contains(id test)noformat.  I believe the condition noformatid=testnoformat is illegal and it would be better to throw an exception instead saying a @ is missing.", "A_clean_title": ["xpath", "path", "queri", "compat", "miss", "front", "properti", "namesxpath", "name", "path", "queri", "condit", "form", "noformatid=testnoformat", "are", "not", "problemat", "jackrabbit", "interpret", "such", "condit", "as", "noformat", "id=testnoformat", "oak", "current", "interpret", "them", "as", "noformat", "id", "testnoformat", "as", "thi", "expect", "behavior", "condit", "form", "noformatjcr", "contain", "id", "test", "noformat", "believ", "condit", "noformatid=testnoformat", "illeg", "it", "would", "better", "throw", "except", "instead", "say", "miss"], "B_title": "XPath queries: compatibility for missing @ in front of property names", "B_clean_title": ["xpath", "path", "queri", "compat", "miss", "front", "properti", "name"]},
{"A_title": "@this emits warning when used with a typedefNone", "A_clean_title": ["thi", "emit", "warn", "when", "use", "typedefnon", "typedef", "none"], "B_title": "Coerce null and undefined out of the @this type when we resolve lazily. We already do this when we resolve @this blocks immediately. Theres some question about whether we should be coercing to the global object instead but im going to just punt on this for now. Fixes issue 274", "B_clean_title": ["coerc", "null", "undefin", "out", "thi", "type", "when", "we", "resolv", "lazili", "we", "alreadi", "thi", "when", "we", "resolv", "thi", "block", "immedi", "there", "some", "question", "about", "whether", "we", "coerc", "global", "object", "instead", "but", "im", "go", "just", "punt", "thi", "now", "fix", "issu", "274"]},
{"A_title": "Division by zeroIn class Complex division by zero always returns NaN. I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF. See here|http://en.wikipedia.org/wiki/Riemann_sphere#Arithmetic_operations.", "A_clean_title": ["divis", "by", "zeroin", "zero", "class", "complex", "divis", "by", "zero", "alway", "return", "nan", "na", "think", "that", "it", "return", "nan", "na", "onli", "when", "numer", "also", "zero", "otherwis", "result", "inf", "see", "here|http", "wikipedia", "en", "sphere", "org", "wiki", "riemann", "arithmet", "oper"], "B_title": "Complex division by zero:  z / 0 = INF if z is not ZERO  0 / 0 = NaN", "B_clean_title": ["complex", "divis", "by", "zero", "inf", "not", "zero", "nan", "na"]},
{"A_title": "NPE in DateTimeZoneBuilderWhen a DateTimeZone is build with duplicate-named recurring saving time in a first thread all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:", "A_clean_title": ["npe", "datetimezonebuilderwhen", "date", "time", "zone", "builder", "when", "datetimezon", "date", "time", "zone", "build", "duplic", "name", "recur", "save", "time", "first", "thread", "all", "goe", "ok", "warn", "messag", "gener", "identifi", "automat", "gener", "precalculatedzon", "creat", "precalcul", "zone", "when", "second", "thread", "same", "npe", "gener", "zoneinfocompil", "verbos", "zone", "info", "compil", "caus", "that", "cverbos", "verbos", "threadloc", "thread", "local", "incorrectli", "initi", "zoneinfocompil", "zone", "info", "compil", "will", "initi", "cverbos", "verbos", "onli", "first", "thread", "not", "subsequ", "one", "npe", "caus", "by", "autobox", "better", "approach", "could", "remov", "initi", "test", "null"], "B_title": "Fix ZoneInfoCompiler and DateTimeZoneBuilder multi-threading", "B_clean_title": ["fix", "zoneinfocompil", "zone", "info", "compil", "datetimezonebuild", "date", "time", "zone", "builder", "multi", "thread"]},
{"A_title": "Dates.round() behaves incorrectly for minutes and secondsGet unexpected output for rounding by minutes or seconds. public void testRound()      Calendar testCalendar = Calendar.getInstance(TimeZone.getTimeZone(GMT));     testCalendar.set(2007 6 2 8 9 50);     Date date = testCalendar.getTime();     System.out.println(Before round()  + date);     System.out.println(After round()   + DateUtils.round(date Calendar.MINUTE));  --2.1 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:10:00 CDT 2007  this is what I would expect --2.2 and 2.3 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:01:00 CDT 2007  this appears to be wrong", "A_clean_title": ["date", "round", "behav", "incorrectli", "minut", "secondsget", "second", "get", "unexpect", "output", "round", "by", "minut", "or", "second", "public", "void", "testround", "test", "round", "calendar", "testcalendar", "test", "calendar", "calendar", "getinst", "get", "instanc", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "testcalendar", "set", "test", "calendar", "2007", "50", "date", "date", "testcalendar", "gettim", "test", "calendar", "get", "time", "system", "out", "println", "befor", "round", "date", "system", "out", "println", "after", "round", "dateutil", "round", "date", "util", "date", "calendar", "minut", "produc", "befor", "round", "mon", "jul", "02", "03:09:50", "cdt", "2007", "after", "round", "mon", "jul", "02", "03:10:00", "cdt", "2007", "thi", "what", "would", "expect", "produc", "befor", "round", "mon", "jul", "02", "03:09:50", "cdt", "2007", "after", "round", "mon", "jul", "02", "03:01:00", "cdt", "2007", "thi", "appear", "wrong"], "B_title": "Applying the fix and the test patches from LANG-346 - fixes bugs in DateUtils.round() for minutes and seconds. Patch from Dave Meikle", "B_clean_title": ["appli", "fix", "test", "patch", "lang", "346", "fix", "bug", "dateutil", "round", "date", "util", "minut", "second", "patch", "dave", "meikl"]},
{"A_title": "XPath: querying for nodes named text element and rep:excerpt failsQueries that contain text or element as a node name currently fail because the the parser assumes text() / element(...). Example query that fails:  noformat /jcr:root/content/text/jcr:content//element(*nt:unstructured) noformat  A workaround is to use the escape mechanism that is:  noformat /jcr:root/tmp/_x0074_ext/jcr:content//element(*nt:unstructured) noformat  It looks like ( and ) are valid characters in node names but to query for those characters they need to be escaped.", "A_clean_title": ["xpath", "path", "queri", "node", "name", "text", "element", "rep", "excerpt", "failsqueri", "fail", "queri", "that", "contain", "text", "or", "element", "as", "node", "name", "current", "fail", "becaus", "parser", "assum", "text", "element", "exampl", "queri", "that", "fail", "noformat", "jcr", "root", "content", "text", "jcr", "content", "element", "nt", "unstructur", "noformat", "workaround", "use", "escap", "mechan", "that", "noformat", "jcr", "x0074", "root", "tmp", "ext", "jcr", "content", "element", "nt", "unstructur", "noformat", "it", "look", "like", "are", "valid", "charact", "node", "name", "but", "queri", "those", "charact", "they", "need", "escap"], "B_title": "XPath: querying for nodes named text element and rep:excerpt fails", "B_clean_title": ["xpath", "path", "queri", "node", "name", "text", "element", "rep", "excerpt", "fail"]},
{"A_title": "Event broadcast type Depth does not work when the sink is a Component but not a MarkupContainerEvent broadcast type Depth does not work when the sink is a Component but not a MarkupContainer. In this case no sinks receive the event.", "A_clean_title": ["event", "broadcast", "type", "depth", "not", "work", "when", "sink", "compon", "but", "not", "markupcontainerev", "markup", "contain", "event", "broadcast", "type", "depth", "not", "work", "when", "sink", "compon", "but", "not", "markupcontain", "markup", "contain", "thi", "case", "no", "sink", "receiv", "event"], "B_title": "Issue: WICKET-3539", "B_clean_title": ["issu", "wicket", "3539"]},
{"A_title": "AbstractTextComponent not escaping html data by default therefore user text is not redisplayed correctlyUser input is not escaped in all text fields by default (and the default is not configurable).  This leads to user entered text not being redisplayed correctly.  * You can replicate using the project from WICKET-3330. * Just enter the text my&frac12;companyname and press enter * The field will not redisplay the text entered properly", "A_clean_title": ["abstracttextcompon", "abstract", "text", "compon", "not", "escap", "html", "data", "by", "default", "therefor", "user", "text", "not", "redisplay", "correctlyus", "correctli", "user", "input", "not", "escap", "all", "text", "field", "by", "default", "default", "not", "configur", "thi", "lead", "user", "enter", "text", "not", "be", "redisplay", "correctli", "you", "replic", "project", "wicket", "3330", "just", "enter", "text", "my", "frac12", "companynam", "press", "enter", "field", "will", "not", "redisplay", "text", "enter", "properli"], "B_title": "unescape markup attribute during parsing dont unescape while rendering", "B_clean_title": ["unescap", "markup", "attribut", "dure", "pars", "dont", "unescap", "while", "render"]},
{"A_title": "SmartLinkLabel doesnt recognize already tagged linksThe SmartLinkLabel works as expected for the texts without <a>..</a> tag.  for text like extensions @ http://www.wicketframework.org/wicket-extensions/index.html are cool!! SmartLinkLabel generates the html -  extensions @ <a href=http://www.wicketframework.org/wicket-extensions/index.html>http://www.wicketframework.org/wicket-extensions/index.html</a> are cool!!  but for the text like extensions @ <a href=http://www.wicketframework.org/wicket-extensions/index.html>http://www.wicketframework.org/wicket-extensions/index.html</a> are cool!! SmartLinkLabel generates the html -  extensions @ <a href=<a href=http://www.wicketframework.org/wicket-extensions/index.html>http://www.wicketframework.org/wicket-extensions/index.html</a>><a href=http://www.wicketframework.org/wicket-extensions/index.html>http://www.wicketframework.org/wicket-extensions/index.html</a></a> are cool!!  I think this is a bug & needs a fix.", "A_clean_title": ["smartlinklabel", "smart", "link", "label", "doesnt", "recogn", "alreadi", "tag", "linksth", "link", "smartlinklabel", "smart", "link", "label", "work", "as", "expect", "text", "without", "tag", "text", "like", "extens", "http", "wicketframework", "html", "www", "org", "wicket", "extens", "index", "are", "cool", "smartlinklabel", "smart", "link", "label", "gener", "html", "extens", "href=http", "wicketframework", "html", "www", "org", "wicket", "extens", "index", "http", "wicketframework", "html", "www", "org", "wicket", "extens", "index", "are", "cool", "but", "text", "like", "extens", "href=http", "wicketframework", "html", "www", "org", "wicket", "extens", "index", "http", "wicketframework", "html", "www", "org", "wicket", "extens", "index", "are", "cool", "smartlinklabel", "smart", "link", "label", "gener", "html", "extens", "href=", "href=http", "wicketframework", "html", "www", "org", "wicket", "extens", "index", "http", "wicketframework", "html", "www", "org", "wicket", "extens", "index", "href=http", "wicketframework", "html", "www", "org", "wicket", "extens", "index", "http", "wicketframework", "html", "www", "org", "wicket", "extens", "index", "are", "cool", "think", "thi", "bug", "need", "fix"], "B_title": "SmartLinkLabel doesnt recognize already tagged links", "B_clean_title": ["smartlinklabel", "smart", "link", "label", "doesnt", "recogn", "alreadi", "tag", "link"]}]