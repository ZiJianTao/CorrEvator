[{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Tweak optimisation for 64 bit KMeans clustering. Fix the build .. Fix NPE in FuzzyKMeansClusterer patch .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "tweak", "optimis", "64", "bit", "kmean", "mean", "cluster", "fix", "build", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the build .. added new centroid clustering method. ", "B_clean_title": ["fix", "build", "ad", "new", "centroid", "cluster", "method"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Fix the for loop. added new centroid clustering method. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "loop", "ad", "new", "centroid", "cluster", "method"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Fix one more test. Throw a NumberIsTooSmallException if fuzziness <= 1 . 0d. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "fix", "one", "more", "test", "throw", "numberistoosmallexcept", "number", "too", "small", "except", "fuzzi", "0d"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Fix one more test. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "fix", "one", "more", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "fixed 10 / 11 error. Fix the bug in FuzzyKMeansClusterer .. Fix NPE in FuzzyKMeansClusterer patch .. ", "B_clean_title": ["fix", "10", "11", "error", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where the size of the points are zero. Fix the case of new centroid clustering. added new centroid clustering patch. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "size", "point", "are", "zero", "fix", "case", "new", "centroid", "cluster", "ad", "new", "centroid", "cluster", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "throw exception if size < k. added points = Collections . unmodifiable ( dataPoints ) ;. Remove unused code. ", "B_clean_title": ["throw", "except", "size", "ad", "point", "collect", "unmodifi", "datapoint", "data", "point", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Fix membership matrix for newly added k = 1 . 5 new dataset. added missing int .. Remove oversampling .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "fix", "membership", "matrix", "newli", "ad", "new", "dataset", "ad", "miss", "int", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer  closes # 773. Fix minCluster. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "773", "fix", "minclust", "min", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Remove oversampling .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix the build .. Fix NPE in FuzzyKMeansClusterer patch .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "build", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 1796. Removed patched code. Fix the for loop. ", "B_clean_title": ["fix", "1796", "remov", "patch", "code", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix the build .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Removed patch for max membership in FuzzyKMeansClusterer. Fix membership matrix .. ", "B_clean_title": ["fix", "7759", "remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Readded clear ( ) patched by accident. Fix membership matrix .. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["read", "clear", "patch", "by", "accid", "fix", "membership", "matrix", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where no points are provided. Remove unused local variable .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "no", "point", "are", "provid", "remov", "unus", "local", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Don  t update cluster leaders if size = 0. Fix NPE in FuzzyKMeansClusterer .. ", "B_clean_title": ["don", "updat", "cluster", "leader", "size", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer. Fix the for loop. added new centroid clustering bug. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "loop", "ad", "new", "centroid", "cluster", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are too small to split. Set membershipMatrix  i   j  = random . nextDouble ( ). ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "too", "small", "split", "set", "membershipmatrix", "membership", "matrix", "random", "nextdoubl", "next", "doubl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix a bug in FuzzyKMeansClusterer .. Reverted the change in clustering code. Fix the build .. Fix NPE in FuzzyKMeansClusterer patch .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "revert", "chang", "cluster", "code", "fix", "build", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are too small to split. Fix the bug. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "too", "small", "split", "fix", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix 1082 issue. Remove a redundant check. Fix the indentation of FuzzyKMeansClusterer .. Fix NPE in FuzzyKMeansClusterer patch .. ", "B_clean_title": ["fix", "1082", "issu", "remov", "redund", "check", "fix", "indent", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove oversampling .. ", "B_clean_title": ["remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove unused line. added new centroid clustering method. ", "B_clean_title": ["remov", "unus", "line", "ad", "new", "centroid", "cluster", "method"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix a bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Add minDistance patch forFUzzyKMeansClusterer .. Fix a bug in FuzzyKMeansClusterer .. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["add", "mindist", "min", "distanc", "patch", "forfuzzykmeanscluster", "uzzi", "mean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Remove unused local variable .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "unus", "local", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer  closes # 774. Fix the bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "774", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer  closes # 771. Fix the bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "771", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Fixing the build .. ", "B_clean_title": ["remov", "patch", "code", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Remove a couple of unused patches. Removed patch from fuzzy kmeans clusterer. Removed unused variable .. ", "B_clean_title": ["fix", "7759", "remov", "coupl", "unus", "patch", "remov", "patch", "fuzzi", "kmean", "cluster", "remov", "unus", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix the build .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Set minDistance and maxDistance as constants. Remove unused code. ", "B_clean_title": ["set", "mindist", "min", "distanc", "maxdist", "max", "distanc", "as", "constant", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix swapped line. Remove unused patch. ", "B_clean_title": ["fix", "swap", "line", "remov", "unus", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix a bug in FuzzyKMeansClusterer where neighbors are not used. Fix the for loop. Fixing the build .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "neighbor", "are", "not", "use", "fix", "loop", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Fix the build .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Removed patch from fuzzykmeans clusterer. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "patch", "fuzzykmean", "cluster", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix swapped line. Remove unused code. ", "B_clean_title": ["fix", "swap", "line", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. added missing patch. Remove unused local variable .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "ad", "miss", "patch", "remov", "unus", "local", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix the bug. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Fix membership matrix for newly added k = 1 . 5 new dataset. Remove unused line. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "membership", "matrix", "newli", "ad", "new", "dataset", "remov", "unus", "line"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Remove unused local variable .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "unus", "local", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Don  t update cluster leaders if size = 0. Fix the for loop. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["don", "updat", "cluster", "leader", "size", "fix", "loop", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Fix one more test. Fix the issue of best variance summation in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "one", "more", "test", "fix", "issu", "best", "varianc", "summat", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Set membershipMatrix  i   j  = random . nextDouble ( ). ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "set", "membershipmatrix", "membership", "matrix", "random", "nextdoubl", "next", "doubl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Readded missing call to initializeMembershipMatrix ( ) .. Fix the build .. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "read", "miss", "call", "initializemembershipmatrix", "initi", "membership", "matrix", "fix", "build", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Remove unused code. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "remov", "unus", "code", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix 64 - bit GROOVY - 7759 .. Fix minCluster and maxCluster for FuzzyKMeansClusterer. ", "B_clean_title": ["fix", "64", "bit", "groovi", "7759", "fix", "minclust", "min", "cluster", "maxclust", "max", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Fix a bug in FuzzyKMeansClusterer where neighbors are not used. Remove unused line. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "neighbor", "are", "not", "use", "remov", "unus", "line"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove too small exception. Fix the bug. ", "B_clean_title": ["remov", "too", "small", "except", "fix", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove unused code. Fix the merge issue of FuzzyKMeansClusterer .. ", "B_clean_title": ["remov", "unus", "code", "fix", "merg", "issu", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove unneeded patch. removed unused variable. ", "B_clean_title": ["remov", "unneed", "patch", "remov", "unus", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Fix the for loop. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Add minDistance patch forFUzzyKMeansClusterer .. Remove unused code. ", "B_clean_title": ["add", "mindist", "min", "distanc", "patch", "forfuzzykmeanscluster", "uzzi", "mean", "cluster", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the for loop. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["fix", "loop", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Remove unused local variable .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "unus", "local", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 1796. Fix membership matrix from patched file. Remove oversampling .. ", "B_clean_title": ["fix", "1796", "fix", "membership", "matrix", "patch", "file", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Fix membership matrix .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove unused code. ", "B_clean_title": ["remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Remove unused local variable .. added missing int. ", "B_clean_title": ["fix", "7759", "remov", "unus", "local", "variabl", "ad", "miss", "int"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Fix minCluster in FuzzyKMeansClusterer .. added new centroid clustering method. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "ad", "new", "centroid", "cluster", "method"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Fix minCluster used in clustering test. Remove oversampling .. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "fix", "minclust", "min", "cluster", "use", "cluster", "test", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "throw exception if size < k. Fix the for loop. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["throw", "except", "size", "fix", "loop", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Remove redundant code. ", "B_clean_title": ["remov", "patch", "code", "remov", "redund", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix a bug in FuzzyKMeansClusterer where neighbors are not used. Fix the for loop. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "neighbor", "are", "not", "use", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Fix int index = 0 ;. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "fix", "int", "index", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Remove patch from fuzzy kmeans clusterer. Removed patch from fuzzykmeans clusterer. Fix membership matrix .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "patch", "fuzzi", "kmean", "cluster", "remov", "patch", "fuzzykmean", "cluster", "fix", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where the size of the points are zero. Remove unused code. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "size", "point", "are", "zero", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Removed unused code. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where no points are provided. Fix minCluster. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "no", "point", "are", "provid", "fix", "minclust", "min", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where no points are provided. Fix the bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "no", "point", "are", "provid", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Fix the bug. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points were not being taken into. Fix membership matrix for newly added k = 1 . 5 new dataset. Fix membership matrix .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "were", "not", "be", "taken", "into", "fix", "membership", "matrix", "newli", "ad", "new", "dataset", "fix", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Set minDistance so that it is more reliably located .. Removed patch from fuzzykmeans clusterer. Fixing the bug in FuzzyKMeansClusterer .. Fix NPE in FuzzyKMeansClusterer patch .. ", "B_clean_title": ["set", "mindist", "min", "distanc", "so", "that", "it", "more", "reliabl", "locat", "remov", "patch", "fuzzykmean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Remove unused code. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Fix the for loop. added new centroid clustering bug. ", "B_clean_title": ["fix", "7759", "fix", "loop", "ad", "new", "centroid", "cluster", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed unused variable .. Fix NPE in FuzzyKMeansClusterer . updateMembershipMatrix ( ). ", "B_clean_title": ["remov", "unus", "variabl", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "updatemembershipmatrix", "updat", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where no points are provided. Remove unused code. Fix the merge issue of FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "no", "point", "are", "provid", "remov", "unus", "code", "fix", "merg", "issu", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "throw exception if size < k. Fixing the build .. ", "B_clean_title": ["throw", "except", "size", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove oversampling .. added a little bit more tidying of the code. ", "B_clean_title": ["remov", "oversampl", "ad", "littl", "bit", "more", "tidi", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer  closes # 774. Remove unused local variable .. Fix NPE in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "774", "remov", "unus", "local", "variabl", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove unused code. ", "B_clean_title": ["remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Removed patch from fuzzykmeans clusterer. Fix membership matrix .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "patch", "fuzzykmean", "cluster", "fix", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Set points to null in FuzzyKMeansClusterer  this way we can access the. Fix the build .. ", "B_clean_title": ["set", "point", "null", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "thi", "way", "we", "access", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added missing patch. Fix the for loop. ", "B_clean_title": ["ad", "miss", "patch", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Don  t reset the points array if no points are provided  as we don  t have. Remove unused code. ", "B_clean_title": ["don", "reset", "point", "array", "no", "point", "are", "provid", "as", "we", "don", "have", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Don  t throw NPE if fuzziness < 1 . 0d. Removed patch from fuzzykmeans clusterer. Fixing a bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "7759", "don", "throw", "npe", "fuzzi", "0d", "remov", "patch", "fuzzykmean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix indentation and code style. Fix the case of one - to - one calls to scaleInPlace ( ) in Fuzzy. added new centroid clustering method. ", "B_clean_title": ["fix", "indent", "code", "style", "fix", "case", "one", "one", "call", "scaleinplac", "scale", "place", "fuzzi", "ad", "new", "centroid", "cluster", "method"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Don  t update cluster leaders if size = 0. Remove unused code. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "don", "updat", "cluster", "leader", "size", "remov", "unus", "code", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "throw exception if size < k. Fix the for loop. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["throw", "except", "size", "fix", "loop", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 278. Fix membership matrix for newly added k = 1 . 5 new dataset. Fix membership matrix .. ", "B_clean_title": ["fix", "278", "fix", "membership", "matrix", "newli", "ad", "new", "dataset", "fix", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fixing the build .. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["fix", "build", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove too small exception. Fix the issue of new centroid clustering. ", "B_clean_title": ["remov", "too", "small", "except", "fix", "issu", "new", "centroid", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where no points are provided  this way. Fix the for loop. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "no", "point", "are", "provid", "thi", "way", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix maxIterations. ", "B_clean_title": ["fix", "maxiter", "max", "iter"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fixing the build .. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer. Remove unused code. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not listed in the. Fix a bug in FuzzyKMeansClusterer where neighbors are not used. Fix the bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "list", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "neighbor", "are", "not", "use", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Don  t update cluster leaders if size = 0. Remove unused code. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "don", "updat", "cluster", "leader", "size", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove too small exception. Fix a bug in FuzzyKMeansClusterer where the size of the points are zero. Remove unused code. ", "B_clean_title": ["remov", "too", "small", "except", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "size", "point", "are", "zero", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Remove unused code. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove too small exception. throw exception if size < k. Fix the for loop. ", "B_clean_title": ["remov", "too", "small", "except", "throw", "except", "size", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove a redundant empty line. fixed accidently removed int j = 0 ;. Remove oversampling .. ", "B_clean_title": ["remov", "redund", "empti", "line", "fix", "accid", "remov", "int", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where no points are provided. Remove oversampling .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "no", "point", "are", "provid", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Removed unused variable .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "unus", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Remove unused local variable .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "unus", "local", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix FUNY_KMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "funi", "kmeanscluster", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Don  t update cluster leaders if size = 0. Fixing the build .. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "don", "updat", "cluster", "leader", "size", "fix", "build", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "7759", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Fix minCluster in FuzzyKMeansClusterer . java. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "java"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 278. Fix the for loop. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["fix", "278", "fix", "loop", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. added missing patch. Remove unused code. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "ad", "miss", "patch", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Set membershipMatrix  i   j  = random . nextDouble ( ). ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "set", "membershipmatrix", "membership", "matrix", "random", "nextdoubl", "next", "doubl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Removed patch from fuzzykmeans clusterer. Fixing the bug in FuzzyKMeansClusterer .. Fix a bug in FuzzyKMeansClusterer . updateMembershipMatrix ( ) .. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "remov", "patch", "fuzzykmean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "updatemembershipmatrix", "updat", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove too small exception. Remove a couple of unused patches. Remove unused local variable .. ", "B_clean_title": ["remov", "too", "small", "except", "remov", "coupl", "unus", "patch", "remov", "unus", "local", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer  closes # 773. Fix the for loop. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "773", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Fix membership matrix for newly added k = 1 . 5 new dataset. Fix the for loop. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "membership", "matrix", "newli", "ad", "new", "dataset", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Removed patch from fuzzy kmeans clusterer. Remove unused variable .. ", "B_clean_title": ["fix", "7759", "remov", "patch", "fuzzi", "kmean", "cluster", "remov", "unus", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Removed patched file. Remove oversampling .. Fix NPE in FuzzyKMeansClusterer. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "remov", "patch", "file", "remov", "oversampl", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Fix minCluster. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "fix", "minclust", "min", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Removed patch from fuzzykmeans clusterer. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "patch", "fuzzykmean", "cluster", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove unneeded patch. Remove oversampling .. ", "B_clean_title": ["remov", "unneed", "patch", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "fixed 1014 bug. Remove unused code. ", "B_clean_title": ["fix", "1014", "bug", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Readded missing assignment. Fix minCluster in FuzzyKMeansClusterer .. added new centroid clustering bug. ", "B_clean_title": ["read", "miss", "assign", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "ad", "new", "centroid", "cluster", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added missing int. Remove unused code. ", "B_clean_title": ["ad", "miss", "int", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer  closes # 773. Fix the case of new membership information propagation. Fix membership matrix .. Fix NPE in FuzzyKMeansClusterer patch .. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "773", "fix", "case", "new", "membership", "inform", "propag", "fix", "membership", "matrix", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where the size of the points are zero. Remove unused line. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "size", "point", "are", "zero", "remov", "unus", "line"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "fixed 10 / 10 error. Remove unused line. ", "B_clean_title": ["fix", "10", "10", "error", "remov", "unus", "line"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are too small to split. Set membershipMatrix  i   j  = random . nextDouble ( ). ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "too", "small", "split", "set", "membershipmatrix", "membership", "matrix", "random", "nextdoubl", "next", "doubl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove unused line. ", "B_clean_title": ["remov", "unus", "line"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer. Fix the for loop. added new centroid clustering bug. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "loop", "ad", "new", "centroid", "cluster", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Don  t update cluster leaders if size = 0. Fix membership matrix .. ", "B_clean_title": ["don", "updat", "cluster", "leader", "size", "fix", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Removed patch of FuzzyKMeansClusterer  closes # 774. Remove redundant code. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "patch", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "774", "remov", "redund", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Don  t update cluster leaders if size = 0. Fixing the build .. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "don", "updat", "cluster", "leader", "size", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed unused variable .. ", "B_clean_title": ["remov", "unus", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Remove unused code. Fix the issue of best variance summation in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "7759", "remov", "unus", "code", "fix", "issu", "best", "varianc", "summat", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Fix UnboundLocalException in FuzzyKMeansClusterer. ", "B_clean_title": ["fix", "7759", "fix", "unboundlocalexcept", "unbound", "local", "except", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer. Remove unused code. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer  closes # 773. Remove unused code. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "773", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Add minDistance patch for FuzzyKMeansClusterer .. Fixing the build .. ", "B_clean_title": ["add", "mindist", "min", "distanc", "patch", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Removed patched code. Fix one more test. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "patch", "code", "fix", "one", "more", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Remove unused code. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added missing patch. Fix the for loop. ", "B_clean_title": ["ad", "miss", "patch", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer constructor. Fix the bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "constructor", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Readded missing assignment. Fixing the build .. added new centroid clustering patch. ", "B_clean_title": ["read", "miss", "assign", "fix", "build", "ad", "new", "centroid", "cluster", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = n pairs. Remove unused code. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["ad", "pair", "remov", "unus", "code", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Set membershipMatrix  i   j  = random . nextDouble ( ). ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "set", "membershipmatrix", "membership", "matrix", "random", "nextdoubl", "next", "doubl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer. Fix minCluster. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "minclust", "min", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Remove oversampling .. ", "B_clean_title": ["fix", "7759", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added neighbors list. Fix minCluster. ", "B_clean_title": ["ad", "neighbor", "list", "fix", "minclust", "min", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Readded missing patch. Fix membership matrix .. ", "B_clean_title": ["read", "miss", "patch", "fix", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Set membershipMatrix  i   j  = random . nextDouble ( ). Fix NPE in FuzzyKMeansClusterer patch .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "set", "membershipmatrix", "membership", "matrix", "random", "nextdoubl", "next", "doubl", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Remove unused code. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Set membershipMatrix  i   j  = random . nextDouble ( ). ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "set", "membershipmatrix", "membership", "matrix", "random", "nextdoubl", "next", "doubl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from outside. Fix membership matrix for newly added k = 1 .. Fixing the membership matrix used for the first time. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "outsid", "fix", "membership", "matrix", "newli", "ad", "fix", "membership", "matrix", "use", "first", "time"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where the clustering table was not updated. Remove unused code. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "cluster", "tabl", "wa", "not", "updat", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "throw exception if size < k. Fix the for loop. ", "B_clean_title": ["throw", "except", "size", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Fix the bug. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "fix", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Fix the bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Add minDistance patch toFUzzyKMeansClusterer  too .. Remove unneeded patch. Fixing the build .. ", "B_clean_title": ["add", "mindist", "min", "distanc", "patch", "tofuzzykmeanscluster", "uzzi", "mean", "cluster", "too", "remov", "unneed", "patch", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove too small exception. added missing int. Fix the bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["remov", "too", "small", "except", "ad", "miss", "int", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where no points are provided. Remove unused local variable .. Fix the merge issue of FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "no", "point", "are", "provid", "remov", "unus", "local", "variabl", "fix", "merg", "issu", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Don  t update cluster leaders if size = 0. Fix the for loop. ", "B_clean_title": ["don", "updat", "cluster", "leader", "size", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Fix membership matrix for newly added k = 1 . 5 new dataset. added missing int .. Remove oversampling .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "membership", "matrix", "newli", "ad", "new", "dataset", "ad", "miss", "int", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Don  t update cluster leaders if size = 0. Fix bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "don", "updat", "cluster", "leader", "size", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer  closes # 773. Fix the case of new membership information propagation in FuzzyKMeansClusterer .. Fix the build .. Fix the merge issue of FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "773", "fix", "case", "new", "membership", "inform", "propag", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "build", "fix", "merg", "issu", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Updated distSqSum in FuzzyKMeansClusterer. Don  t throw NPE if fuzziness < 1 . 0d. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "updat", "distsqsum", "dist", "sq", "sum", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "don", "throw", "npe", "fuzzi", "0d"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Updated the iterative implementation of FuzzyKMeansClusterer . addPoint ( ). Remove unused code. Normalize membership matrix .. ", "B_clean_title": ["updat", "iter", "implement", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "addpoint", "add", "point", "remov", "unus", "code", "normal", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Remove unused code. ", "B_clean_title": ["fix", "7759", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are too small to split. Set membershipMatrix  i   j  = random . nextDouble ( ). Remove a couple of unused patches. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "too", "small", "split", "set", "membershipmatrix", "membership", "matrix", "random", "nextdoubl", "next", "doubl", "remov", "coupl", "unus", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Fix membership matrix from patch. Remove oversampling .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "membership", "matrix", "patch", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Removed unused variable .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "unus", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where the size of the points are zero. Remove unused line. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "size", "point", "are", "zero", "remov", "unus", "line"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix NPE in FuzzyKMeansClusterer .. Removed unused code. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Fix the bug. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer  closes # 773. Fix the build .. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "773", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer. Fix the for loop. added new centroid clustering bug. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "loop", "ad", "new", "centroid", "cluster", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Set minDistance so that it is more reliably located .. Fixed a bug where clustering is not enabled .. Fixing the build .. ", "B_clean_title": ["set", "mindist", "min", "distanc", "so", "that", "it", "more", "reliabl", "locat", "fix", "bug", "where", "cluster", "not", "enabl", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Fix membership matrix for newly added k = 1 . 5 new dataset. Fix minCluster in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "fix", "membership", "matrix", "newli", "ad", "new", "dataset", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer  closes # 773. added missing patch. Remove unused code. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "773", "ad", "miss", "patch", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove oversampling. ", "B_clean_title": ["remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove a redundant empty line. Remove oversampling .. ", "B_clean_title": ["remov", "redund", "empti", "line", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove too small exception. Remove oversampling .. ", "B_clean_title": ["remov", "too", "small", "except", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Fix the bug. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. removed minCluster from FuzzyKMeansClusterer . java. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "java"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer  closes # 773. Removed patch from fuzzy kmeans clusterer. Fix the bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "773", "remov", "patch", "fuzzi", "kmean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer. Using a patched file from Gremlin .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "patch", "file", "gremlin"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added resultSet = new ArrayList < CentroidCluster < T > > ( ) ;. Remove oversampling .. ", "B_clean_title": ["ad", "resultset", "result", "set", "new", "arraylist", "array", "list", "centroidclust", "centroid", "cluster", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove too small exception. added missing int. Fix the issue of new centroid clustering. Fix NPE in FuzzyKMeansClusterer. ", "B_clean_title": ["remov", "too", "small", "except", "ad", "miss", "int", "fix", "issu", "new", "centroid", "cluster", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Removed unused variable .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "unus", "variabl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix minCluster. ", "B_clean_title": ["fix", "minclust", "min", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Fix a bug in FuzzyKMeansClusterer where neighbors are not used. Fix a bug in the membership matrix .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "neighbor", "are", "not", "use", "fix", "bug", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix indentation and code style. Fix the for loop. ", "B_clean_title": ["fix", "indent", "code", "style", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Fix the for loop. added new centroid clustering method. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "loop", "ad", "new", "centroid", "cluster", "method"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 1796. Remove unused code. Fix the issue of best variance summation in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "1796", "remov", "unus", "code", "fix", "issu", "best", "varianc", "summat", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Removed patch from fuzzykmeans clusterer. Remove too - old merge of one another line. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "patch", "fuzzykmean", "cluster", "remov", "too", "old", "merg", "one", "anoth", "line"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where no points are provided. Fix minCluster in FuzzyKMeansClusterer . java. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "no", "point", "are", "provid", "fix", "minclust", "min", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "java"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Fix the for loop. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 273. Fix the for loop. ", "B_clean_title": ["fix", "273", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer  closes # 773. Removed patch from fuzzykmeans clusterer. Fix the bug in FuzzyKMeansClusterer .. Fix a bug in FuzzyKMeansClusterer . updateMembershipMatrix ( ) .. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "close", "773", "remov", "patch", "fuzzykmean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "updatemembershipmatrix", "updat", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. Remove scaleInPlace ( ) from FuzzyKMeansClusterer . java. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "remov", "scaleinplac", "scale", "place", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "java"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Remove unused code. ", "B_clean_title": ["fix", "7759", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Fix the for loop. ", "B_clean_title": ["fix", "7759", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer. Remove unused code. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove oversampling .. added new centroid clustering method. ", "B_clean_title": ["remov", "oversampl", "ad", "new", "centroid", "cluster", "method"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "fix a crash. Fix the for loop. ", "B_clean_title": ["fix", "crash", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix the bug in FuzzyKMeansClusterer .. Fix NPE in FuzzyKMeansClusterer patch .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from fuzzy kmeans clusterer. Fix a bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["remov", "patch", "fuzzi", "kmean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Fix minCluster and maxCluster for FuzzyKMeansClusterer. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "fix", "minclust", "min", "cluster", "maxclust", "max", "cluster", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from fuzzy kmeans clusterer. Fix the bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["remov", "patch", "fuzzi", "kmean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Fix a bug in the membership matrix .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "bug", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove unused code. ", "B_clean_title": ["remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. Removed patch from fuzzykmeans clusterer. Fix membership matrix .. ", "B_clean_title": ["fix", "7759", "remov", "patch", "fuzzykmean", "cluster", "fix", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "throw exception if size < k. Fix the for loop. ", "B_clean_title": ["throw", "except", "size", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix # 7759. don  t update cluster centers on the fly. Fix membership matrix .. ", "B_clean_title": ["fix", "7759", "don", "updat", "cluster", "center", "fli", "fix", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix the build .. Fix NPE in FuzzyKMeansClusterer patch .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "build", "fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Remove unused for loop. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "remov", "unus", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Updated the code for the clustering test .. Removing minCluster from newly added code. ", "B_clean_title": ["updat", "code", "cluster", "test", "remov", "minclust", "min", "cluster", "newli", "ad", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from the. fixed a small bug. Remove oversampling .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "fix", "small", "bug", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used. Fix the for loop. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not used .. Don  t scale the array .. added new centroid clustering bug. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "use", "don", "scale", "array", "ad", "new", "centroid", "cluster", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix swapped line. Remove unused line. added minCluster to newly added clusters .. ", "B_clean_title": ["fix", "swap", "line", "remov", "unus", "line", "ad", "minclust", "min", "cluster", "newli", "ad", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Set minDistance to Double . MAX_VALUE for FuzzyKMeansClusterer. Remove unused code. ", "B_clean_title": ["set", "mindist", "min", "distanc", "doubl", "max", "valu", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are not accessible from outside. Fix membership matrix for newly added k = 1 . 5 new dataset. Fixing the bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "not", "access", "outsid", "fix", "membership", "matrix", "newli", "ad", "new", "dataset", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove a redundant empty line. Remove unused code. ", "B_clean_title": ["remov", "redund", "empti", "line", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix new feature. Fix a bug in FuzzyKMeansClusterer . updateMembershipMatrix ( ) .. ", "B_clean_title": ["fix", "new", "featur", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "updatemembershipmatrix", "updat", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer where data points are too small to split. Fix a bug in FuzzyKMeansClusterer .. Using a patched file from Gremlin .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "data", "point", "are", "too", "small", "split", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "patch", "file", "gremlin"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added k = number of nodes to the new collection. Fix the for loop. ", "B_clean_title": ["ad", "number", "node", "new", "collect", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Revert this patch if it is still failing .. ", "B_clean_title": ["revert", "thi", "patch", "it", "still", "fail"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove a redundant empty line. Fix membership test. ", "B_clean_title": ["remov", "redund", "empti", "line", "fix", "membership", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. Remove over - aggressive clustering. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "over", "aggress", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test script. Fix a bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["remov", "patch", "test", "script", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Removed patched code. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "patch", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "If fuzziness < 1 . 0d then throw an exception. ", "B_clean_title": ["fuzzi", "0d", "then", "throw", "except"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Removed patch for max membership in FuzzyKMeansClusterer. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test script. Remove oversampling .. ", "B_clean_title": ["remov", "patch", "test", "script", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix membership matrix from previous fix. ", "B_clean_title": ["fix", "membership", "matrix", "previou", "fix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. Fix new test. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "new", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix membership matrix. Remove oversampling. ", "B_clean_title": ["fix", "membership", "matrix", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added dataPoints to become unmodifiable. If we can  t find a clusterer with fuzziness < 1 . 0d  throw. ", "B_clean_title": ["ad", "datapoint", "data", "point", "becom", "unmodifi", "we", "find", "cluster", "fuzzi", "0d", "throw"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Readded missing updateClusterCenters method. Removed patch from fuzzykmeans clusterer. Remove spurious j ++. ", "B_clean_title": ["read", "miss", "updateclustercent", "updat", "cluster", "center", "method", "remov", "patch", "fuzzykmean", "cluster", "remov", "spuriou"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "If fuzziness < 1 . 0d then throw an exception. added new centroid clustering test. ", "B_clean_title": ["fuzzi", "0d", "then", "throw", "except", "ad", "new", "centroid", "cluster", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix membership matrix after membership update .. ", "B_clean_title": ["fix", "membership", "matrix", "after", "membership", "updat"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "throw exception if size < k. ", "B_clean_title": ["throw", "except", "size"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added dataPoints to become unmodifiable. ", "B_clean_title": ["ad", "datapoint", "data", "point", "becom", "unmodifi"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. Readded missing assignment. Remove spurious j ++. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "read", "miss", "assign", "remov", "spuriou"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. Fix membership matrix for newly added k - means clusterer .. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "membership", "matrix", "newli", "ad", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove a couple of unused patches. Removed patch for max membership in FuzzyKMeansClusterer. Readded missing patch. ", "B_clean_title": ["remov", "coupl", "unus", "patch", "remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "read", "miss", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Fixing a small issue in FuzzyKMeansClusterer .. ", "B_clean_title": ["remov", "patch", "test", "fix", "small", "issu", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove a couple incorrect lines. ", "B_clean_title": ["remov", "coupl", "incorrect", "line"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["remov", "patch", "test", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. added centroid clustering test. Remove i ++ to fix the build .. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "ad", "centroid", "cluster", "test", "remov", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "make dataPoints unmodifiable. Removed patch from test script. Remove over - aggressive clustering. ", "B_clean_title": ["make", "datapoint", "data", "point", "unmodifi", "remov", "patch", "test", "script", "remov", "over", "aggress", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Remove patch for newly added clusterer. ", "B_clean_title": ["remov", "patch", "test", "remov", "patch", "newli", "ad", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix County Change. throw exception if fuzziness < 1 . 0d. ", "B_clean_title": ["fix", "counti", "chang", "throw", "except", "fuzzi", "0d"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix whitespace. Fix single threaded update of cluster center in case of changed max membership. Fix a bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "whitespac", "fix", "singl", "thread", "updat", "cluster", "center", "case", "chang", "max", "membership", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix membership matrix not being modified by accident. ", "B_clean_title": ["fix", "membership", "matrix", "not", "be", "modifi", "by", "accid"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added dataPoints to become unmodifiable. Remove spurious j ++. ", "B_clean_title": ["ad", "datapoint", "data", "point", "becom", "unmodifi", "remov", "spuriou"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix whitespace. Removed patch for max membership in FuzzyKMeansClusterer. Remove spurious increment of the array index. ", "B_clean_title": ["fix", "whitespac", "remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "spuriou", "increment", "array", "index"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Readded a clear hack .. ", "B_clean_title": ["remov", "patch", "test", "read", "clear", "hack"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer. Removed patch for max membership in FuzzyKMeansClusterer. If we have not found a match throw exception. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "we", "have", "not", "found", "match", "throw", "except"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Fix a small bug in FuzzyKMeansClusterer. ", "B_clean_title": ["remov", "patch", "test", "fix", "small", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove a couple of unused patches. Removed patch for now .. ", "B_clean_title": ["remov", "coupl", "unus", "patch", "remov", "patch", "now"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Fix scaleInPlace for newly added centroid clusterer. ", "B_clean_title": ["remov", "patch", "code", "fix", "scaleinplac", "scale", "place", "newli", "ad", "centroid", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Removed patched code. Fix the bug. Readded missing patch. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "patch", "code", "fix", "bug", "read", "miss", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "throw exception if data is too small. Removed patch from test. ", "B_clean_title": ["throw", "except", "data", "too", "small", "remov", "patch", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Throw the right exception if fuzziness is not 1 . 0d. ", "B_clean_title": ["remov", "patch", "code", "throw", "right", "except", "fuzzi", "not", "0d"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test script. Fix a bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["remov", "patch", "test", "script", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added dataPoints to become unmodifiable. Remove over - aggressive loop. ", "B_clean_title": ["ad", "datapoint", "data", "point", "becom", "unmodifi", "remov", "over", "aggress", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from fuzzy kmeans clusterer. Fix a bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["remov", "patch", "fuzzi", "kmean", "cluster", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Fix a small bug. Remove i ++ to fix the build .. ", "B_clean_title": ["remov", "patch", "test", "fix", "small", "bug", "remov", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. Readded missing assignment. Remove over - aggressive loop. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "read", "miss", "assign", "remov", "over", "aggress", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Readded a clear line to test the clustering code. ", "B_clean_title": ["remov", "patch", "code", "read", "clear", "line", "test", "cluster", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added points = Collections . unmodifiable ( new ArrayList < T > ( dataPoints ));. Removed patch for max membership in FuzzyKMeansClusterer. Normalize membership matrix for newly added point. ", "B_clean_title": ["ad", "point", "collect", "unmodifi", "new", "arraylist", "array", "list", "datapoint", "data", "point", "remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "normal", "membership", "matrix", "newli", "ad", "point"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix membershipMatrix. Remove over - aggressive clustering. ", "B_clean_title": ["fix", "membershipmatrix", "membership", "matrix", "remov", "over", "aggress", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Fix a bug in FuzzyKMeansClusterer where point is not added to the points. ", "B_clean_title": ["remov", "patch", "test", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "where", "point", "not", "ad", "point"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer .. Removed patch from test script. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "patch", "test", "script"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for clustering test. added new centroid clustering test. ", "B_clean_title": ["remov", "patch", "cluster", "test", "ad", "new", "centroid", "cluster", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Fix the bug. ", "B_clean_title": ["remov", "patch", "test", "fix", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. Fix the bug. Readded missing patch. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "bug", "read", "miss", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Remove spurious change. ", "B_clean_title": ["remov", "patch", "code", "remov", "spuriou", "chang"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove a couple of unused patches. Fix membership matrix not being modified by accident. ", "B_clean_title": ["remov", "coupl", "unus", "patch", "fix", "membership", "matrix", "not", "be", "modifi", "by", "accid"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added dataPoints to become unmodifiable. Remove oversampling .. ", "B_clean_title": ["ad", "datapoint", "data", "point", "becom", "unmodifi", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer. Removed patch from test script. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "patch", "test", "script"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix membershipMatrix. ", "B_clean_title": ["fix", "membershipmatrix", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Remove scaleInPlace from newly added patch. ", "B_clean_title": ["remov", "patch", "code", "remov", "scaleinplac", "scale", "place", "newli", "ad", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test script. Set membershipMatrix  i  j  = 1 . 0 / sum ;. ", "B_clean_title": ["remov", "patch", "test", "script", "set", "membershipmatrix", "membership", "matrix", "sum"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. added missing patch. ", "B_clean_title": ["remov", "patch", "test", "ad", "miss", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. Readded missing patch. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "read", "miss", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Added a throw if we are too small to split. ", "B_clean_title": ["ad", "throw", "we", "are", "too", "small", "split"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove a redundant empty line. Removed patch from test. Remove oversampling .. ", "B_clean_title": ["remov", "redund", "empti", "line", "remov", "patch", "test", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Reverted the change that the clustering test was using. Remove a couple incorrect entries. ", "B_clean_title": ["revert", "chang", "that", "cluster", "test", "wa", "remov", "coupl", "incorrect", "entri"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test script. Fix scaleInPlace .. ", "B_clean_title": ["remov", "patch", "test", "script", "fix", "scaleinplac", "scale", "place"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["remov", "patch", "test", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Fix a bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["remov", "patch", "code", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Reverted the change that the clustering test was using. Fix FuzzyKMeansClusterer .. ", "B_clean_title": ["revert", "chang", "that", "cluster", "test", "wa", "fix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove one more test. ", "B_clean_title": ["remov", "one", "more", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. Remove oversampling .. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Reverted the change that the clustering test was using. If we have not found a clusterer  throw an exception if we can  t find a. ", "B_clean_title": ["revert", "chang", "that", "cluster", "test", "wa", "we", "have", "not", "found", "cluster", "throw", "except", "we", "find"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Remove scaleInPlace ( ) from FuzzyKMeansClusterer. ", "B_clean_title": ["remov", "patch", "test", "remov", "scaleinplac", "scale", "place", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Set membershipMatrix  i   j  for new cluster. ", "B_clean_title": ["remov", "patch", "test", "set", "membershipmatrix", "membership", "matrix", "new", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Added a throw if we are too small to split. Remove oversampling. Remove over - aggressive clustering. ", "B_clean_title": ["ad", "throw", "we", "are", "too", "small", "split", "remov", "oversampl", "remov", "over", "aggress", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "throw exception if size < k. ", "B_clean_title": ["throw", "except", "size"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix single threaded update of cluster center after speedup .. added centroid clustering test. ", "B_clean_title": ["fix", "singl", "thread", "updat", "cluster", "center", "after", "speedup", "ad", "centroid", "cluster", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a small bug in FuzzyKMeansClusterer. Removed patch for max membership in FuzzyKMeansClusterer. ", "B_clean_title": ["fix", "small", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test script. Remove i ++ to fix the build .. ", "B_clean_title": ["remov", "patch", "test", "script", "remov", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Fix a bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["remov", "patch", "code", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Remove oversampling .. ", "B_clean_title": ["remov", "patch", "code", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. If we can  t find a clusterer with fuzziness < 1 . 0d  throw. ", "B_clean_title": ["remov", "patch", "code", "we", "find", "cluster", "fuzzi", "0d", "throw"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Fix single line. ", "B_clean_title": ["remov", "patch", "test", "fix", "singl", "line"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer. Removed patch from test script. Remove oversampling .. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "patch", "test", "script", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove too small exception. Removed patch from test script. Readded missing patch. ", "B_clean_title": ["remov", "too", "small", "except", "remov", "patch", "test", "script", "read", "miss", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Added throw if size < k. Fix a small bug. ", "B_clean_title": ["ad", "throw", "size", "fix", "small", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. ", "B_clean_title": ["remov", "patch", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix whitespace. Removed patch from fuzzykmeans clusterer. Remove oversampling .. ", "B_clean_title": ["fix", "whitespac", "remov", "patch", "fuzzykmean", "cluster", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove a redundant empty line. Removed patch for max membership in FuzzyKMeansClusterer. Reset membership matrix after point reduction. If fuzziness < = 1 . 0d  throw an exception if we cannot do anything. ", "B_clean_title": ["remov", "redund", "empti", "line", "remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "reset", "membership", "matrix", "after", "point", "reduct", "fuzzi", "0d", "throw", "except", "we", "not", "anyth"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Added a throw. ", "B_clean_title": ["ad", "throw"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Readded missing updateClusterCenters method. Removed patch for max membership in FuzzyKMeansClusterer. ", "B_clean_title": ["read", "miss", "updateclustercent", "updat", "cluster", "center", "method", "remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix membership matrix after merge of patched JAR. Removed patch from test. Remove patch from tmp. ", "B_clean_title": ["fix", "membership", "matrix", "after", "merg", "patch", "jar", "remov", "patch", "test", "remov", "patch", "tmp"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove a redundant empty line. Removed patch from test. ", "B_clean_title": ["remov", "redund", "empti", "line", "remov", "patch", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. added centroid clustering fix. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "ad", "centroid", "cluster", "fix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "If fuzziness < 1 . 0d  throw an exception if it is too small .. Remove oversampling. ", "B_clean_title": ["fuzzi", "0d", "throw", "except", "it", "too", "small", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added dataPoints back into view as a list. If we have a max fuzziness  throw an exception if we can  t find a dataset. ", "B_clean_title": ["ad", "datapoint", "data", "point", "back", "into", "view", "as", "list", "we", "have", "max", "fuzzi", "throw", "except", "we", "find", "dataset"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Remove over - updated code. ", "B_clean_title": ["remov", "patch", "test", "remov", "over", "updat", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Remove spurious j ++. ", "B_clean_title": ["remov", "patch", "test", "remov", "spuriou"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "throw exception if size < k. ", "B_clean_title": ["throw", "except", "size"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. Reverted the changes related to multiple memberships .. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "revert", "chang", "relat", "multipl", "membership"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Readded missing updateClusterCenters method. Removed patch from test. Remove oversampling .. ", "B_clean_title": ["read", "miss", "updateclustercent", "updat", "cluster", "center", "method", "remov", "patch", "test", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Remove a couple incorrect lines. ", "B_clean_title": ["remov", "patch", "code", "remov", "coupl", "incorrect", "line"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix membership matrix. Remove unused line. ", "B_clean_title": ["fix", "membership", "matrix", "remov", "unus", "line"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Fix a bug in FuzzyKMeansClusterer .. Readded missing patch. ", "B_clean_title": ["remov", "patch", "test", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "read", "miss", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test script. Throw the right exception if fuzziness is not 1 . 0d. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["remov", "patch", "test", "script", "throw", "right", "except", "fuzzi", "not", "0d", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Readded clear line. ", "B_clean_title": ["remov", "patch", "code", "read", "clear", "line"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from fuzzykmeans clusterer. Fix the bug. Remove over - aggressive loop. ", "B_clean_title": ["remov", "patch", "fuzzykmean", "cluster", "fix", "bug", "remov", "over", "aggress", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. Fixing small issue in FuzzyKMeansClusterer .. Remove over - aggressive clustering. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "small", "issu", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "over", "aggress", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patched code. Remove over - aggressive clustering. ", "B_clean_title": ["remov", "patch", "code", "remov", "over", "aggress", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Fix membership matrix after adding point to pointArray. ", "B_clean_title": ["remov", "patch", "test", "fix", "membership", "matrix", "after", "ad", "point", "pointarray", "point", "array"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix membership matrix not being modified by accident. Fix a small bug in FuzzyKMeansClusterer. ", "B_clean_title": ["fix", "membership", "matrix", "not", "be", "modifi", "by", "accid", "fix", "small", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix membershipMatrix. Remove oversampling .. ", "B_clean_title": ["fix", "membershipmatrix", "membership", "matrix", "remov", "oversampl"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix membershipMatrix. Remove scaleInPlace from newly added test case. ", "B_clean_title": ["fix", "membershipmatrix", "membership", "matrix", "remov", "scaleinplac", "scale", "place", "newli", "ad", "test", "case"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Remove scaleInPlace from FuzzyKMeansClusterer. ", "B_clean_title": ["remov", "patch", "test", "remov", "scaleinplac", "scale", "place", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from fuzzykmeans clusterer. ", "B_clean_title": ["remov", "patch", "fuzzykmean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "If fuzziness < 1 . 0d then throw an exception. If we have a max fuzziness value  throw an exception if it is too small .. ", "B_clean_title": ["fuzzi", "0d", "then", "throw", "except", "we", "have", "max", "fuzzi", "valu", "throw", "except", "it", "too", "small"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix membership matrix after membership update. ", "B_clean_title": ["fix", "membership", "matrix", "after", "membership", "updat"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. added missing patch. Remove scaleInPlace from newly added patch. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "ad", "miss", "patch", "remov", "scaleinplac", "scale", "place", "newli", "ad", "patch"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. Remove scaleInPlace from newly added piece. Set membershipMatrix  i   j  for new cluster. ", "B_clean_title": ["remov", "patch", "test", "remov", "scaleinplac", "scale", "place", "newli", "ad", "piec", "set", "membershipmatrix", "membership", "matrix", "new", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for max membership in FuzzyKMeansClusterer. Remove spurious increment of clustering code. ", "B_clean_title": ["remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "spuriou", "increment", "cluster", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from test. If fuzziness < = 1 . 0d  throw an exception if we cannot do anything. ", "B_clean_title": ["remov", "patch", "test", "fuzzi", "0d", "throw", "except", "we", "not", "anyth"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "throw exception if size < k. Fix a bug in FuzzyKMeansClusterer. ", "B_clean_title": ["throw", "except", "size", "fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix NPE in FuzzyKMeansClusterer. Removed patch from test script. ", "B_clean_title": ["fix", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "patch", "test", "script"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove the scaleInPlace ( ) from the array .. ", "B_clean_title": ["remov", "scaleinplac", "scale", "place", "array"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove unused code. ", "B_clean_title": ["remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Reverted the change that removed from another PR to avoid additional NPE in the same way. Remove unused membership matrix .. ", "B_clean_title": ["revert", "chang", "that", "remov", "anoth", "pr", "avoid", "addit", "npe", "same", "way", "remov", "unus", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the build .. Remove a bit from the RS repair bug. ", "B_clean_title": ["fix", "build", "remov", "bit", "rs", "repair", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch from fuzzykmeans clusterer. Fix one more test. ", "B_clean_title": ["remov", "patch", "fuzzykmean", "cluster", "fix", "one", "more", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "added missing checkNotNull check. Remove a couple incorrect entries. ", "B_clean_title": ["ad", "miss", "checknotnul", "check", "not", "null", "check", "remov", "coupl", "incorrect", "entri"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the indentation of FuzzyKMeansClusterer. Removed patch for clustering bug. added missing int. ", "B_clean_title": ["fix", "indent", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "patch", "cluster", "bug", "ad", "miss", "int"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the build .. Fix a small bug in FuzzyKMeansClusterer. ", "B_clean_title": ["fix", "build", "fix", "small", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove unused code. Fix one more test. ", "B_clean_title": ["remov", "unus", "code", "fix", "one", "more", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Normalize membership matrix in case of no points provided. Removed patch for max membership in FuzzyKMeansClusterer. ", "B_clean_title": ["normal", "membership", "matrix", "case", "no", "point", "provid", "remov", "patch", "max", "membership", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove minDistance from newly added piece. ", "B_clean_title": ["remov", "mindist", "min", "distanc", "newli", "ad", "piec"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the for loop. Remove unused code. ", "B_clean_title": ["fix", "loop", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fixing the bug in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove unused code. Removed fixed distSqSum .. ", "B_clean_title": ["remov", "unus", "code", "remov", "fix", "distsqsum", "dist", "sq", "sum"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed too small exception. Fix the for - loop of FuzzyKMeansClusterer .. Fix the for loop. ", "B_clean_title": ["remov", "too", "small", "except", "fix", "loop", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "fix", "loop"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "removed empty line. Add a null check. Fix the build. ", "B_clean_title": ["remov", "empti", "line", "add", "null", "check", "fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "throw exception if size < k. ", "B_clean_title": ["throw", "except", "size"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "removed empty line. Remove unused code. ", "B_clean_title": ["remov", "empti", "line", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix a bug in FuzzyKMeansClusterer with no points provided. Add a null check. Fix the indentation of FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "bug", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "no", "point", "provid", "add", "null", "check", "fix", "indent", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix assignedDifferently in FuzzyKMeansClusterer .. ", "B_clean_title": ["fix", "assigneddiffer", "assign", "differ", "fuzzykmeanscluster", "fuzzi", "mean", "cluster"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Throw the right exception if fuzziness is not met .. Fix single line error. ", "B_clean_title": ["throw", "right", "except", "fuzzi", "not", "met", "fix", "singl", "line", "error"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the compilation with Java 1 . 6. Fix membership matrix. ", "B_clean_title": ["fix", "compil", "java", "fix", "membership", "matrix"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Remove a couple of unused patches. Removed patch from fuzzykmeans clusterer. Fix one more test. ", "B_clean_title": ["remov", "coupl", "unus", "patch", "remov", "patch", "fuzzykmean", "cluster", "fix", "one", "more", "test"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix the issue of NPE in FuzzyKMeansClusterer .. Remove unused code. ", "B_clean_title": ["fix", "issu", "npe", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "remov", "unus", "code"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Removed patch for clustering bug. Remove spurious j ++ for newClusters .. ", "B_clean_title": ["remov", "patch", "cluster", "bug", "remov", "spuriou", "newclust", "new", "cluster"]},
{"A_title": "BinomialDistribution deals with degenerate cases incorrectlyThe following calculation returns false results:  new BinomialDistribution(0 0.01).logProbability(0)  It evaluates to Double.NaN when it should be 0 (cf. for example dbinom(0 0 0.01 log=T) in R).  I attach a patch dealing with the problem. The patch also adds a test for this bug.", "A_clean_title": ["binomialdistribut", "binomi", "distribut", "deal", "degener", "case", "incorrectlyth", "incorrectli", "follow", "calcul", "return", "fals", "result", "new", "binomialdistribut", "binomi", "distribut", "01", "logprob", "log", "probabl", "it", "evalu", "doubl", "nan", "na", "when", "it", "cf", "exampl", "dbinom", "01", "log=t", "attach", "patch", "deal", "problem", "patch", "also", "add", "test", "thi", "bug"], "B_title": "Fix SaddlePointExpansion test. Fix NPE in SaddlePointExpansion. ", "B_clean_title": ["fix", "saddlepointexpans", "saddl", "point", "expans", "test", "fix", "npe", "saddlepointexpans", "saddl", "point", "expans"]},
{"A_title": "BinomialDistribution deals with degenerate cases incorrectlyThe following calculation returns false results:  new BinomialDistribution(0 0.01).logProbability(0)  It evaluates to Double.NaN when it should be 0 (cf. for example dbinom(0 0 0.01 log=T) in R).  I attach a patch dealing with the problem. The patch also adds a test for this bug.", "A_clean_title": ["binomialdistribut", "binomi", "distribut", "deal", "degener", "case", "incorrectlyth", "incorrectli", "follow", "calcul", "return", "fals", "result", "new", "binomialdistribut", "binomi", "distribut", "01", "logprob", "log", "probabl", "it", "evalu", "doubl", "nan", "na", "when", "it", "cf", "exampl", "dbinom", "01", "log=t", "attach", "patch", "deal", "problem", "patch", "also", "add", "test", "thi", "bug"], "B_title": "Fix SaddlePointExpansion with a max of 1  min = - 1  max = -. ", "B_clean_title": ["fix", "saddlepointexpans", "saddl", "point", "expans", "max", "min", "max"]},
{"A_title": "Generate change list separated by types using labelsAs discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like question or refactoring). There is also headerForOtherChanges method to override default Other header.", "A_clean_title": ["gener", "chang", "list", "separ", "by", "type", "labelsa", "label", "as", "discuss", "mail", "list", "instead", "one", "big", "list", "improv", "chang", "list", "releas", "divid", "into", "chang", "type", "base", "label", "it", "requir", "specifi", "which", "label", "consid", "separ", "some", "other", "label", "exclud", "like", "question", "or", "refactor", "there", "also", "headerforotherchang", "header", "other", "chang", "method", "overrid", "default", "other", "header"], "B_title": "Add null check in ArgumentMatchingTool. ", "B_clean_title": ["add", "null", "check", "argumentmatchingtool", "argument", "match", "tool"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "erron", "loop", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "erron", "loop", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Added missing @@. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Added a fix for null constraint. ", "B_clean_title": ["ad", "fix", "null", "constraint"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug in BisectionSolver. fixed erroneous test. ", "B_clean_title": ["fix", "small", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed a small bug. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "small", "bug"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug. fixed bug in BisectionSolver. ", "B_clean_title": ["fix", "small", "bug", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous build. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "build"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. updated bisection solver with updated maximal iterations. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "updat", "bisect", "solver", "updat", "maxim", "iter"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver . solve ( ) .. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "solv"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous loop. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. Set default function value accuracy across the full range of solutions .. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "set", "default", "function", "valu", "accuraci", "across", "full", "rang", "solut"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. ", "B_clean_title": ["fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed N4G test. Set result to 0 in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "n4g", "test", "set", "result", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed N4G problem. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "n4g", "problem", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in the bisection solver. ", "B_clean_title": ["fix", "bug", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed N4G problem. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "n4g", "problem", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed n4g1 patch. fixed erroneous build. ", "B_clean_title": ["fix", "n4g1", "patch", "fix", "erron", "build"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous build. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "build"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed N4G problem. ", "B_clean_title": ["fix", "n4g", "problem"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed NPE in BisectionSolver . solve ( ) .. ", "B_clean_title": ["fix", "npe", "bisectionsolv", "bisect", "solver", "solv"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous build. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "build"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous build. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "build"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed NPE in BisectionSolver . solve ( ) .. ", "B_clean_title": ["fix", "npe", "bisectionsolv", "bisect", "solver", "solv"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver . solve ( ) .. fixed bug in BisectionSolver. ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "solv", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed N4G problem. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "n4g", "problem", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed N4G problem. Fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "n4g", "problem", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug in BisectionSolver. fixed erroneous test. ", "B_clean_title": ["fix", "small", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed N4G problem. fixed bug in BisectionSolver. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "n4g", "problem", "fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. ", "B_clean_title": ["fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. ", "B_clean_title": ["fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver. Revert  fix a small bug in BisectionSolver . ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "revert", "fix", "small", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated intro patch. Reverted the changes related to bisectionSolver. ", "B_clean_title": ["updat", "intro", "patch", "revert", "chang", "relat", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated solve ( ) method. Fix error in BisectionSolver. ", "B_clean_title": ["updat", "solv", "method", "fix", "error", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a merge conflict in BisectionSolver. I had left it harwired to allow for partial nashorn support .. ", "B_clean_title": ["fix", "merg", "conflict", "bisectionsolv", "bisect", "solver", "had", "left", "it", "harwir", "allow", "partial", "nashorn", "support"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver. fixed erroneous test. ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Set default function value accuracy after running fixed tests .. ", "B_clean_title": ["set", "default", "function", "valu", "accuraci", "after", "run", "fix", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "I had left it harwired to say that we can merge a couple of solutions together. ", "B_clean_title": ["had", "left", "it", "harwir", "say", "that", "we", "merg", "coupl", "solut", "togeth"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous loop. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver. fixed erroneous test. ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. Revert  Increased maximal iterations for bisection solver to fix cruise (. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "revert", "increas", "maxim", "iter", "bisect", "solver", "fix", "cruis"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a typo in BisectionSolver . solve ( ). fixed erroneous loop. ", "B_clean_title": ["fix", "typo", "bisectionsolv", "bisect", "solver", "solv", "fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug. Re - computed the bisection solver with fixed erroneous data. ", "B_clean_title": ["fix", "small", "bug", "re", "comput", "bisect", "solver", "fix", "erron", "data"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated solve ( ) method. fixed maxIter = max ; patched. ", "B_clean_title": ["updat", "solv", "method", "fix", "maxit", "max", "iter", "max", "patch"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a typo in BisectionSolver . solve ( ). fixed erroneous loop. ", "B_clean_title": ["fix", "typo", "bisectionsolv", "bisect", "solver", "solv", "fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a typo in BisectionSolver . solve ( ). Set functionValueAccuracy to defaultFunctionValueAccuracy. ", "B_clean_title": ["fix", "typo", "bisectionsolv", "bisect", "solver", "solv", "set", "functionvalueaccuraci", "function", "valu", "accuraci", "defaultfunctionvalueaccuraci", "default", "function", "valu", "accuraci"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Increasing max iterations for bisection solver .. ", "B_clean_title": ["increas", "max", "iter", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. Set function value accuracy to default value accuracy. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "set", "function", "valu", "accuraci", "default", "valu", "accuraci"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver. fixed erroneous loop. added i = 0 ; patched. ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "loop", "ad", "patch"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver. Revert  Fixed a small bug in BisectionSolver . computedValue ( ) . ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "revert", "fix", "small", "bug", "bisectionsolv", "bisect", "solver", "computedvalu", "comput", "valu"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated solve ( ) method. Set function value accuracy to default value accuracy. ", "B_clean_title": ["updat", "solv", "method", "set", "function", "valu", "accuraci", "default", "valu", "accuraci"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Reset the function value accuracy after running the bisectionSolver .. ", "B_clean_title": ["reset", "function", "valu", "accuraci", "after", "run", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver. Set function value accuracy to default when min = max = 0. ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "set", "function", "valu", "accuraci", "default", "when", "min", "max"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed maxIter = max ; patched. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "maxit", "max", "iter", "max", "patch"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "I had left it harwired to allow for correct bracketing. ", "B_clean_title": ["had", "left", "it", "harwir", "allow", "correct", "bracket"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. Reset function value accuracy after maximal iterations reached the default max .. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "reset", "function", "valu", "accuraci", "after", "maxim", "iter", "reach", "default", "max"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous test. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor issue with bisectionSolver. Reverted the changes related to bisectionSolver. ", "B_clean_title": ["fix", "minor", "issu", "bisectionsolv", "bisect", "solver", "revert", "chang", "relat", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. updated patch. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "updat", "patch"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated solve ( ) method. fixed a small bug. ", "B_clean_title": ["updat", "solv", "method", "fix", "small", "bug"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "set result of bisectionSolver. updated intro patch. ", "B_clean_title": ["set", "result", "bisectionsolv", "bisect", "solver", "updat", "intro", "patch"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated solve ( ) method. fixed erroneous loop. ", "B_clean_title": ["updat", "solv", "method", "fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated intro patch. Set maximalIterationCount as well. ", "B_clean_title": ["updat", "intro", "patch", "set", "maximaliterationcount", "maxim", "iter", "count", "as", "well"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated intro patch. Set default function value accuracy. ", "B_clean_title": ["updat", "intro", "patch", "set", "default", "function", "valu", "accuraci"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a typo in BisectionSolver . solve ( ). Set default function value accuracy when using fixed maxIterCount. ", "B_clean_title": ["fix", "typo", "bisectionsolv", "bisect", "solver", "solv", "set", "default", "function", "valu", "accuraci", "when", "fix", "maxitercount", "max", "iter", "count"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated intro patch. fixed erroneous test. ", "B_clean_title": ["updat", "intro", "patch", "fix", "erron", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug. I had left it harwired to allow for partial nashorn support .. ", "B_clean_title": ["fix", "small", "bug", "had", "left", "it", "harwir", "allow", "partial", "nashorn", "support"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated intro patch. Set iterationCount as well as maximalIterationCount. ", "B_clean_title": ["updat", "intro", "patch", "set", "iterationcount", "iter", "count", "as", "well", "as", "maximaliterationcount", "maxim", "iter", "count"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix parseShort erro. ", "B_clean_title": ["fix", "parseshort", "pars", "short", "erro"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed extra chars. ", "B_clean_title": ["remov", "extra", "char"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Improve error handling for --  and  ( areas with the same length ) - removed 0x. ", "B_clean_title": ["improv", "error", "handl", "area", "same", "length", "remov", "0x"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Handle hex number format in NumberUtils. ", "B_clean_title": ["handl", "hex", "number", "format", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "formatting fixes. ", "B_clean_title": ["format", "fix"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Remove a check for -- . ", "B_clean_title": ["remov", "check"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow null string input. ", "B_clean_title": ["allow", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix checkstyle. ", "B_clean_title": ["fix", "checkstyl"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix a regression in NumberUtils. ", "B_clean_title": ["fix", "regress", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix NumberFormatException. fixed NPE in NumberUtils. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "numberformatexcept", "number", "format", "except", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for 0x digits. Fix NumberFormatException. Fix NPE. ", "B_clean_title": ["ignor", "sign", "0x", "digit", "fix", "numberformatexcept", "number", "format", "except", "fix", "npe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in NumberUtils. ", "B_clean_title": ["fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. fixed E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix E3C. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix e3c032e032c0. fix the build. Added patch for E3E. revert accidently change. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032e032c0", "fix", "build", "ad", "patch", "e3e", "revert", "accid", "chang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. Handle null string in GenProg_Defects4J_Lang_7. Added patch for DoubleUtils. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp", "handl", "null", "string", "genprog", "defects4j", "lang", "gen", "prog", "ad", "patch", "doubleutil", "doubl", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix e3c032 error in GenProg_Defects4J_Lang. Fix StringUtils . createDouble ( String ). ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032", "error", "genprog", "defects4j", "lang", "gen", "prog", "fix", "stringutil", "string", "util", "createdoubl", "creat", "doubl", "string"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for 0x digits. Fix NPE in NumberUtils. ", "B_clean_title": ["ignor", "sign", "0x", "digit", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NPE in NumberUtils. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. Fix NPE in GenProg_Defects4J_Lang_7. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp", "fix", "npe", "genprog", "defects4j", "lang", "gen", "prog"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix e3c032e032c0. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "e3c032e032c0"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Eliminate more flakiness in NumberUtils. fix the build. Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "elimin", "more", "flaki", "numberutil", "number", "util", "fix", "build", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix NumberFormatException. formatting fixes. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "numberformatexcept", "number", "format", "except", "format", "fix"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix StringUtils . createDouble ( String ). ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "stringutil", "string", "util", "createdoubl", "creat", "doubl", "string"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NPE in GenProg_Defects4J_Lang_7. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "npe", "genprog", "defects4j", "lang", "gen", "prog"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix e3c032e032e. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032e032"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate the fix of the merge conflict in NumberUtils. Fix NumberFormatException. Allow null values for exp. ", "B_clean_title": ["elimin", "fix", "merg", "conflict", "numberutil", "number", "util", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete unused patch. Fix NumberFormatException. Fix e3c032 error in GenProg_Defects4J_Lang. fix a typo in the code. ", "B_clean_title": ["delet", "unus", "patch", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032", "error", "genprog", "defects4j", "lang", "gen", "prog", "fix", "typo", "code"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix e3c032e032b1. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "e3c032e032b1"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "E3C - 11674 Fix too many for an int. Fix E3C. ", "B_clean_title": ["e3c", "11674", "fix", "too", "mani", "int", "fix", "e3c"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix e3c032e032b1. Fix NPE in GenProg_Defects4J_Lang_7. Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032e032b1", "fix", "npe", "genprog", "defects4j", "lang", "gen", "prog", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for 0x digits. Fix NumberFormatException. Allow null values for exp. Ignore undefined fields in GenProg_Defects4J_Lang_7. ", "B_clean_title": ["ignor", "sign", "0x", "digit", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp", "ignor", "undefin", "field", "genprog", "defects4j", "lang", "gen", "prog"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for 0x digits. ", "B_clean_title": ["ignor", "sign", "0x", "digit"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix NumberFormatException. Fix e3c032e032c0. Fix E3C. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032e032c0", "fix", "e3c"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. fix the build. fixed formatting. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp", "fix", "build", "fix", "format"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix NumberFormatException. formatting fix. fix a bug in NumberUtils. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "numberformatexcept", "number", "format", "except", "format", "fix", "fix", "bug", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix NPE in NumberUtils. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "revert accidently change. Delete old and unused local variable. Fix NumberFormatException. ", "B_clean_title": ["revert", "accid", "chang", "delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix NumberFormatException. Fix e3c032 error in GenProg_Defects4J_Lang. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032", "error", "genprog", "defects4j", "lang", "gen", "prog"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate negative hex digits in StringUtils. Eliminate more flakiness in NumberUtils. Allow null values for exp. ", "B_clean_title": ["elimin", "neg", "hex", "digit", "stringutil", "string", "util", "elimin", "more", "flaki", "numberutil", "number", "util", "allow", "null", "valu", "exp"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. fix the build. revert accidently change. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp", "fix", "build", "revert", "accid", "chang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for 0x digits. Fix NumberFormatException. ", "B_clean_title": ["ignor", "sign", "0x", "digit", "fix", "numberformatexcept", "number", "format", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. fix the build. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "build"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate the hex digits from the beginning of a string. Fix NumberFormatExceptions. Allow null values for exp. ", "B_clean_title": ["elimin", "hex", "digit", "begin", "string", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix a bug in NumberUtils. Fix NumberFormatException. ", "B_clean_title": ["fix", "bug", "numberutil", "number", "util", "fix", "numberformatexcept", "number", "format", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix NPE in DateUtils. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "npe", "dateutil", "date", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. Improve patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp", "improv", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Delete old definition file. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "delet", "old", "definit", "file"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Eliminate more flakiness in NumberUtils. Allow null values for exp. fix the build. Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "elimin", "more", "flaki", "numberutil", "number", "util", "allow", "null", "valu", "exp", "fix", "build", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix erroneous error in NumberUtils. Fix E3C. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "erron", "error", "numberutil", "number", "util", "fix", "e3c"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Allow null values for exp. Eliminate trailing comma in NumberUtils . createDouble ( ). Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "allow", "null", "valu", "exp", "elimin", "trail", "comma", "numberutil", "number", "util", "createdoubl", "creat", "doubl", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate the fix of the merge conflict in NumberUtils. Fix NumberFormatException. ", "B_clean_title": ["elimin", "fix", "merg", "conflict", "numberutil", "number", "util", "fix", "numberformatexcept", "number", "format", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. formatting fixes. Eliminate trailing comma in NumberUtils . createDouble ( ). Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "format", "fix", "elimin", "trail", "comma", "numberutil", "number", "util", "createdoubl", "creat", "doubl", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. fix the build. Fix NPE in NumberUtils. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "build", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Added patch for StringUtils . createDouble ( String ). ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "ad", "patch", "stringutil", "string", "util", "createdoubl", "creat", "doubl", "string"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused patch. Fix NumberFormatException. fix the build. Fix NPE in NumberUtils. Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "patch", "fix", "numberformatexcept", "number", "format", "except", "fix", "build", "fix", "npe", "numberutil", "number", "util", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow null string input. ", "B_clean_title": ["allow", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NBFI patching. ", "B_clean_title": ["fix", "nbfi", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate the hex digits in the first place ; we  re adding them all at the. ", "B_clean_title": ["elimin", "hex", "digit", "first", "place", "we", "re", "ad", "them", "all", "at"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Added exp = null for isNaN ( ) / null .. ", "B_clean_title": ["remov", "patch", "string", "util", "ad", "exp", "null", "isnan", "na", "null"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "parseShort was throwing an exception. Fix NPE in Arja  s StringUtils. I don  t really see a justification for doing a number format change in Arja  s. ", "B_clean_title": ["parseshort", "pars", "short", "wa", "throw", "except", "fix", "npe", "arja", "stringutil", "string", "util", "don", "realli", "see", "justif", "do", "number", "format", "chang", "arja"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in NumberUtils. Handle early NPE for string isEmpty. ", "B_clean_title": ["fix", "npe", "numberutil", "number", "util", "handl", "earli", "npe", "string", "isempti", "empti"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. I had left it harwired to say it was a valid number .. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "had", "left", "it", "harwir", "say", "it", "wa", "valid", "number"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NBFR patching. ", "B_clean_title": ["fix", "nbfr", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NBFI patch. ", "B_clean_title": ["fix", "nbfi", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. fix a numeric value to work with StringUtils. Added exp = null for numberUtils . createDouble ( ). ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "numer", "valu", "work", "stringutil", "string", "util", "ad", "exp", "null", "numberutil", "number", "util", "createdoubl", "creat", "doubl"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in Arja  s StringUtils. ", "B_clean_title": ["fix", "npe", "arja", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Added exp = 0 . 0F to NumberUtils . createFloat ( ). ", "B_clean_title": ["remov", "patch", "string", "util", "ad", "exp", "0f", "numberutil", "number", "util", "createfloat", "creat", "float"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Allow negative exponents in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "allow", "neg", "expon", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja_Defects4J_Lang_7. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "defects4j", "lang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Handle StringUtils . isBlank ( str ) in ArjaDefects4J_Lang_7. ", "B_clean_title": ["remov", "patch", "string", "util", "handl", "stringutil", "string", "util", "isblank", "blank", "str", "arjadefects4j", "lang", "arja", "defects4j"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  - - hexDigits - - err  from the opengl opengl string. Fix NPE in StringUtils. ", "B_clean_title": ["remov", "unnecessari", "hexdigit", "hex", "digit", "err", "opengl", "opengl", "string", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Add the missing throwing of the exception. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "add", "miss", "throw", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Added exp = null for numberUtils . createDouble ( ). ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "ad", "exp", "null", "numberutil", "number", "util", "createdoubl", "creat", "doubl"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja  s patch. fix a numeric string to work with StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "patch", "fix", "numer", "string", "work", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in Arja  s patch. ", "B_clean_title": ["fix", "npe", "arja", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in StringUtils. remove exp. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "stringutil", "string", "util", "remov", "exp"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in Arja_Defects4J_Lang_7. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "arja", "defects4j", "lang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Add exp back. ", "B_clean_title": ["remov", "patch", "string", "util", "add", "exp", "back"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. remove exp. ", "B_clean_title": ["remov", "patch", "string", "util", "remov", "exp"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. remove backslash. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "remov", "backslash"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in NumberUtils. ", "B_clean_title": ["fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Remove patch for 0x18e01095c1. removed expPos from str ; fix it. ", "B_clean_title": ["remov", "patch", "0x18e01095c1", "remov", "exppo", "exp", "po", "str", "fix", "it"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Remove exp from numberUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "remov", "exp", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Allow one - line ifs. Fix NPE in Arja_Defects4J_Lang_7. ", "B_clean_title": ["remov", "patch", "string", "util", "allow", "one", "line", "if", "fix", "npe", "arja", "defects4j", "lang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. fixed NPE for 1 . 7. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NBFI patch. Fix NPE in StringUtils. ", "B_clean_title": ["fix", "nbfi", "patch", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NBFI for ( ). ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "nbfi"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow null string input. ", "B_clean_title": ["allow", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed extraneous space. ", "B_clean_title": ["remov", "extran", "space"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Added exp = null for numberUtils . createDouble ( String  boolean  boolean ). ", "B_clean_title": ["remov", "patch", "string", "util", "ad", "exp", "null", "numberutil", "number", "util", "createdoubl", "creat", "doubl", "string", "boolean", "boolean"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. fixed NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Add missing exception check. ", "B_clean_title": ["add", "miss", "except", "check"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in StringUtils. ", "B_clean_title": ["fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Add the missing patch. ", "B_clean_title": ["add", "miss", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. adding mant variable to exp var. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "ad", "mant", "variabl", "exp", "var"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja  s StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in OE. ", "B_clean_title": ["fix", "npe", "oe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in Arja_Defects4J_Lang_7. Handle null string input in NumberUtils. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "arja", "defects4j", "lang", "handl", "null", "string", "input", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Handle null string input. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "handl", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Handle string blank numbers in Arja  s patch. ", "B_clean_title": ["remov", "patch", "string", "util", "handl", "string", "blank", "number", "arja", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Handle  ----  in NumberUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "handl", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. remove expPos. Allow null string input. I am using the patch I just added. ", "B_clean_title": ["remov", "patch", "string", "util", "remov", "exppo", "exp", "po", "allow", "null", "string", "input", "am", "patch", "just", "ad"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "parseShort was throwing an exception. Allow string to be expanded into a valid number. ", "B_clean_title": ["parseshort", "pars", "short", "wa", "throw", "except", "allow", "string", "expand", "into", "valid", "number"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed extraneous space. ", "B_clean_title": ["remov", "extran", "space"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "parseShort was throwing an exception. Add the missing throwing of the exception. ", "B_clean_title": ["parseshort", "pars", "short", "wa", "throw", "except", "add", "miss", "throw", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Add a throw exception if it is not a valid number. ", "B_clean_title": ["add", "throw", "except", "it", "not", "valid", "number"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja_Defects4J_Lang_7. Handle null string input from NumberUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "defects4j", "lang", "handl", "null", "string", "input", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NBFI patch. ", "B_clean_title": ["fix", "nbfi", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in StringUtils. fix a numeric string to work with StringUtils. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "stringutil", "string", "util", "fix", "numer", "string", "work", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Handle null string input from JSON. ", "B_clean_title": ["remov", "patch", "string", "util", "handl", "null", "string", "input", "json"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Handle null string input in NumberUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "handl", "null", "string", "input", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  - - hexDigits - - err  from the opengl opengl string. fix a numeric string to work with StringUtils. ", "B_clean_title": ["remov", "unnecessari", "hexdigit", "hex", "digit", "err", "opengl", "opengl", "string", "fix", "numer", "string", "work", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Allow null string input. ", "B_clean_title": ["remov", "patch", "string", "util", "allow", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in JSON. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "json"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate the hex digits in the first place ; we  re adding them all at the. fix a numeric string to work with StringUtils. ", "B_clean_title": ["elimin", "hex", "digit", "first", "place", "we", "re", "ad", "them", "all", "at", "fix", "numer", "string", "work", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in Arja  s patch. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "arja", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow too many hex digits for an int. ", "B_clean_title": ["allow", "too", "mani", "hex", "digit", "int"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow null string input. fixed NPE in NumberUtils. ", "B_clean_title": ["allow", "null", "string", "input", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in Arja_Defects4J_Lang_7. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "arja", "defects4j", "lang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  - - hexDigits - - err  from the opengl opengl string. ", "B_clean_title": ["remov", "unnecessari", "hexdigit", "hex", "digit", "err", "opengl", "opengl", "string"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NBFC for LIGHT_NO_MOON. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "nbfc", "light", "no", "moon"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "parseShort was throwing an exception. removed the prefix removed by the patch. ", "B_clean_title": ["parseshort", "pars", "short", "wa", "throw", "except", "remov", "prefix", "remov", "by", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Add missing throw. Allow string to be expanded into float precision .. ", "B_clean_title": ["add", "miss", "throw", "allow", "string", "expand", "into", "float", "precis"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  - - hexDigits - - err  from StringUtils . parseLong ( str. ", "B_clean_title": ["remov", "unnecessari", "hexdigit", "hex", "digit", "err", "stringutil", "string", "util", "parselong", "pars", "long", "str"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow null string input. ", "B_clean_title": ["allow", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. fix a numeric string to work with StringUtils. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "numer", "string", "work", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in OE. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "oe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "parseShort was throwing an exception. Added exp = null for numberUtils . createDouble ( ). ", "B_clean_title": ["parseshort", "pars", "short", "wa", "throw", "except", "ad", "exp", "null", "numberutil", "number", "util", "createdoubl", "creat", "doubl"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Added missing exp string for float precision string. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "ad", "miss", "exp", "string", "float", "precis", "string"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. remove mant. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "remov", "mant"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in OE. ", "B_clean_title": ["fix", "npe", "oe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. fixed NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE for OE. ", "B_clean_title": ["fix", "npe", "oe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja_Defects4J_Lang_7. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "defects4j", "lang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow too many hex digits for an int. Allow negative exponents in StringUtils. ", "B_clean_title": ["allow", "too", "mani", "hex", "digit", "int", "allow", "neg", "expon", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow null string input. ", "B_clean_title": ["allow", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate the over - aggressive loop through the string .. Added missing backslash. ", "B_clean_title": ["elimin", "over", "aggress", "loop", "through", "string", "ad", "miss", "backslash"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NBFI patch. Revert  move to the patch . ", "B_clean_title": ["fix", "nbfi", "patch", "revert", "move", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in StringUtils. ", "B_clean_title": ["fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja  s patch. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "fixed NPE for number utils. Remove erroneous test for isFinite ( ) and allZeros ( ). ", "B_clean_title": ["fix", "npe", "number", "util", "remov", "erron", "test", "isfinit", "finit", "allzero", "all", "zero"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja_Defects4J_Lang_7. Fix NBFR patch. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "defects4j", "lang", "fix", "nbfr", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in OE. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "oe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  - - hexDigits - - err  from the opengl opengl string. Allow negative exponents in StringUtils. ", "B_clean_title": ["remov", "unnecessari", "hexdigit", "hex", "digit", "err", "opengl", "opengl", "string", "allow", "neg", "expon", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix newline in RSRepair_Defects4J_Lang_7. ", "B_clean_title": ["fix", "newlin", "rsrepair", "defects4j", "lang", "rs", "repair"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from previous commit  fixes NPE. revert accidently change. ", "B_clean_title": ["remov", "patch", "previou", "commit", "fix", "npe", "revert", "accid", "chang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix null in RSRepair_Defects4J_Lang_7. ", "B_clean_title": ["fix", "null", "rsrepair", "defects4j", "lang", "rs", "repair"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE. ", "B_clean_title": ["fix", "npe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix newline in RSRepair_Defects4J_Lang_7. ", "B_clean_title": ["fix", "newlin", "rsrepair", "defects4j", "lang", "rs", "repair"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "don  t allow signs in numbers. ", "B_clean_title": ["don", "allow", "sign", "number"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix null string handling. ", "B_clean_title": ["fix", "null", "string", "handl"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in RSRepair_Defects4J_Lang_7. ", "B_clean_title": ["fix", "npe", "rsrepair", "defects4j", "lang", "rs", "repair"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in RSRepair_Defects4J_Lang_7. ", "B_clean_title": ["fix", "npe", "rsrepair", "defects4j", "lang", "rs", "repair"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed unused var. ", "B_clean_title": ["remov", "unus", "var"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Add null check in LocaleUtils. ", "B_clean_title": ["add", "null", "check", "localeutil", "local", "util"]},
{"A_title": "StringIndexOutOfBoundsException in CharSequenceTranslatorI found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. uD83DuDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception      assertEquals(uD83DuDE30 StringEscapeUtils.escapeCsv(uD83DuDE30));    Youll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 at java.lang.String.charAt(String.java:658) at java.lang.Character.codePointAt(Character.java:4668) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached the method affected:  public final void translate(CharSequence input Writer out) throws IOException", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "charsequencetranslatori", "char", "sequenc", "translat", "found", "that", "there", "bad", "surrog", "pair", "handl", "charsequencetransl", "char", "sequenc", "translat", "thi", "simpl", "test", "case", "thi", "problem", "ud83dude30", "d83du", "de30", "surrog", "pair", "test", "public", "void", "testescapesurrogatepair", "test", "escap", "surrog", "pair", "throw", "except", "assertequ", "assert", "equal", "ud83dude30", "d83du", "de30", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "ud83dude30", "d83du", "de30", "youll", "get", "except", "as", "shown", "below", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:658", "at", "java", "lang", "charact", "codepointat", "code", "point", "at", "charact", "java:4668", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:95", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:59", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "stringescapeutil", "java:556", "string", "escap", "util", "patch", "attach", "method", "affect", "public", "final", "void", "translat", "charsequ", "char", "sequenc", "input", "writer", "out", "throw", "ioexcept", "io", "except"], "B_title": "Don  t reverse the changes since we  re about to manipulate the codepoint count. ", "B_clean_title": ["don", "revers", "chang", "sinc", "we", "re", "about", "manipul", "codepoint", "count"]},
{"A_title": "StringIndexOutOfBoundsException in CharSequenceTranslatorI found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. uD83DuDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception      assertEquals(uD83DuDE30 StringEscapeUtils.escapeCsv(uD83DuDE30));    Youll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 at java.lang.String.charAt(String.java:658) at java.lang.Character.codePointAt(Character.java:4668) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached the method affected:  public final void translate(CharSequence input Writer out) throws IOException", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "charsequencetranslatori", "char", "sequenc", "translat", "found", "that", "there", "bad", "surrog", "pair", "handl", "charsequencetransl", "char", "sequenc", "translat", "thi", "simpl", "test", "case", "thi", "problem", "ud83dude30", "d83du", "de30", "surrog", "pair", "test", "public", "void", "testescapesurrogatepair", "test", "escap", "surrog", "pair", "throw", "except", "assertequ", "assert", "equal", "ud83dude30", "d83du", "de30", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "ud83dude30", "d83du", "de30", "youll", "get", "except", "as", "shown", "below", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:658", "at", "java", "lang", "charact", "codepointat", "code", "point", "at", "charact", "java:4668", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:95", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:59", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "stringescapeutil", "java:556", "string", "escap", "util", "patch", "attach", "method", "affect", "public", "final", "void", "translat", "charsequ", "char", "sequenc", "input", "writer", "out", "throw", "ioexcept", "io", "except"], "B_title": "Use the writer null pointer for CharSequenceTranslator. ", "B_clean_title": ["use", "writer", "null", "pointer", "charsequencetransl", "char", "sequenc", "translat"]},
{"A_title": "StringIndexOutOfBoundsException in CharSequenceTranslatorI found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. uD83DuDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception      assertEquals(uD83DuDE30 StringEscapeUtils.escapeCsv(uD83DuDE30));    Youll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 at java.lang.String.charAt(String.java:658) at java.lang.Character.codePointAt(Character.java:4668) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached the method affected:  public final void translate(CharSequence input Writer out) throws IOException", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "charsequencetranslatori", "char", "sequenc", "translat", "found", "that", "there", "bad", "surrog", "pair", "handl", "charsequencetransl", "char", "sequenc", "translat", "thi", "simpl", "test", "case", "thi", "problem", "ud83dude30", "d83du", "de30", "surrog", "pair", "test", "public", "void", "testescapesurrogatepair", "test", "escap", "surrog", "pair", "throw", "except", "assertequ", "assert", "equal", "ud83dude30", "d83du", "de30", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "ud83dude30", "d83du", "de30", "youll", "get", "except", "as", "shown", "below", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:658", "at", "java", "lang", "charact", "codepointat", "code", "point", "at", "charact", "java:4668", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:95", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:59", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "stringescapeutil", "java:556", "string", "escap", "util", "patch", "attach", "method", "affect", "public", "final", "void", "translat", "charsequ", "char", "sequenc", "input", "writer", "out", "throw", "ioexcept", "io", "except"], "B_title": "Don  t count surrogate pairs as we don  t understand code points at the beginning of a. ", "B_clean_title": ["don", "count", "surrog", "pair", "as", "we", "don", "understand", "code", "point", "at", "begin"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "I had left it harwired to say that it was still failing the tableau test .. ", "B_clean_title": ["had", "left", "it", "harwir", "say", "that", "it", "wa", "still", "fail", "tableau", "test"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fixed a bug in the linear search algorithm. ", "B_clean_title": ["fix", "bug", "linear", "search", "algorithm"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Added missing comment. ", "B_clean_title": ["ad", "miss", "comment"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix the for cycles. ", "B_clean_title": ["fix", "cycl"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix 141. ", "B_clean_title": ["fix", "141"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix unused variable. ", "B_clean_title": ["fix", "unus", "variabl"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "removed a couple incorrect lines. ", "B_clean_title": ["remov", "coupl", "incorrect", "line"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Removed patch for row minimization. ", "B_clean_title": ["remov", "patch", "row", "minim"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "added some debug code. ", "B_clean_title": ["ad", "some", "debug", "code"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "@@ add minRatioPositions . add ( i ). ", "B_clean_title": ["add", "minratioposit", "min", "ratio", "posit", "add"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "I had left it harwired to the minRatioSolver. ", "B_clean_title": ["had", "left", "it", "harwir", "minratiosolv", "min", "ratio", "solver"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Add incrementIterationsCounter ( ) to the minRow so it can be used for sorting. ", "B_clean_title": ["add", "incrementiterationscount", "increment", "iter", "counter", "minrow", "min", "row", "so", "it", "use", "sort"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Remove a redundant check. ", "B_clean_title": ["remov", "redund", "check"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "removed some code that was accidentally left in the last commit. ", "B_clean_title": ["remov", "some", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fixed missing minRow return. ", "B_clean_title": ["fix", "miss", "minrow", "min", "row", "return"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fixed a bug in SimplexSolver . java. ", "B_clean_title": ["fix", "bug", "simplexsolv", "simplex", "solver", "java"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "removed a redundant check. ", "B_clean_title": ["remov", "redund", "check"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix the bug in SimplexSolver . java. ", "B_clean_title": ["fix", "bug", "simplexsolv", "simplex", "solver", "java"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Improved the linear search code. ", "B_clean_title": ["improv", "linear", "search", "code"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fixed data error with Math_28_SimplexSolver_t. ", "B_clean_title": ["fix", "data", "error", "math", "28", "simplexsolv", "simplex", "solver"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Add some error data. ", "B_clean_title": ["add", "some", "error", "data"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Added fix from patch. ", "B_clean_title": ["ad", "fix", "patch"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Add missing import. Fix minRatioPositions for tableau min row. ", "B_clean_title": ["add", "miss", "import", "fix", "minratioposit", "min", "ratio", "posit", "tableau", "min", "row"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "added fixed patch. ", "B_clean_title": ["ad", "fix", "patch"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Using lower maxUlps value in linear search. ", "B_clean_title": ["lower", "maxulp", "max", "ulp", "valu", "linear", "search"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fixed the minRatioPositions for tableau. ", "B_clean_title": ["fix", "minratioposit", "min", "ratio", "posit", "tableau"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Remove patch from GenProg_Defects4J_Math_28. added patch for minRow = row. Fix NPE in AbstractLinearOptimizer. ", "B_clean_title": ["remov", "patch", "genprog", "defects4j", "math", "28", "gen", "prog", "ad", "patch", "minrow", "min", "row", "row", "fix", "npe", "abstractlinearoptim", "abstract", "linear", "optim"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Updated patch for linear optimization. Fix a merge conflict in LocalizedFormats . getLocalizedString ( ). Missing patch for E3 ( conflict with prev PR ). Removing a minRatioPositions . add ( i ) for now .. Remove patch for 1 . 6 . 1. Remove a redundant patch. ", "B_clean_title": ["updat", "patch", "linear", "optim", "fix", "merg", "conflict", "localizedformat", "local", "format", "getlocalizedstr", "get", "local", "string", "miss", "patch", "e3", "conflict", "prev", "pr", "remov", "minratioposit", "min", "ratio", "posit", "add", "now", "remov", "patch", "remov", "redund", "patch"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix missing StringBuilder in getLocalizedString ( ). Remove patch for 1 . 7 . 5. ", "B_clean_title": ["fix", "miss", "stringbuild", "string", "builder", "getlocalizedstr", "get", "local", "string", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix merge conflict for end . add ( field  newdiff ). ", "B_clean_title": ["fix", "merg", "conflict", "end", "add", "field", "newdiff"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix copy / paste error. ", "B_clean_title": ["fix", "copi", "past", "error"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix merge bug in DurationFormatUtils. ", "B_clean_title": ["fix", "merg", "bug", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix typo. ", "B_clean_title": ["fix", "typo"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fixed bug for calendar systems .. ", "B_clean_title": ["fix", "bug", "calendar", "system"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fixed formatting mistake. ", "B_clean_title": ["fix", "format", "mistak"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix bug in DurationFormatUtils. ", "B_clean_title": ["fix", "bug", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove over - aggressive add in DurationFormatUtils. ", "B_clean_title": ["remov", "over", "aggress", "add", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fixed the merge bug in DurationFormatUtils. ", "B_clean_title": ["fix", "merg", "bug", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix bug in duration format utils. Fix bug in duration format. ", "B_clean_title": ["fix", "bug", "durat", "format", "util", "fix", "bug", "durat", "format"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix merge conflict between end and start. ", "B_clean_title": ["fix", "merg", "conflict", "between", "end", "start"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. removed two - times add ( field  old ). ", "B_clean_title": ["remov", "patch", "remov", "two", "time", "add", "field", "old"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. Remove over - aggressive fix. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "patch", "remov", "over", "aggress", "fix", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for month - > hour. Remove fixed patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "month", "hour", "remov", "fix", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "was asking for M in the format. fix bug. removed patch. ", "B_clean_title": ["wa", "ask", "format", "fix", "bug", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "revert accidently change. ", "B_clean_title": ["revert", "accid", "chang"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for leap year. Add fix for leap year. removed patch. ", "B_clean_title": ["add", "fix", "leap", "year", "add", "fix", "leap", "year", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed too - old test. remove patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "too", "old", "test", "remov", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed too - old pattern. Remove patch for day / week. removed patch. ", "B_clean_title": ["fix", "too", "old", "pattern", "remov", "patch", "day", "week", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix duration format mistake. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "durat", "format", "mistak", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore non - calendar days for now .. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "non", "calendar", "day", "now", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove M from the end of the month string. fixed erroneous changes in duration format. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "end", "month", "string", "fix", "erron", "chang", "durat", "format", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for month - > hour. Ignore H = 0 ( fix provided by @ rmb938 ). removed patch. ", "B_clean_title": ["fix", "month", "hour", "ignor", "fix", "provid", "by", "rmb938", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. remove patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "patch", "remov", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict in DurationFormatUtils. remove patch. removed patch. ", "B_clean_title": ["fix", "merg", "conflict", "durationformatutil", "durat", "format", "util", "remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. removed patch. ", "B_clean_title": ["remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split sentence. Remove accidential modification. ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "sentenc", "remov", "accidenti", "modif"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed minute / hour delay. remove months = = 0. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "fix", "minut", "hour", "delay", "remov", "month", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H .. removed patch. ", "B_clean_title": ["ignor", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add months / years back. removed patch. ", "B_clean_title": ["add", "month", "year", "back", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. Remove over - aggressive fix. removed patch. ", "B_clean_title": ["remov", "patch", "remov", "over", "aggress", "fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed typo. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "typo", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 1796. fix removed minute and year from end of month / year log. removed patch. ", "B_clean_title": ["fix", "1796", "fix", "remov", "minut", "year", "end", "month", "year", "log", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove loop. removed patch. ", "B_clean_title": ["remov", "loop", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for leap year. removed patch. ", "B_clean_title": ["add", "fix", "leap", "year", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed erroneous test case. Remove over - aggressive fix. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "erron", "test", "case", "remov", "over", "aggress", "fix", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. Add missing token. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "add", "miss", "token", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix broken ut. removed fixed minute / hours offset. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "broken", "ut", "remov", "fix", "minut", "hour", "offset", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove redundant patch. Add one year to the end of the month in classic duration format. removed patch. ", "B_clean_title": ["remov", "redund", "patch", "add", "one", "year", "end", "month", "classic", "durat", "format", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed typo in DurationFormatUtils. ", "B_clean_title": ["fix", "typo", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for calendar year in classic pattern. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "calendar", "year", "classic", "pattern", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "was going to fix the build. removed a redundant call to add ( field  value ). ", "B_clean_title": ["wa", "go", "fix", "build", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for month - > hour. fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "month", "hour", "fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore modifier from end - to - end time. Add end of year fix. removed patch. ", "B_clean_title": ["ignor", "modifi", "end", "end", "time", "add", "end", "year", "fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for month name calculation. removed patch. ", "B_clean_title": ["add", "fix", "month", "name", "calcul", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for leap year in definition time. removed patch. ", "B_clean_title": ["fix", "leap", "year", "definit", "time", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split sentence. Add fix for leap year. removed patch. ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "sentenc", "add", "fix", "leap", "year", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove the oversampling of the duration format parser. remove patch. fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "oversampl", "durat", "format", "parser", "remov", "patch", "fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed minute / hour delay. Add end of year fix. removed patch. ", "B_clean_title": ["remov", "fix", "minut", "hour", "delay", "add", "end", "year", "fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. Remove redundant patch. removed patch. ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "remov", "redund", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Put back the duration formatUtils until it is fix .. removed a redundant call to add ( field  value ). ", "B_clean_title": ["put", "back", "durat", "formatutil", "format", "util", "until", "it", "fix", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore minutes / hours in the end of month value. removed fixed minute offset. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "minut", "hour", "end", "month", "valu", "remov", "fix", "minut", "offset", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove months = = 0. Remove fixed patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "month", "remov", "fix", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed EAP. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "eap", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split sentence. fix for month - first. fix bug. removed a redundant call to add ( field  value ). ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "sentenc", "fix", "month", "first", "fix", "bug", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove months = = 0. Remove over - aggressive fix. removed patch. ", "B_clean_title": ["remov", "month", "remov", "over", "aggress", "fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove patch for endDate. ", "B_clean_title": ["remov", "patch", "enddat", "end", "date"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Added fix for lost minute / second delay in duration format. removed patch. ", "B_clean_title": ["ad", "fix", "lost", "minut", "second", "delay", "durat", "format", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H . 264 in DurationFormatUtils. removed patch. ", "B_clean_title": ["ignor", "264", "durationformatutil", "durat", "format", "util", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore minutes / m in the same month / year definition. Add one year to the end of the month in classic duration format. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "minut", "same", "month", "year", "definit", "add", "one", "year", "end", "month", "classic", "durat", "format", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split sentence. Remove fixed patch. removed patch. ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "sentenc", "remov", "fix", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add H = > 60. removed patch. ", "B_clean_title": ["add", "60", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed year ending delay. Remove patch for week ending. removed patch. ", "B_clean_title": ["fix", "year", "end", "delay", "remov", "patch", "week", "end", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove years from the duration format. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "year", "durat", "format", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add missing MMS offset for days / week. remove patch. ", "B_clean_title": ["add", "miss", "mm", "offset", "day", "week", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed syntax error. removed patch. ", "B_clean_title": ["remov", "fix", "syntax", "error", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed patch. ", "B_clean_title": ["fix", "bug", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove patched duration format utils. removed unnecessary add ( ) in DurationFormatUtils. ", "B_clean_title": ["remov", "patch", "durat", "format", "util", "remov", "unnecessari", "add", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix the issue of not adding M. fixed typo. ", "B_clean_title": ["fix", "issu", "not", "ad", "fix", "typo"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 773. Remove fixed patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "773", "remov", "fix", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. ", "B_clean_title": ["remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. removed patch. ", "B_clean_title": ["remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add the month value for the duration format. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "month", "valu", "durat", "format", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed unnecessary add ( ). ", "B_clean_title": ["remov", "unnecessari", "add"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. removed patch. ", "B_clean_title": ["remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove loop. fixed syntax error. removed patch. ", "B_clean_title": ["remov", "loop", "fix", "syntax", "error", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. remove patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove fixed patch. fix bug. ", "B_clean_title": ["remov", "fix", "patch", "fix", "bug"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed minute / hour delay. remove patch. removed two - times add ( field  old ). ", "B_clean_title": ["remov", "fix", "minut", "hour", "delay", "remov", "patch", "remov", "two", "time", "add", "field", "old"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix broken patch. removed patch. ", "B_clean_title": ["fix", "broken", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed erroneous test. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "erron", "test", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patched minute / hours. removed patch. ", "B_clean_title": ["remov", "patch", "minut", "hour", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed patch. ", "B_clean_title": ["fix", "bug", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix year overflow in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "year", "overflow", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Added fix for # 774. fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ad", "fix", "774", "fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H + H in DurationFormatUtils. Added missing minutes. Add missing minutes and hours to fix. fix merge conflict in DurationFormatUtils. fixed merge conflict in DurationFormatUtils. ", "B_clean_title": ["ignor", "durationformatutil", "durat", "format", "util", "ad", "miss", "minut", "add", "miss", "minut", "hour", "fix", "fix", "merg", "conflict", "durationformatutil", "durat", "format", "util", "fix", "merg", "conflict", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix the bug of teenager year range .. fix removed patch. removed patch. ", "B_clean_title": ["fix", "bug", "teenag", "year", "rang", "fix", "remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore patterns with wrong value for month / year. remove patch. removed patch. ", "B_clean_title": ["ignor", "pattern", "wrong", "valu", "month", "year", "remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for month - first. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "month", "first", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge issue. fix bug. ", "B_clean_title": ["fix", "merg", "issu", "fix", "bug"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. removed fixed minute / hours delay. removed patch. ", "B_clean_title": ["fix", "week", "end", "remov", "fix", "minut", "hour", "delay", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove patch for not having minutes in the same time frame. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "patch", "not", "have", "minut", "same", "time", "frame", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for leap year. removed patch. ", "B_clean_title": ["fix", "leap", "year", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 274. Fix format string for years = 0. fix merge conflict resolution. removed unnecessary add ( ). ", "B_clean_title": ["fix", "274", "fix", "format", "string", "year", "fix", "merg", "conflict", "resolut", "remov", "unnecessari", "add"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 434. ", "B_clean_title": ["fix", "434"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix for Persian and Urdu language maps # 2019. Remove patch for week ending. removed patch. ", "B_clean_title": ["fix", "persian", "urdu", "languag", "map", "2019", "remov", "patch", "week", "end", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "minut", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix removed patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "remov", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed wrong end date. revert accidently change. ", "B_clean_title": ["fix", "wrong", "end", "date", "revert", "accid", "chang"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed for 1 . 5. removed patch. ", "B_clean_title": ["fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore minutes / hours in the end of month value. fix removed minute increments. removed patch. ", "B_clean_title": ["ignor", "minut", "hour", "end", "month", "valu", "fix", "remov", "minut", "increment", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H + H in DurationFormatUtils. remove loop. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "durationformatutil", "durat", "format", "util", "remov", "loop", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split sentence. fixed typo in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "sentenc", "fix", "typo", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed minute / hour offset. removed patch. ", "B_clean_title": ["fix", "minut", "hour", "offset", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. fix for leap year in definition time. remove patch. removed patch. ", "B_clean_title": ["fix", "week", "end", "fix", "leap", "year", "definit", "time", "remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. Remove over - aggressive fix. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "week", "end", "remov", "over", "aggress", "fix", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. ", "B_clean_title": ["fix", "merg", "conflict", "resolut"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add missing minutes and hours back. Add end of year fix. removed patch. ", "B_clean_title": ["add", "miss", "minut", "hour", "back", "add", "end", "year", "fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "reduce number of days in first month of year. removed a redundant call to add ( field  value ). ", "B_clean_title": ["reduc", "number", "day", "first", "month", "year", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed a bug in the diff script. ", "B_clean_title": ["fix", "bug", "diff", "script"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixedEndDate = fixedStartDate = fixedEndDate. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fixedendd", "fix", "end", "date", "fixedstartd", "fix", "start", "date", "fixedendd", "fix", "end", "date", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for month name calculation. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "fix", "month", "name", "calcul", "remov", "minut", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed minute / hour delay. removed patch. ", "B_clean_title": ["remov", "fix", "minut", "hour", "delay", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split in ISO 8601 duration format. Add the missing seconds as part of the duration format fix. removed patch. ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "iso", "8601", "durat", "format", "add", "miss", "second", "as", "part", "durat", "format", "fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed month ending. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "month", "end", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. was going to fix the build. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "week", "end", "wa", "go", "fix", "build", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for leap year. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "leap", "year", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. Add one year to the end of the month in classic duration format. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "add", "one", "year", "end", "month", "classic", "durat", "format", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed too - old pattern. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "too", "old", "pattern", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed typo in DurationFormatUtils. Remove patch for endDate. ", "B_clean_title": ["fix", "typo", "durationformatutil", "durat", "format", "util", "remov", "patch", "enddat", "end", "date"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. Remove patch for calendar year. ", "B_clean_title": ["fix", "syntax", "error", "remov", "patch", "calendar", "year"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "revert patch. ", "B_clean_title": ["revert", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. removed extraneous line. ", "B_clean_title": ["remov", "patch", "remov", "extran", "line"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. fix merge conflict in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "fix", "merg", "conflict", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed too - old pattern. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "too", "old", "pattern", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. remove loop. removed patch. ", "B_clean_title": ["fix", "bug", "remov", "loop", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove fixed minute / second mistake. removed patch. ", "B_clean_title": ["remov", "fix", "minut", "second", "mistak", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. Fix years count. removed patch. ", "B_clean_title": ["fix", "week", "end", "fix", "year", "count", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix for Persian and Urdu language maps # 283. removed patch. ", "B_clean_title": ["fix", "persian", "urdu", "languag", "map", "283", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore minutes / hours in the end of month value. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "minut", "hour", "end", "month", "valu", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed typo in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "typo", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix duration format mistake. Remove fixed patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "durat", "format", "mistak", "remov", "fix", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove the oversampling of the duration format parser. fixed merge conflict in DurationFormatUtils. ", "B_clean_title": ["remov", "oversampl", "durat", "format", "parser", "fix", "merg", "conflict", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove the oversampling of the duration format parser. fix bug. ", "B_clean_title": ["remov", "oversampl", "durat", "format", "parser", "fix", "bug"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix removed minute increments. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "remov", "minut", "increment", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove backwards incompatible change. removed patch. ", "B_clean_title": ["remov", "backward", "incompat", "chang", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore modifier from end - to - end time. removed patch. ", "B_clean_title": ["ignor", "modifi", "end", "end", "time", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. Remove patch for minute / second. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "week", "end", "remov", "patch", "minut", "second", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove patch for endDate. ", "B_clean_title": ["remov", "patch", "enddat", "end", "date"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove redundant patch. removed patch. ", "B_clean_title": ["remov", "redund", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "reduce and correct the duration in the case of month - first. fix bug. removed patch. ", "B_clean_title": ["reduc", "correct", "durat", "case", "month", "first", "fix", "bug", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for leap year. fixed syntax error. removed patch. ", "B_clean_title": ["fix", "leap", "year", "fix", "syntax", "error", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add end of month to fix # 33. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "end", "month", "fix", "33", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix for Persian and Urdu language maps # 283. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "persian", "urdu", "languag", "map", "283", "remov", "minut", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed erroneous test. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "erron", "test", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add missing patch. removed patch. ", "B_clean_title": ["add", "miss", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore minutes / hours in the end of month value. Remove fixed / unused variable. removed patch. ", "B_clean_title": ["ignor", "minut", "hour", "end", "month", "valu", "remov", "fix", "unus", "variabl", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict in DurationFormatUtils. removed patch. ", "B_clean_title": ["fix", "merg", "conflict", "durationformatutil", "durat", "format", "util", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H + H in DurationFormatUtils. removed patch. ", "B_clean_title": ["ignor", "durationformatutil", "durat", "format", "util", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H .. remove patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "remov", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove loop. reduce HOUR_OF_DAY by one month. fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "loop", "reduc", "hour", "day", "by", "one", "month", "fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed hours  fix from pull request. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "hour", "fix", "pull", "request", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for patch 1833. fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "patch", "1833", "fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H . 264 in DurationFormatUtils. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "264", "durationformatutil", "durat", "format", "util", "remov", "minut", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for month name calculation. Remove over - aggressive fix. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "fix", "month", "name", "calcul", "remov", "over", "aggress", "fix", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. fixed month - > year in configuration. Ignore H = 0 ( fix provided by @ rmb938 ). removed unnecessary add ( ) in DurationFormatUtils. ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "fix", "month", "year", "configur", "ignor", "fix", "provid", "by", "rmb938", "remov", "unnecessari", "add", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed year ending. removed fixed minute / hours offset. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "year", "end", "remov", "fix", "minut", "hour", "offset", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add H = > 60. fix for month - first. removed patch. ", "B_clean_title": ["add", "60", "fix", "month", "first", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed syntax error. Remove patch for endDate. ", "B_clean_title": ["remov", "fix", "syntax", "error", "remov", "patch", "enddat", "end", "date"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix ISO 8601 duration format. removed fixed minute / hours delay. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "iso", "8601", "durat", "format", "remov", "fix", "minut", "hour", "delay", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed test for same day / month. fixed syntax error. fixed legitimization. ", "B_clean_title": ["remov", "test", "same", "day", "month", "fix", "syntax", "error", "fix", "legitim"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. revert patch. ", "B_clean_title": ["remov", "patch", "revert", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove redundant code. fixed syntax error in DurationFormatUtils. removed patch. ", "B_clean_title": ["remov", "redund", "code", "fix", "syntax", "error", "durationformatutil", "durat", "format", "util", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add hours / minutes to months number. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "hour", "minut", "month", "number", "remov", "minut", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix reverseEach. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "reverseeach", "revers", "each", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix duration format mistake. remove minute = 0 ; patch = 0 ;. fixed legitimization. ", "B_clean_title": ["fix", "durat", "format", "mistak", "remov", "minut", "patch", "fix", "legitim"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix disabled patch for minute / hour. removed patch. ", "B_clean_title": ["fix", "disabl", "patch", "minut", "hour", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for month - first. fixed syntax error. revert patch. ", "B_clean_title": ["fix", "month", "first", "fix", "syntax", "error", "revert", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove redundant patch. Ignore H . 264 in DurationFormatUtils. removed fixed minute offset. removed patch. ", "B_clean_title": ["remov", "redund", "patch", "ignor", "264", "durationformatutil", "durat", "format", "util", "remov", "fix", "minut", "offset", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore modifier from end - to - end time. fix merge conflict resolution. ", "B_clean_title": ["ignor", "modifi", "end", "end", "time", "fix", "merg", "conflict", "resolut"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. fixed erroneous legacy change. removed patch. ", "B_clean_title": ["fix", "week", "end", "fix", "erron", "legaci", "chang", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split in ISO 8601 duration format. removed patch. ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "iso", "8601", "durat", "format", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed minute / hours offset. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "fix", "minut", "hour", "offset", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "reduce HOUR_OF_DAY by one month. removed patch. ", "B_clean_title": ["reduc", "hour", "day", "by", "one", "month", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove M from the end of the month estimates. removed unnecessary add ( ) in DurationFormatUtils. ", "B_clean_title": ["remov", "end", "month", "estim", "remov", "unnecessari", "add", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed minute / hours delay. removed patch. ", "B_clean_title": ["remov", "fix", "minut", "hour", "delay", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for month - > year. Remove useless assignment. removed patch. ", "B_clean_title": ["fix", "month", "year", "remov", "useless", "assign", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for month name calculation. Remove fixed minute / hour offset. removed patch. ", "B_clean_title": ["add", "fix", "month", "name", "calcul", "remov", "fix", "minut", "hour", "offset", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove minute = 0 ; patch = > minute. remove patch. ", "B_clean_title": ["remov", "minut", "patch", "minut", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove backwards incompatible change. Add missing minutes and hours back. removed patch. ", "B_clean_title": ["remov", "backward", "incompat", "chang", "add", "miss", "minut", "hour", "back", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix disabled loop. removed patch. ", "B_clean_title": ["fix", "disabl", "loop", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split sentence. removed a redundant call to add ( field  value ). ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "sentenc", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "reverse the changes. ", "B_clean_title": ["revers", "chang"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error in DurationFormatUtils. removed patch. ", "B_clean_title": ["fix", "syntax", "error", "durationformatutil", "durat", "format", "util", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add end of year fix. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "end", "year", "fix", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add missing value. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "miss", "valu", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Added missing minutes to the duration format test. removed patch. ", "B_clean_title": ["ad", "miss", "minut", "durat", "format", "test", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix disabled month value for ISO 8601 duration format. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "disabl", "month", "valu", "iso", "8601", "durat", "format", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Added fix for lost seconds / minutes in DurationFormatUtils. remove patch. removed patch. ", "B_clean_title": ["ad", "fix", "lost", "second", "minut", "durationformatutil", "durat", "format", "util", "remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix bug in fix month / end of month .. ", "B_clean_title": ["fix", "bug", "fix", "month", "end", "month"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix for leap year. ", "B_clean_title": ["fix", "leap", "year"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 435. ", "B_clean_title": ["fix", "435"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix for bug 6841215 - Fix for Persian and Urdu language maps .. ", "B_clean_title": ["fix", "bug", "6841215", "fix", "persian", "urdu", "languag", "map"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 435. ", "B_clean_title": ["fix", "435"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for bug fix. Updated fix for # 443. ", "B_clean_title": ["add", "fix", "bug", "fix", "updat", "fix", "443"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix empty end fix. ", "B_clean_title": ["fix", "empti", "end", "fix"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 435. ", "B_clean_title": ["fix", "435"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 435. ", "B_clean_title": ["fix", "435"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove years from the duration format. fix # 434. ", "B_clean_title": ["remov", "year", "durat", "format", "fix", "434"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 435. ", "B_clean_title": ["fix", "435"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix bug in fix_defects4J_Lang_63. ", "B_clean_title": ["fix", "bug", "fix", "defects4j", "lang", "63"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove useless assignment. Fix for bug fix. ", "B_clean_title": ["remov", "useless", "assign", "fix", "bug", "fix"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Remove one more test. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["remov", "one", "more", "test", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix CMAESOptimizer logMu2 = Math . log ( mu + 0 . 5 ) ;. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "cmaesoptim", "cmae", "optim", "logmu2", "log", "mu2", "math", "log", "mu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix a bug in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "bug", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Revert this. update marker file. Fix C = diag ( x ) .. ", "B_clean_title": ["revert", "thi", "updat", "marker", "file", "fix", "diag"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix C = fix. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "fix", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). remove patch. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "remov", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix single line error in CMAESOptimizer. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "singl", "line", "error", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). update marker. Remove a couple incorrect lines. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "marker", "remov", "coupl", "incorrect", "line"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix NPE. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "npe"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reset repaired  i  to 0 ; we don  t need it. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["reset", "repair", "we", "don", "need", "it", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "CCC = > RC. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["ccc", "rc", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Use the latest log4j step for CMAES optimization. Fix a bug in CMAESOptimizer caused by incorrect patch .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["use", "latest", "log4j", "step", "cmae", "optim", "fix", "bug", "cmaesoptim", "cmae", "optim", "caus", "by", "incorrect", "patch", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Remove a couple incorrect lines. Fix a bug in CMAESOptimizer where the boundaries are not null .. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "remov", "coupl", "incorrect", "line", "fix", "bug", "cmaesoptim", "cmae", "optim", "where", "boundari", "are", "not", "null"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "update marker. CCC = > RBF ( min mueff value ). Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["updat", "marker", "ccc", "rbf", "min", "mueff", "valu", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix NPE in CMAESOptimizer. Fix single line error in CMAESOptimizer. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "npe", "cmaesoptim", "cmae", "optim", "fix", "singl", "line", "error", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix single line exception. CANCER patch attempted fix. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "singl", "line", "except", "cancer", "patch", "attempt", "fix", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix a look for a better error message. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "look", "better", "error", "messag"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix a minor bug in CMAESOptimizer such that it does not set a value. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "minor", "bug", "cmaesoptim", "cmae", "optim", "such", "that", "it", "not", "set", "valu", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix a look for a better exception in  cmAESOptimizer . fix merge conflict resolution. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "look", "better", "except", "cmaesoptim", "cm", "ae", "optim", "fix", "merg", "conflict", "resolut", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Updated patch for MathRuntimeException . getLocalizedMessage ( ). ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "patch", "mathruntimeexcept", "math", "runtim", "except", "getlocalizedmessag", "get", "local", "messag"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Missing context variable. Fix possible NPE in CMAESOptimizer. Revert previous patch. ", "B_clean_title": ["miss", "context", "variabl", "fix", "possibl", "npe", "cmaesoptim", "cmae", "optim", "revert", "previou", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix single line error in CMAESOptimizer . repair ( ) .. Fix possible NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "singl", "line", "error", "cmaesoptim", "cmae", "optim", "repair", "fix", "possibl", "npe", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Use the latest log4j step for CMAES optimization. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "use", "latest", "log4j", "step", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "update marker. Fix NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["updat", "marker", "fix", "npe", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Remove a couple incorrect lines. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "remov", "coupl", "incorrect", "line"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Remove stray patch .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["remov", "stray", "patch", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Use the latest log4j step for CMAES optimization. Fix CMAESOptimizer patch .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["use", "latest", "log4j", "step", "cmae", "optim", "fix", "cmaesoptim", "cmae", "optim", "patch", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). update marker. Fix a look for a better error message. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "marker", "fix", "look", "better", "error", "messag"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Add a backprop to CMAESOptimizer logMu2 .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["add", "backprop", "cmaesoptim", "cmae", "optim", "logmu2", "log", "mu2", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). CCC = min mueff for CMAES optimization. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "ccc", "min", "mueff", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). readded missing context object .. Remove unnecessary line. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "read", "miss", "context", "object", "remov", "unnecessari", "line"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix NPE in CMAESOptimizer. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "npe", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Use the latest log4j step for CMAES optimization. Fix a bug in CMAESOptimizer where the boundaries are not null. Revert previous patch. Revert previous patch. ", "B_clean_title": ["use", "latest", "log4j", "step", "cmae", "optim", "fix", "bug", "cmaesoptim", "cmae", "optim", "where", "boundari", "are", "not", "null", "revert", "previou", "patch", "revert", "previou", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix diagD. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "diagd", "diag", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Revert previous patch. update marker. CAMEL - 2833 fixed the inverse of square root. ", "B_clean_title": ["revert", "previou", "patch", "updat", "marker", "camel", "2833", "fix", "invers", "squar", "root"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "npe", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix diagD = sqrt ( diagD ) ;. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "diagd", "diag", "sqrt", "diagd", "diag"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). update penalty from patched PR. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "penalti", "patch", "pr"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). CAMAESOptimizer now uses one - to - one because it is not compatible with current A. CAMEL - 102 fixed the indentation of the objective function. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "camaesoptim", "cama", "optim", "now", "use", "one", "one", "becaus", "it", "not", "compat", "current", "camel", "102", "fix", "indent", "object", "function"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "update marker. CAMAESOptimizer now uses one - to - one because it is not compatible with current A. Revert MathUtils rounding method. ", "B_clean_title": ["updat", "marker", "camaesoptim", "cama", "optim", "now", "use", "one", "one", "becaus", "it", "not", "compat", "current", "revert", "mathutil", "math", "util", "round", "method"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Set historySize for CMAESOptimizer . penalty ( ). ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "set", "historys", "histori", "size", "cmaesoptim", "cmae", "optim", "penalti"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Revert MathUtils rounding method. Fix single line error in CMAESOptimizer . repair ( ). ", "B_clean_title": ["revert", "mathutil", "math", "util", "round", "method", "fix", "singl", "line", "error", "cmaesoptim", "cmae", "optim", "repair"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Revert MathUtils rounding method. remove patch from CMAESOptimizer. Fix single line error in CMAESOptimizer . repair ( ). ", "B_clean_title": ["revert", "mathutil", "math", "util", "round", "method", "remov", "patch", "cmaesoptim", "cmae", "optim", "fix", "singl", "line", "error", "cmaesoptim", "cmae", "optim", "repair"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix NPE in CMAESOptimizer. Fix NPE in CMAESOptimizer . repair ( ) .. Revert previous patch. ", "B_clean_title": ["fix", "npe", "cmaesoptim", "cmae", "optim", "fix", "npe", "cmaesoptim", "cmae", "optim", "repair", "revert", "previou", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "update patch for CMAESOptimizer. Fix a bug in CMAESOptimizer where the boundaries are not null. Revert previous patch. ", "B_clean_title": ["updat", "patch", "cmaesoptim", "cmae", "optim", "fix", "bug", "cmaesoptim", "cmae", "optim", "where", "boundari", "are", "not", "null", "revert", "previou", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Remove one more test. Remove a couple incorrect lines. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "remov", "one", "more", "test", "remov", "coupl", "incorrect", "line"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix a minor bug in CMAESOptimizer . java. Fix CMAESOptimizer penalty ( fixed in 1 . 6 . 2 ) .. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "minor", "bug", "cmaesoptim", "cmae", "optim", "java", "fix", "cmaesoptim", "cmae", "optim", "penalti", "fix"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Remove ccovmuSep from CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["remov", "ccovmusep", "ccovmu", "sep", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Reset fitness history after 1 . 0 value was found. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "reset", "fit", "histori", "after", "valu", "wa", "found"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix CMAESOptimizer patch. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "cmaesoptim", "cmae", "optim", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Revert MathUtils rounding method. ", "B_clean_title": ["revert", "mathutil", "math", "util", "round", "method"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Stop the CMAES optimization from running in a war. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["stop", "cmae", "optim", "run", "war", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Revert previous patch. Fix single line exception. Fix NPE in CMAESOptimizer. ", "B_clean_title": ["revert", "previou", "patch", "fix", "singl", "line", "except", "fix", "npe", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix a bug in CMAESOptimizer where lambda was not applied  this . lambda was not used. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "bug", "cmaesoptim", "cmae", "optim", "where", "lambda", "wa", "not", "appli", "thi", "lambda", "wa", "not", "use", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). update patch. Remove a couple incorrect lines. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "patch", "remov", "coupl", "incorrect", "line"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Set context to empty string so it doesn  t get put into the same place as the other. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "set", "context", "empti", "string", "so", "it", "doesn", "get", "put", "into", "same", "place", "as", "other"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Updated patch for MathRuntimeException . getMessage. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["updat", "patch", "mathruntimeexcept", "math", "runtim", "except", "getmessag", "get", "messag", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix possible NPE in CMAESOptimizer. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "possibl", "npe", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "readded missing context object .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["read", "miss", "context", "object", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Set historySize for CMAESOptimizer . penalty ( ). Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["set", "historys", "histori", "size", "cmaesoptim", "cmae", "optim", "penalti", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "update patch. Fix CMAESOptimizer patch. Fix C = diag ( x ) .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["updat", "patch", "fix", "cmaesoptim", "cmae", "optim", "patch", "fix", "diag", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "update normps after convergence check. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["updat", "normp", "after", "converg", "check", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Updated patch for 118. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "patch", "118"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix CMAESOptimizer patch. Revert previous patch. ", "B_clean_title": ["fix", "cmaesoptim", "cmae", "optim", "patch", "revert", "previou", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "increment evaluations . incrementCount ( ). Fix incorrect C = > 1 . 0 in CMAESOptimizer. Fix NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["increment", "evalu", "incrementcount", "increment", "count", "fix", "incorrect", "cmaesoptim", "cmae", "optim", "fix", "npe", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix unnecessarily non - minimal penalty in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "unnecessarili", "non", "minim", "penalti", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix diagD .. Set historySize for CMAESOptimizer . penalty ( ). ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "diagd", "diag", "set", "historys", "histori", "size", "cmaesoptim", "cmae", "optim", "penalti"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix broken patch. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "broken", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "update patch for CMAESOptimizer. Fix CMAESOptimizer penalty ( fixed in 1 . 6 . 2 ) .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["updat", "patch", "cmaesoptim", "cmae", "optim", "fix", "cmaesoptim", "cmae", "optim", "penalti", "fix", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Remove a couple incorrect lines. Set historySize for CMAESOptimizer . penalty ( ). Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "set", "historys", "histori", "size", "cmaesoptim", "cmae", "optim", "penalti", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix C = diag ( x ) .. Fix NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "diag", "fix", "npe", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). update patch. Set historySize for CMAES optimization patch .. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "patch", "set", "historys", "histori", "size", "cmae", "optim", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Missing context variable. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "miss", "context", "variabl"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix uninitialized variable. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "uniniti", "variabl", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Remove a redundant check. update CMAESOptimizer with a new patch. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["remov", "redund", "check", "updat", "cmaesoptim", "cmae", "optim", "new", "patch", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "update prev guess after convergence check. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["updat", "prev", "guess", "after", "converg", "check", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Revert previous patch. CAMEL - 328513f3 fixed a small bug. ", "B_clean_title": ["revert", "previou", "patch", "camel", "328513f3", "fix", "small", "bug"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix a minor bug in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "minor", "bug", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix single dimension exception. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "singl", "dimens", "except", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Added missing patch. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "ad", "miss", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Set iterations = 0 in CMAESOptimizer . java. Fix NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["set", "iter", "cmaesoptim", "cmae", "optim", "java", "fix", "npe", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix a bug in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "bug", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix a bug in CMAESOptimizer. Fix a minor bug in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "bug", "cmaesoptim", "cmae", "optim", "fix", "minor", "bug", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix C = diag ( x ) .. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "diag"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Use the latest log4j step for CMAES optimization. Revert this. ", "B_clean_title": ["use", "latest", "log4j", "step", "cmae", "optim", "revert", "thi"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Use a new evaluations object added by accident. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["use", "new", "evalu", "object", "ad", "by", "accid", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). update marker. Fix single line exception. Fix single line error in CMAESOptimizer. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "marker", "fix", "singl", "line", "except", "fix", "singl", "line", "error", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). update marker. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "marker"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "update marker. CANCEO - 1216  adjust for the fix. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["updat", "marker", "canceo", "1216", "adjust", "fix", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Set historySize for CMAESOptimizer. Fix C = diag ( x ) .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["set", "historys", "histori", "size", "cmaesoptim", "cmae", "optim", "fix", "diag", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). CAMAESOptimizer now uses one - to - one because it is not compatible with current A. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "camaesoptim", "cama", "optim", "now", "use", "one", "one", "becaus", "it", "not", "compat", "current"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Revert previous patch. Allow null values in CMAESOptimizer. ", "B_clean_title": ["revert", "previou", "patch", "allow", "null", "valu", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reset diagonalonly after each loop. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["reset", "diagonalonli", "after", "each", "loop", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix a bug in CMAESOptimizer where the boundaries are not null .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "bug", "cmaesoptim", "cmae", "optim", "where", "boundari", "are", "not", "null", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Revert this. Fix a bug in CMAESOptimizer. ", "B_clean_title": ["revert", "thi", "fix", "bug", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix CMAESOptimizer patch .. Fix incorrect patch. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "cmaesoptim", "cmae", "optim", "patch", "fix", "incorrect", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Set iterations = 0 in CMAESOptimizer . java. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["set", "iter", "cmaesoptim", "cmae", "optim", "java", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Set historySize for CMAESOptimizer. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "set", "historys", "histori", "size", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). readded missing context object .. update patch. Fix cmAESOptimizer patch. Remove stray patch from CMAESOptimizer. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "read", "miss", "context", "object", "updat", "patch", "fix", "cmaesoptim", "cm", "ae", "optim", "patch", "remov", "stray", "patch", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix CMAESOptimizer patch. Fix diagD .. Updated patch for MathRuntimeException . getLocalizedMessage ( ). Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "cmaesoptim", "cmae", "optim", "patch", "fix", "diagd", "diag", "updat", "patch", "mathruntimeexcept", "math", "runtim", "except", "getlocalizedmessag", "get", "local", "messag", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Add missing patch. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["add", "miss", "patch", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix cmAESOptimizer patch. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "cmaesoptim", "cm", "ae", "optim", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix a bug in CMAESOptimizer caused by incorrect patch .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "bug", "cmaesoptim", "cmae", "optim", "caus", "by", "incorrect", "patch", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). CANCEO - 1216  adjust for the fix. Fix CMAESOptimizer patch. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "canceo", "1216", "adjust", "fix", "fix", "cmaesoptim", "cmae", "optim", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "update patch. Fix single line error in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["updat", "patch", "fix", "singl", "line", "error", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "CCC = > RBF ( min mueff value ). Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["ccc", "rbf", "min", "mueff", "valu", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix possible NPE in CMAESOptimizer. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "possibl", "npe", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). update marker. Fix a possible NPE in CMAESOptimizer. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "marker", "fix", "possibl", "npe", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "CAMEL - 6209 Fixed a bug in CMAESOptimizer such that lambda > .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["camel", "6209", "fix", "bug", "cmaesoptim", "cmae", "optim", "such", "that", "lambda", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "CAMEL - 6209 Fixed the inverse of square root .. CANCER patch attempted fix. Revert previous patch. ", "B_clean_title": ["camel", "6209", "fix", "invers", "squar", "root", "cancer", "patch", "attempt", "fix", "revert", "previou", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Updated patch for MathRuntimeException. Use the latest log4j step for CMAES optimization. increment evaluations . incrementCount ( ). ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "patch", "mathruntimeexcept", "math", "runtim", "except", "use", "latest", "log4j", "step", "cmae", "optim", "increment", "evalu", "incrementcount", "increment", "count"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix uninitialized variable. CAMEL - 7209 Fixed a minor issue with the inverse function of some of the arguments. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "uniniti", "variabl", "camel", "7209", "fix", "minor", "issu", "invers", "function", "some", "argument", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "CAMEL - 7209 Fixed a minor issue with the objective function of CMAESOptimizer at. Revert previous patch. ", "B_clean_title": ["camel", "7209", "fix", "minor", "issu", "object", "function", "cmaesoptim", "cmae", "optim", "at", "revert", "previou", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Remove one more test. Fix diagD .. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "remov", "one", "more", "test", "fix", "diagd", "diag"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix NPE in CMAESOptimizer. Set historySize for CMAESOptimizer . penalty ( ). Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "npe", "cmaesoptim", "cmae", "optim", "set", "historys", "histori", "size", "cmaesoptim", "cmae", "optim", "penalti", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reset fitness history after 1 . 0 value was found. Fix NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["reset", "fit", "histori", "after", "valu", "wa", "found", "fix", "npe", "cmaesoptim", "cmae", "optim", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "CANCER patch attempted fix. Remove unnecessary line. Revert previous patch. ", "B_clean_title": ["cancer", "patch", "attempt", "fix", "remov", "unnecessari", "line", "revert", "previou", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). update patch. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "patch"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). update CMAESOptimizer with a new one - liner. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "cmaesoptim", "cmae", "optim", "new", "one", "liner"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix single line exception. Remove a couple incorrect lines. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "singl", "line", "except", "remov", "coupl", "incorrect", "line", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix NPE in CMAESOptimizer. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "npe", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix NPE in CMAESOptimizer. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "npe", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Revert previous patch. update patch. Add ccov1 back into repaired objective function. ", "B_clean_title": ["revert", "previou", "patch", "updat", "patch", "add", "ccov1", "back", "into", "repair", "object", "function"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix single line exception. Fix a bug in CMAESOptimizer where the boundaries are not null .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "singl", "line", "except", "fix", "bug", "cmaesoptim", "cmae", "optim", "where", "boundari", "are", "not", "null", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). update marker. Use the latest log4j step for CMAES optimization. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "marker", "use", "latest", "log4j", "step", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Revert MathUtils rounding method. Remove a couple incorrect lines. Fix possible NPE in CMAESOptimizer. ", "B_clean_title": ["revert", "mathutil", "math", "util", "round", "method", "remov", "coupl", "incorrect", "line", "fix", "possibl", "npe", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Remove a couple incorrect lines. CCC = > RBF ( min mueff value ). Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "ccc", "rbf", "min", "mueff", "valu", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "CANCER patched  so that we can use the ccov1 function as well. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["cancer", "patch", "so", "that", "we", "use", "ccov1", "function", "as", "well", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix a bug in CMAESOptimizer. Fix NPE in CMAESOptimizer. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "bug", "cmaesoptim", "cmae", "optim", "fix", "npe", "cmaesoptim", "cmae", "optim"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Revert MathUtils rounding method. Reset the value of the penalty column to 0 ; the new penalty column would be better placed on. ", "B_clean_title": ["revert", "mathutil", "math", "util", "round", "method", "reset", "valu", "penalti", "column", "new", "penalti", "column", "would", "better", "place"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "update penalty from patched PR. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["updat", "penalti", "patch", "pr", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). update patch. Fix single line exception. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "updat", "patch", "fix", "singl", "line", "except"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix a bug in CMAESOptimizer where the boundaries are not null. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "bug", "cmaesoptim", "cmae", "optim", "where", "boundari", "are", "not", "null", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix diagD .. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "diagd", "diag", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). CAMEL - 2833 fixed lambda = 4 + ( int ) ( 3 . log (. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "camel", "2833", "fix", "lambda", "int", "log"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Fix C = diag ( x ) .. CCC = > RBF ( min mueff value ). ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "fix", "diag", "ccc", "rbf", "min", "mueff", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix cmAESOptimizer patch. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["fix", "cmaesoptim", "cm", "ae", "optim", "patch", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "update lambda / 2. Reverted accidental throw of MathUtils . doubleValue ( ). ", "B_clean_title": ["updat", "lambda", "revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Reverted accidental throw of MathUtils . doubleValue ( ). Add a logMu2 variable to CMAESOptimizer . java. ", "B_clean_title": ["revert", "accident", "throw", "mathutil", "math", "util", "doublevalu", "doubl", "valu", "add", "logmu2", "log", "mu2", "variabl", "cmaesoptim", "cmae", "optim", "java"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Fix a bug in CMAESOptimizer. Added CCC to the patch for CMAES optimization. Revert previous patch. ", "B_clean_title": ["fix", "bug", "cmaesoptim", "cmae", "optim", "ad", "ccc", "patch", "cmae", "optim", "revert", "previou", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing if (. ", "B_clean_title": ["miss"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing closing paren in BooleanUtils. ", "B_clean_title": ["miss", "close", "paren", "booleanutil", "boolean", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "@@ commented out previous fix. ", "B_clean_title": ["comment", "out", "previou", "fix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed null check. ", "B_clean_title": ["remov", "null", "check"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "don  t compare y  to  y . don  t compare Y  to  Y  ( fixes # 77 ). ", "B_clean_title": ["don", "compar", "don", "compar", "fix", "77"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed y as separator at the end of StringUtils. ", "B_clean_title": ["remov", "as", "separ", "at", "end", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing if (. ", "B_clean_title": ["miss"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Fixed bug in BooleanUtils where empty string is not the case. ", "B_clean_title": ["fix", "bug", "booleanutil", "boolean", "util", "where", "empti", "string", "not", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing if (. ", "B_clean_title": ["miss"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing one if (. ", "B_clean_title": ["miss", "one"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Remove backslash which prevents overflow from StringUtils. ", "B_clean_title": ["remov", "backslash", "which", "prevent", "overflow", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Handle case when String is empty or null. ", "B_clean_title": ["handl", "case", "when", "string", "empti", "or", "null"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Handle case when String is empty or null. ", "B_clean_title": ["handl", "case", "when", "string", "empti", "or", "null"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Revert previous patch. ", "B_clean_title": ["revert", "previou", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. ", "B_clean_title": ["lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed an issue with BooleanUtils . toBoolean ( ). Removed unnecessary patch. ", "B_clean_title": ["fix", "issu", "booleanutil", "boolean", "util", "toboolean", "boolean", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add patch for StringUtils. ", "B_clean_title": ["add", "patch", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Removed patch for BooleanUtils . toBoolean ( ) .. Removed unnecessary patch. ", "B_clean_title": ["remov", "patch", "booleanutil", "boolean", "util", "toboolean", "boolean", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string handling. toLowerCase ( ). ", "B_clean_title": ["lowercas", "string", "handl", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Fixed null string handling. Removed unnecessary patch. ", "B_clean_title": ["fix", "null", "string", "handl", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "remove patch for true / false match. toLowerCase ( ). ", "B_clean_title": ["remov", "patch", "true", "fals", "match", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing case in StringUtils. Removed unnecessary if / else .. ", "B_clean_title": ["ad", "miss", "case", "stringutil", "string", "util", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add null check. Removed unnecessary if / else .. ", "B_clean_title": ["add", "null", "check", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added booleanUtils . equalsIgnoreCase ( ). lowercased string to match actual string. ", "B_clean_title": ["ad", "booleanutil", "boolean", "util", "equalsignorecas", "equal", "ignor", "case", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add null check. toLowerCase ( ) removed previous patch. lowercased string to match patch. ", "B_clean_title": ["add", "null", "check", "tolowercas", "lower", "case", "remov", "previou", "patch", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for strings with spaces in the code. lowercased string to match patch. ", "B_clean_title": ["improv", "perform", "string", "space", "code", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Remove unnecessary booleanUtils patch. Removed unnecessary patch. ", "B_clean_title": ["remov", "unnecessari", "booleanutil", "boolean", "util", "patch", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "remove patched / removed unnecessary boolean utils class. Removed unnecessary patch. ", "B_clean_title": ["remov", "patch", "remov", "unnecessari", "boolean", "util", "class", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "remove patch. Removed unnecessary patch. ", "B_clean_title": ["remov", "patch", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed null string handling. lowercased string to match actual string. ", "B_clean_title": ["fix", "null", "string", "handl", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "BooleanUtils patch for < = >. Removed patch for  true  and  off  .. ", "B_clean_title": ["booleanutil", "boolean", "util", "patch", "remov", "patch", "true", "off"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Updated toBoolean ( ). Removed unnecessary patch. ", "B_clean_title": ["updat", "toboolean", "boolean", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "remove patched code. toLowerCase ( ). ", "B_clean_title": ["remov", "patch", "code", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. remove null check. toLowerCase ( ). ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "remov", "null", "check", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for null strings. removed patch for year in BooleanUtils. Removed unnecessary patch. ", "B_clean_title": ["improv", "perform", "null", "string", "remov", "patch", "year", "booleanutil", "boolean", "util", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add case for string comparison. lowercased string to match patch. ", "B_clean_title": ["add", "case", "string", "comparison", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for empty strings. Removed unnecessary if / else .. ", "B_clean_title": ["improv", "perform", "empti", "string", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Fixed a bug in BooleanUtils. Remove over - old boolean utils pattern. Removed unnecessary if / else .. ", "B_clean_title": ["fix", "bug", "booleanutil", "boolean", "util", "remov", "over", "old", "boolean", "util", "pattern", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed StringUtils . equalsIgnoreCase. lowercased string to match actual string. ", "B_clean_title": ["fix", "stringutil", "string", "util", "equalsignorecas", "equal", "ignor", "case", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Updated to match String class .. remove patched boolean utils. ", "B_clean_title": ["updat", "match", "string", "class", "remov", "patch", "boolean", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed patch for Y = > E. lowercase affix. ", "B_clean_title": ["remov", "patch", "lowercas", "affix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed patch for Y = > E. lowercased string to match their definition. ", "B_clean_title": ["remov", "patch", "lowercas", "string", "match", "their", "definit"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Removed patch from BooleanUtils. remove patch for BooleanUtils. Removed unnecessary patch. ", "B_clean_title": ["remov", "patch", "booleanutil", "boolean", "util", "remov", "patch", "booleanutil", "boolean", "util", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string comparisons. ", "B_clean_title": ["lowercas", "string", "comparison"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for strings with length > = 647. lowercased string to match actual string. ", "B_clean_title": ["improv", "perform", "string", "length", "647", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Remove patched code. case insensitive match for  true  to false . ", "B_clean_title": ["remov", "patch", "code", "case", "insensit", "match", "true", "fals"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "match regex. ", "B_clean_title": ["match", "regex"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match their definition. ", "B_clean_title": ["lowercas", "string", "match", "their", "definit"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Remove patch for year in BooleanUtils. Removed unnecessary patch. ", "B_clean_title": ["remov", "patch", "year", "booleanutil", "boolean", "util", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Optimize equalsIgnoreCase. Removed unnecessary if / else .. ", "B_clean_title": ["optim", "equalsignorecas", "equal", "ignor", "case", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. Removed unnecessary if / else .. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed null string handling. lowercased string to match patch. ", "B_clean_title": ["fix", "null", "string", "handl", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "toLowerCase ( ). ", "B_clean_title": ["tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add patch for true in boolean utils. Removed patch for StringUtils. ", "B_clean_title": ["add", "patch", "true", "boolean", "util", "remov", "patch", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve matching of empty strings. lowercased string to match patch. ", "B_clean_title": ["improv", "match", "empti", "string", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed patch for year in BooleanUtils. IgnoreCase string  s value .. ", "B_clean_title": ["remov", "patch", "year", "booleanutil", "boolean", "util", "ignorecas", "ignor", "case", "string", "valu"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "toLowerCase ( ). ", "B_clean_title": ["tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed StringUtils . equalsIgnoreCase. Removed unnecessary if / else .. ", "B_clean_title": ["fix", "stringutil", "string", "util", "equalsignorecas", "equal", "ignor", "case", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Removed an obsolete equalsIgnoreCase method. Add an exception check for isEmpty ( String ). Removed unnecessary patch. ", "B_clean_title": ["remov", "obsolet", "equalsignorecas", "equal", "ignor", "case", "method", "add", "except", "check", "isempti", "empti", "string", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add patch for null string handling. toLowerCase ( ). ", "B_clean_title": ["add", "patch", "null", "string", "handl", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed empty string handling. lowercased string handling. ", "B_clean_title": ["remov", "empti", "string", "handl", "lowercas", "string", "handl"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add an empty line check. Remove patched code. Removed patch for StringUtils. ", "B_clean_title": ["add", "empti", "line", "check", "remov", "patch", "code", "remov", "patch", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "toLowerCase the y string. Removed unnecessary if / else .. ", "B_clean_title": ["tolowercas", "lower", "case", "string", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add case for string  s equalsIgnoreCase. Removed unnecessary patch. ", "B_clean_title": ["add", "case", "string", "equalsignorecas", "equal", "ignor", "case", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "BooleanUtils now uses empty string literals. lowercased string to match patch. ", "B_clean_title": ["booleanutil", "boolean", "util", "now", "use", "empti", "string", "liter", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. ", "B_clean_title": ["lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. ", "B_clean_title": ["lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "ignore isDigit for boolean equals. ", "B_clean_title": ["ignor", "isdigit", "digit", "boolean", "equal"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. lowercased string to match patch. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added ignore case for  off  and  no  .. Removed unnecessary if / else .. ", "B_clean_title": ["ad", "ignor", "case", "off", "no", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. ", "B_clean_title": ["lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for strings with length > = 647. Modified patch for StringUtils . equalsIgnoreCase. remove patched for last char. ", "B_clean_title": ["improv", "perform", "string", "length", "647", "modifi", "patch", "stringutil", "string", "util", "equalsignorecas", "equal", "ignor", "case", "remov", "patch", "last", "char"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add an exception check for isEmpty ( String ). lowercased string to match patch. ", "B_clean_title": ["add", "except", "check", "isempti", "empti", "string", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased. Removed unnecessary patch. ", "B_clean_title": ["lowercas", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing case in StringUtils. Removed unnecessary if / else .. ", "B_clean_title": ["ad", "miss", "case", "stringutil", "string", "util", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. patched BooleanUtils. ", "B_clean_title": ["lowercas", "string", "match", "patch", "patch", "booleanutil", "boolean", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. Remove over - aggressive patching of boolean utils. lowercased string to match actual string. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "remov", "over", "aggress", "patch", "boolean", "util", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "IgnoreCase Strings. Removed unnecessary if / else .. ", "B_clean_title": ["ignorecas", "ignor", "case", "string", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercase affix. ", "B_clean_title": ["lowercas", "affix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add patch for null string comparison. lowercased string comparisons. lowercased string to match patch. ", "B_clean_title": ["add", "patch", "null", "string", "comparison", "lowercas", "string", "comparison", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add patch for null string handling. lowercased string to match patch. ", "B_clean_title": ["add", "patch", "null", "string", "handl", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added patch for  off  and  no  .. toLowerCase ( ). ", "B_clean_title": ["ad", "patch", "off", "no", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add null check. Removed unnecessary patch. ", "B_clean_title": ["add", "null", "check", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "strtolower the string. Removed unnecessary patch. ", "B_clean_title": ["strtolow", "string", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "remove patch from source code. lowercased string to match patch. ", "B_clean_title": ["remov", "patch", "sourc", "code", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Corrected a typo in StringUtils. ", "B_clean_title": ["correct", "typo", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed patch for year in BooleanUtils. lowercased string to match patch. ", "B_clean_title": ["remov", "patch", "year", "booleanutil", "boolean", "util", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string handling. ", "B_clean_title": ["lowercas", "string", "handl"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. Added missing case in StringUtils. lowercased string to match actual string. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "ad", "miss", "case", "stringutil", "string", "util", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "isEmpty ( ) = > false. ", "B_clean_title": ["isempti", "empti", "fals"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing case in BooleanUtils. Removed unnecessary patch. ", "B_clean_title": ["ad", "miss", "case", "booleanutil", "boolean", "util", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Put back previous patch. Removed unnecessary patch. ", "B_clean_title": ["put", "back", "previou", "patch", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for null string matches  note the patch for more readable strings. Removed unnecessary if / else .. ", "B_clean_title": ["improv", "perform", "null", "string", "match", "note", "patch", "more", "readabl", "string", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Removed patch from BooleanUtils. lowercased. Removed unnecessary patch. ", "B_clean_title": ["remov", "patch", "booleanutil", "boolean", "util", "lowercas", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "patched by accident. removed patch for year in BooleanUtils. Removed patch for  true  and  off  .. ", "B_clean_title": ["patch", "by", "accid", "remov", "patch", "year", "booleanutil", "boolean", "util", "remov", "patch", "true", "off"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "strtolower the string. lowercased string to match patch. ", "B_clean_title": ["strtolow", "string", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add an exception if the String is empty ( I am looking at you Dave ). toLowerCase ( ). ", "B_clean_title": ["add", "except", "string", "empti", "am", "look", "at", "you", "dave", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "modified BooleanUtils. lowercased string to match patch. ", "B_clean_title": ["modifi", "booleanutil", "boolean", "util", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string comparisons. ", "B_clean_title": ["lowercas", "string", "comparison"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "toLowerCase ( ) removed previous patch. Removed unnecessary if / else .. ", "B_clean_title": ["tolowercas", "lower", "case", "remov", "previou", "patch", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add exception if String is empty. ", "B_clean_title": ["add", "except", "string", "empti"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Allow null string input. lowercase affix. ", "B_clean_title": ["allow", "null", "string", "input", "lowercas", "affix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string comparisons. Removed unnecessary patch. ", "B_clean_title": ["lowercas", "string", "comparison", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing case in StringUtils. Removed unnecessary patch. ", "B_clean_title": ["ad", "miss", "case", "stringutil", "string", "util", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "strtolower the string. toLowerCase ( ). ", "B_clean_title": ["strtolow", "string", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. lowercased string to match patch. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add missing case. Removed unnecessary patch. ", "B_clean_title": ["add", "miss", "case", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added patch for  true  in StringUtils. lowercase affix. ", "B_clean_title": ["ad", "patch", "true", "stringutil", "string", "util", "lowercas", "affix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. removed patched / removed unnecessary booleanUtils properties. lowercased string to match actual string. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "remov", "patch", "remov", "unnecessari", "booleanutil", "boolean", "util", "properti", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. lowercased string comparisons. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "lowercas", "string", "comparison"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "IgnoreCase string  s value .. ", "B_clean_title": ["ignorecas", "ignor", "case", "string", "valu"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "toLowerCase ( ) matches any string. ", "B_clean_title": ["tolowercas", "lower", "case", "match", "ani", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add null check. lowercased string to match patch. ", "B_clean_title": ["add", "null", "check", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "IgnoreCase string  s value .. ", "B_clean_title": ["ignorecas", "ignor", "case", "string", "valu"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed String . equalsIgnoreCase. ", "B_clean_title": ["fix", "string", "equalsignorecas", "equal", "ignor", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed null string handling. lowercased string to match patch. ", "B_clean_title": ["fix", "null", "string", "handl", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. ", "B_clean_title": ["lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "I had left it harwired to true  but it was still possible to check string equality. ", "B_clean_title": ["had", "left", "it", "harwir", "true", "but", "it", "wa", "still", "possibl", "check", "string", "equal"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed null check. lowercased string to match actual string. ", "B_clean_title": ["remov", "null", "check", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for null / empty strings. Removed unnecessary if / else .. ", "B_clean_title": ["improv", "perform", "null", "empti", "string", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "remove patch for BooleanUtils . equals. lowercased string to match their definition. ", "B_clean_title": ["remov", "patch", "booleanutil", "boolean", "util", "equal", "lowercas", "string", "match", "their", "definit"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add case for string  s equalsIgnoreCase. lowercased string to match patch. ", "B_clean_title": ["add", "case", "string", "equalsignorecas", "equal", "ignor", "case", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercase affix. ", "B_clean_title": ["lowercas", "affix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. ", "B_clean_title": ["lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match their definition. ", "B_clean_title": ["lowercas", "string", "match", "their", "definit"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add null check. IgnoreCase string  s value .. ", "B_clean_title": ["add", "null", "check", "ignorecas", "ignor", "case", "string", "valu"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing patch for null string match. lowercased string to match patch. ", "B_clean_title": ["miss", "patch", "null", "string", "match", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Allow null string input. Removed patch for StringUtils. ", "B_clean_title": ["allow", "null", "string", "input", "remov", "patch", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed StringUtils . equalsIgnoreCase. lowercased string to match patch. ", "B_clean_title": ["fix", "stringutil", "string", "util", "equalsignorecas", "equal", "ignor", "case", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Corrected a typo in StringUtils. ", "B_clean_title": ["correct", "typo", "stringutil", "string", "util"]},
{"A_title": "java.lang.StringIndexOutOfBoundsException in ComplexFormat.parse(String source ParsePosition pos)The parse(String source ParsePosition pos) method in the ComplexFormat class does not check whether the imaginary character is set or not which produces StringIndexOutOfBoundsException in the substring method : (line 375 of ComplexFormat) ...         // parse imaginary character         int n = getImaginaryCharacter().length();         startIndex = pos.getIndex();         int endIndex = startIndex + n;         if (source.substring(startIndex endIndex).compareTo(             getImaginaryCharacter()) != 0)  ... I encoutered this exception typing in a JTextFied with ComplexFormat set to look up an AbstractFormatter. If only the user types the imaginary part of the complex number first he gets this exception. Solution: Before setting to n length of the imaginary character check if the source contains it. My proposal: ...         int n = 0;         if (source.contains(getImaginaryCharacter()))         n = getImaginaryCharacter().length(); ...  F.S.", "A_clean_title": ["java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "complexformat", "pars", "complex", "format", "string", "sourc", "parseposit", "pars", "posit", "po", "pars", "string", "sourc", "parseposit", "pars", "posit", "po", "method", "complexformat", "complex", "format", "class", "not", "check", "whether", "imaginari", "charact", "set", "or", "not", "which", "produc", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "substr", "method", "line", "375", "complexformat", "complex", "format", "pars", "imaginari", "charact", "int", "getimaginarycharact", "get", "imaginari", "charact", "length", "startindex", "start", "index", "po", "getindex", "get", "index", "int", "endindex", "end", "index", "startindex", "start", "index", "sourc", "substr", "startindex", "start", "index", "endindex", "end", "index", "compareto", "compar", "getimaginarycharact", "get", "imaginari", "charact", "encout", "thi", "except", "type", "jtextfi", "text", "fie", "complexformat", "complex", "format", "set", "look", "up", "abstractformatt", "abstract", "formatt", "onli", "user", "type", "imaginari", "part", "complex", "number", "first", "he", "get", "thi", "except", "solut", "befor", "set", "length", "imaginari", "charact", "check", "sourc", "contain", "it", "my", "propos", "int", "sourc", "contain", "getimaginarycharact", "get", "imaginari", "charact", "getimaginarycharact", "get", "imaginari", "charact", "length"], "B_title": "Removed symbolic link to error patch .. ", "B_clean_title": ["remov", "symbol", "link", "error", "patch"]},
{"A_title": "java.lang.StringIndexOutOfBoundsException in ComplexFormat.parse(String source ParsePosition pos)The parse(String source ParsePosition pos) method in the ComplexFormat class does not check whether the imaginary character is set or not which produces StringIndexOutOfBoundsException in the substring method : (line 375 of ComplexFormat) ...         // parse imaginary character         int n = getImaginaryCharacter().length();         startIndex = pos.getIndex();         int endIndex = startIndex + n;         if (source.substring(startIndex endIndex).compareTo(             getImaginaryCharacter()) != 0)  ... I encoutered this exception typing in a JTextFied with ComplexFormat set to look up an AbstractFormatter. If only the user types the imaginary part of the complex number first he gets this exception. Solution: Before setting to n length of the imaginary character check if the source contains it. My proposal: ...         int n = 0;         if (source.contains(getImaginaryCharacter()))         n = getImaginaryCharacter().length(); ...  F.S.", "A_clean_title": ["java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "complexformat", "pars", "complex", "format", "string", "sourc", "parseposit", "pars", "posit", "po", "pars", "string", "sourc", "parseposit", "pars", "posit", "po", "method", "complexformat", "complex", "format", "class", "not", "check", "whether", "imaginari", "charact", "set", "or", "not", "which", "produc", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "substr", "method", "line", "375", "complexformat", "complex", "format", "pars", "imaginari", "charact", "int", "getimaginarycharact", "get", "imaginari", "charact", "length", "startindex", "start", "index", "po", "getindex", "get", "index", "int", "endindex", "end", "index", "startindex", "start", "index", "sourc", "substr", "startindex", "start", "index", "endindex", "end", "index", "compareto", "compar", "getimaginarycharact", "get", "imaginari", "charact", "encout", "thi", "except", "type", "jtextfi", "text", "fie", "complexformat", "complex", "format", "set", "look", "up", "abstractformatt", "abstract", "formatt", "onli", "user", "type", "imaginari", "part", "complex", "number", "first", "he", "get", "thi", "except", "solut", "befor", "set", "length", "imaginari", "charact", "check", "sourc", "contain", "it", "my", "propos", "int", "sourc", "contain", "getimaginarycharact", "get", "imaginari", "charact", "getimaginarycharact", "get", "imaginari", "charact", "length"], "B_title": "fix parseAndIgnoreWhitespace ( source  pos ). ", "B_clean_title": ["fix", "parseandignorewhitespac", "pars", "ignor", "whitespac", "sourc", "po"]},
{"A_title": "combining @interface and multiple @extends can crash compilerNone", "A_clean_title": ["combin", "interfac", "multipl", "extend", "crash", "compilernon", "compil", "none"], "B_title": "Fix TypeCheck . checkForExtraProperties. ", "B_clean_title": ["fix", "typecheck", "type", "check", "checkforextraproperti", "check", "extra", "properti"]},
{"A_title": "Dangerous code in PoissonDistributionImplIn the following excerpt from class PoissonDistributionImpl: PoissonDistributionImpl.java     public PoissonDistributionImpl(double p NormalDistribution z)          super();         setNormal(z);         setMean(p);        (1) Overridable methods are called within the constructor. (2) The reference z is stored and modified within the class. Ive encountered problem (1) in several classes while working on issue 348. In those cases in order to remove potential problems I copied/pasted the body of the setter methods inside the constructor but I think that a more elegant solution would be to remove the setters altogether (i.e. make the classes immutable). Problem (2) can also create unexpected behaviour. Is it really necessary to pass the NormalDistribution object; cant it be always created within the class?", "A_clean_title": ["danger", "code", "poissondistributionimplin", "poisson", "distribut", "impl", "follow", "excerpt", "class", "poissondistributionimpl", "poisson", "distribut", "impl", "poissondistributionimpl", "java", "poisson", "distribut", "impl", "public", "poissondistributionimpl", "poisson", "distribut", "impl", "doubl", "normaldistribut", "normal", "distribut", "super", "setnorm", "set", "normal", "setmean", "set", "mean", "overrid", "method", "are", "call", "within", "constructor", "refer", "store", "modifi", "within", "class", "ive", "encount", "problem", "sever", "class", "while", "work", "issu", "348", "those", "case", "order", "remov", "potenti", "problem", "copi", "past", "bodi", "setter", "method", "insid", "constructor", "but", "think", "that", "more", "eleg", "solut", "would", "remov", "setter", "altogeth", "make", "class", "immut", "problem", "also", "creat", "unexpect", "behaviour", "it", "realli", "necessari", "pass", "normaldistribut", "normal", "distribut", "object", "cant", "it", "alway", "creat", "within", "class"], "B_title": "Fixed a bug in PoissonDistributionImpl .. ", "B_clean_title": ["fix", "bug", "poissondistributionimpl", "poisson", "distribut", "impl"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "update tmp. Remove patch 1434. ", "B_clean_title": ["updat", "tmp", "remov", "patch", "1434"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Fix a bug in the BroadcastOutputSelectorWrapper . addCollector. update patched jar. Remove a redundant call to put in a map. Remove patched code. fix broken patch. ", "B_clean_title": ["fix", "bug", "broadcastoutputselectorwrapp", "broadcast", "output", "selector", "wrapper", "addcollector", "add", "collector", "updat", "patch", "jar", "remov", "redund", "call", "put", "map", "remov", "patch", "code", "fix", "broken", "patch"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove unnecessary code. fix broken patch. update patch. ", "B_clean_title": ["remov", "unnecessari", "code", "fix", "broken", "patch", "updat", "patch"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove patched code. update patched jar. fix broken patch. ", "B_clean_title": ["remov", "patch", "code", "updat", "patch", "jar", "fix", "broken", "patch"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Removed patch for codenarc. update patch for code improvement. Remove wrapper from chained configuration ; it is not needed .. ", "B_clean_title": ["remov", "patch", "codenarc", "updat", "patch", "code", "improv", "remov", "wrapper", "chain", "configur", "it", "not", "need"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove patch from code. Fix a bug in the CollectorWrapper class .. fix broken patch. ", "B_clean_title": ["remov", "patch", "code", "fix", "bug", "collectorwrapp", "collector", "wrapper", "class", "fix", "broken", "patch"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "fix broken patch. update patched jar. Remove patch from jar. ", "B_clean_title": ["fix", "broken", "patch", "updat", "patch", "jar", "remov", "patch", "jar"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Fix a bug in the BroadcastOutputSelectorWrapper . addCollector. fix broken patch. Remove wrapper from chained configuration ; it is not needed .. ", "B_clean_title": ["fix", "bug", "broadcastoutputselectorwrapp", "broadcast", "output", "selector", "wrapper", "addcollector", "add", "collector", "fix", "broken", "patch", "remov", "wrapper", "chain", "configur", "it", "not", "need"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "fix broken patch. Remove wrapper from chained configuration ; it is not needed .. Remove patched code. ", "B_clean_title": ["fix", "broken", "patch", "remov", "wrapper", "chain", "configur", "it", "not", "need", "remov", "patch", "code"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove patched code. update patched jar. ", "B_clean_title": ["remov", "patch", "code", "updat", "patch", "jar"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "fix broken patch. ", "B_clean_title": ["fix", "broken", "patch"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove patched code. Removed patch for code improvement. ", "B_clean_title": ["remov", "patch", "code", "remov", "patch", "code", "improv"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "update patched jar. Remove patch from jar. Fix broken patch. ", "B_clean_title": ["updat", "patch", "jar", "remov", "patch", "jar", "fix", "broken", "patch"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove wrapper from chained configuration ; it is not needed .. update patch for code improvement. ", "B_clean_title": ["remov", "wrapper", "chain", "configur", "it", "not", "need", "updat", "patch", "code", "improv"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "fix broken patch. Remove unnecessary code. ", "B_clean_title": ["fix", "broken", "patch", "remov", "unnecessari", "code"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "fix broken patch. update patch for closure issues. Remove patch from code. ", "B_clean_title": ["fix", "broken", "patch", "updat", "patch", "closur", "issu", "remov", "patch", "code"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove unnecessary code. fix broken patch. ", "B_clean_title": ["remov", "unnecessari", "code", "fix", "broken", "patch"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove patched code. fix broken patch. ", "B_clean_title": ["remov", "patch", "code", "fix", "broken", "patch"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "update patched jar. Remove patch from jar. Updated patch for code improvement. ", "B_clean_title": ["updat", "patch", "jar", "remov", "patch", "jar", "updat", "patch", "code", "improv"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "fix a bug in the code style. update patch for streaming job graph generator. Added patch for streaming job graph generation. ", "B_clean_title": ["fix", "bug", "code", "style", "updat", "patch", "stream", "job", "graph", "gener", "ad", "patch", "stream", "job", "graph", "gener"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "update tmp. ", "B_clean_title": ["updat", "tmp"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove patch for class loader reset. Remove wrapper from chained configurations. Remove unused patch. ", "B_clean_title": ["remov", "patch", "class", "loader", "reset", "remov", "wrapper", "chain", "configur", "remov", "unus", "patch"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "update patched jar. update patched jar. ", "B_clean_title": ["updat", "patch", "jar", "updat", "patch", "jar"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove patched code. fix broken patch. Fix a bug in the BroadcastOutputSelectorWrapper . addCollector. ", "B_clean_title": ["remov", "patch", "code", "fix", "broken", "patch", "fix", "bug", "broadcastoutputselectorwrapp", "broadcast", "output", "selector", "wrapper", "addcollector", "add", "collector"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "update patched jar. Added patch for streaming job graph generation. ", "B_clean_title": ["updat", "patch", "jar", "ad", "patch", "stream", "job", "graph", "gener"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "fix broken patch. Remove wrapper from chained configuration ; it is not needed .. Remove patched code. Removed patched code. update patched jar. ", "B_clean_title": ["fix", "broken", "patch", "remov", "wrapper", "chain", "configur", "it", "not", "need", "remov", "patch", "code", "remov", "patch", "code", "updat", "patch", "jar"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove patched code. update patched jar. ", "B_clean_title": ["remov", "patch", "code", "updat", "patch", "jar"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "fix broken patch. Remove wrapper from chained configuration ; it is not needed .. ", "B_clean_title": ["fix", "broken", "patch", "remov", "wrapper", "chain", "configur", "it", "not", "need"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "update patch for code improvement. Remove patch from jar. update patch for closure issues. Moving to a new patch. ", "B_clean_title": ["updat", "patch", "code", "improv", "remov", "patch", "jar", "updat", "patch", "closur", "issu", "move", "new", "patch"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove patch from jar. Fix a bug in the BroadcastOutputSelectorWrapper . addCollector. update tmp. ", "B_clean_title": ["remov", "patch", "jar", "fix", "bug", "broadcastoutputselectorwrapp", "broadcast", "output", "selector", "wrapper", "addcollector", "add", "collector", "updat", "tmp"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Removed patch .. update patched jar. ", "B_clean_title": ["remov", "patch", "updat", "patch", "jar"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "fix broken patch. update patch. Remove wrapper from chained configuration ; it is not needed .. ", "B_clean_title": ["fix", "broken", "patch", "updat", "patch", "remov", "wrapper", "chain", "configur", "it", "not", "need"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "Remove wrapper from tmp. fix broken patch. update patch for closure issues. update tmp. ", "B_clean_title": ["remov", "wrapper", "tmp", "fix", "broken", "patch", "updat", "patch", "closur", "issu", "updat", "tmp"]},
{"A_title": "cloning of TimeSeriesIts just a minor bug!  When I clone a TimeSeries which has no items I get an IllegalArgumentException (Requires start <= end). But I dont think the user should be responsible for checking whether the TimeSeries has any items or not.", "A_clean_title": ["clone", "timeseriesit", "time", "seri", "it", "just", "minor", "bug", "when", "clone", "timeseri", "time", "seri", "which", "ha", "no", "item", "get", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "but", "dont", "think", "user", "respons", "check", "whether", "timeseri", "time", "seri", "ha", "ani", "item", "or", "not"], "B_title": "Fix an issue with TimeSeries . delete ( ) where the start < end would throw an exception. Fix bug in TimeSeries . clone. ", "B_clean_title": ["fix", "issu", "timeseri", "time", "seri", "delet", "where", "start", "end", "would", "throw", "except", "fix", "bug", "timeseri", "time", "seri", "clone"]},
{"A_title": "cloning of TimeSeriesIts just a minor bug!  When I clone a TimeSeries which has no items I get an IllegalArgumentException (Requires start <= end). But I dont think the user should be responsible for checking whether the TimeSeries has any items or not.", "A_clean_title": ["clone", "timeseriesit", "time", "seri", "it", "just", "minor", "bug", "when", "clone", "timeseri", "time", "seri", "which", "ha", "no", "item", "get", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "but", "dont", "think", "user", "respons", "check", "whether", "timeseri", "time", "seri", "ha", "ani", "item", "or", "not"], "B_title": "fix a bug in TimeSeries . clone. ", "B_clean_title": ["fix", "bug", "timeseri", "time", "seri", "clone"]},
{"A_title": "cloning of TimeSeriesIts just a minor bug!  When I clone a TimeSeries which has no items I get an IllegalArgumentException (Requires start <= end). But I dont think the user should be responsible for checking whether the TimeSeries has any items or not.", "A_clean_title": ["clone", "timeseriesit", "time", "seri", "it", "just", "minor", "bug", "when", "clone", "timeseri", "time", "seri", "which", "ha", "no", "item", "get", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "but", "dont", "think", "user", "respons", "check", "whether", "timeseri", "time", "seri", "ha", "ani", "item", "or", "not"], "B_title": "Fix bug in delete ( ). ", "B_clean_title": ["fix", "bug", "delet"]},
{"A_title": "cloning of TimeSeriesIts just a minor bug!  When I clone a TimeSeries which has no items I get an IllegalArgumentException (Requires start <= end). But I dont think the user should be responsible for checking whether the TimeSeries has any items or not.", "A_clean_title": ["clone", "timeseriesit", "time", "seri", "it", "just", "minor", "bug", "when", "clone", "timeseri", "time", "seri", "which", "ha", "no", "item", "get", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "but", "dont", "think", "user", "respons", "check", "whether", "timeseri", "time", "seri", "ha", "ani", "item", "or", "not"], "B_title": "Fixed a bug with not throwing the clone exception. ", "B_clean_title": ["fix", "bug", "not", "throw", "clone", "except"]}]