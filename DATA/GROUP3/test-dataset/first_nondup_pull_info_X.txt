[{"A_title": "weird object literal invalid property error on unrelated object prototypeNone", "A_clean_title": ["weird", "object", "liter", "invalid", "properti", "error", "unrel", "object", "prototypenon", "prototyp", "none"], "B_title": "Allow property types to be declared in closure constraints. ", "B_clean_title": ["allow", "properti", "type", "declar", "closur", "constraint"]},
{"A_title": "weird object literal invalid property error on unrelated object prototypeNone", "A_clean_title": ["weird", "object", "liter", "invalid", "properti", "error", "unrel", "object", "prototypenon", "prototyp", "none"], "B_title": "Remove unneeded whitespace. ", "B_clean_title": ["remov", "unneed", "whitespac"]},
{"A_title": "weird object literal invalid property error on unrelated object prototypeNone", "A_clean_title": ["weird", "object", "liter", "invalid", "properti", "error", "unrel", "object", "prototypenon", "prototyp", "none"], "B_title": "Added a missing if / else .. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "weird object literal invalid property error on unrelated object prototypeNone", "A_clean_title": ["weird", "object", "liter", "invalid", "properti", "error", "unrel", "object", "prototypenon", "prototyp", "none"], "B_title": "Allow property types to be inferred from boolean to string .. ", "B_clean_title": ["allow", "properti", "type", "infer", "boolean", "string"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "Fix a bug in the linear tableau test .. ", "B_clean_title": ["fix", "bug", "linear", "tableau", "test"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "Fix a bug in the tableau test .. ", "B_clean_title": ["fix", "bug", "tableau", "test"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "removed test code. ", "B_clean_title": ["remov", "test", "code"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "added check for erroneous division. ", "B_clean_title": ["ad", "check", "erron", "divis"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "Fix warning. Fix a bug in the similarity function. ", "B_clean_title": ["fix", "warn", "fix", "bug", "similar", "function"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "Fixed a bug in the linear search results. ", "B_clean_title": ["fix", "bug", "linear", "search", "result"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "added fixed case for tableau sizes. ", "B_clean_title": ["ad", "fix", "case", "tableau", "size"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from str ; if it was < - 1. ", "B_clean_title": ["remov", "exppo", "exp", "po", "str", "it", "wa"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string .. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos. ", "B_clean_title": ["remov", "exppo", "exp", "po"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Fix copy ( ). ", "B_clean_title": ["fix", "copi"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Fix typo in first line of text file. ", "B_clean_title": ["fix", "typo", "first", "line", "text", "file"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant patch. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Fix parse error. ", "B_clean_title": ["fix", "pars", "error"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Fix incorrect patch. ", "B_clean_title": ["fix", "incorrect", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Added throw exception if string is null. removed expPos from mant string. ", "B_clean_title": ["ad", "throw", "except", "string", "null", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. Fix NPE in Arja  s patch. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "npe", "arja", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. fix a typo in NumberUtils. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "fix", "typo", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. Allow null string input. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "allow", "null", "string", "input"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "formatting null values as null values are not accepted. removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. ", "B_clean_title": ["format", "null", "valu", "as", "null", "valu", "are", "not", "accept", "remov", "exppo", "exp", "po", "mant", "string", "fix", "npe", "arjadefects4j", "lang", "27", "arja", "defects4j"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Fixed NPE in StringUtils. ", "B_clean_title": ["fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed ninth - month issue. removed expPos from mant string. fixed a bug in NumberUtils. ", "B_clean_title": ["fix", "ninth", "month", "issu", "remov", "exppo", "exp", "po", "mant", "string", "fix", "bug", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "fix", "npe", "arjadefects4j", "lang", "27", "arja", "defects4j"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed a bug in NumberUtils. removed expPos from mant string. ", "B_clean_title": ["fix", "bug", "numberutil", "number", "util", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. remove the extraneous space. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "remov", "extran", "space"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. Fix Eclipse warning. fixed a bug in NumberUtils. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "eclips", "warn", "fix", "bug", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. try string to create double from string. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "tri", "string", "creat", "doubl", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. remove the unnecessary dec string. try string to create double from string. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "remov", "unnecessari", "dec", "string", "tri", "string", "creat", "doubl", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed NPE in Arja_Defects4J_Lang_27. removed expPos from mant string. ", "B_clean_title": ["fix", "npe", "arja", "defects4j", "lang", "27", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not needed. don  t put patched exception in place. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "need", "don", "put", "patch", "except", "place"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed BigDecimal class name. ", "B_clean_title": ["fix", "bigdecim", "big", "decim", "class", "name"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed erroneous legacy patch. ", "B_clean_title": ["remov", "erron", "legaci", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "throw exception if str is null. removed expPos from mant string. ", "B_clean_title": ["throw", "except", "str", "null", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed a bug in StringUtils. removed expPos from mant string. ", "B_clean_title": ["fix", "bug", "stringutil", "string", "util", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. fixed NPE in ArjaDefects4J_Lang_27. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "npe", "arjadefects4j", "lang", "27", "arja", "defects4j"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. try string to create double from string. remove wrong symbol. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "tri", "string", "creat", "doubl", "string", "remov", "wrong", "symbol"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. Handle null string input. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "handl", "null", "string", "input"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "avoid NPE. removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. fix a typo in NumberUtils. ", "B_clean_title": ["avoid", "npe", "remov", "exppo", "exp", "po", "mant", "string", "fix", "npe", "arjadefects4j", "lang", "27", "arja", "defects4j", "fix", "typo", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "A blank string is not a valid number. removed expPos from mant string. ", "B_clean_title": ["blank", "string", "not", "valid", "number", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fix null string handling. removed expPos from mant string. ", "B_clean_title": ["fix", "null", "string", "handl", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. Fix number parsing in Arja_Defects4J_Lang_27. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "number", "pars", "arja", "defects4j", "lang", "27"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Add a patch for formatting numbers in Avro settings. removed expPos from mant string. remove expPos. ", "B_clean_title": ["add", "patch", "format", "number", "avro", "set", "remov", "exppo", "exp", "po", "mant", "string", "remov", "exppo", "exp", "po"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "throw exception if str is null. removed expPos from mant string. convert numeric to double for compatibility with 1 . 5. ", "B_clean_title": ["throw", "except", "str", "null", "remov", "exppo", "exp", "po", "mant", "string", "convert", "numer", "doubl", "compat"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed NPE in NumberUtils. removed expPos from mant string. ", "B_clean_title": ["fix", "npe", "numberutil", "number", "util", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove unnecessary default value. removed expPos from mant string. ", "B_clean_title": ["remov", "unnecessari", "default", "valu", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Add the missing patch. removed expPos from mant string. ", "B_clean_title": ["add", "miss", "patch", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. fixed syntax error in previous patch. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "syntax", "error", "previou", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "avoid NPE. removed expPos from mant string. ", "B_clean_title": ["avoid", "npe", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not needed. try Integer . decode ( str ) instead of String . create ( str ). ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "need", "tri", "integ", "decod", "str", "instead", "string", "creat", "str"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove unused patch. removed expPos from mant string. ", "B_clean_title": ["remov", "unus", "patch", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not needed. Handle null string input. adding mant variable to prevent compiler from giving an error message. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "need", "handl", "null", "string", "input", "ad", "mant", "variabl", "prevent", "compil", "give", "error", "messag"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. fix a minor typo in NumberUtils. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "minor", "typo", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not needed. fixed a bug in NumberUtils. Fix NPE in Arja  s patch. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "need", "fix", "bug", "numberutil", "number", "util", "fix", "npe", "arja", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. remove the unnecessary dec string. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "remov", "unnecessari", "dec", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed NPE in Arja_Defects4J_Lang_27. removed expPos from mant string. ", "B_clean_title": ["fix", "npe", "arja", "defects4j", "lang", "27", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. remove expPos. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "remov", "exppo", "exp", "po"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Handle parseDouble for StringUtils .. ", "B_clean_title": ["handl", "parsedoubl", "pars", "doubl", "stringutil", "string", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. Allow trailing comma in Strings. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "allow", "trail", "comma", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "fix", "npe", "arjadefects4j", "lang", "27", "arja", "defects4j"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. remove the unnecessary dec string. Remove exp pos from definition of Double. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "remov", "unnecessari", "dec", "string", "remov", "exp", "po", "definit", "doubl"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "avoid NPE. fixed NPE in Arja_Defects4J_Lang_27. removed expPos from mant string. fixed NPE in Arja_Defects4J_Lang_27. ", "B_clean_title": ["avoid", "npe", "fix", "npe", "arja", "defects4j", "lang", "27", "remov", "exppo", "exp", "po", "mant", "string", "fix", "npe", "arja", "defects4j", "lang", "27"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Allow null string input. removed expPos from mant string. ", "B_clean_title": ["allow", "null", "string", "input", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed a bug in NumberUtils. removed expPos from mant string. fixed syntax error in previous patch. ", "B_clean_title": ["fix", "bug", "numberutil", "number", "util", "remov", "exppo", "exp", "po", "mant", "string", "fix", "syntax", "error", "previou", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed a bug in NumberUtils. removed unnecessary check for integer precision thing. Remove expPos from mant string  because we  re about to replace it with the exp. try string to create double from numeric value. ", "B_clean_title": ["fix", "bug", "numberutil", "number", "util", "remov", "unnecessari", "check", "integ", "precis", "thing", "remov", "exppo", "exp", "po", "mant", "string", "becaus", "we", "re", "about", "replac", "it", "exp", "tri", "string", "creat", "doubl", "numer", "valu"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Allow null exponent string to be parsed as a string. removed expPos from mant string. ", "B_clean_title": ["allow", "null", "expon", "string", "pars", "as", "string", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. remove the extraneous space. fix a merge conflict in NumberUtils. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "remov", "extran", "space", "fix", "merg", "conflict", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed exp fix. ", "B_clean_title": ["remov", "exp", "fix"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. Allow null string input. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "allow", "null", "string", "input"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Fix lost backslash. Fix a bug in NumberUtils. ", "B_clean_title": ["fix", "lost", "backslash", "fix", "bug", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Add null check. removed expPos from mant string. ", "B_clean_title": ["add", "null", "check", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. fixed a bug in NumberUtils. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "bug", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. Fixed ment = string .. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "fix", "ment", "string"]},
{"A_title": "LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to itLevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it. This makes it hard to specify custom stopping criteria for the optimizer.", "A_clean_title": ["levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "ignor", "vectorialconvergencecheck", "vectori", "converg", "checker", "paramet", "pass", "itlevenbergmarquardtoptim", "it", "levenberg", "marquardt", "optim", "ignor", "vectorialconvergencecheck", "vectori", "converg", "checker", "paramet", "pass", "it", "thi", "make", "it", "hard", "specifi", "custom", "stop", "criteria", "optim"], "B_title": "Fix a regression in LevenbergMarquardtOptimizer . java. ", "B_clean_title": ["fix", "regress", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "java"]},
{"A_title": "RETURNS_DEEP_STUBS automatically tries to create serializable mocksYou are using the setting withSettings().serializable() however the type you are trying to mock NotSerializableReturnValue do not implement Serializable AND do not have a no-arg constructor.", "A_clean_title": ["return", "deep", "stub", "automat", "tri", "creat", "serializ", "mocksyou", "mock", "you", "are", "set", "withset", "set", "serializ", "howev", "type", "you", "are", "tri", "mock", "notserializablereturnvalu", "not", "serializ", "return", "valu", "not", "implement", "serializ", "not", "have", "no", "arg", "constructor"], "B_title": "fix merge conflict resolution. ", "B_clean_title": ["fix", "merg", "conflict", "resolut"]},
{"A_title": "Classify non-rightmost expressions as problematicNone", "A_clean_title": ["classifi", "non", "rightmost", "express", "as", "problematicnon", "problemat", "none"], "B_title": "Allow one - line ifs. ", "B_clean_title": ["allow", "one", "line", "if"]},
{"A_title": "Classify non-rightmost expressions as problematicNone", "A_clean_title": ["classifi", "non", "rightmost", "express", "as", "problematicnon", "problemat", "none"], "B_title": "Fix side effects ofcommas in functional tests. ", "B_clean_title": ["fix", "side", "effect", "ofcomma", "function", "test"]},
{"A_title": "Classify non-rightmost expressions as problematicNone", "A_clean_title": ["classifi", "non", "rightmost", "express", "as", "problematicnon", "problemat", "none"], "B_title": "Fix maybe - dead code. ", "B_clean_title": ["fix", "mayb", "dead", "code"]},
{"A_title": "Classify non-rightmost expressions as problematicNone", "A_clean_title": ["classifi", "non", "rightmost", "express", "as", "problematicnon", "problemat", "none"], "B_title": "Fix the case of a null pointer check in a few places .. ", "B_clean_title": ["fix", "case", "null", "pointer", "check", "few", "place"]},
{"A_title": "Classify non-rightmost expressions as problematicNone", "A_clean_title": ["classifi", "non", "rightmost", "express", "as", "problematicnon", "problemat", "none"], "B_title": "Fix the case of no - op in a closure check .. ", "B_clean_title": ["fix", "case", "no", "op", "closur", "check"]},
{"A_title": "Classify non-rightmost expressions as problematicNone", "A_clean_title": ["classifi", "non", "rightmost", "express", "as", "problematicnon", "problemat", "none"], "B_title": "Add gramps as a modifier to a name .. ", "B_clean_title": ["add", "gramp", "as", "modifi", "name"]},
{"A_title": "Classify non-rightmost expressions as problematicNone", "A_clean_title": ["classifi", "non", "rightmost", "express", "as", "problematicnon", "problemat", "none"], "B_title": "Allow non - expr results in closure closure check .. ", "B_clean_title": ["allow", "non", "expr", "result", "closur", "closur", "check"]},
{"A_title": "Classify non-rightmost expressions as problematicNone", "A_clean_title": ["classifi", "non", "rightmost", "express", "as", "problematicnon", "problemat", "none"], "B_title": "JSDoc info removed from closure patch. ", "B_clean_title": ["jsdoc", "js", "doc", "info", "remov", "closur", "patch"]},
{"A_title": "Classify non-rightmost expressions as problematicNone", "A_clean_title": ["classifi", "non", "rightmost", "express", "as", "problematicnon", "problemat", "none"], "B_title": "Remove stray return statement from a checksideeffects patch .. ", "B_clean_title": ["remov", "stray", "return", "statement", "checksideeffect", "patch"]},
{"A_title": "getLInfNorm() uses wrong formula in both ArrayRealVector and OpenMapRealVector (in different ways)the L_infinity norm of a finite dimensional vector is just the max of the absolute value of its entries. The current implementation in ArrayRealVector has a typo:      public double getLInfNorm()          double max = 0;         for (double a : data)              max += Math.max(max Math.abs(a));                  return max;        the += should just be an =. There is sadly a unit test assuring us that this is the correct behavior (effectively a regression-only test not a test for correctness). Worse the implementation in OpenMapRealVector is not even positive semi-definite:          public double getLInfNorm()          double max = 0;         Iterator iter = entries.iterator();         while (iter.hasNext())              iter.advance();             max += iter.value();                  return max;        I would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator():    public double getLInfNorm()      double norm = 0;     Iterator<Entry> it = sparseIterator();     Entry e;     while(it.hasNext() && (e = it.next()) != null)        norm = Math.max(norm Math.abs(e.getValue()));          return norm;      Unit tests with negative valued vectors would be helpful to check for this kind of thing in the future.", "A_clean_title": ["getlinfnorm", "get", "inf", "norm", "use", "wrong", "formula", "both", "arrayrealvector", "array", "real", "vector", "openmaprealvector", "open", "map", "real", "vector", "differ", "way", "infin", "norm", "finit", "dimension", "vector", "just", "max", "absolut", "valu", "it", "entri", "current", "implement", "arrayrealvector", "array", "real", "vector", "ha", "typo", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "max", "doubl", "data", "max", "math", "max", "max", "math", "ab", "return", "max", "just", "there", "sadli", "unit", "test", "assur", "us", "that", "thi", "correct", "behavior", "effect", "regress", "onli", "test", "not", "test", "correct", "wors", "implement", "openmaprealvector", "open", "map", "real", "vector", "not", "even", "posit", "semi", "definit", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "max", "iter", "iter", "entri", "iter", "while", "iter", "hasnext", "ha", "next", "iter", "advanc", "max", "iter", "valu", "return", "max", "would", "suggest", "that", "thi", "method", "move", "up", "abstractrealvector", "abstract", "real", "vector", "superclass", "implement", "sparseiter", "spars", "iter", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "norm", "iter", "entri", "it", "sparseiter", "spars", "iter", "entri", "while", "it", "hasnext", "ha", "next", "it", "next", "null", "norm", "math", "max", "norm", "math", "ab", "getvalu", "get", "valu", "return", "norm", "unit", "test", "neg", "valu", "vector", "would", "help", "check", "thi", "kind", "thing", "futur"], "B_title": "Fix ArrayRealVector . getLInfNorm ( ). ", "B_clean_title": ["fix", "arrayrealvector", "array", "real", "vector", "getlinfnorm", "get", "inf", "norm"]},
{"A_title": "PearsonsCorrelation.getCorrelationPValues() precision limited by machine epsilonSimilar to the issue described in MATH-201 using PearsonsCorrelation.getCorrelationPValues() with many treatments results in p-values that are continuous down to 2.2e-16 but that drop to 0 after that. In MATH-201 the problem was described as such: > So in essence the p-value returned by TTestImpl.tTest() is: >  > 1.0 - (cumulativeProbability(t) - cumulativeProbabily(-t)) >  > For large-ish t-statistics cumulativeProbabilty(-t) can get quite small and cumulativeProbabilty(t) can get very close to 1.0. When  > cumulativeProbability(-t) is less than the machine epsilon we get p-values equal to zero because: >  > 1.0 - 1.0 + 0.0 = 0.0 The solution in MATH-201 was to modify the p-value calculation to this: > p = 2.0 * cumulativeProbability(-t) Here the problem is similar.  From PearsonsCorrelation.getCorrelationPValues():   p = 2 * (1 - tDistribution.cumulativeProbability(t)); Directly calculating the p-value using identical code as PearsonsCorrelation.getCorrelationPValues() but with the following change seems to solve the problem:   p = 2 * (tDistribution.cumulativeProbability(-t));", "A_clean_title": ["pearsonscorrel", "getcorrelationpvalu", "pearson", "correl", "get", "correl", "valu", "precis", "limit", "by", "machin", "epsilonsimilar", "epsilon", "similar", "issu", "describ", "math", "201", "pearsonscorrel", "getcorrelationpvalu", "pearson", "correl", "get", "correl", "valu", "mani", "treatment", "result", "valu", "that", "are", "continu", "down", "16", "2e", "but", "that", "drop", "after", "that", "math", "201", "problem", "wa", "describ", "as", "such", "so", "essenc", "valu", "return", "by", "ttestimpl", "ttest", "test", "impl", "test", "cumulativeprob", "cumul", "probabl", "cumulativeprobabili", "cumul", "probabili", "larg", "ish", "statist", "cumulativeprobabilti", "cumul", "probabilti", "get", "quit", "small", "cumulativeprobabilti", "cumul", "probabilti", "get", "veri", "close", "when", "cumulativeprob", "cumul", "probabl", "less", "than", "machin", "epsilon", "we", "get", "valu", "equal", "zero", "becaus", "solut", "math", "201", "wa", "modifi", "valu", "calcul", "thi", "cumulativeprob", "cumul", "probabl", "here", "problem", "similar", "pearsonscorrel", "getcorrelationpvalu", "pearson", "correl", "get", "correl", "valu", "tdistribut", "cumulativeprob", "distribut", "cumul", "probabl", "directli", "calcul", "valu", "ident", "code", "as", "pearsonscorrel", "getcorrelationpvalu", "pearson", "correl", "get", "correl", "valu", "but", "follow", "chang", "seem", "solv", "problem", "tdistribut", "cumulativeprob", "distribut", "cumul", "probabl"], "B_title": "Missing test for HIVE5199 ( I had left it harwired to say ). ", "B_clean_title": ["miss", "test", "hive5199", "had", "left", "it", "harwir", "say"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "Set signChangeIndex to 2. ", "B_clean_title": ["set", "signchangeindex", "sign", "chang", "index"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "fix the sign change index so it works. ", "B_clean_title": ["fix", "sign", "chang", "index", "so", "it", "work"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "Added missing if (. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "Added missing sign in BracketingNthOrderBrentSolver. ", "B_clean_title": ["ad", "miss", "sign", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "Added a fix for the case where the root of the bracketing NthOrderBrent. ", "B_clean_title": ["ad", "fix", "case", "where", "root", "bracket", "nthorderbr", "nth", "order", "brent"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "Fix swapped sign exchange error in BracketingNthOrderBrentSolver . java. ", "B_clean_title": ["fix", "swap", "sign", "exchang", "error", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "java"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "moving yA to 0 when we drop the lowest value in the array. Forgot to include verifyInterval in BracketingNthOrderBrentSolver . solve (. Fix EZC from pull request. ", "B_clean_title": ["move", "ya", "when", "we", "drop", "lowest", "valu", "array", "forgot", "includ", "verifyinterv", "verifi", "interv", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "solv", "fix", "ezc", "pull", "request"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fixed zero - is - max datetime field. ", "B_clean_title": ["fix", "zero", "max", "datetim", "field"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Added zeroismaxdatetimefield copy. ", "B_clean_title": ["ad", "zeroismaxdatetimefield", "copi"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fixed zero - is - max datetime field. ", "B_clean_title": ["fix", "zero", "max", "datetim", "field"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fixed zero - is - maxDateTimeField minimization. ", "B_clean_title": ["fix", "zero", "maxdatetimefield", "max", "date", "time", "field", "minim"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fixed the build .. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Add an exception. ", "B_clean_title": ["add", "except"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Add an exception. ", "B_clean_title": ["add", "except"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fix # 135. ", "B_clean_title": ["fix", "135"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fixed zero - is - max datetime field minimization. ", "B_clean_title": ["fix", "zero", "max", "datetim", "field", "minim"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fix incorrect patch180 data. ", "B_clean_title": ["fix", "incorrect", "patch180", "data"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Add 0 . 5 for the getMaximumValue ( ) method  but not in the patch. ", "B_clean_title": ["add", "getmaximumvalu", "get", "maximum", "valu", "method", "but", "not", "patch"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Add missing import .. Fixed whitespace in ZeroIsMaxDateTimeField . getMaximumValue ( ReadablePartial instant  int . ", "B_clean_title": ["add", "miss", "import", "fix", "whitespac", "zeroismaxdatetimefield", "zero", "max", "date", "time", "field", "getmaximumvalu", "get", "maximum", "valu", "readableparti", "readabl", "partial", "instant", "int"]},
{"A_title": "ClassCastException during TypeCheck passNone", "A_clean_title": ["classcastexcept", "class", "cast", "except", "dure", "typecheck", "type", "check", "passnon", "pass", "none"], "B_title": "Switch the default closure implementation back to the record type .. ", "B_clean_title": ["switch", "default", "closur", "implement", "back", "record", "type"]},
{"A_title": "ClassCastException during TypeCheck passNone", "A_clean_title": ["classcastexcept", "class", "cast", "except", "dure", "typecheck", "type", "check", "passnon", "pass", "none"], "B_title": "Don  t compare JSType against native object type .. ", "B_clean_title": ["don", "compar", "jstype", "js", "type", "against", "nativ", "object", "type"]},
{"A_title": "ClassCastException during TypeCheck passNone", "A_clean_title": ["classcastexcept", "class", "cast", "except", "dure", "typecheck", "type", "check", "passnon", "pass", "none"], "B_title": "don  t include regexps in closures. ", "B_clean_title": ["don", "includ", "regexp", "closur"]},
{"A_title": "ClassCastException during TypeCheck passNone", "A_clean_title": ["classcastexcept", "class", "cast", "except", "dure", "typecheck", "type", "check", "passnon", "pass", "none"], "B_title": "Fix jstype matching of non - Record types .. ", "B_clean_title": ["fix", "jstype", "match", "non", "record", "type"]},
{"A_title": "ClassCastException during TypeCheck passNone", "A_clean_title": ["classcastexcept", "class", "cast", "except", "dure", "typecheck", "type", "check", "passnon", "pass", "none"], "B_title": "Fix closure patching. ", "B_clean_title": ["fix", "closur", "patch"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that  code      * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic code  Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "code", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "code", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add the missing null check. ", "B_clean_title": ["add", "miss", "null", "check"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that  code      * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic code  Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "code", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "code", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add a missing if / else in Complex . add ( ). ", "B_clean_title": ["add", "miss", "complex", "add"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that  code      * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic code  Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "code", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "code", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add the missing NaN check. ", "B_clean_title": ["add", "miss", "nan", "na", "check"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that  code      * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic code  Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "code", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "code", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add NaN to complex add ( ). ", "B_clean_title": ["add", "nan", "na", "complex", "add"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that  code      * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic code  Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "code", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "code", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add NaN check. ", "B_clean_title": ["add", "nan", "na", "check"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that  code      * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic code  Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "code", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "code", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add NaN check. ", "B_clean_title": ["add", "nan", "na", "check"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that  code      * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic code  Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "code", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "code", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add NaN to Complex . add ( ). ", "B_clean_title": ["add", "nan", "na", "complex", "add"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that  code      * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic code  Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "code", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "code", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add the missing checkNotNull check. ", "B_clean_title": ["add", "miss", "checknotnul", "check", "not", "null", "check"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that  code      * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic code  Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "code", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "code", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add NaN to fix # 1796. ", "B_clean_title": ["add", "nan", "na", "fix", "1796"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "Fix top level delete / merge bug. ", "B_clean_title": ["fix", "top", "level", "delet", "merg", "bug"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "Remove unnecessary switch case. remove patched code. ", "B_clean_title": ["remov", "unnecessari", "switch", "case", "remov", "patch", "code"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove accidential modification. remove patch for > => < =. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "accidenti", "modif", "remov", "patch"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove patch for > => < =. remove old combiner patch. remove patch for  findTop ( ) . ", "B_clean_title": ["remov", "patch", "remov", "old", "combin", "patch", "remov", "patch", "findtop", "find", "top"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove unnecessary check for type. remove a redundant check. remove old combiner patch. ", "B_clean_title": ["remov", "unnecessari", "check", "type", "remov", "redund", "check", "remov", "old", "combin", "patch"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove a / b sign from a combiner. remove patched code. ", "B_clean_title": ["remov", "sign", "combin", "remov", "patch", "code"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old erroneous fall through for long combiner. remove max / min entries found by accident. remove old combiner patch. ", "B_clean_title": ["remov", "old", "erron", "fall", "through", "long", "combin", "remov", "max", "min", "entri", "found", "by", "accid", "remov", "old", "combin", "patch"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove max / min entries in jar because they  re not compatible with java 1 . 5. remove old combiner patch. ", "B_clean_title": ["remov", "max", "min", "entri", "jar", "becaus", "they", "re", "not", "compat", "java", "remov", "old", "combin", "patch"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove unnecessary check for type. remove max / min entries found by accident. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "unnecessari", "check", "type", "remov", "max", "min", "entri", "found", "by", "accid"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove patch for > => < =. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "patch"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove aSign == 0 for greater than or equal to 0. remove patch from top level. remove patch for column family iterators. ", "B_clean_title": ["remov", "asign", "sign", "greater", "than", "or", "equal", "remov", "patch", "top", "level", "remov", "patch", "column", "famili", "iter"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old break. remove old combiner patch. remove findTop ( ) from Combiner . java. ", "B_clean_title": ["remov", "old", "break", "remov", "old", "combin", "patch", "remov", "findtop", "find", "top", "combin", "java"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove patch for > => < =. remove old combiner patch. ", "B_clean_title": ["remov", "patch", "remov", "old", "combin", "patch"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove patched code. remove patch for column family iterators. remove patch for > > >. ", "B_clean_title": ["remov", "patch", "code", "remov", "patch", "column", "famili", "iter", "remov", "patch"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old erroneous fall through for long combiner. remove old combiner patch. remove patched findTop. ", "B_clean_title": ["remov", "old", "erron", "fall", "through", "long", "combin", "remov", "old", "combin", "patch", "remov", "patch", "findtop", "find", "top"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove old erroneous fall through for long combiner. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "old", "erron", "fall", "through", "long", "combin"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove old erroneous fall through for long combiner. remove max / min implementation of LongCombiner. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "old", "erron", "fall", "through", "long", "combin", "remov", "max", "min", "implement", "longcombin", "long", "combin"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove patch for column family iterators. remove max / min entries found by accident. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "patch", "column", "famili", "iter", "remov", "max", "min", "entri", "found", "by", "accid"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove patch. remove patch for > => < =. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "patch", "remov", "patch"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove unnecessary check for type. gh - 66 fixed a bug. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "unnecessari", "check", "type", "gh", "66", "fix", "bug"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove patch for column family iterators. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "patch", "column", "famili", "iter"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove patch for column family iterators. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "patch", "column", "famili", "iter"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove patch for > => < =. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "patch"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove patch from top level jar. remove old erroneous fall through for long combiner. ", "B_clean_title": ["remov", "patch", "top", "level", "jar", "remov", "old", "erron", "fall", "through", "long", "combin"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove a redundant check. remove old combiner patch. remove patch for column family iterators. ", "B_clean_title": ["remov", "redund", "check", "remov", "old", "combin", "patch", "remov", "patch", "column", "famili", "iter"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove patch for hadoop / accumulo / hadoop / fs / LengthFileChecksum . java. ", "B_clean_title": ["remov", "patch", "hadoop", "accumulo", "hadoop", "fs", "lengthfilechecksum", "length", "file", "checksum", "java"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove accidential modification. remove aSign > bSign. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "accidenti", "modif", "remov", "asign", "sign", "bsign", "sign"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove patch for > > >. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "patch"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove patch for reduce ( ). ", "B_clean_title": ["remov", "patch", "reduc"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove patch for reduce ( ). remove max / min entries in jar because they  re not compatible with java 1 . 5. ", "B_clean_title": ["remov", "patch", "reduc", "remov", "max", "min", "entri", "jar", "becaus", "they", "re", "not", "compat", "java"]},
{"A_title": "Combiner default behavior is dangerousCurrently if the users does not give the combiner any columns to work against it will work against all columns.  This is dangerous if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().", "A_clean_title": ["combin", "default", "behavior", "dangerouscurr", "danger", "current", "user", "not", "give", "combin", "ani", "column", "work", "against", "it", "will", "work", "against", "all", "column", "thi", "danger", "user", "accident", "forget", "specifi", "column", "then", "their", "data", "could", "unintent", "corrupt", "someth", "differ", "need", "done", "also", "class", "that", "extend", "combin", "call", "super", "validateopt", "valid", "option"], "B_title": "remove old combiner patch. remove old erroneous fall through for long combiner. ", "B_clean_title": ["remov", "old", "combin", "patch", "remov", "old", "erron", "fall", "through", "long", "combin"]},
{"A_title": "calling MiniAccumuloCluster.stop multiple times fails with NPEOn the mailing list ~ctubbsii mentioned seeing some NPEs in the stderr for mvn verify.  I see one here when running mvn verify with either hadoop profile:  quote Exception in thread Thread-0 java.lang.NullPointerException at org.apache.accumulo.minicluster.MiniAccumuloCluster.stopProcessWithTimeout(MiniAccumuloCluster.java:449) at org.apache.accumulo.minicluster.MiniAccumuloCluster.stop(MiniAccumuloCluster.java:376) at org.apache.accumulo.minicluster.MiniAccumuloCluster 1.run(MiniAccumuloCluster.java:318) quote  The relevant piece of code (in 1.5.2-SNAP) is the executor.execute below  code   private int stopProcessWithTimeout(final Process proc long timeout TimeUnit unit) throws InterruptedException ExecutionException TimeoutException      FutureTask<Integer> future = new FutureTask<Integer>(new Callable<Integer>()          @Override         public Integer call() throws InterruptedException            proc.destroy();           return proc.waitFor();              );      executor.execute(future);      return future.get(timeout unit);    code  Reading through the code for stop it nulls out executor when its done. So the easy way to get an NPE is calling stop() multiple times on a MAC instance. Since we have a shutdown hook that calls stop that means that a single user invocation of stop should result in a NPE later.  Since start() doesnt allow multiple starts we probably shouldnt allow multiple stops. That would mean adding logic to the shutdown hook to check if were already stopped or making a private unguarded version of stop that allows multiple calls and using that from the hook.  criteria for closing this issue:  * MAC should document wether calling stop() multiple times is allowed * fix MAC.stop to either guard against multiple calls or handle them gracefully * find out why this only gets an NPE in one place. Do we rely on the shutdown hook everywhere?", "A_clean_title": ["call", "miniaccumuloclust", "stop", "mini", "accumulo", "cluster", "multipl", "time", "fail", "npeon", "npe", "mail", "list", "~ctubbsii", "mention", "see", "some", "npe", "np", "es", "stderr", "mvn", "verifi", "see", "one", "here", "when", "run", "mvn", "verifi", "either", "hadoop", "profil", "quot", "except", "thread", "thread", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "accumulo", "miniclust", "miniaccumuloclust", "stopprocesswithtimeout", "mini", "accumulo", "cluster", "stop", "process", "timeout", "miniaccumuloclust", "java:449", "mini", "accumulo", "cluster", "at", "org", "apach", "accumulo", "miniclust", "miniaccumuloclust", "stop", "mini", "accumulo", "cluster", "miniaccumuloclust", "java:376", "mini", "accumulo", "cluster", "at", "org", "apach", "accumulo", "miniclust", "miniaccumuloclust", "mini", "accumulo", "cluster", "run", "miniaccumuloclust", "java:318", "mini", "accumulo", "cluster", "quot", "relev", "piec", "code", "snap", "executor", "execut", "below", "code", "privat", "int", "stopprocesswithtimeout", "stop", "process", "timeout", "final", "process", "proc", "long", "timeout", "timeunit", "time", "unit", "unit", "throw", "interruptedexcept", "interrupt", "except", "executionexcept", "execut", "except", "timeoutexcept", "timeout", "except", "futuretask", "futur", "task", "integ", "futur", "new", "futuretask", "futur", "task", "integ", "new", "callabl", "integ", "overrid", "public", "integ", "call", "throw", "interruptedexcept", "interrupt", "except", "proc", "destroy", "return", "proc", "waitfor", "wait", "executor", "execut", "futur", "return", "futur", "get", "timeout", "unit", "code", "read", "through", "code", "stop", "it", "null", "out", "executor", "when", "it", "done", "so", "easi", "way", "get", "npe", "call", "stop", "multipl", "time", "mac", "instanc", "sinc", "we", "have", "shutdown", "hook", "that", "call", "stop", "that", "mean", "that", "singl", "user", "invoc", "stop", "result", "npe", "later", "sinc", "start", "doesnt", "allow", "multipl", "start", "we", "probabl", "shouldnt", "allow", "multipl", "stop", "that", "would", "mean", "ad", "logic", "shutdown", "hook", "check", "were", "alreadi", "stop", "or", "make", "privat", "unguard", "version", "stop", "that", "allow", "multipl", "call", "that", "hook", "criteria", "close", "thi", "issu", "mac", "document", "wether", "call", "stop", "multipl", "time", "allow", "fix", "mac", "stop", "either", "guard", "against", "multipl", "call", "or", "handl", "them", "grace", "find", "out", "whi", "thi", "onli", "get", "npe", "one", "place", "we", "reli", "shutdown", "hook", "everywher"], "B_title": "Fix secondary scan JAR after 90 min. ", "B_clean_title": ["fix", "secondari", "scan", "jar", "after", "90", "min"]},
{"A_title": "Exception when emitting code containing gettersNone", "A_clean_title": ["except", "when", "emit", "code", "contain", "gettersnon", "getter", "none"], "B_title": "Added patch for parseHelperCode ( ). ", "B_clean_title": ["ad", "patch", "parsehelpercod", "pars", "helper", "code"]},
{"A_title": "Exception when emitting code containing gettersNone", "A_clean_title": ["except", "when", "emit", "code", "contain", "gettersnon", "getter", "none"], "B_title": "Remove false alarms that were failing the closure compiler .. ", "B_clean_title": ["remov", "fals", "alarm", "that", "were", "fail", "closur", "compil"]},
{"A_title": "Exception when emitting code containing gettersNone", "A_clean_title": ["except", "when", "emit", "code", "contain", "gettersnon", "getter", "none"], "B_title": "Fix maybeGetSingleReturnRValue ( ). ", "B_clean_title": ["fix", "maybegetsinglereturnrvalu", "mayb", "get", "singl", "return", "valu"]},
{"A_title": "Exception when emitting code containing gettersNone", "A_clean_title": ["except", "when", "emit", "code", "contain", "gettersnon", "getter", "none"], "B_title": "Remove unneeded call to NodeTraversal . traverse ( ) .. ", "B_clean_title": ["remov", "unneed", "call", "nodetravers", "node", "travers", "travers"]},
{"A_title": "Bug in MonotoneChain: a collinear point landing on the existing boundary should be dropped (patch)The is a bug on the code in MonotoneChain.java that attempts to handle the case of a point on the line formed by the previous last points and the last point of the chain being constructed. When `includeCollinearPoints` is false the point should be dropped entirely. In common-math 33 the point is added which in some cases can cause a `ConvergenceException` to be thrown.  In the patch below the data points are from a case that showed up in testing before we went to production.  code:java Index: src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java =================================================================== --- src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java(revision 1609491) +++ src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java(working copy) @@ -1608 +1608 @@                   else                       if (distanceToCurrent > distanceToLast)                           hull.remove(size - 1); +                        hull.add(point);                       -                    hull.add(point);                                    return;               else if (offset > 0)  Index: src/test/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHullGenerator2DAbstractTest.java =================================================================== --- src/test/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHullGenerator2DAbstractTest.java(revision 1609491) +++ src/test/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHullGenerator2DAbstractTest.java(working copy) @@ -2046 +20424 @@              @Test +    public void testCollinnearPointOnExistingBoundary()  +        final Collection<Vector2D> points = new ArrayList<Vector2D>(); +        points.add(new Vector2D(7.3152 34.7472)); +        points.add(new Vector2D(6.400799999999997 34.747199999999985)); +        points.add(new Vector2D(5.486399999999997 34.7472)); +        points.add(new Vector2D(4.876799999999999 34.7472)); +        points.add(new Vector2D(4.876799999999999 34.1376)); +        points.add(new Vector2D(4.876799999999999 30.48)); +        points.add(new Vector2D(6.0959999999999965 30.48)); +        points.add(new Vector2D(6.0959999999999965 34.1376)); +        points.add(new Vector2D(7.315199999999996 34.1376)); +        points.add(new Vector2D(7.3152 30.48)); + +        final ConvexHull2D hull = generator.generate(points); +        checkConvexHull(points hull); +     + +    @Test      public void testIssue1123()             List<Vector2D> points = new ArrayList<Vector2D>(); code", "A_clean_title": ["bug", "monotonechain", "monoton", "chain", "collinear", "point", "land", "exist", "boundari", "drop", "patch", "bug", "code", "monotonechain", "java", "monoton", "chain", "that", "attempt", "handl", "case", "point", "line", "form", "by", "previou", "last", "point", "last", "point", "chain", "be", "construct", "when", "includecollinearpoint", "includ", "collinear", "point", "fals", "point", "drop", "entir", "common", "math", "33", "point", "ad", "which", "some", "case", "caus", "convergenceexcept", "converg", "except", "thrown", "patch", "below", "data", "point", "are", "case", "that", "show", "up", "test", "befor", "we", "went", "product", "code", "java", "index", "java", "src", "main", "java", "org", "apach", "common", "math3", "geometri", "euclidean", "twod", "hull", "monotonechain", "monoton", "chain", "java", "src", "main", "java", "org", "apach", "common", "math3", "geometri", "euclidean", "twod", "hull", "monotonechain", "monoton", "chain", "revis", "1609491", "java", "src", "main", "java", "org", "apach", "common", "math3", "geometri", "euclidean", "twod", "hull", "monotonechain", "monoton", "chain", "work", "copi", "1608", "+1608", "distancetocurr", "distanc", "current", "distancetolast", "distanc", "last", "hull", "remov", "size", "hull", "add", "point", "hull", "add", "point", "return", "offset", "index", "java", "src", "test", "java", "org", "apach", "common", "math3", "geometri", "euclidean", "twod", "hull", "convexhullgenerator2dabstracttest", "convex", "hull", "generator2d", "abstract", "test", "java", "src", "test", "java", "org", "apach", "common", "math3", "geometri", "euclidean", "twod", "hull", "convexhullgenerator2dabstracttest", "convex", "hull", "generator2d", "abstract", "test", "revis", "1609491", "java", "src", "test", "java", "org", "apach", "common", "math3", "geometri", "euclidean", "twod", "hull", "convexhullgenerator2dabstracttest", "convex", "hull", "generator2d", "abstract", "test", "work", "copi", "2046", "+20424", "test", "public", "void", "testcollinnearpointonexistingboundari", "test", "collinnear", "point", "exist", "boundari", "final", "collect", "vector2d", "point", "new", "arraylist", "array", "list", "vector2d", "point", "add", "new", "vector2d", "3152", "34", "7472", "point", "add", "new", "vector2d", "400799999999997", "34", "747199999999985", "point", "add", "new", "vector2d", "486399999999997", "34", "7472", "point", "add", "new", "vector2d", "876799999999999", "34", "7472", "point", "add", "new", "vector2d", "876799999999999", "34", "1376", "point", "add", "new", "vector2d", "876799999999999", "30", "48", "point", "add", "new", "vector2d", "0959999999999965", "30", "48", "point", "add", "new", "vector2d", "0959999999999965", "34", "1376", "point", "add", "new", "vector2d", "315199999999996", "34", "1376", "point", "add", "new", "vector2d", "3152", "30", "48", "final", "convexhull2d", "convex", "hull2d", "hull", "gener", "gener", "point", "checkconvexhul", "check", "convex", "hull", "point", "hull", "test", "public", "void", "testissue1123", "test", "issue1123", "list", "vector2d", "point", "new", "arraylist", "array", "list", "vector2d", "code"], "B_title": "removed patched code. ", "B_clean_title": ["remov", "patch", "code"]},
{"A_title": "Bug on withLaterOffsetAtOverlap methodOn the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all ).", "A_clean_title": ["bug", "withlateroffsetatoverlap", "later", "offset", "at", "overlap", "methodon", "method", "last", "two", "bracket", "we", "see", "that", "withlateroffsetatoverlap", "later", "offset", "at", "overlap", "not", "undo", "withearlieroffsetatoverlap", "earlier", "offset", "at", "overlap", "as", "it", "not", "even", "work", "at", "all"], "B_title": "Fix an issue with DateTimeZone . getOffset ( ) where the difference was not an overlap. ", "B_clean_title": ["fix", "issu", "datetimezon", "date", "time", "zone", "getoffset", "get", "offset", "where", "differ", "wa", "not", "overlap"]},
{"A_title": "Bug on withLaterOffsetAtOverlap methodOn the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all ).", "A_clean_title": ["bug", "withlateroffsetatoverlap", "later", "offset", "at", "overlap", "methodon", "method", "last", "two", "bracket", "we", "see", "that", "withlateroffsetatoverlap", "later", "offset", "at", "overlap", "not", "undo", "withearlieroffsetatoverlap", "earlier", "offset", "at", "overlap", "as", "it", "not", "even", "work", "at", "all"], "B_title": "Fix bug in time zone ISO 8601 format. ", "B_clean_title": ["fix", "bug", "time", "zone", "iso", "8601", "format"]}]