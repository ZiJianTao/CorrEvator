[{"A_title": "IllegalStateException at com.google.javascript.rhino.jstype.FunctionType.getInstanceTypeNone", "A_clean_title": ["illegalstateexcept", "illeg", "state", "except", "at", "com", "googl", "javascript", "rhino", "jstype", "functiontyp", "getinstancetypenon", "function", "type", "get", "instanc", "type", "none"], "B_title": "Allow false to be true case when comparison is desired. ", "B_clean_title": ["allow", "fals", "true", "case", "when", "comparison", "desir"]},
{"A_title": "IllegalStateException at com.google.javascript.rhino.jstype.FunctionType.getInstanceTypeNone", "A_clean_title": ["illegalstateexcept", "illeg", "state", "except", "at", "com", "googl", "javascript", "rhino", "jstype", "functiontyp", "getinstancetypenon", "function", "type", "get", "instanc", "type", "none"], "B_title": "Add missing imports .. Fix TypeCheck . java for ES6 closures .. ", "B_clean_title": ["add", "miss", "import", "fix", "typecheck", "type", "check", "java", "es6", "closur"]},
{"A_title": "StringEscapeUtils.escapeJava(String) escapes / charactersCommons Lang 2.4 StringEscapeUtils.escapeJava(String) now escapes / characters which is not a valid escapable character in Java strings.  I havent tried the other Java escape/unescape methods to see if they have a similar problem or that only Java escapable characters are escaped by escapeJava(String). This bug may have appeared as an unintended side-effect of the fix for LANG-363. Also the javadoc for escapeJava is now a little off in that / should now be included in the sentence describing the differences between Java and Javascript strings with respect to escaping rules. The following is a JUnit3 test demonstrating the bug. import junit.framework.TestCase; import org.apache.commons.lang.StringEscapeUtils; public class StringEscapeUtilsTest extends TestCase      public void testEscapeJavaWithSlash()           final String input = String with a slash (/) in it;                  final String expected = input;         final String actual   = StringEscapeUtils.escapeJava( input );          /**          * In 2.4 StringEscapeUtils.escapeJava(String) escapes / characters          * which are not a valid character to escape in a Java string.            */         assertEquals( expected actual );      ", "A_clean_title": ["stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "escap", "characterscommon", "charact", "common", "lang", "stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "now", "escap", "charact", "which", "not", "valid", "escap", "charact", "java", "string", "havent", "tri", "other", "java", "escap", "unescap", "method", "see", "they", "have", "similar", "problem", "or", "that", "onli", "java", "escap", "charact", "are", "escap", "by", "escapejava", "escap", "java", "string", "thi", "bug", "may", "have", "appear", "as", "unintend", "side", "effect", "fix", "lang", "363", "also", "javadoc", "escapejava", "escap", "java", "now", "littl", "off", "that", "now", "includ", "sentenc", "describ", "differ", "between", "java", "javascript", "string", "respect", "escap", "rule", "follow", "junit3", "unit3", "test", "demonstr", "bug", "import", "junit", "framework", "testcas", "test", "case", "import", "org", "apach", "common", "lang", "stringescapeutil", "string", "escap", "util", "public", "class", "stringescapeutilstest", "string", "escap", "util", "test", "extend", "testcas", "test", "case", "public", "void", "testescapejavawithslash", "test", "escap", "java", "slash", "final", "string", "input", "string", "slash", "it", "final", "string", "expect", "input", "final", "string", "actual", "stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "input", "stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "escap", "charact", "which", "are", "not", "valid", "charact", "escap", "java", "string", "assertequ", "assert", "equal", "expect", "actual"], "B_title": "don  t escape single quote when escaping backslash. ", "B_clean_title": ["don", "escap", "singl", "quot", "when", "escap", "backslash"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "isDigits ( numeric ) will ignore - > long. ", "B_clean_title": ["isdigit", "digit", "numer", "will", "ignor", "long"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Handle isDigits ( numeric ) as well as ( exp == null ). ", "B_clean_title": ["handl", "isdigit", "digit", "numer", "as", "well", "as", "exp", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Handle negative exponentiblity in StringUtils . java. ", "B_clean_title": ["handl", "neg", "exponentibl", "stringutil", "string", "util", "java"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Handle isDigits ( string ) with patch 1 - Lang - 58 - Hercules . fixed. ", "B_clean_title": ["handl", "isdigit", "digit", "string", "patch", "lang", "58", "hercul", "fix"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "isDigits ( string ) fix. ", "B_clean_title": ["isdigit", "digit", "string", "fix"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "try to create long from Javadoc. ", "B_clean_title": ["tri", "creat", "long", "javadoc"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix parse error. ", "B_clean_title": ["fix", "pars", "error"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix incorrect patch. ", "B_clean_title": ["fix", "incorrect", "patch"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "try StringUtils . isDigit. I had left it harwired to null .. ", "B_clean_title": ["tri", "stringutil", "string", "util", "isdigit", "digit", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix regex processing. I had left it harwired to null .. ", "B_clean_title": ["fix", "regex", "process", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "don  t throw NumberFormatException if decPos < decPos. I had left it harwired to say that it was a valid number .. ", "B_clean_title": ["don", "throw", "numberformatexcept", "number", "format", "except", "decpo", "dec", "po", "decpo", "dec", "po", "had", "left", "it", "harwir", "say", "that", "it", "wa", "valid", "number"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. start with - -. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "start"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add a missing patch. I had left it harwired to null .. don  t check isEmpty ( str )  because it seems we  re trying to understand why. ", "B_clean_title": ["add", "miss", "patch", "had", "left", "it", "harwir", "null", "don", "check", "isempti", "empti", "str", "becaus", "it", "seem", "we", "re", "tri", "understand", "whi"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. don  t check isEmpty ( str ) in StringUtils. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "don", "check", "isempti", "empti", "str", "stringutil", "string", "util"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "remove exp = null ; fix for patched code. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. ", "B_clean_title": ["remov", "exp", "null", "fix", "patch", "code", "had", "left", "it", "harwir", "null", "fix", "isallzero", "all", "zero", "persian", "urdu", "languag", "map"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Allow null string input. Add an error if the string is blank .. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. ", "B_clean_title": ["allow", "null", "string", "input", "add", "error", "string", "blank", "had", "left", "it", "harwir", "null", "fix", "isallzero", "all", "zero", "persian", "urdu", "languag", "map"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add the missing throw exception. I had left it harwired to null .. ", "B_clean_title": ["add", "miss", "throw", "except", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Remove exp = null in numberUtils. I had left it harwired to null .. ", "B_clean_title": ["remov", "exp", "null", "numberutil", "number", "util", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix NPE. don  t check isEmpty ( str ) in StringUtils. ", "B_clean_title": ["fix", "npe", "don", "check", "isempti", "empti", "str", "stringutil", "string", "util"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. isEmpty ( str ) fixed NHY - 1342  fixed NHY - 1342. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "isempti", "empti", "str", "fix", "nhi", "1342", "fix", "nhi", "1342"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "fixed String . isBlank ( ). Add a patch for formatting numbers in Avro settings. I had left it harwired to null .. ", "B_clean_title": ["fix", "string", "isblank", "blank", "add", "patch", "format", "number", "avro", "set", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "fix a numeric type request. I had left it harwired to null .. ", "B_clean_title": ["fix", "numer", "type", "request", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Allow null string input. I had left it harwired to null .. ", "B_clean_title": ["allow", "null", "string", "input", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. remove fix. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "remov", "fix"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Allow null string input. I had left it harwired to null .. ", "B_clean_title": ["allow", "null", "string", "input", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. don  t check isEmpty ( str ) in StringUtils. Add an error if a blank string is not a valid number. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "don", "check", "isempti", "empti", "str", "stringutil", "string", "util", "add", "error", "blank", "string", "not", "valid", "number"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Remove old and unused method. I had left it harwired to null .. ", "B_clean_title": ["remov", "old", "unus", "method", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Allow string to be parsed as a literal int. I had left it harwired to null .. ", "B_clean_title": ["allow", "string", "pars", "as", "liter", "int", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. add null check. add isDigit to StringUtils. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "add", "null", "check", "add", "isdigit", "digit", "stringutil", "string", "util"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "fixed String . isBlank ( ). I had left it harwired to null .. ", "B_clean_title": ["fix", "string", "isblank", "blank", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. Allow null to be passed. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "allow", "null", "pass"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. add null check. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "add", "null", "check"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. ", "B_clean_title": ["had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add an error if the string is blank .. I had left it harwired to null .. ", "B_clean_title": ["add", "error", "string", "blank", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. Add string isEmpty ( ) to isAllZeros ( ). ", "B_clean_title": ["had", "left", "it", "harwir", "null", "add", "string", "isempti", "empti", "isallzero", "all", "zero"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add an exception if the string is null. I had left it harwired to null .. ", "B_clean_title": ["add", "except", "string", "null", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "add patch for isDigit. I had left it harwired to null .. ", "B_clean_title": ["add", "patch", "isdigit", "digit", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add a missing patch. I had left it harwired to null .. Add a throw statement so that it can be cleaned up by the patcher .. ", "B_clean_title": ["add", "miss", "patch", "had", "left", "it", "harwir", "null", "add", "throw", "statement", "so", "that", "it", "clean", "up", "by", "patcher"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. isDigits method patched. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "isdigit", "digit", "method", "patch"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Remove old and unused method. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. ", "B_clean_title": ["remov", "old", "unus", "method", "had", "left", "it", "harwir", "null", "fix", "isallzero", "all", "zero", "persian", "urdu", "languag", "map"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add an error if the string is blank .. don  t throw NPE at end of definition file. I had left it harwired to null .. ", "B_clean_title": ["add", "error", "string", "blank", "don", "throw", "npe", "at", "end", "definit", "file", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. don  t throw NumberFormatException on isBlank ( string ). ", "B_clean_title": ["had", "left", "it", "harwir", "null", "don", "throw", "numberformatexcept", "number", "format", "except", "isblank", "blank", "string"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to say that it was a valid number .. ", "B_clean_title": ["had", "left", "it", "harwir", "say", "that", "it", "wa", "valid", "number"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "fix", "isallzero", "all", "zero", "persian", "urdu", "languag", "map"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add a throw if it is not a valid number. I had left it harwired to null .. ", "B_clean_title": ["add", "throw", "it", "not", "valid", "number", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to say that it was a valid number .. ", "B_clean_title": ["had", "left", "it", "harwir", "say", "that", "it", "wa", "valid", "number"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Remove old and unused patch. Allow null to be passed in for numberUtils . createBigInteger ( ). start with - -. ", "B_clean_title": ["remov", "old", "unus", "patch", "allow", "null", "pass", "numberutil", "number", "util", "createbiginteg", "creat", "big", "integ", "start"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. @ patch_1228 for StringUtils . isDigit. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "patch", "1228", "stringutil", "string", "util", "isdigit", "digit"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix 143 potential value error. fixed NHYD fixed. I had left it harwired to null .. ", "B_clean_title": ["fix", "143", "potenti", "valu", "error", "fix", "nhyd", "fix", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "fix null string handling. I had left it harwired to null .. ", "B_clean_title": ["fix", "null", "string", "handl", "had", "left", "it", "harwir", "null"]},
{"A_title": "GJChronology rejects valid Julian datesThe 2nd statement fails with org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range 128.  Given that I left the cutover date at the default (October 15 1582) isnt 1500/02/29 a valid date in the GJChronology?", "A_clean_title": ["gjchronolog", "gj", "chronolog", "reject", "valid", "julian", "datesth", "date", "2nd", "statement", "fail", "org", "joda", "time", "illegalfieldvalueexcept", "illeg", "field", "valu", "except", "valu", "29", "dayofmonth", "day", "month", "must", "rang", "128", "given", "that", "left", "cutov", "date", "at", "default", "octob", "15", "1582", "isnt", "1500", "02", "29", "valid", "date", "gjchronolog", "gj", "chronolog"], "B_title": "Fixed incorrect patch. ", "B_clean_title": ["fix", "incorrect", "patch"]},
{"A_title": "assignment to object in conditional causes type error on function w/ record type return typeNone", "A_clean_title": ["assign", "object", "condit", "caus", "type", "error", "function", "record", "type", "return", "typenon", "type", "none"], "B_title": "Make ObjectType collapseUnion if one is not null .. ", "B_clean_title": ["make", "objecttyp", "object", "type", "collapseunion", "collaps", "union", "one", "not", "null"]},
{"A_title": "FastDateFormat formats year differently than SimpleDateFormat in Java 7Starting with Java 7 does SimpleDateFormat format a year pattern of Y or YYY as 2003 instead of 03 as in former Java releases. According Javadoc this pattern should have been always been formatted as number therefore the new behavior seems to be a bug fix in the JDK. FastDateFormat is adjusted to behave the same.", "A_clean_title": ["fastdateformat", "fast", "date", "format", "format", "year", "differ", "than", "simpledateformat", "simpl", "date", "format", "java", "7start", "java", "simpledateformat", "simpl", "date", "format", "format", "year", "pattern", "or", "yyy", "as", "2003", "instead", "03", "as", "former", "java", "releas", "accord", "javadoc", "thi", "pattern", "have", "been", "alway", "been", "format", "as", "number", "therefor", "new", "behavior", "seem", "bug", "fix", "jdk", "fastdateformat", "fast", "date", "format", "adjust", "behav", "same"], "B_title": "FastDateFormat doesn  t select week / month fields ( issue # 507 ). ", "B_clean_title": ["fastdateformat", "fast", "date", "format", "doesn", "select", "week", "month", "field", "issu", "507"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed patch from BSPTree. fixed a merge bug in PolygonsSet caused by unecessary close. ", "B_clean_title": ["remov", "patch", "bsptree", "bsp", "tree", "fix", "merg", "bug", "polygonsset", "polygon", "set", "caus", "by", "unecessari", "close"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed erroneous warning. fixed a bug in the ot package. removed patch from BSPTree. ", "B_clean_title": ["fix", "erron", "warn", "fix", "bug", "ot", "packag", "remov", "patch", "bsptree", "bsp", "tree"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed a bug in Groovy. removed patch from BSPTree. fixed erroneous warning. ", "B_clean_title": ["fix", "bug", "groovi", "remov", "patch", "bsptree", "bsp", "tree", "fix", "erron", "warn"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed erroneous warning. fixed a small bug. removed unused patch. fixed issue with inf / negInf in GenProg_Bug_dot_jar_Common. ", "B_clean_title": ["fix", "erron", "warn", "fix", "small", "bug", "remov", "unus", "patch", "fix", "issu", "inf", "neginf", "neg", "inf", "genprog", "bug", "dot", "jar", "common", "gen", "prog"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed a merge bug in PolygonsSet caused by unecessary close. fixed a bug in ot . encode. BSPTree now uses BSPTree . chopOffMinus ( )  not BSPTree. ", "B_clean_title": ["fix", "merg", "bug", "polygonsset", "polygon", "set", "caus", "by", "unecessari", "close", "fix", "bug", "ot", "encod", "bsptree", "bsp", "tree", "now", "use", "bsptree", "bsp", "tree", "chopoffminu", "chop", "off", "minu", "not", "bsptree", "bsp", "tree"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed a bit of code. fixed erroneous warning. ", "B_clean_title": ["fix", "bit", "code", "fix", "erron", "warn"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed erroneous warning. fixed a bug in OrderedTuple. ", "B_clean_title": ["fix", "erron", "warn", "fix", "bug", "orderedtupl", "order", "tupl"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed erroneous warning. removed patch from BSPTree. fixed erroneous import. ", "B_clean_title": ["fix", "erron", "warn", "remov", "patch", "bsptree", "bsp", "tree", "fix", "erron", "import"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed erroneous warning. fixed ot . offset = ot . encode ( offset ) ;. removed patch from BSPTree. fixed a small bug. ", "B_clean_title": ["fix", "erron", "warn", "fix", "ot", "offset", "ot", "encod", "offset", "remov", "patch", "bsptree", "bsp", "tree", "fix", "small", "bug"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed patch. fixed ot . offset = offset ;. fixed erroneous warning. ", "B_clean_title": ["remov", "patch", "fix", "ot", "offset", "offset", "fix", "erron", "warn"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed erroneous warning. removed patch. fixed a bug in ot . encode ( ). ", "B_clean_title": ["fix", "erron", "warn", "remov", "patch", "fix", "bug", "ot", "encod"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed erroneous warning. fixed OE. removed patch from BSPTree. ", "B_clean_title": ["fix", "erron", "warn", "fix", "oe", "remov", "patch", "bsptree", "bsp", "tree"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed erroneous warning. ", "B_clean_title": ["fix", "erron", "warn"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed ot . offset = offset ;. removed patch from BSPTree. fixed erroneous warning. ", "B_clean_title": ["fix", "ot", "offset", "offset", "remov", "patch", "bsptree", "bsp", "tree", "fix", "erron", "warn"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed a bug in ot . encode ( ) .. fixed erroneous warning. ", "B_clean_title": ["fix", "bug", "ot", "encod", "fix", "erron", "warn"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed erroneous warning. fixed ot . offset = offset ;. ", "B_clean_title": ["fix", "erron", "warn", "fix", "ot", "offset", "offset"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed scale of OrderedTuple. removed patch from BSPTree. fixed erroneous warning. ", "B_clean_title": ["fix", "scale", "orderedtupl", "order", "tupl", "remov", "patch", "bsptree", "bsp", "tree", "fix", "erron", "warn"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed erroneous warning. fixed old bug. removed unused vars. ", "B_clean_title": ["fix", "erron", "warn", "fix", "old", "bug", "remov", "unus", "var"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed erroneous import. removed unused patch. fixed old bug. fixed erroneous warning. fixed a small bug. Change the ExceptionContext . getMessage ( ) to use the default locale .. Missing final modifier .. ", "B_clean_title": ["fix", "erron", "import", "remov", "unus", "patch", "fix", "old", "bug", "fix", "erron", "warn", "fix", "small", "bug", "chang", "exceptioncontext", "except", "context", "getmessag", "get", "messag", "use", "default", "local", "miss", "final", "modifi"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed unused patch. fixed old bug. fixed erroneous warning. ", "B_clean_title": ["remov", "unus", "patch", "fix", "old", "bug", "fix", "erron", "warn"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed erroneous warning. fixed a bug in ot . encode. removed patch from BSPTree. ", "B_clean_title": ["fix", "erron", "warn", "fix", "bug", "ot", "encod", "remov", "patch", "bsptree", "bsp", "tree"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw. fixed a bug in OrderedTuple. ", "B_clean_title": ["remov", "throw", "fix", "bug", "orderedtupl", "order", "tupl"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "update pending array. removed throw. ", "B_clean_title": ["updat", "pend", "array", "remov", "throw"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw new MathInternalError ( ). Fix swapped inf / inf in OrderedTuple. ", "B_clean_title": ["remov", "throw", "new", "mathinternalerror", "math", "intern", "error", "fix", "swap", "inf", "inf", "orderedtupl", "order", "tupl"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw. BSPTree now uses the modified cut property. ", "B_clean_title": ["remov", "throw", "bsptree", "bsp", "tree", "now", "use", "modifi", "cut", "properti"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed extraneous whitespace. removed throw new MathInternalError ( ). ", "B_clean_title": ["remov", "extran", "whitespac", "remov", "throw", "new", "mathinternalerror", "math", "intern", "error"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "Fix euclidean intersections  added missing patch. Fix swapped offset values in OrderedTuple. removed throw. ", "B_clean_title": ["fix", "euclidean", "intersect", "ad", "miss", "patch", "fix", "swap", "offset", "valu", "orderedtupl", "order", "tupl", "remov", "throw"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "Fix parallel hyperplanes  added patch. removed patch for BSPTree. removed throw. ", "B_clean_title": ["fix", "parallel", "hyperplan", "ad", "patch", "remov", "patch", "bsptree", "bsp", "tree", "remov", "throw"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw. Set exception context to empty string context for now. ", "B_clean_title": ["remov", "throw", "set", "except", "context", "empti", "string", "context", "now"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed patch from BSPTree. removed throw. ", "B_clean_title": ["remov", "patch", "bsptree", "bsp", "tree", "remov", "throw"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw. BSPTree now cuts off - the - minus sign .. ", "B_clean_title": ["remov", "throw", "bsptree", "bsp", "tree", "now", "cut", "off", "minu", "sign"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw. removed patch from BSPTree. ", "B_clean_title": ["remov", "throw", "remov", "patch", "bsptree", "bsp", "tree"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "Add blank line. removed throw new MathInternalError ( ). ", "B_clean_title": ["add", "blank", "line", "remov", "throw", "new", "mathinternalerror", "math", "intern", "error"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw new MathInternalError ( ). fixed a bug in OrderedTuple. ", "B_clean_title": ["remov", "throw", "new", "mathinternalerror", "math", "intern", "error", "fix", "bug", "orderedtupl", "order", "tupl"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed a small bug in OrderedTuple. removed throw. ", "B_clean_title": ["fix", "small", "bug", "orderedtupl", "order", "tupl", "remov", "throw"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "Missing patch for getting message from default locale .. removed throw new MathInternalError ( ). ", "B_clean_title": ["miss", "patch", "get", "messag", "default", "local", "remov", "throw", "new", "mathinternalerror", "math", "intern", "error"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed a bug in OrderedTuple. removed throw. ", "B_clean_title": ["fix", "bug", "orderedtupl", "order", "tupl", "remov", "throw"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "BSPTree no longer links ( cut = null ). removed throw new MathInternalError ( ). ", "B_clean_title": ["bsptree", "bsp", "tree", "no", "longer", "link", "cut", "null", "remov", "throw", "new", "mathinternalerror", "math", "intern", "error"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "Fix Euclidean geometry patch. removed throw new MathInternalError ( ). ", "B_clean_title": ["fix", "euclidean", "geometri", "patch", "remov", "throw", "new", "mathinternalerror", "math", "intern", "error"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "Fix swapped inf / inf in OrderedTuple. removed throw new MathInternalError ( ). ", "B_clean_title": ["fix", "swap", "inf", "inf", "orderedtupl", "order", "tupl", "remov", "throw", "new", "mathinternalerror", "math", "intern", "error"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw. Fixed a typo in code. ", "B_clean_title": ["remov", "throw", "fix", "typo", "code"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw new MathInternalError ( ). Fix swapped offset values in OrderedTuple. ", "B_clean_title": ["remov", "throw", "new", "mathinternalerror", "math", "intern", "error", "fix", "swap", "offset", "valu", "orderedtupl", "order", "tupl"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw. reset parent links. ", "B_clean_title": ["remov", "throw", "reset", "parent", "link"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed patch for BSPTree. fixed a bug in OrderedTuple. removed throw new MathInternalError ( ). ", "B_clean_title": ["remov", "patch", "bsptree", "bsp", "tree", "fix", "bug", "orderedtupl", "order", "tupl", "remov", "throw", "new", "mathinternalerror", "math", "intern", "error"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw new MathInternalError ( ). Fix swapped offset values in OrderedTuple. Revert accidently removed patch .. ", "B_clean_title": ["remov", "throw", "new", "mathinternalerror", "math", "intern", "error", "fix", "swap", "offset", "valu", "orderedtupl", "order", "tupl", "revert", "accid", "remov", "patch"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "BSPTree now uses the same cut value as the others. fixed a small bug in OrderedTuple. removed throw new MathInternalError ( ). ", "B_clean_title": ["bsptree", "bsp", "tree", "now", "use", "same", "cut", "valu", "as", "other", "fix", "small", "bug", "orderedtupl", "order", "tupl", "remov", "throw", "new", "mathinternalerror", "math", "intern", "error"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "Fix swapped offset values in OrderedTuple. removed throw new MathInternalError ( ). ", "B_clean_title": ["fix", "swap", "offset", "valu", "orderedtupl", "order", "tupl", "remov", "throw", "new", "mathinternalerror", "math", "intern", "error"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw. Revert since it was removed as part of a revu 58396 .. ", "B_clean_title": ["remov", "throw", "revert", "sinc", "it", "wa", "remov", "as", "part", "revu", "58396"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw. Fix euclidean intersections  add patch. remove patch. ", "B_clean_title": ["remov", "throw", "fix", "euclidean", "intersect", "add", "patch", "remov", "patch"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "BSPTree now has a null pointer. removed throw. ", "B_clean_title": ["bsptree", "bsp", "tree", "now", "ha", "null", "pointer", "remov", "throw"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "fixed possible NPE in OrderedTuple. removed throw. ", "B_clean_title": ["fix", "possibl", "npe", "orderedtupl", "order", "tupl", "remov", "throw"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw. Fix swapped inf / inf in OrderedTuple. ", "B_clean_title": ["remov", "throw", "fix", "swap", "inf", "inf", "orderedtupl", "order", "tupl"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "Set lsb to Integer . MAX_VALUE for OrderedTuple. removed throw. ", "B_clean_title": ["set", "lsb", "integ", "max", "valu", "orderedtupl", "order", "tupl", "remov", "throw"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw. removed patch from BSPTree. ", "B_clean_title": ["remov", "throw", "remov", "patch", "bsptree", "bsp", "tree"]},
{"A_title": "Constructor of PolyhedronsSet throws NullPointerExceptionThe following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d 0.0d 0.0d 0.0d 0.0d 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)", "A_clean_title": ["constructor", "polyhedronsset", "polyhedron", "set", "throw", "nullpointerexceptionth", "null", "pointer", "except", "follow", "statement", "throw", "nullpointerexcept", "null", "pointer", "except", "new", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "0d", "0d", "0d", "0d", "0d", "0d", "found", "that", "other", "number", "also", "produc", "that", "effect", "stack", "trace", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "fittocel", "bsp", "tree", "fit", "cell", "bsptree", "java:297", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "bsptree", "insertcut", "bsp", "tree", "insert", "cut", "bsptree", "java:155", "bsp", "tree", "at", "org", "apach", "common", "math3", "geometri", "partit", "regionfactori", "buildconvex", "region", "factori", "build", "convex", "regionfactori", "java:55", "region", "factori", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "buildboundari", "polyhedron", "set", "build", "boundari", "polyhedronsset", "java:119", "polyhedron", "set", "at", "org", "apach", "common", "math3", "geometri", "euclidean", "threed", "polyhedronsset", "polyhedron", "set", "init", "polyhedronsset", "java:97", "polyhedron", "set"], "B_title": "removed throw new MathInternalError ( ). Reset inf / negInf after first try. ", "B_clean_title": ["remov", "throw", "new", "mathinternalerror", "math", "intern", "error", "reset", "inf", "neginf", "neg", "inf", "after", "first", "tri"]},
{"A_title": "numerical problems in rotation creationbuilding a rotation from the following vector pairs leads to NaN: u1 = -4921140.837095533 -2.1512094250440013E7 -890093.279426377 u2 = -2.7238580938724895E9 -2.169664921341876E9 6.749688708885301E10 v1 = 1 0 0 v2 = 0 0 1 The constructor first changes the (v1 v2) pair into (v1 v2) ensuring the following scalar products hold:  <v1|v1> == <u1|u1>  <v2|v2> == <u2|u2>  <u1 |u2>  == <v1|v2> Once the (v1 v2) pair has been computed we compute the cross product:   k = (v1 - u1)^(v2 - u2) and the scalar product:   c = <k | (u1^u2)> By construction c is positive or null and the quaternion axis we want to build is q = k/2*sqrt(c). c should be null only if some of the vectors are aligned and this is dealt with later in the algorithm. However there are numerical problems with the vector above with the way these computations are done as shown by the following comparisons showing the result we get from our Java code and the result we get from manual computation with the same formulas but with enhanced precision: commons math:   k = 38514476.5            -84.                           -1168590144 high precision: k = 38514410.36093388...  -0.374075245201180409222711... -1168590152.10599715208... and it becomes worse when computing c because the vectors are almost orthogonal to each other hence inducing additional cancellations. We get: commons math    c = -1.2397173627587605E20 high precision: c =  558382746168463196.7079627... We have lost ALL significant digits in cancellations and even the sign is wrong!", "A_clean_title": ["numer", "problem", "rotat", "creationbuild", "rotat", "follow", "vector", "pair", "lead", "nan", "na", "u1", "4921140", "837095533", "1512094250440013e7", "890093", "279426377", "u2", "7238580938724895e9", "169664921341876e9", "749688708885301e10", "v1", "v2", "constructor", "first", "chang", "v1", "v2", "pair", "into", "v1", "v2", "ensur", "follow", "scalar", "product", "hold", "v1|v1", "u1|u1", "v2|v2", "u2|u2", "u1", "|u2", "v1|v2", "onc", "v1", "v2", "pair", "ha", "been", "comput", "we", "comput", "cross", "product", "v1", "u1", "v2", "u2", "scalar", "product", "u1^u2", "by", "construct", "posit", "or", "null", "quaternion", "axi", "we", "want", "build", "sqrt", "null", "onli", "some", "vector", "are", "align", "thi", "dealt", "later", "algorithm", "howev", "there", "are", "numer", "problem", "vector", "abov", "way", "these", "comput", "are", "done", "as", "shown", "by", "follow", "comparison", "show", "result", "we", "get", "our", "java", "code", "result", "we", "get", "manual", "comput", "same", "formula", "but", "enhanc", "precis", "common", "math", "38514476", "84", "1168590144", "high", "precis", "38514410", "36093388", "374075245201180409222711", "1168590152", "10599715208", "it", "becom", "wors", "when", "comput", "becaus", "vector", "are", "almost", "orthogon", "each", "other", "henc", "induc", "addit", "cancel", "we", "get", "common", "math", "2397173627587605e20", "high", "precis", "558382746168463196", "7079627", "we", "have", "lost", "all", "signific", "digit", "cancel", "even", "sign", "wrong"], "B_title": "Fixed a bug in the cross product test. ", "B_clean_title": ["fix", "bug", "cross", "product", "test"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction . greatestCommonDivisor ( ). ", "B_clean_title": ["fix", "fraction", "greatestcommondivisor", "greatest", "common", "divisor"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction . greatestCommonDivisor ( ). ", "B_clean_title": ["fix", "fraction", "greatestcommondivisor", "greatest", "common", "divisor"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix greatestCommonDivisor from Lee Butts. ", "B_clean_title": ["fix", "greatestcommondivisor", "greatest", "common", "divisor", "lee", "butt"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction . greatestCommonDivisor ( ). ", "B_clean_title": ["fix", "fraction", "greatestcommondivisor", "greatest", "common", "divisor"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction . greatestCommonDivisor ( ). ", "B_clean_title": ["fix", "fraction", "greatestcommondivisor", "greatest", "common", "divisor"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction . greatestCommonDivisor ( ). ", "B_clean_title": ["fix", "fraction", "greatestcommondivisor", "greatest", "common", "divisor"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix greatestCommonDivisor result. ", "B_clean_title": ["fix", "greatestcommondivisor", "greatest", "common", "divisor", "result"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix false alarm in JKali patch. ", "B_clean_title": ["fix", "fals", "alarm", "jkali", "kali", "patch"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix a bug in JMutRepair where abs ( u ) > v. ", "B_clean_title": ["fix", "bug", "jmutrepair", "mut", "repair", "where", "ab"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix # 1796. remove patch for 1 . 7 . 0 - > 1 . 7 . 0. ", "B_clean_title": ["fix", "1796", "remov", "patch"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix greatestCommonDivisor patch. Fix string comparison in Fraction . equals ( ). ", "B_clean_title": ["fix", "greatestcommondivisor", "greatest", "common", "divisor", "patch", "fix", "string", "comparison", "fraction", "equal"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "remove patch for 1 . 6. Fix string comparison between 0 . 1 and 1 . 2. ", "B_clean_title": ["remov", "patch", "fix", "string", "comparison", "between"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "fix a numeric equality bug in Fraction. remove patch for 1 . 6. ", "B_clean_title": ["fix", "numer", "equal", "bug", "fraction", "remov", "patch"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "remove 582  as it is not applicable. fixed a small bug. ", "B_clean_title": ["remov", "582", "as", "it", "not", "applic", "fix", "small", "bug"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Add missing toProperString. remove 583  as it is not maintained by OpenJDK .. ", "B_clean_title": ["add", "miss", "toproperstr", "proper", "string", "remov", "583", "as", "it", "not", "maintain", "by", "openjdk", "open", "jdk"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction patch. Fix string comparison in Fraction . equals ( ). ", "B_clean_title": ["fix", "fraction", "patch", "fix", "string", "comparison", "fraction", "equal"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Add missing toProperString. Fix accidental conversion of inf to int. ", "B_clean_title": ["add", "miss", "toproperstr", "proper", "string", "fix", "accident", "convers", "inf", "int"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Remove redundant patch. gh - 66 fixed a small bug. fix missing timestamp in MockTable. ", "B_clean_title": ["remov", "redund", "patch", "gh", "66", "fix", "small", "bug", "fix", "miss", "timestamp", "mocktabl", "mock", "tabl"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix MockTable count in compareTo. ", "B_clean_title": ["fix", "mocktabl", "mock", "tabl", "count", "compareto", "compar"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix MockTable count in compareTo. ", "B_clean_title": ["fix", "mocktabl", "mock", "tabl", "count", "compareto", "compar"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix JAR compareTo .. remove erroneous check for table name. ", "B_clean_title": ["fix", "jar", "compareto", "compar", "remov", "erron", "check", "tabl", "name"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Remove erroneous check for table name. gh - 66 fixed a small bug. Remove redundant patch. ", "B_clean_title": ["remov", "erron", "check", "tabl", "name", "gh", "66", "fix", "small", "bug", "remov", "redund", "patch"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. remove patched file. remove erroneous check for table name. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "remov", "patch", "file", "remov", "erron", "check", "tabl", "name"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "remove erroneous line. gh - 66 fixed a small bug. ", "B_clean_title": ["remov", "erron", "line", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix put ( ) method. gh - 66 fixed a small bug. Remove erroneous check for table name. remove erroneous check for table name. ", "B_clean_title": ["fix", "put", "method", "gh", "66", "fix", "small", "bug", "remov", "erron", "check", "tabl", "name", "remov", "erron", "check", "tabl", "name"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. Remove erroneous check for table name. Fix put ( ) method. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "remov", "erron", "check", "tabl", "name", "fix", "put", "method"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix columulo index update patch. Fix MockTable compareTo. ", "B_clean_title": ["fix", "columulo", "index", "updat", "patch", "fix", "mocktabl", "mock", "tabl", "compareto", "compar"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed case with datanucleus scan. remove patch for now. ", "B_clean_title": ["gh", "66", "fix", "case", "datanucleu", "scan", "remov", "patch", "now"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "remove erroneous check for table name. gh - 66 fixed a small bug. Fix put ( ). ", "B_clean_title": ["remov", "erron", "check", "tabl", "name", "gh", "66", "fix", "small", "bug", "fix", "put"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "remove patch. gh - 66 fixed a small bug. Fix column visibility for collapsed scans. ", "B_clean_title": ["remov", "patch", "gh", "66", "fix", "small", "bug", "fix", "column", "visibl", "collaps", "scan"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. Fix columulo index update patch. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "fix", "columulo", "index", "updat", "patch"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix an issue with MockStoreTest . compareTo ( Key ). ", "B_clean_title": ["fix", "issu", "mockstoretest", "mock", "store", "test", "compareto", "compar", "key"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Remove erroneous check for tableName. remove erroneous check for table name. gh - 66 fixed a small bug. ", "B_clean_title": ["remov", "erron", "check", "tablenam", "tabl", "name", "remov", "erron", "check", "tabl", "name", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "remove erroneous check for table name. gh - 66 fixed a small bug. ", "B_clean_title": ["remov", "erron", "check", "tabl", "name", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix ant build break. ", "B_clean_title": ["fix", "ant", "build", "break"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix put ( ). Fix ant build break. ", "B_clean_title": ["fix", "put", "fix", "ant", "build", "break"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix an issue with MockStoreTest . compareTo ( Key ). Fix put ( ). ", "B_clean_title": ["fix", "issu", "mockstoretest", "mock", "store", "test", "compareto", "compar", "key", "fix", "put"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix put ( ). gh - 66 fixed a small bug. ", "B_clean_title": ["fix", "put", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "remove erroneous line. gh - 66 fixed a small bug. ", "B_clean_title": ["remov", "erron", "line", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. remove erroneous check for table name. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "remov", "erron", "check", "tabl", "name"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix MockTable age. ", "B_clean_title": ["fix", "mocktabl", "mock", "tabl", "age"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. gh - 66 - fixed opengl error. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "gh", "66", "fix", "opengl", "error"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. remove patch for columulo column update. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "remov", "patch", "columulo", "column", "updat"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. gh - 66 fixed opengl error. gh - 66 fixed case with datanucleus scan. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "gh", "66", "fix", "opengl", "error", "gh", "66", "fix", "case", "datanucleu", "scan"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Remove erroneous check for table name. Fix put ( ). remove erroneous line. gh - 66 fixed a small bug. fix missing timestamp in MockTable . put ( ). ", "B_clean_title": ["remov", "erron", "check", "tabl", "name", "fix", "put", "remov", "erron", "line", "gh", "66", "fix", "small", "bug", "fix", "miss", "timestamp", "mocktabl", "mock", "tabl", "put"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "remove erroneous check for table name. gh - 66 fixed a small bug. gh - 66 fixed opengl error. ", "B_clean_title": ["remov", "erron", "check", "tabl", "name", "gh", "66", "fix", "small", "bug", "gh", "66", "fix", "opengl", "error"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. ", "B_clean_title": ["gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix columulo columulo patch .. fix broken patch. ", "B_clean_title": ["fix", "columulo", "columulo", "patch", "fix", "broken", "patch"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "remove erroneous check for table name. gh - 66 fixed a small bug. ", "B_clean_title": ["remov", "erron", "check", "tabl", "name", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. gh - 66 - fixed opengl error. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "gh", "66", "fix", "opengl", "error"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix collocation in MockTable . compareTo ( Key ). gh - 66 fixed opengl mistake. ", "B_clean_title": ["fix", "colloc", "mocktabl", "mock", "tabl", "compareto", "compar", "key", "gh", "66", "fix", "opengl", "mistak"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix columulo columulo patch. remove patch for now. Remove erroneous check for table name. ", "B_clean_title": ["fix", "columulo", "columulo", "patch", "remov", "patch", "now", "remov", "erron", "check", "tabl", "name"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. gh - 66 fixed opengl error. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "gh", "66", "fix", "opengl", "error"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. Fix put ( ) method. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "fix", "put", "method"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix put ( ). gh - 66 fixed a small bug. ", "B_clean_title": ["fix", "put", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. remove erroneous line. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "remov", "erron", "line"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "remove patched addMutation. ", "B_clean_title": ["remov", "patch", "addmut", "add", "mutat"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix an issue with MockStoreTest . compareTo ( Key ). remove erroneous line. ", "B_clean_title": ["fix", "issu", "mockstoretest", "mock", "store", "test", "compareto", "compar", "key", "remov", "erron", "line"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. fix missing timestamp in MockTable . put ( ). remove erroneous check for table name. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "fix", "miss", "timestamp", "mocktabl", "mock", "tabl", "put", "remov", "erron", "check", "tabl", "name"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. gh - 66 - fixed opengl mistake. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "gh", "66", "fix", "opengl", "mistak"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix ant build break. gh - 66 fixed opengl error. ", "B_clean_title": ["fix", "ant", "build", "break", "gh", "66", "fix", "opengl", "error"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix data file. fix broken patch. ", "B_clean_title": ["fix", "data", "file", "fix", "broken", "patch"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed case with MockConnector. gh - 66 fixed a small bug. ", "B_clean_title": ["gh", "66", "fix", "case", "mockconnector", "mock", "connector", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. remove patch. remove erroneous check for table name. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "remov", "patch", "remov", "erron", "check", "tabl", "name"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix put ( ) method. Fix columulo index update patch. remove erroneous check for table name. gh - 66 fixed a small bug. ", "B_clean_title": ["fix", "put", "method", "fix", "columulo", "index", "updat", "patch", "remov", "erron", "check", "tabl", "name", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a slight problem. gh - 66 fixed a small bug. ", "B_clean_title": ["gh", "66", "fix", "slight", "problem", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. Fix put patch. Fix put ( ). ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "fix", "put", "patch", "fix", "put"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. ", "B_clean_title": ["gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. ", "B_clean_title": ["gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. gh - 66 - Updated patch for CASSANDRA - 51. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "gh", "66", "updat", "patch", "cassandra", "51"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. gh - 66 - Updated patch for CASSANDRA - 51. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "gh", "66", "updat", "patch", "cassandra", "51"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Remove erroneous check for tableName. gh - 66 fixed a small bug. ", "B_clean_title": ["remov", "erron", "check", "tablenam", "tabl", "name", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix put patch. gh - 66 fixed a small bug. ", "B_clean_title": ["fix", "put", "patch", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Remove erroneous check for tableName. gh - 66 fixed a small bug. ", "B_clean_title": ["remov", "erron", "check", "tablenam", "tabl", "name", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. gh - 66 fixed opengl error. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "gh", "66", "fix", "opengl", "error"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. gh - 66 - fixed opengl error. Remove erroneous check for tableName. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "gh", "66", "fix", "opengl", "error", "remov", "erron", "check", "tablenam", "tabl", "name"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "remove erroneous line. gh - 66 fixed a small bug. Fix put ( ). ", "B_clean_title": ["remov", "erron", "line", "gh", "66", "fix", "small", "bug", "fix", "put"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. gh - 66 fixed opengl mistake. Remove erroneous check for tableName. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "gh", "66", "fix", "opengl", "mistak", "remov", "erron", "check", "tablenam", "tabl", "name"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix put ( ). fix broken patch. ", "B_clean_title": ["fix", "put", "fix", "broken", "patch"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 removed patch to fix failing test. remove patch for now. ", "B_clean_title": ["gh", "66", "remov", "patch", "fix", "fail", "test", "remov", "patch", "now"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. remove patch for 1 . 5476a0d. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "remov", "patch", "5476a0d"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix MockTable compareTo. gh - 66 fixed case with MockConnector. ", "B_clean_title": ["fix", "mocktabl", "mock", "tabl", "compareto", "compar", "gh", "66", "fix", "case", "mockconnector", "mock", "connector"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "fix merge conflict count bug. ", "B_clean_title": ["fix", "merg", "conflict", "count", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "remove erroneous check for table name. gh - 66 fixed a small bug. remove erroneous line. ", "B_clean_title": ["remov", "erron", "check", "tabl", "name", "gh", "66", "fix", "small", "bug", "remov", "erron", "line"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "remove erroneous check for table name. Fix MockTable compareTo. ", "B_clean_title": ["remov", "erron", "check", "tabl", "name", "fix", "mocktabl", "mock", "tabl", "compareto", "compar"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. gh - 66 fixed a small bug. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "gh", "66", "fix", "small", "bug"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix MockTable compareTo. ", "B_clean_title": ["fix", "mocktabl", "mock", "tabl", "compareto", "compar"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. fix missing timestamp in MockTable. ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "fix", "miss", "timestamp", "mocktabl", "mock", "tabl"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Fix an issue with MockStoreTest . compareTo ( Key ). Remove erroneous check for tableName. remove erroneous check for table name. ", "B_clean_title": ["fix", "issu", "mockstoretest", "mock", "store", "test", "compareto", "compar", "key", "remov", "erron", "check", "tablenam", "tabl", "name", "remov", "erron", "check", "tabl", "name"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 66 fixed a small bug. gh - 66 - fixed opengl error. Fix put ( ). ", "B_clean_title": ["gh", "66", "fix", "small", "bug", "gh", "66", "fix", "opengl", "error", "fix", "put"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "gh - 454 - added missing throw. gh - 66 fixed a small bug. gh - 66 - fixed opengl error. ", "B_clean_title": ["gh", "454", "ad", "miss", "throw", "gh", "66", "fix", "small", "bug", "gh", "66", "fix", "opengl", "error"]},
{"A_title": "RegExFilter deepCopy NullPointerExceptionIf any of the regex matcher objects are null (i.e. for example if you only specify a regex for the column family) the deepCopy call will throw a NullPointerException.", "A_clean_title": ["regexfilt", "reg", "ex", "filter", "deepcopi", "deep", "copi", "nullpointerexceptionif", "null", "pointer", "except", "ani", "regex", "matcher", "object", "are", "null", "exampl", "you", "onli", "specifi", "regex", "column", "famili", "deepcopi", "deep", "copi", "call", "will", "throw", "nullpointerexcept", "null", "pointer", "except"], "B_title": "add return. ", "B_clean_title": ["add", "return"]},
{"A_title": "Constructor types that return all or unknown fail to parseNone", "A_clean_title": ["constructor", "type", "that", "return", "all", "or", "unknown", "fail", "parsenon", "pars", "none"], "B_title": "Add parseAndRecordTypeNode to the parseContextTypeExpression method in JsDocInfoParser. ", "B_clean_title": ["add", "parseandrecordtypenod", "pars", "record", "type", "node", "parsecontexttypeexpress", "pars", "context", "type", "express", "method", "jsdocinfopars", "js", "doc", "info", "parser"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add 5 more space for appendFixedWidthPadRight ( ). ", "B_clean_title": ["add", "more", "space", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add 5 elements for appendFixedWidthPadRight ( ). ", "B_clean_title": ["strbuilder", "str", "builder", "add", "element", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add some space .. ", "B_clean_title": ["add", "some", "space"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added more ensureCapacity. ", "B_clean_title": ["ad", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add more space for appendFixedWidthPadRight ( ). ", "B_clean_title": ["strbuilder", "str", "builder", "add", "more", "space", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add 4 + 4 space for appendFixedWidthPadRight ( ). ", "B_clean_title": ["add", "space", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added more ensureCapacity. ", "B_clean_title": ["ad", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add 4 + 4 ensureCapacity ( ). ", "B_clean_title": ["add", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added ensureCapacity ( ) for string builder. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add 4 + 4 entries for appendFixedWidthPadRight ( ). ", "B_clean_title": ["strbuilder", "str", "builder", "add", "entri", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add some space for StringBuilder . appendFixedWidthPadRight ( ). ", "B_clean_title": ["add", "some", "space", "stringbuild", "string", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 +. ", "B_clean_title": ["strbuilder", "str", "builder", "add"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added ensureCapacity ( ) for string builder. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add the right padding right .. ", "B_clean_title": ["strbuilder", "str", "builder", "add", "right", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add padChar + width if object is null. ", "B_clean_title": ["strbuilder", "str", "builder", "add", "padchar", "pad", "char", "width", "object", "null"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder copy ( ) . ", "B_clean_title": ["strbuilder", "str", "builder", "copi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder ( ) uses char instead of char   for the char array .. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "char", "instead", "char", "char", "array"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) needs buffer .. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "need", "buffer"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add more ensureCapacity ( ) for string builder. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add 4 more ensureCapacity .. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add more ensureCapacity .. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 +. ", "B_clean_title": ["strbuilder", "str", "builder", "add"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add 4 spaces for appendFixedWidthPadRight ( ). ", "B_clean_title": ["strbuilder", "str", "builder", "add", "space", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder ( ) uses char instead of char .. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "char", "instead", "char"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) will reset the array. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "will", "reset", "array"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "add missing backslash. ", "B_clean_title": ["add", "miss", "backslash"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses CAPACITY rather than arrayCopy. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "capac", "rather", "than", "arraycopi", "array", "copi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity .. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix null string handling. ", "B_clean_title": ["fix", "null", "string", "handl"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added ensureCapacity ( size + 1 ) for appendFixedWidthPadRight. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "size", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) uses new array constructor. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "new", "array", "constructor"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) now uses char  as the indexing array is. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "now", "use", "char", "as", "index", "array"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses char instead of char because it is not compatible. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "char", "instead", "char", "becaus", "it", "not", "compat"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity ( ) call. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac", "call"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t create arrayCopy ( ) .. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "creat", "arraycopi", "array", "copi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder patched ( changed ). ", "B_clean_title": ["strbuilder", "str", "builder", "patch", "chang"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build .. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should fix the build. ", "B_clean_title": ["strbuilder", "str", "builder", "fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add empty buffer for appendFixedWidthPadRight. ", "B_clean_title": ["add", "empti", "buffer", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix an issue with the appendFixedWidthPadRight method where the object is null .. ", "B_clean_title": ["fix", "issu", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "method", "where", "object", "null"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added expanded array structure. ", "B_clean_title": ["ad", "expand", "array", "structur"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should reset the StringBuilder and not use the array when creating the string. ", "B_clean_title": ["strbuilder", "str", "builder", "reset", "stringbuild", "string", "builder", "not", "use", "array", "when", "creat", "string"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText field. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "field"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses empty array for easier building. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "empti", "array", "easier", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Reset nullText if we have text .. ", "B_clean_title": ["reset", "nulltext", "null", "text", "we", "have", "text"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix an issue with null string builders .. ", "B_clean_title": ["fix", "issu", "null", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses new array constructor. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "new", "array", "constructor"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix nullText setting .. ", "B_clean_title": ["fix", "nulltext", "null", "text", "set"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses char  instead of char   for the append of. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "char", "instead", "char", "append"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix null string handling. ", "B_clean_title": ["fix", "null", "string", "handl"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Reset line endings. ", "B_clean_title": ["reset", "line", "end"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix NPE in StrBuilder . appendFixedWidthPadRight. ", "B_clean_title": ["fix", "npe", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText properly. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "properli"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add more ensureCapacity .. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add empty array if we can  t append string with spaces .. ", "B_clean_title": ["add", "empti", "array", "we", "append", "string", "space"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText properly. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "properli"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should fix the build. ", "B_clean_title": ["strbuilder", "str", "builder", "fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add null check in StrBuilder. ", "B_clean_title": ["add", "null", "check", "strbuilder", "str", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix null string handling. ", "B_clean_title": ["fix", "null", "string", "handl"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) uses new char   not nullText. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "new", "char", "not", "nulltext", "null", "text"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should fix the build. ", "B_clean_title": ["strbuilder", "str", "builder", "fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add 4 more ensureCapacity .. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText properly. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "properli"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set the nullText field. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "field"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should use a char array initially. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "char", "array", "initi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should use a char array initially. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "char", "array", "initi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity ( ) call. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac", "call"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses buffer . length - > string . length. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "buffer", "length", "string", "length"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set the nullText field. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "field"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix buffer issue. ", "B_clean_title": ["fix", "buffer", "issu"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText field. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "field"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix ensureCapacity ( ) for string builders. ", "B_clean_title": ["fix", "ensurecapac", "ensur", "capac", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses a char array initially. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "char", "array", "initi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity .. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t overwrite existing buffer .. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "overwrit", "exist", "buffer"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText properly. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "properli"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses new array constructor. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "new", "array", "constructor"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder patched ( initially empty ). ", "B_clean_title": ["strbuilder", "str", "builder", "patch", "initi", "empti"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses stringBuilder  but string is not expanding the buffer ;. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "stringbuild", "string", "builder", "but", "string", "not", "expand", "buffer"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder patched ( initially empty ). ", "B_clean_title": ["strbuilder", "str", "builder", "patch", "initi", "empti"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add more space for string builders. ", "B_clean_title": ["add", "more", "space", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should reset the array if we add null text  otherwise it will throw an NPE. ", "B_clean_title": ["strbuilder", "str", "builder", "reset", "array", "we", "add", "null", "text", "otherwis", "it", "will", "throw", "npe"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should use the newLine setting for each builder object. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "newlin", "new", "line", "set", "each", "builder", "object"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add null string if possible. ", "B_clean_title": ["add", "null", "string", "possibl"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity ( ) call. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac", "call"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix lost ensureCapacity .. ", "B_clean_title": ["fix", "lost", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the bug in StrBuilder . appendFixedWidthPadRight. ", "B_clean_title": ["fix", "bug", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "ConvergenceException in NormalDistributionImpl.cumulativeProbability()I get a ConvergenceException in  NormalDistributionImpl.cumulativeProbability() for very large/small parameters including Infinity -Infinity. For instance in the following code: @Test public void testCumulative()  final NormalDistribution nd = new NormalDistributionImpl(); for (int i = 0; i < 500; i++)  final double val = Math.exp; try   System.out.println(val =  + val +  cumulative =  + nd.cumulativeProbability(val));   catch (MathException e)   e.printStackTrace(); fail();    In version 2.0 I get no exception.  My suggestion is to change in the implementation of cumulativeProbability(double) to catch all ConvergenceException (and return for very large and very small values) not just MaxIterationsExceededException.", "A_clean_title": ["convergenceexcept", "converg", "except", "normaldistributionimpl", "cumulativeprob", "normal", "distribut", "impl", "cumul", "probabl", "get", "convergenceexcept", "converg", "except", "normaldistributionimpl", "cumulativeprob", "normal", "distribut", "impl", "cumul", "probabl", "veri", "larg", "small", "paramet", "includ", "infin", "infin", "instanc", "follow", "code", "test", "public", "void", "testcumul", "test", "cumul", "final", "normaldistribut", "normal", "distribut", "nd", "new", "normaldistributionimpl", "normal", "distribut", "impl", "int", "500", "i++", "final", "doubl", "val", "math", "exp", "tri", "system", "out", "println", "val", "val", "cumul", "nd", "cumulativeprob", "cumul", "probabl", "val", "catch", "mathexcept", "math", "except", "printstacktrac", "print", "stack", "trace", "fail", "version", "get", "no", "except", "my", "suggest", "chang", "implement", "cumulativeprob", "cumul", "probabl", "doubl", "catch", "all", "convergenceexcept", "converg", "except", "return", "veri", "larg", "veri", "small", "valu", "not", "just", "maxiterationsexceededexcept", "max", "iter", "exceed", "except"], "B_title": "BUGS. Missing return from convergedFraction method. ", "B_clean_title": ["bug", "miss", "return", "convergedfract", "converg", "fraction", "method"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Fix minor bug in SimplexSolver . compareTo ( double  double  double  double ) .. Added minRatioPositions . size ( ) == 0 ? null : minRatioPositions. ", "B_clean_title": ["fix", "minor", "bug", "simplexsolv", "simplex", "solver", "compareto", "compar", "doubl", "doubl", "doubl", "doubl", "ad", "minratioposit", "min", "ratio", "posit", "size", "null", "minratioposit", "min", "ratio", "posit"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "remove column to drop from list of columns to avoid duplicates. ", "B_clean_title": ["remov", "column", "drop", "list", "column", "avoid", "duplic"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Added a test to see if the dataset is not sufficiently large and not too large .. ", "B_clean_title": ["ad", "test", "see", "dataset", "not", "suffici", "larg", "not", "too", "larg"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Add missing column to drop from tableau if it is too large. ", "B_clean_title": ["add", "miss", "column", "drop", "tableau", "it", "too", "larg"]},
{"A_title": "ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.A semicolon is introduced into the class name at the end for all arrays... String sArray = new String2; sArray0 = mark; sArray1 = is cool; String simpleString = chris; assertEquals(String ClassUtils.getShortClassName(simpleString null)); assertEquals(String; ClassUtils.getShortClassName(sArray null));", "A_clean_title": ["classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "will", "not", "work", "array", "it", "seem", "add", "semicolon", "end", "semicolon", "introduc", "into", "class", "name", "at", "end", "all", "array", "string", "sarray", "array", "new", "string2", "sarray0", "array0", "mark", "sarray1", "array1", "cool", "string", "simplestr", "simpl", "string", "chri", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "simplestr", "simpl", "string", "null", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "sarray", "array", "null"], "B_title": "@@ changed to use packageCanonicalName instead of getPackageName ( ) for inner class access. make ClassUtils . getShortCanonicalName static. ", "B_clean_title": ["chang", "use", "packagecanonicalnam", "packag", "canon", "name", "instead", "getpackagenam", "get", "packag", "name", "inner", "class", "access", "make", "classutil", "class", "util", "getshortcanonicalnam", "get", "short", "canon", "name", "static"]},
{"A_title": "ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.A semicolon is introduced into the class name at the end for all arrays... String sArray = new String2; sArray0 = mark; sArray1 = is cool; String simpleString = chris; assertEquals(String ClassUtils.getShortClassName(simpleString null)); assertEquals(String; ClassUtils.getShortClassName(sArray null));", "A_clean_title": ["classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "will", "not", "work", "array", "it", "seem", "add", "semicolon", "end", "semicolon", "introduc", "into", "class", "name", "at", "end", "all", "array", "string", "sarray", "array", "new", "string2", "sarray0", "array0", "mark", "sarray1", "array1", "cool", "string", "simplestr", "simpl", "string", "chri", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "simplestr", "simpl", "string", "null", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "sarray", "array", "null"], "B_title": "Fix ClassUtils # getShortClassName ( ). ", "B_clean_title": ["fix", "classutil", "class", "util", "getshortclassnam", "get", "short", "class", "name"]},
{"A_title": "ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.A semicolon is introduced into the class name at the end for all arrays... String sArray = new String2; sArray0 = mark; sArray1 = is cool; String simpleString = chris; assertEquals(String ClassUtils.getShortClassName(simpleString null)); assertEquals(String; ClassUtils.getShortClassName(sArray null));", "A_clean_title": ["classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "will", "not", "work", "array", "it", "seem", "add", "semicolon", "end", "semicolon", "introduc", "into", "class", "name", "at", "end", "all", "array", "string", "sarray", "array", "new", "string2", "sarray0", "array0", "mark", "sarray1", "array1", "cool", "string", "simplestr", "simpl", "string", "chri", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "simplestr", "simpl", "string", "null", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "sarray", "array", "null"], "B_title": "make ClassUtils . getShortCanonicalName work for 1 . 7. made ClassUtils . getPackageCanonicalName a little easier to resolve. ", "B_clean_title": ["make", "classutil", "class", "util", "getshortcanonicalnam", "get", "short", "canon", "name", "work", "made", "classutil", "class", "util", "getpackagecanonicalnam", "get", "packag", "canon", "name", "littl", "easier", "resolv"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a bug in the lineToFrontBall method .. ", "B_clean_title": ["fix", "bug", "linetofrontbal", "line", "front", "ball", "method"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Delete some unused code. fix merge issue. ", "B_clean_title": ["delet", "some", "unus", "code", "fix", "merg", "issu"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Delete unsed check for inner ball. fix merge issue. ", "B_clean_title": ["delet", "uns", "check", "inner", "ball", "fix", "merg", "issu"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a bug in the lineToFrontBall method  too .. removed extraneous whitespace. Save EnclosingBall in case of max distance from the point .. Ignore patterns added by accident. ", "B_clean_title": ["fix", "bug", "linetofrontbal", "line", "front", "ball", "method", "too", "remov", "extran", "whitespac", "save", "enclosingbal", "enclos", "ball", "case", "max", "distanc", "point", "ignor", "pattern", "ad", "by", "accid"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix NPE in JDK7. removed extraneous whitespace. ", "B_clean_title": ["fix", "npe", "jdk7", "remov", "extran", "whitespac"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Delete some unused code. removed NPE from extremes. ", "B_clean_title": ["delet", "some", "unus", "code", "remov", "npe", "extrem"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Added extreme . add ( points . get ( 0 ) ) to ball .. Delete some unused code. moving EnclosingBall to the front of the list. added support list. ", "B_clean_title": ["ad", "extrem", "add", "point", "get", "ball", "delet", "some", "unus", "code", "move", "enclosingbal", "enclos", "ball", "front", "list", "ad", "support", "list"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Delete some debug code. ", "B_clean_title": ["delet", "some", "debug", "code"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Add the missing localization message. Fix a bug in the lineToFrontBall method where the ball was not centered. removed patch from extreme . set ( 0  pi ). Save saved ball in case of closer bug. ", "B_clean_title": ["add", "miss", "local", "messag", "fix", "bug", "linetofrontbal", "line", "front", "ball", "method", "where", "ball", "wa", "not", "center", "remov", "patch", "extrem", "set", "pi", "save", "save", "ball", "case", "closer", "bug"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Delete unsed check. fixed E3E. fixed ExceptionContext . getLocalizedMessage ( ). ", "B_clean_title": ["delet", "uns", "check", "fix", "e3e", "fix", "exceptioncontext", "except", "context", "getlocalizedmessag", "get", "local", "messag"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix merge conflict in MathIllegalStateException. Delete some unused code. Fix Rearranger - fix. ", "B_clean_title": ["fix", "merg", "conflict", "mathillegalstateexcept", "math", "illeg", "state", "except", "delet", "some", "unus", "code", "fix", "rearrang", "fix"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a bug in the lineToFrontBall method where the ball is not restricted to the very. ", "B_clean_title": ["fix", "bug", "linetofrontbal", "line", "front", "ball", "method", "where", "ball", "not", "restrict", "veri"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a bug in the lineToFrontBall method where the ball is not restricted to the far. removed patch from extremes. Save saved ball in g7c9a9. Add the missing localization message. Ignore patterns added by accident. ", "B_clean_title": ["fix", "bug", "linetofrontbal", "line", "front", "ball", "method", "where", "ball", "not", "restrict", "far", "remov", "patch", "extrem", "save", "save", "ball", "g7c9a9", "add", "miss", "local", "messag", "ignor", "pattern", "ad", "by", "accid"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed patch. Fix EvilSeph  s patch. ", "B_clean_title": ["remov", "patch", "fix", "evilseph", "evil", "seph", "patch"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a bug in the support ArrayList. ", "B_clean_title": ["fix", "bug", "support", "arraylist", "array", "list"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed patch from code. Fix EvilSeph  s patch. ", "B_clean_title": ["remov", "patch", "code", "fix", "evilseph", "evil", "seph", "patch"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a bug in the lineToFrontBall method .. Improve cleanup of ExceptionContext . format ( Object  String  boolean  boolean ). ", "B_clean_title": ["fix", "bug", "linetofrontbal", "line", "front", "ball", "method", "improv", "cleanup", "exceptioncontext", "except", "context", "format", "object", "string", "boolean", "boolean"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a bug in the lineToFrontBall method where the ball is not restricted to the very. removed patch from extremes. Save saved ball in g7c9a9. Add the missing localization message. Ignore patterns added by accident. ", "B_clean_title": ["fix", "bug", "linetofrontbal", "line", "front", "ball", "method", "where", "ball", "not", "restrict", "veri", "remov", "patch", "extrem", "save", "save", "ball", "g7c9a9", "add", "miss", "local", "messag", "ignor", "pattern", "ad", "by", "accid"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Added extreme . add ( points . get ( 0 ) ) to ball .. Delete some unused code. moving extreme ball to the front. added support list. ", "B_clean_title": ["ad", "extrem", "add", "point", "get", "ball", "delet", "some", "unus", "code", "move", "extrem", "ball", "front", "ad", "support", "list"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Add the missing localization message. Fix a bug in the lineToFrontBall method where the ball is not restricted to the far. removed patch for GROOVY - 816. Save EnclosingBall in case of max distance from the point .. ", "B_clean_title": ["add", "miss", "local", "messag", "fix", "bug", "linetofrontbal", "line", "front", "ball", "method", "where", "ball", "not", "restrict", "far", "remov", "patch", "groovi", "816", "save", "enclosingbal", "enclos", "ball", "case", "max", "distanc", "point"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix NPE in JDK9. Fix Rearranger - fix. removed erroneous patch. ", "B_clean_title": ["fix", "npe", "jdk9", "fix", "rearrang", "fix", "remov", "erron", "patch"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a bug in the lineToFrontBall method  too .. fix merge issue. Fix a bug in the middle of the beam. ", "B_clean_title": ["fix", "bug", "linetofrontbal", "line", "front", "ball", "method", "too", "fix", "merg", "issu", "fix", "bug", "middl", "beam"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Delete some unused code. removed NPE in extreme patch. Ignore patterns added by accident. ", "B_clean_title": ["delet", "some", "unus", "code", "remov", "npe", "extrem", "patch", "ignor", "pattern", "ad", "by", "accid"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a bug in the lineToFrontBall method that was not reliably located .. Fix EvilSeph  s patch. ", "B_clean_title": ["fix", "bug", "linetofrontbal", "line", "front", "ball", "method", "that", "wa", "not", "reliabl", "locat", "fix", "evilseph", "evil", "seph", "patch"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a bug in the lineToFrontBall method  too .. fix merge issue. Updated the fix of the rebase of welzlEncloser .. ", "B_clean_title": ["fix", "bug", "linetofrontbal", "line", "front", "ball", "method", "too", "fix", "merg", "issu", "updat", "fix", "rebas", "welzlenclos", "welzl", "enclos"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Delete unsed check for inner ball. fix a bug in the extremes of WelzlEncloser .. removed extraneous line. ", "B_clean_title": ["delet", "uns", "check", "inner", "ball", "fix", "bug", "extrem", "welzlenclos", "welzl", "enclos", "remov", "extran", "line"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Delete some unused code. Removed fixed NPE in WelzlEncloser .. ", "B_clean_title": ["delet", "some", "unus", "code", "remov", "fix", "npe", "welzlenclos", "welzl", "enclos"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix NPE in pivotingBall. Fix moveToFrontBall ( ). Fix EvilSeph  s patch. removed patch from selectFarthest ( ). ", "B_clean_title": ["fix", "npe", "pivotingbal", "pivot", "ball", "fix", "movetofrontbal", "move", "front", "ball", "fix", "evilseph", "evil", "seph", "patch", "remov", "patch", "selectfarthest", "select", "farthest"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Improve cleanup of ExceptionContext . format ( Object  String  boolean  boolean ). Delete unsed check. ", "B_clean_title": ["improv", "cleanup", "exceptioncontext", "except", "context", "format", "object", "string", "boolean", "boolean", "delet", "uns", "check"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Ignore patterns added by accident. Delete some unused code. removed NPE from extremes. Save saved ball in case of closer bug. ", "B_clean_title": ["ignor", "pattern", "ad", "by", "accid", "delet", "some", "unus", "code", "remov", "npe", "extrem", "save", "save", "ball", "case", "closer", "bug"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Delete unneeded patch. Fix EvilSeph  s patch. ", "B_clean_title": ["delet", "unneed", "patch", "fix", "evilseph", "evil", "seph", "patch"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix NPE in JDK7. Fix EvilSeph  s patch .. ", "B_clean_title": ["fix", "npe", "jdk7", "fix", "evilseph", "evil", "seph", "patch"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix NPE in JSF. ", "B_clean_title": ["fix", "npe", "jsf"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a bug in the enclosing Balls. ", "B_clean_title": ["fix", "bug", "enclos", "ball"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Added extreme . add ( 0  farthest ) to ball .. removed patch for E3E. ", "B_clean_title": ["ad", "extrem", "add", "farthest", "ball", "remov", "patch", "e3e"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed patch for E3E. Fix Reverted the patch .. removed patch from extremes. ", "B_clean_title": ["remov", "patch", "e3e", "fix", "revert", "patch", "remov", "patch", "extrem"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Remove a couple of errors. moving the first extreme point to the front. ", "B_clean_title": ["remov", "coupl", "error", "move", "first", "extrem", "point", "front"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a minor issue with the + 1 . 5 error in AffectEntityClass .. moving ball to the front of the extreme list. ", "B_clean_title": ["fix", "minor", "issu", "error", "affectentityclass", "affect", "entiti", "class", "move", "ball", "front", "extrem", "list"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a typo in code. removed patch for E3E. ", "B_clean_title": ["fix", "typo", "code", "remov", "patch", "e3e"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a typo in code. Fix NPE in RegenerateBallOfPoints  fixes # 1615. ", "B_clean_title": ["fix", "typo", "code", "fix", "npe", "regenerateballofpoint", "regener", "ball", "point", "fix", "1615"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix the merge of AffectLineEnd to trigger the rebase. ", "B_clean_title": ["fix", "merg", "affectlineend", "affect", "line", "end", "trigger", "rebas"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Remove a couple of errors. removed extraneous line. ", "B_clean_title": ["remov", "coupl", "error", "remov", "extran", "line"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Remove a couple of errors. Revert previous patch. ", "B_clean_title": ["remov", "coupl", "error", "revert", "previou", "patch"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a potential NPE in AffectEntityClassPath. removed extra extreme loop. ", "B_clean_title": ["fix", "potenti", "npe", "affectentityclasspath", "affect", "entiti", "class", "path", "remov", "extra", "extrem", "loop"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Reverted the patch of MathIllegalStateException. Fix E3e bug. removed a couple incorrect lines. ", "B_clean_title": ["revert", "patch", "mathillegalstateexcept", "math", "illeg", "state", "except", "fix", "e3e", "bug", "remov", "coupl", "incorrect", "line"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Remove a couple of errors. ", "B_clean_title": ["remov", "coupl", "error"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed patch from refactoring  see. Fixed a bug in the extremes of WelzlEncloser .. ", "B_clean_title": ["remov", "patch", "refactor", "see", "fix", "bug", "extrem", "welzlenclos", "welzl", "enclos"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a minor issue with the patch .. ", "B_clean_title": ["fix", "minor", "issu", "patch"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Add missing patch. Remove a couple of errors. moving ball to the front of the extreme list. ", "B_clean_title": ["add", "miss", "patch", "remov", "coupl", "error", "move", "ball", "front", "extrem", "list"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Remove patch from refactoring .. Add missing patch. ", "B_clean_title": ["remov", "patch", "refactor", "add", "miss", "patch"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed extreme . add ( points . get ( 0 ) ) from proguard. ", "B_clean_title": ["remov", "extrem", "add", "point", "get", "proguard"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix NPE in ball on support from infinite loop. ", "B_clean_title": ["fix", "npe", "ball", "support", "infinit", "loop"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Remove a couple of debug files. Fix E3E4F1E3E2E .. ", "B_clean_title": ["remov", "coupl", "debug", "file", "fix", "e3e4f1e3e2"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed patch for E3E. Fix the loop. ", "B_clean_title": ["remov", "patch", "e3e", "fix", "loop"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed a recursive loop. ", "B_clean_title": ["remov", "recurs", "loop"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed a redundant throw. removed extra step. ", "B_clean_title": ["remov", "redund", "throw", "remov", "extra", "step"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix NPE in AffectEntityException. ", "B_clean_title": ["fix", "npe", "affectentityexcept", "affect", "entiti", "except"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed extraneous whitespace. ", "B_clean_title": ["remov", "extran", "whitespac"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed patch from code. fix the infinite loop. Fix rebase. ", "B_clean_title": ["remov", "patch", "code", "fix", "infinit", "loop", "fix", "rebas"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed extraneous comment. fix the infinite loop. ", "B_clean_title": ["remov", "extran", "comment", "fix", "infinit", "loop"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix NPE in AffectEntityException. Updated patch to fix focal length issue. ", "B_clean_title": ["fix", "npe", "affectentityexcept", "affect", "entiti", "except", "updat", "patch", "fix", "focal", "length", "issu"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix EAP. Remove a couple of errors. Fix rebase. ", "B_clean_title": ["fix", "eap", "remov", "coupl", "error", "fix", "rebas"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed extraneous line. removed patch from refactoring  see. ", "B_clean_title": ["remov", "extran", "line", "remov", "patch", "refactor", "see"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed null check. removed patch from refactoring  see. ", "B_clean_title": ["remov", "null", "check", "remov", "patch", "refactor", "see"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed patch for E3E. moving extremes to the front ball. ", "B_clean_title": ["remov", "patch", "e3e", "move", "extrem", "front", "ball"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed a redundant throw. ", "B_clean_title": ["remov", "redund", "throw"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Remove patch from refactoring .. removed extra extreme loop. Fix the loop. ", "B_clean_title": ["remov", "patch", "refactor", "remov", "extra", "extrem", "loop", "fix", "loop"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed patch from refactoring  see. fix the edge case. ", "B_clean_title": ["remov", "patch", "refactor", "see", "fix", "edg", "case"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a potential NPE in AffectEntityClassPath. Readded missing support array in extremes. ", "B_clean_title": ["fix", "potenti", "npe", "affectentityclasspath", "affect", "entiti", "class", "path", "read", "miss", "support", "array", "extrem"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Remove a couple of errors. Readded missing support . clear ( ) after welzl encloser patch. ", "B_clean_title": ["remov", "coupl", "error", "read", "miss", "support", "clear", "after", "welzl", "enclos", "patch"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Added patch for MathIllegalStateException. Remove a couple of debug files. Updated the zip code. ", "B_clean_title": ["ad", "patch", "mathillegalstateexcept", "math", "illeg", "state", "except", "remov", "coupl", "debug", "file", "updat", "zip", "code"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Revert previous patch. removed patch from previous commit  because it probably didn  t work. ", "B_clean_title": ["revert", "previou", "patch", "remov", "patch", "previou", "commit", "becaus", "it", "probabl", "didn", "work"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Added patch for MathIllegalStateException. removed patch from refactoring  see. ", "B_clean_title": ["ad", "patch", "mathillegalstateexcept", "math", "illeg", "state", "except", "remov", "patch", "refactor", "see"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix a bit of code. ", "B_clean_title": ["fix", "bit", "code"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Remove a couple of errors. Fix EAP. Removed a moveToFrontBall that was not necessary  fixes ryas. ", "B_clean_title": ["remov", "coupl", "error", "fix", "eap", "remov", "movetofrontbal", "move", "front", "ball", "that", "wa", "not", "necessari", "fix", "rya"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Revert wrong patch. Remove patch for EulerBalls. Fix the for - loop of a bug in the geometry encloser patch .. ", "B_clean_title": ["revert", "wrong", "patch", "remov", "patch", "eulerbal", "euler", "ball", "fix", "loop", "bug", "geometri", "enclos", "patch"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed extreme . add ( points . get ( 0 ) ) from proguard. Readded missing clear ( ) call. ", "B_clean_title": ["remov", "extrem", "add", "point", "get", "proguard", "read", "miss", "clear", "call"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix NPE in newly added piece. Remove a couple of errors. ", "B_clean_title": ["fix", "npe", "newli", "ad", "piec", "remov", "coupl", "error"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed a couple incorrect lines. removed extra extreme loop. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "remov", "extra", "extrem", "loop"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed patch for E3E. removed extra step. ", "B_clean_title": ["remov", "patch", "e3e", "remov", "extra", "step"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Remove a couple of errors. removed a couple incorrect lines. ", "B_clean_title": ["remov", "coupl", "error", "remov", "coupl", "incorrect", "line"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Fix E3e bug. removed patch for E3E. ", "B_clean_title": ["fix", "e3e", "bug", "remov", "patch", "e3e"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "Remove a couple of errors. Fix EAP. ", "B_clean_title": ["remov", "coupl", "error", "fix", "eap"]},
{"A_title": "implementation of smallest enclosing ball algorithm sometime failsThe algorithm for finding the smallest ball is designed in such a way the radius should be strictly increasing at each iteration.  In some cases it is not true and one iteration has a smaller ball. In most cases there is no consequence there is just one or two more iterations. However in rare cases discovered while testing 3D this generates an infinite loop.  Some very short offending cases have already been identified and added to the test suite. These cases are currently deactivated in the main repository while I am already working on them. The test cases are  * WelzlEncloser2DTest.testReducingBall * WelzlEncloser2DTest.testLargeSamples * WelzlEncloser3DTest.testInfiniteLoop * WelzlEncloser3DTest.testLargeSamples", "A_clean_title": ["implement", "smallest", "enclos", "ball", "algorithm", "sometim", "failsth", "fail", "algorithm", "find", "smallest", "ball", "design", "such", "way", "radiu", "strictli", "increas", "at", "each", "iter", "some", "case", "it", "not", "true", "one", "iter", "ha", "smaller", "ball", "most", "case", "there", "no", "consequ", "there", "just", "one", "or", "two", "more", "iter", "howev", "rare", "case", "discov", "while", "test", "3d", "thi", "gener", "infinit", "loop", "some", "veri", "short", "offend", "case", "have", "alreadi", "been", "identifi", "ad", "test", "suit", "these", "case", "are", "current", "deactiv", "main", "repositori", "while", "am", "alreadi", "work", "them", "test", "case", "are", "welzlencloser2dtest", "testreducingbal", "welzl", "encloser2d", "test", "test", "reduc", "ball", "welzlencloser2dtest", "testlargesampl", "welzl", "encloser2d", "test", "test", "larg", "sampl", "welzlencloser3dtest", "testinfiniteloop", "welzl", "encloser3d", "test", "test", "infinit", "loop", "welzlencloser3dtest", "testlargesampl", "welzl", "encloser3d", "test", "test", "larg", "sampl"], "B_title": "removed patch for E3E. Updated patch for welzlEncloser. ", "B_clean_title": ["remov", "patch", "e3e", "updat", "patch", "welzlenclos", "welzl", "enclos"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Fix a bug in MultiDirectional .. ", "B_clean_title": ["fix", "bug", "multidirect", "multi", "direct"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Fix a typo in MultiDirectional .. ", "B_clean_title": ["fix", "typo", "multidirect", "multi", "direct"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Fix a typo in MultiDirectional .. ", "B_clean_title": ["fix", "typo", "multidirect", "multi", "direct"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Fixed a bug in MultiDirectional .. Removed a redundant line. ", "B_clean_title": ["fix", "bug", "multidirect", "multi", "direct", "remov", "redund", "line"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "removed incorrect patch. ", "B_clean_title": ["remov", "incorrect", "patch"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Add a return statement so the contract can be used .. ", "B_clean_title": ["add", "return", "statement", "so", "contract", "use"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Fix typo in MultiDirectional .. ", "B_clean_title": ["fix", "typo", "multidirect", "multi", "direct"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "added a missing if / else. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "BrentOptimizer not always reporting the best pointBrentOptimizer (package o.a.c.m.optimization.univariate) does not check that the point it is going to return is indeed the best one it has encountered. Indeed the last evaluated point might be slightly worse than the one before last.", "A_clean_title": ["brentoptim", "brent", "optim", "not", "alway", "report", "best", "pointbrentoptim", "point", "brent", "optim", "packag", "optim", "univari", "not", "check", "that", "point", "it", "go", "return", "inde", "best", "one", "it", "ha", "encount", "inde", "last", "evalu", "point", "might", "slightli", "wors", "than", "one", "befor", "last"], "B_title": "Missing in previous patch. ", "B_clean_title": ["miss", "previou", "patch"]}]