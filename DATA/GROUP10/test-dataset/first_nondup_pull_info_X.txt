[{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Added a backprop to the patch .. ", "B_clean_title": ["ad", "backprop", "patch"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Fix a bug in leastsquares optimizer .. ", "B_clean_title": ["fix", "bug", "leastsquar", "optim"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Added a line of code to track the number of times we iterate over the two - . Remove an unnecessary call to incrementCount .. ", "B_clean_title": ["ad", "line", "code", "track", "number", "time", "we", "iter", "over", "two", "remov", "unnecessari", "call", "incrementcount", "increment", "count"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Fix NPE in LevenbergMarquardtOptimizer . java. ", "B_clean_title": ["fix", "npe", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "java"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Updated variable name. ", "B_clean_title": ["updat", "variabl", "name"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Updated variable name. Fix a bug in the leastsquares optimizer .. ", "B_clean_title": ["updat", "variabl", "name", "fix", "bug", "leastsquar", "optim"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Added a line of code to track the number of times we think we  ve done the. Remove an unnecessary call to incrementCount .. ", "B_clean_title": ["ad", "line", "code", "track", "number", "time", "we", "think", "we", "ve", "done", "remov", "unnecessari", "call", "incrementcount", "increment", "count"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Fix a bug in the leastsquares optimizer .. Fix the patch for one more test. ", "B_clean_title": ["fix", "bug", "leastsquar", "optim", "fix", "patch", "one", "more", "test"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Updated variable name. ", "B_clean_title": ["updat", "variabl", "name"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Put back the initial value of the function in the same thread as the other one .. ", "B_clean_title": ["put", "back", "initi", "valu", "function", "same", "thread", "as", "other", "one"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Added step to increase xNorm .. Fix variable name error. ", "B_clean_title": ["ad", "step", "increas", "xnorm", "norm", "fix", "variabl", "name", "error"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Fix variable name variable. Fix xNorm reset during minimized least squares test. Fix the case for svn patch .. ", "B_clean_title": ["fix", "variabl", "name", "variabl", "fix", "xnorm", "norm", "reset", "dure", "minim", "least", "squar", "test", "fix", "case", "svn", "patch"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Added a line of code to mark the end of a line of code. Remove an unnecessary call to incrementCount .. Fix the patch for one more test. ", "B_clean_title": ["ad", "line", "code", "mark", "end", "line", "code", "remov", "unnecessari", "call", "incrementcount", "increment", "count", "fix", "patch", "one", "more", "test"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Updated one of the patched code .. Fix a bug in the same way as in the other one .. ", "B_clean_title": ["updat", "one", "patch", "code", "fix", "bug", "same", "way", "as", "other", "one"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Updated one of the work items for the patch .. Fix one more test. ", "B_clean_title": ["updat", "one", "work", "item", "patch", "fix", "one", "more", "test"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Added a line of code to track the number of times we iterate over the two - . Fix a bug in the inverse function so that it doesn  t become an error in the inverse. ", "B_clean_title": ["ad", "line", "code", "track", "number", "time", "we", "iter", "over", "two", "fix", "bug", "invers", "function", "so", "that", "it", "doesn", "becom", "error", "invers"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Added a line of code that was accidentally left in the last commit .. Remove an unnecessary call to incrementCount .. Fix xNorm reset during minimized least squares test. ", "B_clean_title": ["ad", "line", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "unnecessari", "call", "incrementcount", "increment", "count", "fix", "xnorm", "norm", "reset", "dure", "minim", "least", "squar", "test"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Fix variable variable. Fix the case for svn patch .. ", "B_clean_title": ["fix", "variabl", "variabl", "fix", "case", "svn", "patch"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Fix variable name error in LevenbergMarquardtOptimizer. ", "B_clean_title": ["fix", "variabl", "name", "error", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Added missing incrementCount ( ) to LevenbergMarquardtOptimizer. Fix a bug in the inverse search. ", "B_clean_title": ["ad", "miss", "incrementcount", "increment", "count", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "fix", "bug", "invers", "search"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Added a line of code to track the number of times we iterate over the two - . Remove an unnecessary call to incrementCount .. Fix patch. ", "B_clean_title": ["ad", "line", "code", "track", "number", "time", "we", "iter", "over", "two", "remov", "unnecessari", "call", "incrementcount", "increment", "count", "fix", "patch"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Updated variable name. Fix a bug in the likelihood function. ", "B_clean_title": ["updat", "variabl", "name", "fix", "bug", "likelihood", "function"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Added one more test to see if the function is still working .. ", "B_clean_title": ["ad", "one", "more", "test", "see", "function", "still", "work"]},
{"A_title": "LevenburgMaquardt switched evaluation and iterationsNone", "A_clean_title": ["levenburgmaquardt", "levenburg", "maquardt", "switch", "evalu", "iterationsnon", "iter", "none"], "B_title": "Fix a bug in the inverse function to save energy .. ", "B_clean_title": ["fix", "bug", "invers", "function", "save", "energi"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fixed incorrect patch HD. ", "B_clean_title": ["fix", "incorrect", "patch", "hd"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated FDistribution . getSupportLowerBound ( ). Fix NPE in UniformRealDistribution . density ( double ). Updated reference to patched code. ", "B_clean_title": ["updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "fix", "npe", "uniformrealdistribut", "uniform", "real", "distribut", "densiti", "doubl", "updat", "refer", "patch", "code"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch_412 .. updated FDistribution . log ( ). updated FDistribution with patched upper bounds. ", "B_clean_title": ["updat", "refer", "patch", "412", "updat", "fdistribut", "distribut", "log", "updat", "fdistribut", "distribut", "patch", "upper", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix a bug in UniformRealDistribution. Updated guidance for real distributions. Updated FDistribution . getSupportLowerBound ( ). ", "B_clean_title": ["fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "guidanc", "real", "distribut", "updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Added missing patch .. Updated reference to patch 1389 in UniformRealDistribution. Throw an exception if denominatorDegreesOfFreedom < 0. fixed FDistribution . getSupportLowerBound. ", "B_clean_title": ["ad", "miss", "patch", "updat", "refer", "patch", "1389", "uniformrealdistribut", "uniform", "real", "distribut", "throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "fix", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Added missing patch. updated FDistribution with patch 1 . 5. Fix a bug in UniformRealDistribution . getSupportUpperBound. Updated reference to patch_959 .. ", "B_clean_title": ["ad", "miss", "patch", "updat", "fdistribut", "distribut", "patch", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "getsupportupperbound", "get", "support", "upper", "bound", "updat", "refer", "patch", "959"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix a bug in UniformRealDistribution. Updated FDistribution . getSupportLowerBound ( ). ", "B_clean_title": ["fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated patch for real distributions. Updated FDistribution . getSupportLowerBound ( ). ", "B_clean_title": ["updat", "patch", "real", "distribut", "updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patched code. Fix FDistribution . exp ( x < 0 ). updated FDistribution with patched lower bound. ", "B_clean_title": ["updat", "refer", "patch", "code", "fix", "fdistribut", "distribut", "exp", "updat", "fdistribut", "distribut", "patch", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch_984 .. Fix FDistribution . density ( double ). updated FDistribution with patched upper bounds. ", "B_clean_title": ["updat", "refer", "patch", "984", "fix", "fdistribut", "distribut", "densiti", "doubl", "updat", "fdistribut", "distribut", "patch", "upper", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated FDistribution . getSupportLowerBound ( ). Fix a bug in UniformRealDistribution. Updated reference to patch w015. ", "B_clean_title": ["updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "refer", "patch", "w015"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patched code. Remove a redundant line. updated FDistribution with better error handling. ", "B_clean_title": ["updat", "refer", "patch", "code", "remov", "redund", "line", "updat", "fdistribut", "distribut", "better", "error", "handl"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "fixed EMC. updated FDistribution with patched upper bounds. Updated reference to patched code. ", "B_clean_title": ["fix", "emc", "updat", "fdistribut", "distribut", "patch", "upper", "bound", "updat", "refer", "patch", "code"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Added missing patch. updated FDistribution with patched upper bounds. Updated reference to patch 1306 .. ", "B_clean_title": ["ad", "miss", "patch", "updat", "fdistribut", "distribut", "patch", "upper", "bound", "updat", "refer", "patch", "1306"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Added missing patch. updated FDistribution with patched upper bounds. Fix a bug in UniformRealDistribution where the first argument is not greater than the second .. Updated reference to patch w015. ", "B_clean_title": ["ad", "miss", "patch", "updat", "fdistribut", "distribut", "patch", "upper", "bound", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "where", "first", "argument", "not", "greater", "than", "second", "updat", "refer", "patch", "w015"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Added a throw if the denominatorDegreesOfFreedom was not greater than the numeratorDegreesOf. updated FDistribution with patch 1255. Updated reference to patched code. ", "B_clean_title": ["ad", "throw", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "wa", "not", "greater", "than", "numeratordegreesof", "numer", "degre", "updat", "fdistribut", "distribut", "patch", "1255", "updat", "refer", "patch", "code"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch_525 .. Updated FDistribution . getSupportLowerBound ( ). fixed FDistribution . isSupportLowerBoundInclusive ( ). ", "B_clean_title": ["updat", "refer", "patch", "525", "updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "fix", "fdistribut", "distribut", "issupportlowerboundinclus", "support", "lower", "bound", "inclus"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated FDistribution . getSupportLowerBound ( ). Add missing patch. Updated reference to patch_631 .. ", "B_clean_title": ["updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "add", "miss", "patch", "updat", "refer", "patch", "631"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . density ( double ). updated FDistribution with patched upper bounds. Updated reference to patch_387 for real distributions. ", "B_clean_title": ["fix", "fdistribut", "distribut", "densiti", "doubl", "updat", "fdistribut", "distribut", "patch", "upper", "bound", "updat", "refer", "patch", "387", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated FDistribution . getSupportLowerBound ( ). Fix a bug in UniformRealDistribution. ", "B_clean_title": ["updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch_934 .. Throw an exception if denominatorDegreesOfFreedom < 0. updated FDistribution with patched lower bound. ", "B_clean_title": ["updat", "refer", "patch", "934", "throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "updat", "fdistribut", "distribut", "patch", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Throw an exception if denominatorDegreesOfFreedom < 0. updated FDistribution with patch_961. Fix a bug in UniformRealDistribution. ", "B_clean_title": ["throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "updat", "fdistribut", "distribut", "patch", "961", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch 1436 .. Add support lowerBound to FDistribution . density ( ). updated FDistribution with patch 1436. ", "B_clean_title": ["updat", "refer", "patch", "1436", "add", "support", "lowerbound", "lower", "bound", "fdistribut", "distribut", "densiti", "updat", "fdistribut", "distribut", "patch", "1436"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch in UniformRealDistribution. Throw an exception if denominatorDegreesOfFreedom < 0. updated FDistribution with patched lower bound. Fix FDistribution . isSupportLowerBoundInclusive ( ). ", "B_clean_title": ["updat", "refer", "patch", "uniformrealdistribut", "uniform", "real", "distribut", "throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "updat", "fdistribut", "distribut", "patch", "lower", "bound", "fix", "fdistribut", "distribut", "issupportlowerboundinclus", "support", "lower", "bound", "inclus"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add support for lowerBound in FDistribution. updated FDistribution with patched lower bound. Updated reference to patch 1366 in UniformRealDistribution. ", "B_clean_title": ["add", "support", "lowerbound", "lower", "bound", "fdistribut", "distribut", "updat", "fdistribut", "distribut", "patch", "lower", "bound", "updat", "refer", "patch", "1366", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix a bug in UniformRealDistribution. Updated FDistribution . getSupportLowerBound ( ). ", "B_clean_title": ["fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix a bug in UniformRealDistribution. Updated FDistribution . getSupportLowerBound ( ). ", "B_clean_title": ["fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add support for lowerBound in FDistribution. updated FDistribution with patch 1445. Updated reference to patch 1445. ", "B_clean_title": ["add", "support", "lowerbound", "lower", "bound", "fdistribut", "distribut", "updat", "fdistribut", "distribut", "patch", "1445", "updat", "refer", "patch", "1445"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix a bug in UniformRealDistribution. Updated reference to patch_892 .. Updated FDistribution . getSupportLowerBound ( ). ", "B_clean_title": ["fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "refer", "patch", "892", "updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch w015. Fix FDistribution . log ( ). updated FDistribution with patched upper bounds. ", "B_clean_title": ["updat", "refer", "patch", "w015", "fix", "fdistribut", "distribut", "log", "updat", "fdistribut", "distribut", "patch", "upper", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch_519 in UniformRealDistribution. updated FDistribution with patched lower bound. Fix FDistribution . isSupportLowerBoundInclusive ( ). ", "B_clean_title": ["updat", "refer", "patch", "519", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "fdistribut", "distribut", "patch", "lower", "bound", "fix", "fdistribut", "distribut", "issupportlowerboundinclus", "support", "lower", "bound", "inclus"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Added missing patch. Fix NPE in UniformRealDistribution . getSupportUpperBound. Updated reference to patch 1421. Throw an exception if the denominatorDegreesOfFreedom was not greater than 0 .. fixed a bug in FDistribution . getSupportLowerBound. ", "B_clean_title": ["ad", "miss", "patch", "fix", "npe", "uniformrealdistribut", "uniform", "real", "distribut", "getsupportupperbound", "get", "support", "upper", "bound", "updat", "refer", "patch", "1421", "throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "wa", "not", "greater", "than", "fix", "bug", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Allow < = > lognxm to be defined for FDistribution . density ( ) .. fixed a bug in FDistribution . getSupportLowerBound. Added missing patch. Fix NPE in UniformRealDistribution . getSupportUpperBound. Updated reference to patch 1471 .. ", "B_clean_title": ["allow", "lognxm", "defin", "fdistribut", "distribut", "densiti", "fix", "bug", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "ad", "miss", "patch", "fix", "npe", "uniformrealdistribut", "uniform", "real", "distribut", "getsupportupperbound", "get", "support", "upper", "bound", "updat", "refer", "patch", "1471"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add support for lowerBound in FDistribution. updated FDistribution with patched lower bound. Fix a bug in UniformRealDistribution . getSupportUpperBound. Updated reference to patched real distribution. ", "B_clean_title": ["add", "support", "lowerbound", "lower", "bound", "fdistribut", "distribut", "updat", "fdistribut", "distribut", "patch", "lower", "bound", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "getsupportupperbound", "get", "support", "upper", "bound", "updat", "refer", "patch", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . log ( x ) .. fixed a bug in FDistribution . getSupportLowerBound. Fix a bug in UniformRealDistribution . getSupportUpperBound. Updated reference to patch_698 .. ", "B_clean_title": ["fix", "fdistribut", "distribut", "log", "fix", "bug", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "getsupportupperbound", "get", "support", "upper", "bound", "updat", "refer", "patch", "698"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add support for lowerBound in FDistribution. fixed a bug in FDistribution . getSupportLowerBound. Updated reference to patch 1334 .. ", "B_clean_title": ["add", "support", "lowerbound", "lower", "bound", "fdistribut", "distribut", "fix", "bug", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "updat", "refer", "patch", "1334"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add support for lowerBound in FDistribution. fixed FDistribution . getSupportLowerBound. Added missing patch. Updated reference to patch 1386 in UniformRealDistribution. ", "B_clean_title": ["add", "support", "lowerbound", "lower", "bound", "fdistribut", "distribut", "fix", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "ad", "miss", "patch", "updat", "refer", "patch", "1386", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch_589 in UniformRealDistribution. Add qa = 0 to numeratorDegreesOfFreedom logn. updated FDistribution with patched upper bounds. ", "B_clean_title": ["updat", "refer", "patch", "589", "uniformrealdistribut", "uniform", "real", "distribut", "add", "qa", "numeratordegreesoffreedom", "numer", "degre", "freedom", "logn", "updat", "fdistribut", "distribut", "patch", "upper", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated FDistribution . getSupportLowerBound ( ). Fix a bug in UniformRealDistribution . getSupportUpperBound. Updated reference to patched real distribution. ", "B_clean_title": ["updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "getsupportupperbound", "get", "support", "upper", "bound", "updat", "refer", "patch", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add qa = 0 to numeratorDegreesOfFreedom logn. updated FDistribution with patched upper bounds. Fix FDistribution . isSupportLowerBoundInclusive ( ). Updated reference to patch_604 .. ", "B_clean_title": ["add", "qa", "numeratordegreesoffreedom", "numer", "degre", "freedom", "logn", "updat", "fdistribut", "distribut", "patch", "upper", "bound", "fix", "fdistribut", "distribut", "issupportlowerboundinclus", "support", "lower", "bound", "inclus", "updat", "refer", "patch", "604"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . log ( x ) .. fixed a bug in FDistribution . getSupportLowerBound. Updated reference to patched real distribution. ", "B_clean_title": ["fix", "fdistribut", "distribut", "log", "fix", "bug", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "updat", "refer", "patch", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add the mu value to FDistribution . log ( ) .. updated FDistribution with patched upper bounds. Updated guidance for real distributions. ", "B_clean_title": ["add", "mu", "valu", "fdistribut", "distribut", "log", "updat", "fdistribut", "distribut", "patch", "upper", "bound", "updat", "guidanc", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated copyright on UniformRealDistribution. Fix FDistribution . density ( double ). ", "B_clean_title": ["updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut", "fix", "fdistribut", "distribut", "densiti", "doubl"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated copyright on UniformRealDistribution. Throw an exception if the denominatorDegreesOfFreedom was not greater than 0 .. ", "B_clean_title": ["updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut", "throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "wa", "not", "greater", "than"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . density ( double ) where the numerator and denominator are not greater than the numerator. Fix FDistribution . getSupportLowerBound ( ). Updated reference to patch_692 .. ", "B_clean_title": ["fix", "fdistribut", "distribut", "densiti", "doubl", "where", "numer", "denomin", "are", "not", "greater", "than", "numer", "fix", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "updat", "refer", "patch", "692"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . density ( double ) where the numerator is not greater than the denominator. Fix up upperBound inclusiveness in UniformRealDistribution. ", "B_clean_title": ["fix", "fdistribut", "distribut", "densiti", "doubl", "where", "numer", "not", "greater", "than", "denomin", "fix", "up", "upperbound", "upper", "bound", "inclus", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch 850 for compatibility with older OSGi versions .. Throw an exception if the denominatorDegreesOfFreedom was not greater than 0 .. ", "B_clean_title": ["updat", "refer", "patch", "850", "compat", "older", "osgi", "os", "gi", "version", "throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "wa", "not", "greater", "than"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add numerical variance to FDistribution . density ( double ). Updated copyright on UniformRealDistribution. ", "B_clean_title": ["add", "numer", "varianc", "fdistribut", "distribut", "densiti", "doubl", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . density ( double ). Updated copyright on UniformRealDistribution. ", "B_clean_title": ["fix", "fdistribut", "distribut", "densiti", "doubl", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add numerical variance to FDistribution . density ( ). fixed NPE in FDistribution. Updated copyright on UniformRealDistribution. ", "B_clean_title": ["add", "numer", "varianc", "fdistribut", "distribut", "densiti", "fix", "npe", "fdistribut", "distribut", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix logx being > = 0 .. Fix UniformRealDistribution patch. ", "B_clean_title": ["fix", "logx", "be", "fix", "uniformrealdistribut", "uniform", "real", "distribut", "patch"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . density ( double ) where the numerator is not greater than the denominator. Updated patch for 1 . 3 . 5. Updated copyright on UniformRealDistribution. ", "B_clean_title": ["fix", "fdistribut", "distribut", "densiti", "doubl", "where", "numer", "not", "greater", "than", "denomin", "updat", "patch", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated copyright on UniformRealDistribution. Throw an exception if the numeratorDegreesOfFreedom > = 0. ", "B_clean_title": ["updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut", "throw", "except", "numeratordegreesoffreedom", "numer", "degre", "freedom"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated copyright on UniformRealDistribution. Fix FDistribution . density ( double ) where the numerical variance was not calculated .. ", "B_clean_title": ["updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut", "fix", "fdistribut", "distribut", "densiti", "doubl", "where", "numer", "varianc", "wa", "not", "calcul"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . density ( double ) where the numerical variance was not calculated .. Updated copyright on UniformRealDistribution. ", "B_clean_title": ["fix", "fdistribut", "distribut", "densiti", "doubl", "where", "numer", "varianc", "wa", "not", "calcul", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add numerical variance to FDistribution . density ( ). Updated copyright on UniformRealDistribution. ", "B_clean_title": ["add", "numer", "varianc", "fdistribut", "distribut", "densiti", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Throw an exception if the denominatorDegreesOfFreedom was not greater than 0 .. Updated patch for 1 . 6 . 2. Updated copyright on UniformRealDistribution. ", "B_clean_title": ["throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "wa", "not", "greater", "than", "updat", "patch", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated copyright on UniformRealDistribution. Fix logx being > = 0. ", "B_clean_title": ["updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut", "fix", "logx", "be"]},
{"A_title": "Mock Accumulo Inverts order of mutations w/ same timestampMock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.", "A_clean_title": ["mock", "accumulo", "invert", "order", "mutat", "same", "timestampmock", "timestamp", "mock", "accumulo", "ha", "differ", "behavior", "than", "real", "accumulo", "when", "same", "key", "updat", "same", "millisecond", "hidden", "memori", "map", "counter", "mock", "accumulo", "need", "sort", "descend"], "B_title": "Revert  fix merge conflict . ", "B_clean_title": ["revert", "fix", "merg", "conflict"]},
{"A_title": "Type refining of this raises IllegalArgumentExceptionNone", "A_clean_title": ["type", "refin", "thi", "rais", "illegalargumentexceptionnon", "illeg", "argument", "except", "none"], "B_title": "refined type cannot be refined .. ", "B_clean_title": ["refin", "type", "not", "refin"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix MathUtils . equals. ", "B_clean_title": ["fix", "mathutil", "math", "util", "equal"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Add missing MathUtils . equals ( double ). ", "B_clean_title": ["add", "miss", "mathutil", "math", "util", "equal", "doubl"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix MathUtils . equals ( double  double  int ). ", "B_clean_title": ["fix", "mathutil", "math", "util", "equal", "doubl", "doubl", "int"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix MathUtils . equals ( double  double ). ", "B_clean_title": ["fix", "mathutil", "math", "util", "equal", "doubl", "doubl"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix MathUtils . equals ( double  double ). ", "B_clean_title": ["fix", "mathutil", "math", "util", "equal", "doubl", "doubl"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix MathUtils . equals ( double  double ). ", "B_clean_title": ["fix", "mathutil", "math", "util", "equal", "doubl", "doubl"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix a bug in MathUtils . equals. ", "B_clean_title": ["fix", "bug", "mathutil", "math", "util", "equal"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix MathUtils . equals ( double  double ). ", "B_clean_title": ["fix", "mathutil", "math", "util", "equal", "doubl", "doubl"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Add missing MathUtils . equals ( ). ", "B_clean_title": ["add", "miss", "mathutil", "math", "util", "equal"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Add missing equals method. ", "B_clean_title": ["add", "miss", "equal", "method"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix a bug in MathUtils . equals. ", "B_clean_title": ["fix", "bug", "mathutil", "math", "util", "equal"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix bug in Controllers / Websocket Session. Added missing lexicographically ordered comparison to equals ( ) .. Added missing javadoc. updated factorialDouble. Added missing patch. Fix bug in MathUtils . equalsIncludingNaN. ", "B_clean_title": ["fix", "bug", "control", "websocket", "session", "ad", "miss", "lexicograph", "order", "comparison", "equal", "ad", "miss", "javadoc", "updat", "factorialdoubl", "factori", "doubl", "ad", "miss", "patch", "fix", "bug", "mathutil", "math", "util", "equalsincludingnan", "equal", "includ", "na"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix bug in equals. ", "B_clean_title": ["fix", "bug", "equal"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix a bug in MathUtils . equals. ", "B_clean_title": ["fix", "bug", "mathutil", "math", "util", "equal"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix bug in MathUtils . equals. ", "B_clean_title": ["fix", "bug", "mathutil", "math", "util", "equal"]},
{"A_title": "FastMath.cosh sinh do not support the same range of values as the Math counterpartsAs reported by Jeff Hain: cosh(double) and sinh(double): Math.cosh(709.783) = 8.991046692770538E307 FastMath.cosh(709.783) = Infinity Math.sinh(709.783) = 8.991046692770538E307 FastMath.sinh(709.783) = Infinity ===> This is due to using exp( x )/2 for values of |x| above 20: the result sometimes should not overflow but exp( x ) does so we end up with some infinity. ===> for values of |x| >= StrictMath.log(Double.MAX_VALUE) exp will overflow so you need to use that instead: for x positive: double t = exp(x*0.5); return (0.5*t)*t; for x negative: double t = exp(-x*0.5); return (-0.5*t)*t;", "A_clean_title": ["fastmath", "cosh", "fast", "math", "sinh", "not", "support", "same", "rang", "valu", "as", "math", "counterpartsa", "counterpart", "as", "report", "by", "jeff", "hain", "cosh", "doubl", "sinh", "doubl", "math", "cosh", "709", "783", "991046692770538e307", "fastmath", "cosh", "fast", "math", "709", "783", "infin", "math", "sinh", "709", "783", "991046692770538e307", "fastmath", "sinh", "fast", "math", "709", "783", "infin", "thi", "due", "exp", "valu", "|x|", "abov", "20", "result", "sometim", "not", "overflow", "but", "exp", "so", "we", "end", "up", "some", "infin", "valu", "|x|", "strictmath", "log", "strict", "math", "doubl", "max", "valu", "exp", "will", "overflow", "so", "you", "need", "use", "that", "instead", "posit", "doubl", "exp", "return", "neg", "doubl", "exp", "return"], "B_title": "Fix typo in cosh ( ). ", "B_clean_title": ["fix", "typo", "cosh"]},
{"A_title": "Break in finally block isnt optimized properlyNone", "A_clean_title": ["break", "final", "block", "isnt", "optim", "properlynon", "properli", "none"], "B_title": "Fix tryMinimizeExits case .. ", "B_clean_title": ["fix", "tryminimizeexit", "tri", "minim", "exit", "case"]},
{"A_title": "Break in finally block isnt optimized properlyNone", "A_clean_title": ["break", "final", "block", "isnt", "optim", "properlynon", "properli", "none"], "B_title": "Fix try / catch block. ", "B_clean_title": ["fix", "tri", "catch", "block"]},
{"A_title": "Break in finally block isnt optimized properlyNone", "A_clean_title": ["break", "final", "block", "isnt", "optim", "properlynon", "properli", "none"], "B_title": "Fix tryMinimizeExits. ", "B_clean_title": ["fix", "tryminimizeexit", "tri", "minim", "exit"]},
{"A_title": "Break in finally block isnt optimized properlyNone", "A_clean_title": ["break", "final", "block", "isnt", "optim", "properlynon", "properli", "none"], "B_title": "Fix the try / finally blocks used in the AST .. ", "B_clean_title": ["fix", "tri", "final", "block", "use", "ast"]},
{"A_title": "Break in finally block isnt optimized properlyNone", "A_clean_title": ["break", "final", "block", "isnt", "optim", "properlynon", "properli", "none"], "B_title": "Fix tryMinimizeExitPoints. ", "B_clean_title": ["fix", "tryminimizeexitpoint", "tri", "minim", "exit", "point"]},
{"A_title": "Break in finally block isnt optimized properlyNone", "A_clean_title": ["break", "final", "block", "isnt", "optim", "properlynon", "properli", "none"], "B_title": "Fix MinimizeExitPoints . java to include imports from confix .. Fix try / finally blocks. ", "B_clean_title": ["fix", "minimizeexitpoint", "minim", "exit", "point", "java", "includ", "import", "confix", "fix", "tri", "final", "block"]},
{"A_title": "Break in finally block isnt optimized properlyNone", "A_clean_title": ["break", "final", "block", "isnt", "optim", "properlynon", "properli", "none"], "B_title": "minimize the closure closure closure closure patch .. ", "B_clean_title": ["minim", "closur", "closur", "closur", "closur", "patch"]},
{"A_title": "Compiler removes function properties that it should notNone", "A_clean_title": ["compil", "remov", "function", "properti", "that", "it", "notnon", "not", "none"], "B_title": "Fix CollapseProperties report. ", "B_clean_title": ["fix", "collapseproperti", "collaps", "properti", "report"]},
{"A_title": "Wrong code generated if mixing types in ternary operatorNone", "A_clean_title": ["wrong", "code", "gener", "mix", "type", "ternari", "operatornon", "oper", "none"], "B_title": "Add true condition to walk pattern. ", "B_clean_title": ["add", "true", "condit", "walk", "pattern"]},
{"A_title": "Wrong code generated if mixing types in ternary operatorNone", "A_clean_title": ["wrong", "code", "gener", "mix", "type", "ternari", "operatornon", "oper", "none"], "B_title": "Fix HOOK pattern in closure situations .. ", "B_clean_title": ["fix", "hook", "pattern", "closur", "situat"]},
{"A_title": "Wrong code generated if mixing types in ternary operatorNone", "A_clean_title": ["wrong", "code", "gener", "mix", "type", "ternari", "operatornon", "oper", "none"], "B_title": "Remove broken upgrade .. closure folding changes. ", "B_clean_title": ["remov", "broken", "upgrad", "closur", "fold", "chang"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed intermittent crossed point search. fixed bug. ", "B_clean_title": ["remov", "intermitt", "cross", "point", "search", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of code that was accidentally left in the last commit .. ", "B_clean_title": ["remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed debug code. fixed bug. ", "B_clean_title": ["fix", "small", "bug", "remov", "debug", "code", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. removed a bit of a hack to fix the merge issue. ", "B_clean_title": ["fix", "small", "bug", "remov", "bit", "hack", "fix", "merg", "issu"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix a small bug in the code. Remove a bit of a debug code. fixed merge issue with prev PR. ", "B_clean_title": ["fix", "small", "bug", "code", "remov", "bit", "debug", "code", "fix", "merg", "issu", "prev", "pr"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet .. fixed bug. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "updated quat array for 1 . 5. ", "B_clean_title": ["updat", "quat", "array"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the size of the PolyhedronsSet in the temporary file for the compatibility fix. fixed bug. ", "B_clean_title": ["set", "size", "polyhedronsset", "polyhedron", "set", "temporari", "file", "compat", "fix", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed a redundant merge of PolyhedronsSet . boundaryFacet. Remove inside attribute from merge of PolyhedronsSet. ", "B_clean_title": ["fix", "small", "bug", "remov", "redund", "merg", "polyhedronsset", "polyhedron", "set", "boundaryfacet", "boundari", "facet", "remov", "insid", "attribut", "merg", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed fixed bug. fixed bug. ", "B_clean_title": ["remov", "fix", "bug", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. fix merge issue. removed a bit from a jar. ", "B_clean_title": ["fix", "small", "bug", "fix", "merg", "issu", "remov", "bit", "jar"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the PolyhedronsSet .. Removed debug code. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "remov", "debug", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. fixed a small bug. fixed bug. ", "B_clean_title": ["fix", "small", "bug", "fix", "small", "bug", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of code that was accidentally left in the last commit .. fixed bug. ", "B_clean_title": ["remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed a bit of a rebase. updated far branch quat array. fixed a small bug. ", "B_clean_title": ["fix", "small", "bug", "remov", "bit", "rebas", "updat", "far", "branch", "quat", "array", "fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add missing hj array .. fixed a bug in the - - plane constructor. removed a bit of a hack to fix the merge issue. fixed bug. ", "B_clean_title": ["add", "miss", "hj", "array", "fix", "bug", "plane", "constructor", "remov", "bit", "hack", "fix", "merg", "issu", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed a redundant check. Fix Euclidean3D bug. ", "B_clean_title": ["fix", "small", "bug", "remov", "redund", "check", "fix", "euclidean3d", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. removed a redundant empty line. Remove inside attribute from PolyhedronsSet. ", "B_clean_title": ["fix", "small", "bug", "remov", "redund", "empti", "line", "remov", "insid", "attribut", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove boundaryFacet from PolyhedronsSet. fixed bug. ", "B_clean_title": ["remov", "boundaryfacet", "boundari", "facet", "polyhedronsset", "polyhedron", "set", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a minor issue with first intersection. fixed a small bug. Removed a redundant merge of PolyhedronsSet . boundaryFacet. ", "B_clean_title": ["fix", "minor", "issu", "first", "intersect", "fix", "small", "bug", "remov", "redund", "merg", "polyhedronsset", "polyhedron", "set", "boundaryfacet", "boundari", "facet"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed a redundant merge of PolyhedronsSet . boundaryFacet. ", "B_clean_title": ["fix", "small", "bug", "remov", "redund", "merg", "polyhedronsset", "polyhedron", "set", "boundaryfacet", "boundari", "facet"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed a redundant merge of PolyhedronsSet . boundaryFacet. ", "B_clean_title": ["fix", "small", "bug", "remov", "redund", "merg", "polyhedronsset", "polyhedron", "set", "boundaryfacet", "boundari", "facet"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. updated bug. ", "B_clean_title": ["fix", "small", "bug", "updat", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. fixed a small bug. removed a bit of a hack to fix the merge issue. Remove inside attribute from merge of PolyhedronsSet. ", "B_clean_title": ["fix", "small", "bug", "fix", "small", "bug", "remov", "bit", "hack", "fix", "merg", "issu", "remov", "insid", "attribut", "merg", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the PolyhedronsSet .. fixed a bug in BSP tree edge attribute .. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "fix", "bug", "bsp", "tree", "edg", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a bug in the same line as the other two points .. Fixed a bit of code with the crossed line being too far from the near branch .. fixed bug. ", "B_clean_title": ["fix", "bug", "same", "line", "as", "other", "two", "point", "fix", "bit", "code", "cross", "line", "be", "too", "far", "near", "branch", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add missing patch .. fixed a small bug. Removed debug code. ", "B_clean_title": ["add", "miss", "patch", "fix", "small", "bug", "remov", "debug", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the PolyhedronsSet .. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the size of the PolyhedronsSet in the patched code. Removed a bit of a rebase. Remove patched file. ", "B_clean_title": ["set", "size", "polyhedronsset", "polyhedron", "set", "patch", "code", "remov", "bit", "rebas", "remov", "patch", "file"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed debug code. Readded visit to fix merge issue. ", "B_clean_title": ["remov", "debug", "code", "read", "visit", "fix", "merg", "issu"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a bit of a hack to fix the merge issue. ", "B_clean_title": ["remov", "bit", "hack", "fix", "merg", "issu"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. don  t use crossed branch for now. ", "B_clean_title": ["fix", "small", "bug", "don", "use", "cross", "branch", "now"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove boundaryFacet from PolyhedronsSet. ", "B_clean_title": ["remov", "boundaryfacet", "boundari", "facet", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed a redundant merge of PolyhedronsSet . boundaryFacet. removed unused code. ", "B_clean_title": ["fix", "small", "bug", "remov", "redund", "merg", "polyhedronsset", "polyhedron", "set", "boundaryfacet", "boundari", "facet", "remov", "unus", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed debug code. Remove stray patch code. ", "B_clean_title": ["remov", "debug", "code", "remov", "stray", "patch", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed debug code. Remove stray check for inside attribute. ", "B_clean_title": ["remov", "debug", "code", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet .. Fix Euclidean geometry test. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "fix", "euclidean", "geometri", "test"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a bit of a hack to fix the merge issue. Remove inside attribute from merge of PolyhedronsSet. ", "B_clean_title": ["remov", "bit", "hack", "fix", "merg", "issu", "remov", "insid", "attribut", "merg", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a bit of a check. fixed bug. ", "B_clean_title": ["remov", "bit", "check", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a bit from a jar. ", "B_clean_title": ["remov", "bit", "jar"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed debug code. Remove stray check for inside attribute. ", "B_clean_title": ["fix", "small", "bug", "remov", "debug", "code", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a bit of a rebase. fixed merge issue with prev PR. ", "B_clean_title": ["remov", "bit", "rebas", "fix", "merg", "issu", "prev", "pr"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix a small bug. Remove a bit of code that was accidentally left in the last commit .. fixed merge issue with closed pull request. ", "B_clean_title": ["fix", "small", "bug", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "fix", "merg", "issu", "close", "pull", "request"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed debug code. fixed bug. ", "B_clean_title": ["remov", "debug", "code", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. removed a bit of a hack to fix the merge issue. Remove inside attribute from merge of PolyhedronsSet. ", "B_clean_title": ["fix", "small", "bug", "remov", "bit", "hack", "fix", "merg", "issu", "remov", "insid", "attribut", "merg", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of a test code. fixed Euclidean3D bug. ", "B_clean_title": ["remov", "bit", "test", "code", "fix", "euclidean3d", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a bit of a cruft. Remove stray check for inside attribute. ", "B_clean_title": ["remov", "bit", "cruft", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. fixed bug. ", "B_clean_title": ["fix", "small", "bug", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a bug in the - - plane constructor. Fixed a bug in the near branch of PolyhedronsSet. fixed NPE in PolyhedronsSet. ", "B_clean_title": ["fix", "bug", "plane", "constructor", "fix", "bug", "near", "branch", "polyhedronsset", "polyhedron", "set", "fix", "npe", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. updated quat array. fixed a small bug. ", "B_clean_title": ["fix", "small", "bug", "updat", "quat", "array", "fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a bug in the - - plane constructor. Removed a redundant check. fixed bug. ", "B_clean_title": ["fix", "bug", "plane", "constructor", "remov", "redund", "check", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Fixed a bug in the near branch of PolyhedronsSet. fixed NPE in PolyhedronsSet fixed. ", "B_clean_title": ["fix", "small", "bug", "fix", "bug", "near", "branch", "polyhedronsset", "polyhedron", "set", "fix", "npe", "polyhedronsset", "polyhedron", "set", "fix"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. removed a bit from a jar. ", "B_clean_title": ["fix", "small", "bug", "remov", "bit", "jar"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed debug code. ", "B_clean_title": ["fix", "small", "bug", "remov", "debug", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Remove a couple of debug code. Revert previous patch. ", "B_clean_title": ["fix", "small", "bug", "remov", "coupl", "debug", "code", "revert", "previou", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed a redundant merge of PolyhedronsSet . boundaryFacet. fixed bug. ", "B_clean_title": ["fix", "small", "bug", "remov", "redund", "merg", "polyhedronsset", "polyhedron", "set", "boundaryfacet", "boundari", "facet", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "updated crossed crossed line. fixed bug. ", "B_clean_title": ["updat", "cross", "cross", "line", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet .. fixed bug. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the near branch of PolyhedronsSet. Remove stray check for inside attribute. ", "B_clean_title": ["fix", "bug", "near", "branch", "polyhedronsset", "polyhedron", "set", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet .. Remove stray check for inside attribute. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed debug code. Remove stray check for inside attribute. ", "B_clean_title": ["remov", "debug", "code", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a bug in the same line as the other two points on the plane. Fixed a bug in PolyhedronsSet .. fixed bug. ", "B_clean_title": ["fix", "bug", "same", "line", "as", "other", "two", "point", "plane", "fix", "bug", "polyhedronsset", "polyhedron", "set", "fix", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet .. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. removed a redundant line. ", "B_clean_title": ["fix", "small", "bug", "remov", "redund", "line"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add a missing + in StorelessCovariance. Remove a bit of a bit of code. ", "B_clean_title": ["add", "miss", "storelesscovari", "storeless", "covari", "remov", "bit", "bit", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add StorelessCovariance patch. Remove a bit of a bit of code. Remove stray return statement. ", "B_clean_title": ["add", "storelesscovari", "storeless", "covari", "patch", "remov", "bit", "bit", "code", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a redundant line. Remove stray return statement. ", "B_clean_title": ["remov", "redund", "line", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed patch from accidently removed pull request. fixed a small bug. ", "B_clean_title": ["remov", "patch", "accid", "remov", "pull", "request", "fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet .. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit to fix # 12. Remove inside attribute from patch. ", "B_clean_title": ["ad", "miss", "visit", "fix", "12", "remov", "insid", "attribut", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the size of the cut hyperplane if it was not found .. ", "B_clean_title": ["set", "size", "cut", "hyperplan", "it", "wa", "not", "found"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. cleaned up code. Remove stray check for edge effect. ", "B_clean_title": ["fix", "small", "bug", "clean", "up", "code", "remov", "stray", "check", "edg", "effect"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a bit of debug code. Remove a bit of code that was accidentally left in the last commit. Remove stray return statement. ", "B_clean_title": ["remov", "bit", "debug", "code", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Reset the size of the cut node to zero. Removed a couple of debug code. ", "B_clean_title": ["reset", "size", "cut", "node", "zero", "remov", "coupl", "debug", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter again .. Remove stray check for edge effect. ", "B_clean_title": ["set", "barycent", "again", "remov", "stray", "check", "edg", "effect"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added cut null check. Remove a redundant patch. Changed default size of the patch .. ", "B_clean_title": ["ad", "cut", "null", "check", "remov", "redund", "patch", "chang", "default", "size", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add a missing + in StorelessCovariance. fixed a small bug. ", "B_clean_title": ["add", "miss", "storelesscovari", "storeless", "covari", "fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Revert previous fix. ", "B_clean_title": ["revert", "previou", "fix"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of a cruft. Readded missing visit to fix merge issue. Add a missing + in StorelessCovariance. ", "B_clean_title": ["remov", "bit", "cruft", "read", "miss", "visit", "fix", "merg", "issu", "add", "miss", "storelesscovari", "storeless", "covari"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a couple of debug code. Set size to 0 when checking in - place ( fixes # 2362 ). ", "B_clean_title": ["remov", "coupl", "debug", "code", "set", "size", "when", "check", "place", "fix", "2362"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a redundant call to setBarycenter ( ). Remove stray return statement. ", "B_clean_title": ["remov", "redund", "call", "setbarycent", "set", "barycent", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a redundant line. Remove stray return statement. Add StorelessCovariance patch. ", "B_clean_title": ["remov", "redund", "line", "remov", "stray", "return", "statement", "add", "storelesscovari", "storeless", "covari", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added missing patch. ", "B_clean_title": ["ad", "miss", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a redundant call to setBarycenter ( ). ", "B_clean_title": ["remov", "redund", "call", "setbarycent", "set", "barycent"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the barycenter to be 1 . 0 / ( 4 * getSize ( ) ). added missing visit to fix # 1796. ", "B_clean_title": ["set", "barycent", "getsiz", "get", "size", "ad", "miss", "visit", "fix", "1796"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added visit to fix # 1296. Fixed a minor issue with fixed geometry size .. ", "B_clean_title": ["ad", "visit", "fix", "1296", "fix", "minor", "issu", "fix", "geometri", "size"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a couple of lines from the edge case. Set size ( ) to 3 . 0 for parallel crossings. ", "B_clean_title": ["remov", "coupl", "line", "edg", "case", "set", "size", "parallel", "cross"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet .. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed null cut. fixed a small bug. ", "B_clean_title": ["fix", "null", "cut", "fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Resetting frame opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl. Remove a bit of code that was accidentally left in the last commit. Readded missing visit. ", "B_clean_title": ["reset", "frame", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "read", "miss", "visit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the size of the cut node to zero if it wasn  t found. Remove stray patch code. ", "B_clean_title": ["set", "size", "cut", "node", "zero", "it", "wasn", "found", "remov", "stray", "patch", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a couple of tries to fix a merge conflict .. Readded missing visit. ", "B_clean_title": ["remov", "coupl", "tri", "fix", "merg", "conflict", "read", "miss", "visit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added cut null check. Remove a bit of code that was accidentally left in the last commit. Changed default size of the PolyhedronsSet to 3 . 0. ", "B_clean_title": ["ad", "cut", "null", "check", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "chang", "default", "size", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a minor issue with B + Rigid Body < - > world crossing. Remove stray return statement. ", "B_clean_title": ["fix", "minor", "issu", "rigid", "bodi", "world", "cross", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added fix for FacetsContributionVisitor. Remove stray return statement. ", "B_clean_title": ["ad", "fix", "facetscontributionvisitor", "facet", "contribut", "visitor", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the barycenter of the PolyhedronsSet object in firstIntersection. Remove stray return statement. ", "B_clean_title": ["set", "barycent", "polyhedronsset", "polyhedron", "set", "object", "firstintersect", "first", "intersect", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed patch from firstIntersection. Removed patch from PolyhedronsSet. Remove stray return statement. ", "B_clean_title": ["remov", "patch", "firstintersect", "first", "intersect", "remov", "patch", "polyhedronsset", "polyhedron", "set", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added a visit to fix a bug. Remove a bit of code that was accidentally left in the last commit. Remove stray check for inside attribute. ", "B_clean_title": ["ad", "visit", "fix", "bug", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed patch from pull request. ", "B_clean_title": ["remov", "patch", "pull", "request"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of a cruft. Remove inside check. ", "B_clean_title": ["remov", "bit", "cruft", "remov", "insid", "check"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added cut null check. removed patch from accidently removed line. ", "B_clean_title": ["ad", "cut", "null", "check", "remov", "patch", "accid", "remov", "line"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed null cut. Remove stray check for edge effect. Set originOffset to 0 ; @ Deprecated. ", "B_clean_title": ["fix", "null", "cut", "remov", "stray", "check", "edg", "effect", "set", "originoffset", "origin", "offset", "deprec"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing patch. ", "B_clean_title": ["ad", "miss", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed erroneous test. added missing visit to fix # 12. Remove inside attribute from patch .. ", "B_clean_title": ["fix", "erron", "test", "ad", "miss", "visit", "fix", "12", "remov", "insid", "attribut", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing patch. Remove stray check for edge effect. ", "B_clean_title": ["ad", "miss", "patch", "remov", "stray", "check", "edg", "effect"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter of sub - set. Fixed a bug in PolyhedronsSet caused by b - r8b0e. Remove stray patch. ", "B_clean_title": ["set", "barycent", "sub", "set", "fix", "bug", "polyhedronsset", "polyhedron", "set", "caus", "by", "r8b0e", "remov", "stray", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a minor issue with points in the cut hyperplane. removed a redundant line. Readded missing visit. ", "B_clean_title": ["fix", "minor", "issu", "point", "cut", "hyperplan", "remov", "redund", "line", "read", "miss", "visit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the cut hyperplane search. Remove stray return statement. ", "B_clean_title": ["fix", "bug", "cut", "hyperplan", "search", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added visit to fix # 1803. added missing visit to fix # 1803. Changed boundary facet point size to 3 . 0. ", "B_clean_title": ["ad", "visit", "fix", "1803", "ad", "miss", "visit", "fix", "1803", "chang", "boundari", "facet", "point", "size"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Modified line speed and line length. updated patch. Remove stray check for inside attribute. ", "B_clean_title": ["modifi", "line", "speed", "line", "length", "updat", "patch", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit to fix # 77. ", "B_clean_title": ["ad", "miss", "visit", "fix", "77"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a couple of tries to fix a merge issue. Readded missing visit. Plane intersection method used for 1 . 8. ", "B_clean_title": ["remov", "coupl", "tri", "fix", "merg", "issu", "read", "miss", "visit", "plane", "intersect", "method", "use"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Reverted accidental change of walk ( ). ", "B_clean_title": ["revert", "accident", "chang", "walk"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add StorelessCovariance patch. Remove a bit of a cruft. Set barycenter of Euclidean3D .. ", "B_clean_title": ["add", "storelesscovari", "storeless", "covari", "patch", "remov", "bit", "cruft", "set", "barycent", "euclidean3d"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add a boundary facet test to PolyhedronsSet. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["add", "boundari", "facet", "test", "polyhedronsset", "polyhedron", "set", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit to fix # 12. ", "B_clean_title": ["ad", "miss", "visit", "fix", "12"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add a patch for testing EP .. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["add", "patch", "test", "ep", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the barycenter of the PolyhedronsSet object to the same value as. Fixed a bug in PolyhedronsSet. ", "B_clean_title": ["set", "barycent", "polyhedronsset", "polyhedron", "set", "object", "same", "valu", "as", "fix", "bug", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit. ", "B_clean_title": ["ad", "miss", "visit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the - - fixed - search order .. reset size if not in case of cut. ", "B_clean_title": ["fix", "bug", "fix", "search", "order", "reset", "size", "not", "case", "cut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the barycenter of the PolyhedronsSet object in firstIntersection. Remove a bit of code that was accidentally left in the last commit. fixed a minor issue with the plane method. ", "B_clean_title": ["set", "barycent", "polyhedronsset", "polyhedron", "set", "object", "firstintersect", "first", "intersect", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "fix", "minor", "issu", "plane", "method"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a problematic empty line. Set barycenter attribute value to null. ", "B_clean_title": ["remov", "problemat", "empti", "line", "set", "barycent", "attribut", "valu", "null"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a minor issue with fixed geometry size .. ", "B_clean_title": ["fix", "minor", "issu", "fix", "geometri", "size"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["fix", "small", "bug", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the - - fixed - search order .. Remove a bit of a test code. ", "B_clean_title": ["fix", "bug", "fix", "search", "order", "remov", "bit", "test", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter attribute value to null. ", "B_clean_title": ["set", "barycent", "attribut", "valu", "null"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix a minor issue with missing patch. removed patch from accidently removed line. Set size = 0 after checking for in - line evidence. ", "B_clean_title": ["fix", "minor", "issu", "miss", "patch", "remov", "patch", "accid", "remov", "line", "set", "size", "after", "check", "line", "evid"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added missing visit to fix .. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["ad", "miss", "visit", "fix", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Reset the size of the PolyhedronsSet in case of a small issue. Remove stray return statement. ", "B_clean_title": ["reset", "size", "polyhedronsset", "polyhedron", "set", "case", "small", "issu", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of code that was accidentally left in the last commit. fixed a minor issue with BSP tree edges. ", "B_clean_title": ["remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "fix", "minor", "issu", "bsp", "tree", "edg"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet with a smaller size .. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "smaller", "size"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a minor issue with the plane method. Add a fix for crossing on the plane. ", "B_clean_title": ["fix", "minor", "issu", "plane", "method", "add", "fix", "cross", "plane"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the size of the cut node to zero in case of a geometry change. fixed null cut. updated patch. Removed the size from the patch .. ", "B_clean_title": ["set", "size", "cut", "node", "zero", "case", "geometri", "chang", "fix", "null", "cut", "updat", "patch", "remov", "size", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed null cut. Fixed a minor issue with missing patch .. Remove stray check for inside attribute. ", "B_clean_title": ["fix", "null", "cut", "fix", "minor", "issu", "miss", "patch", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the PolyhedronsSet .. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added cut null check. Fixed a bug in PolyhedronsSet where the hit3D crossed the plane. Remove stray patch. ", "B_clean_title": ["ad", "cut", "null", "check", "fix", "bug", "polyhedronsset", "polyhedron", "set", "where", "hit3d", "cross", "plane", "remov", "stray", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the - - fixed - search order .. Removed a redundant call to setBarycenter ( ). ", "B_clean_title": ["fix", "bug", "fix", "search", "order", "remov", "redund", "call", "setbarycent", "set", "barycent"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the - - fixed - search order .. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["fix", "bug", "fix", "search", "order", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter to 1 . 0 / ( 4 * getSize ( ) ). Remove a bit of code that was accidentally left in the last commit. Remove stray return statement. ", "B_clean_title": ["set", "barycent", "getsiz", "get", "size", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter manually .. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["set", "barycent", "manual", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter manually .. set barycenter again. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["set", "barycent", "manual", "set", "barycent", "again", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a bug. Remove a bit of a hack. ", "B_clean_title": ["fix", "bug", "remov", "bit", "hack"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "update patch for euclidean line. fixed a small bug. ", "B_clean_title": ["updat", "patch", "euclidean", "line", "fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed intermittent crossed point search. ", "B_clean_title": ["remov", "intermitt", "cross", "point", "search"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "set barycenter again. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["set", "barycent", "again", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Remove stray return statement. ", "B_clean_title": ["fix", "small", "bug", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed patch from pull request. ", "B_clean_title": ["fix", "small", "bug", "remov", "patch", "pull", "request"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "throw exception if crossed line is not found. Remove a bit of a cruft. ", "B_clean_title": ["throw", "except", "cross", "line", "not", "found", "remov", "bit", "cruft"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add StorelessCovariance patch. Remove a bit of a cruft. ", "B_clean_title": ["add", "storelesscovari", "storeless", "covari", "patch", "remov", "bit", "cruft"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["fix", "small", "bug", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove inside check. ", "B_clean_title": ["remov", "insid", "check"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of code that was accidentally left in the last commit. Remove stray check for inside attribute. ", "B_clean_title": ["remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed the size from the patch .. ", "B_clean_title": ["fix", "small", "bug", "remov", "size", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit to fix # 183. Remove a redundant patch. ", "B_clean_title": ["ad", "miss", "visit", "fix", "183", "remov", "redund", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add StorelessCovariance . initializeMatrix ( ). Remove a bit of a bit of code. ", "B_clean_title": ["add", "storelesscovari", "storeless", "covari", "initializematrix", "initi", "matrix", "remov", "bit", "bit", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added fix on FacetsContribution. Fixed a bug in PolyhedronsSet .. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["ad", "fix", "facetscontribut", "facet", "contribut", "fix", "bug", "polyhedronsset", "polyhedron", "set", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a couple of tries to fix a merge issue. fixed a minor issue with the plane method. ", "B_clean_title": ["remov", "coupl", "tri", "fix", "merg", "issu", "fix", "minor", "issu", "plane", "method"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "increased the size of the PolyhedronsSet to 3 . 0. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["increas", "size", "polyhedronsset", "polyhedron", "set", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed null cut. Remove boundaryFacet from PolyhedronsSet. ", "B_clean_title": ["fix", "null", "cut", "remov", "boundaryfacet", "boundari", "facet", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter to 1 . 0 / ( 4 * getSize ( ) ). Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["set", "barycent", "getsiz", "get", "size", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter of diff node. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["set", "barycent", "diff", "node", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added visit to fix # 1896. Remove a couple of debug code. ", "B_clean_title": ["ad", "visit", "fix", "1896", "remov", "coupl", "debug", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": " plane cross product erroneously removed from line .. added cut null check. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["plane", "cross", "product", "erron", "remov", "line", "ad", "cut", "null", "check", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a problematic empty line. Added a visit to fix # 12. ", "B_clean_title": ["remov", "problemat", "empti", "line", "ad", "visit", "fix", "12"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix euclidean intersection bug. Remove a bit of a cruft. Remove stray return statement. ", "B_clean_title": ["fix", "euclidean", "intersect", "bug", "remov", "bit", "cruft", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a redundant line. Resetting frame opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl. ", "B_clean_title": ["remov", "redund", "line", "reset", "frame", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a redundant line. Set barycenter attribute value. ", "B_clean_title": ["remov", "redund", "line", "set", "barycent", "attribut", "valu"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a minor issue with the far branch search .. ", "B_clean_title": ["fix", "minor", "issu", "far", "branch", "search"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added missing visit to fix .. Set barycenter. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["ad", "miss", "visit", "fix", "set", "barycent", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added a patch for testing forbidden intersections. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["ad", "patch", "test", "forbidden", "intersect", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Changed max size of the PolyhedronsSet if it was less than 0 .. removed a redundant line. ", "B_clean_title": ["chang", "max", "size", "polyhedronsset", "polyhedron", "set", "it", "wa", "less", "than", "remov", "redund", "line"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed null cut. cleaned up code. Remove stray check for inside attribute. ", "B_clean_title": ["fix", "null", "cut", "clean", "up", "code", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the barycenter of the PolyhedronsSet if it could not find a. ", "B_clean_title": ["set", "barycent", "polyhedronsset", "polyhedron", "set", "it", "could", "not", "find"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the far branch search .. Remove stray check for edge effect. ", "B_clean_title": ["fix", "bug", "far", "branch", "search", "remov", "stray", "check", "edg", "effect"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Remove a bit of code that was accidentally left in the last commit. Remove stray return statement. ", "B_clean_title": ["fix", "small", "bug", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added visit to fix # 1896. Added patch for crossing point on fixed plane. ", "B_clean_title": ["ad", "visit", "fix", "1896", "ad", "patch", "cross", "point", "fix", "plane"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit to fix # 183. fixed a small bug. Reverted accidental change of boundary facet .. ", "B_clean_title": ["ad", "miss", "visit", "fix", "183", "fix", "small", "bug", "revert", "accident", "chang", "boundari", "facet"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet .. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Changed boundary facet point to be in - place .. ", "B_clean_title": ["chang", "boundari", "facet", "point", "place"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the barycenter of the PolyhedronsSet object in firstIntersection. Set size of PolyhedronsSet .. Remove a redundant patch. Remove stray return statement. ", "B_clean_title": ["set", "barycent", "polyhedronsset", "polyhedron", "set", "object", "firstintersect", "first", "intersect", "set", "size", "polyhedronsset", "polyhedron", "set", "remov", "redund", "patch", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Fixed a bug in the PolyhedronsSet constructor. Set the barycenter of the PolyhedronsSet if it could not find a. ", "B_clean_title": ["fix", "small", "bug", "fix", "bug", "polyhedronsset", "polyhedron", "set", "constructor", "set", "barycent", "polyhedronsset", "polyhedron", "set", "it", "could", "not", "find"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a couple of debug code. Reduce size of the PolyhedronsSet barycenter to 3 . 0. ", "B_clean_title": ["remov", "coupl", "debug", "code", "reduc", "size", "polyhedronsset", "polyhedron", "set", "barycent"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet .. removed patch from accidently removed line. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "remov", "patch", "accid", "remov", "line"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a small bug in PolyhedronsSet. Remove stray patch. ", "B_clean_title": ["fix", "small", "bug", "polyhedronsset", "polyhedron", "set", "remov", "stray", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet where the hit3D crossed the plane. Remove stray patch. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "where", "hit3d", "cross", "plane", "remov", "stray", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of a bit of code. Remove inside attribute from patch .. ", "B_clean_title": ["remov", "bit", "bit", "code", "remov", "insid", "attribut", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. removed a couple of tries to fix the build. ", "B_clean_title": ["fix", "small", "bug", "remov", "coupl", "tri", "fix", "build"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": " handle erroneously in plane constructor. added missing visit to fix # 12. ", "B_clean_title": ["handl", "erron", "plane", "constructor", "ad", "miss", "visit", "fix", "12"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet where the boundaryFacet ( point  node ). Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "where", "boundaryfacet", "boundari", "facet", "point", "node", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a minor issue with closed opengl operations. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["fix", "minor", "issu", "close", "opengl", "oper", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added fix for added facets contribution. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["ad", "fix", "ad", "facet", "contribut", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Remove stray check for edge effect. ", "B_clean_title": ["fix", "small", "bug", "remov", "stray", "check", "edg", "effect"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit to fix # 12. Add StorelessCovariance patch. ", "B_clean_title": ["ad", "miss", "visit", "fix", "12", "add", "storelesscovari", "storeless", "covari", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter manually .. Remove a bit of code that was accidentally left in the last commit. Remove stray return statement. ", "B_clean_title": ["set", "barycent", "manual", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a bug in plane constructor. fixed a small bug. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["fix", "bug", "plane", "constructor", "fix", "small", "bug", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the - - fixed - search order .. Set the size of the cut hyperplane if it was not found .. Remove stray patch. ", "B_clean_title": ["fix", "bug", "fix", "search", "order", "set", "size", "cut", "hyperplan", "it", "wa", "not", "found", "remov", "stray", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add a missing line. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["add", "miss", "line", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the barycenter of the PolyhedronsSet if it could not find a. ", "B_clean_title": ["set", "barycent", "polyhedronsset", "polyhedron", "set", "it", "could", "not", "find"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Remove a redundant patch. ", "B_clean_title": ["fix", "small", "bug", "remov", "redund", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add missing patch. ", "B_clean_title": ["add", "miss", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet with fixed size .. Remove stray check for edge effect. fixed erroneous fallthrough in plane constructor. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "fix", "size", "remov", "stray", "check", "edg", "effect", "fix", "erron", "fallthrough", "plane", "constructor"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter. Removed a couple of debug code. ", "B_clean_title": ["set", "barycent", "remov", "coupl", "debug", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added missing patch. ", "B_clean_title": ["ad", "miss", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added missing patch. ", "B_clean_title": ["ad", "miss", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit. ", "B_clean_title": ["ad", "miss", "visit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a redundant line. Remove stray check for inside attribute. ", "B_clean_title": ["remov", "redund", "line", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added missing visit to fix # 183. Remove a bit of code that was accidentally left in the last commit. Remove stray return statement. ", "B_clean_title": ["ad", "miss", "visit", "fix", "183", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter to 1 . 0 / ( 4 * getSize ( ) ). Remove a bit of a hack. ", "B_clean_title": ["set", "barycent", "getsiz", "get", "size", "remov", "bit", "hack"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the barycenter of the PolyhedronsSet object in patch .. fixed a small bug. ", "B_clean_title": ["set", "barycent", "polyhedronsset", "polyhedron", "set", "object", "patch", "fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added a fix for the near branch search. fixed a small bug. ", "B_clean_title": ["ad", "fix", "near", "branch", "search", "fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter manually .. removed a redundant check. Remove stray return statement. ", "B_clean_title": ["set", "barycent", "manual", "remov", "redund", "check", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added a line of code to check for crossed edges. ", "B_clean_title": ["ad", "line", "code", "check", "cross", "edg"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "set barycenter again. removed patch for now. ", "B_clean_title": ["set", "barycent", "again", "remov", "patch", "now"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of code that was accidentally left in the last commit. Removed fixed bug in JSF. ", "B_clean_title": ["remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "fix", "bug", "jsf"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit to fix # 1568. Remove inside attribute from patch .. ", "B_clean_title": ["ad", "miss", "visit", "fix", "1568", "remov", "insid", "attribut", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit. Remove stray return statement. ", "B_clean_title": ["ad", "miss", "visit", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit to fix # 1796. Remove stray check for inside attribute. ", "B_clean_title": ["ad", "miss", "visit", "fix", "1796", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "increased the size of the PolyhedronsSet to 3 . 0. removed a redundant line. ", "B_clean_title": ["increas", "size", "polyhedronsset", "polyhedron", "set", "remov", "redund", "line"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a redundant line. Fix NPE in code. ", "B_clean_title": ["remov", "redund", "line", "fix", "npe", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet .. Readded missing visit. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "read", "miss", "visit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a couple of debug code. Removed fixed size .. Plane intersection method used for testing build break. ", "B_clean_title": ["remov", "coupl", "debug", "code", "remov", "fix", "size", "plane", "intersect", "method", "use", "test", "build", "break"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Set size to 0 when point is not contained. ", "B_clean_title": ["fix", "small", "bug", "set", "size", "when", "point", "not", "contain"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set cut size to 0. fixed a small bug. Remove stray check for edge effect. ", "B_clean_title": ["set", "cut", "size", "fix", "small", "bug", "remov", "stray", "check", "edg", "effect"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed null cut. Remove a bit of code that was accidentally left in the last commit. Remove stray patch. ", "B_clean_title": ["fix", "null", "cut", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "stray", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed patch from accidently removed PR. Remove stray return statement. ", "B_clean_title": ["remov", "patch", "accid", "remov", "pr", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the size of the cut node to zero in case of a geometry change. Remove boundaryFacet from PolyhedronsSet. ", "B_clean_title": ["set", "size", "cut", "node", "zero", "case", "geometri", "chang", "remov", "boundaryfacet", "boundari", "facet", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a crash. Remove stray check for edge effect. ", "B_clean_title": ["fix", "crash", "remov", "stray", "check", "edg", "effect"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet .. Remove stray patch. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "remov", "stray", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the size of the cut hyperplane if it was not found. ", "B_clean_title": ["set", "size", "cut", "hyperplan", "it", "wa", "not", "found"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of code that was accidentally left in the last commit. Removed patch from pull request. ", "B_clean_title": ["remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "patch", "pull", "request"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a minor issue with fixed geometry size .. ", "B_clean_title": ["fix", "minor", "issu", "fix", "geometri", "size"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the barycenter of the PolyhedronsSet object in firstIntersection. Remove a bit of a hack. ", "B_clean_title": ["set", "barycent", "polyhedronsset", "polyhedron", "set", "object", "firstintersect", "first", "intersect", "remov", "bit", "hack"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "throw exception if crossed line is not found. Fixed a bug in PolyhedronsSet with negative size .. ", "B_clean_title": ["throw", "except", "cross", "line", "not", "found", "fix", "bug", "polyhedronsset", "polyhedron", "set", "neg", "size"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix accidently removed line segment .. Remove stray return statement. ", "B_clean_title": ["fix", "accid", "remov", "line", "segment", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of code that was accidentally left in the last commit. Set size to 0 when point is not contained. ", "B_clean_title": ["remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "set", "size", "when", "point", "not", "contain"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter of diff node. Removed a couple of debug code. ", "B_clean_title": ["set", "barycent", "diff", "node", "remov", "coupl", "debug", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a couple incorrect lines. Remove stray return statement. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove stray check for edge effect. ", "B_clean_title": ["remov", "stray", "check", "edg", "effect"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Plane intersection method used for 1 . 5. Set the size of the cut node to 3 . 0. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["plane", "intersect", "method", "use", "set", "size", "cut", "node", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the barycenter of the PolyhedronsSet object to the same value as. Removed a couple of debug code. Remove stray return statement. ", "B_clean_title": ["set", "barycent", "polyhedronsset", "polyhedron", "set", "object", "same", "valu", "as", "remov", "coupl", "debug", "code", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a minor issue with closed opengl operations. Remove stray patch. ", "B_clean_title": ["fix", "minor", "issu", "close", "opengl", "oper", "remov", "stray", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Revert previous patch. ", "B_clean_title": ["revert", "previou", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Resetting frame opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl. Added visit to fix # 12. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["reset", "frame", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "ad", "visit", "fix", "12", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added fix for # 274. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["ad", "fix", "274", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added fix for FacetsContributionVisitor. added missing visit to fix # 12. ", "B_clean_title": ["ad", "fix", "facetscontributionvisitor", "facet", "contribut", "visitor", "ad", "miss", "visit", "fix", "12"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit to fix # 12. Readded missing visit. ", "B_clean_title": ["ad", "miss", "visit", "fix", "12", "read", "miss", "visit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a couple of debug code. Added missing visit to fix # 30. ", "B_clean_title": ["remov", "coupl", "debug", "code", "ad", "miss", "visit", "fix", "30"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter again .. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["set", "barycent", "again", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add a boundary facet test to PolyhedronsSet. Remove a bit of code that was accidentally left in the last commit. Remove stray return statement. ", "B_clean_title": ["add", "boundari", "facet", "test", "polyhedronsset", "polyhedron", "set", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of code that was accidentally left in the last commit. Reverted accidental change of walk ( ). ", "B_clean_title": ["remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "revert", "accident", "chang", "walk"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set the size of the cut node to 3 . 0. Removed patch to prevent null error in PolyhedronsSet. ", "B_clean_title": ["set", "size", "cut", "node", "remov", "patch", "prevent", "null", "error", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter for removed nodes. fixed a small bug. ", "B_clean_title": ["set", "barycent", "remov", "node", "fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of a cruft. Remove stray patch. Add a missing + in StorelessCovariance. ", "B_clean_title": ["remov", "bit", "cruft", "remov", "stray", "patch", "add", "miss", "storelesscovari", "storeless", "covari"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": " handle erroneously in plane constructor. Fixed a minor issue with missing setBarycenter. removed a redundant line. Remove stray return statement. ", "B_clean_title": ["handl", "erron", "plane", "constructor", "fix", "minor", "issu", "miss", "setbarycent", "set", "barycent", "remov", "redund", "line", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a problematic empty line. Removed patch for setting barycenter. ", "B_clean_title": ["remov", "problemat", "empti", "line", "remov", "patch", "set", "barycent"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added visit to fix added facets contribution. added missing visit to fix # 12. Remove stray return statement. ", "B_clean_title": ["ad", "visit", "fix", "ad", "facet", "contribut", "ad", "miss", "visit", "fix", "12", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Remove stray patch. ", "B_clean_title": ["fix", "small", "bug", "remov", "stray", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Reset the size of the PolyhedronsSet as well. Remove a redundant patch. ", "B_clean_title": ["reset", "size", "polyhedronsset", "polyhedron", "set", "as", "well", "remov", "redund", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added cut null check. removed a couple of lines from the edge case. ", "B_clean_title": ["ad", "cut", "null", "check", "remov", "coupl", "line", "edg", "case"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a couple of debug code. Removed patch for inside attribute. ", "B_clean_title": ["remov", "coupl", "debug", "code", "remov", "patch", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Removed a couple of debug code. ", "B_clean_title": ["fix", "small", "bug", "remov", "coupl", "debug", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "added missing visit to getTree ( true ). added missing visit to fix # 12. ", "B_clean_title": ["ad", "miss", "visit", "gettre", "get", "tree", "true", "ad", "miss", "visit", "fix", "12"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "@@ fix_euclidean_to_world refactoring. Remove a bit of a bit of code. ", "B_clean_title": ["fix", "euclidean", "world", "refactor", "remov", "bit", "bit", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a bit of code that was accidentally left in the last commit. Revert accidently removed patch. ", "B_clean_title": ["remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "revert", "accid", "remov", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Set barycenter manually .. Fixed a bug in PolyhedronsSet where the cut hyperplane was not found .. ", "B_clean_title": ["set", "barycent", "manual", "fix", "bug", "polyhedronsset", "polyhedron", "set", "where", "cut", "hyperplan", "wa", "not", "found"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "removed a redundant line. Changed boundary facet point to be in the same region as the point .. ", "B_clean_title": ["remov", "redund", "line", "chang", "boundari", "facet", "point", "same", "region", "as", "point"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in PolyhedronsSet .. Remove stray check for inside attribute. ", "B_clean_title": ["fix", "bug", "polyhedronsset", "polyhedron", "set", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the - - fixed - search order .. Remove a bit of code that was accidentally left in the last commit. Remove inside attribute from patch .. ", "B_clean_title": ["fix", "bug", "fix", "search", "order", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit", "remov", "insid", "attribut", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove a couple of debug code. Set the size of the PolyhedronsSet attribute to zero if the region is not. ", "B_clean_title": ["remov", "coupl", "debug", "code", "set", "size", "polyhedronsset", "polyhedron", "set", "attribut", "zero", "region", "not"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Remove a redundant patch. ", "B_clean_title": ["fix", "small", "bug", "remov", "redund", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add a fix for crossing the line. Remove stray check for inside attribute. ", "B_clean_title": ["add", "fix", "cross", "line", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed bug. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["fix", "bug", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add a missing + in StorelessCovariance. Set barycenter manually .. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["add", "miss", "storelesscovari", "storeless", "covari", "set", "barycent", "manual", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "increased the size of the PolyhedronsSet to 3 . 0. Removed a redundant call to setBarycenter ( ). ", "B_clean_title": ["increas", "size", "polyhedronsset", "polyhedron", "set", "remov", "redund", "call", "setbarycent", "set", "barycent"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Remove stray return statement. Add StorelessCovariance patch. ", "B_clean_title": ["remov", "stray", "return", "statement", "add", "storelesscovari", "storeless", "covari", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Oops  now search in the far branch  but found a null pointer. ", "B_clean_title": ["oop", "now", "search", "far", "branch", "but", "found", "null", "pointer"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed a small bug. Remove a bit of code that was accidentally left in the last commit. ", "B_clean_title": ["fix", "small", "bug", "remov", "bit", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "fixed search error. Removed unused local variable .. ", "B_clean_title": ["fix", "search", "error", "remov", "unus", "local", "variabl"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix error in previous patch. Fixed a bug in the plane accident patch .. ", "B_clean_title": ["fix", "error", "previou", "patch", "fix", "bug", "plane", "accid", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added missing point exception. Removed patch from PolyhedronsSet. ", "B_clean_title": ["ad", "miss", "point", "except", "remov", "patch", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix bug in JSF. ", "B_clean_title": ["fix", "bug", "jsf"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix RSRepair. ", "B_clean_title": ["fix", "rsrepair", "rs", "repair"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix BSP tree reference. ", "B_clean_title": ["fix", "bsp", "tree", "refer"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Changed the size of the cross section of the PolyhedronsSet .. Remove stray return statement. ", "B_clean_title": ["chang", "size", "cross", "section", "polyhedronsset", "polyhedron", "set", "remov", "stray", "return", "statement"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix RSRepair. ", "B_clean_title": ["fix", "rsrepair", "rs", "repair"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix RSRepair. ", "B_clean_title": ["fix", "rsrepair", "rs", "repair"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed fixed accident in RSRepair  removed removed test. ", "B_clean_title": ["remov", "fix", "accid", "rsrepair", "rs", "repair", "remov", "remov", "test"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in RSRepair .. Remove stray patch. ", "B_clean_title": ["fix", "bug", "rsrepair", "rs", "repair", "remov", "stray", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix RS - 7715. ", "B_clean_title": ["fix", "rs", "7715"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Added missing point exception. Removed a bit of a test code. ", "B_clean_title": ["ad", "miss", "point", "except", "remov", "bit", "test", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed stray line from previous fix .. ", "B_clean_title": ["remov", "stray", "line", "previou", "fix"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a redundant check. Remove stray check for inside attribute. ", "B_clean_title": ["remov", "redund", "check", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed a bug in the near branch of PolyhedronsSet. ", "B_clean_title": ["fix", "bug", "near", "branch", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed broken patch. ", "B_clean_title": ["remov", "broken", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a redundant empty line. ", "B_clean_title": ["remov", "redund", "empti", "line"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add quat attribute to PolyhedronsSet. Remove stray check for inside attribute. ", "B_clean_title": ["add", "quat", "attribut", "polyhedronsset", "polyhedron", "set", "remov", "stray", "check", "insid", "attribut"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "updated fix. ", "B_clean_title": ["updat", "fix"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a bit of a debug code. Removed fixed bug in RSRepair_Bug_dot_jar_Commons. ", "B_clean_title": ["remov", "bit", "debug", "code", "remov", "fix", "bug", "rsrepair", "bug", "dot", "jar", "common", "rs", "repair"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Add missing patch. ", "B_clean_title": ["add", "miss", "patch"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix RS - 7733 - missing final double  . ", "B_clean_title": ["fix", "rs", "7733", "miss", "final", "doubl"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Changed size of the near branch to 3 . 0. Removed a bit of a hack to fix erroneous build .. ", "B_clean_title": ["chang", "size", "near", "branch", "remov", "bit", "hack", "fix", "erron", "build"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fixed bug in RSRepair. ", "B_clean_title": ["fix", "bug", "rsrepair", "rs", "repair"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a couple of debug printlns. Changed possible value of setBarycenter. ", "B_clean_title": ["remov", "coupl", "debug", "println", "chang", "possibl", "valu", "setbarycent", "set", "barycent"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a bit of a rebase. ", "B_clean_title": ["remov", "bit", "rebas"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Removed a unused variable. ", "B_clean_title": ["remov", "unus", "variabl"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix NPE in PolyhedronsSet .. ", "B_clean_title": ["fix", "npe", "polyhedronsset", "polyhedron", "set"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix broken patch. Removed a bit of a test code. ", "B_clean_title": ["fix", "broken", "patch", "remov", "bit", "test", "code"]},
{"A_title": "PolyhedronsSet.firstIntersection(Vector3D point Line line) sometimes reports intersections on wrong end of lineI constructed a PolyhedronsSet from a list of triangular faces representing an icosphere (using the instructions found at https://mail-archives.apache.org/mod_mbox/commons-user/201208.mbox/<5039FE35.2090307@free.fr>).  This seems to produce correct INSIDE/OUTSIDE results for randomly chosen points.  I think my mesh triangles are defined appropriately.  However using PolyhedronsSet.firstIntersection(Vector3D point Line line) to shoot randomly oriented rays from the origin sometimes gives a wrong mesh intersection point behind the origin.  The intersection algorithm is sometimes picking up faces of the sphere-shaped mesh on the wrong semi-infinite portion of the line i.e. meshIntersectionPoint.subtract(point).dotProduct(line.getDirection())<0 where point is the Vector3D at center of the sphere and line extends outward through the mesh.  I think the dot product above should always be positive. If multiple intersections exist along a whole line then the first one in front of the lines origin should be returned. This makes ray tracing with a PolyhedronsSet possible.", "A_clean_title": ["polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "sometim", "report", "intersect", "wrong", "end", "linei", "line", "construct", "polyhedronsset", "polyhedron", "set", "list", "triangular", "face", "repres", "icospher", "instruct", "found", "at", "http", "mail", "archiv", "apach", "user", "201208", "mbox", "org", "mod", "mbox", "common", "5039fe35", "2090307", "free", "fr", "thi", "seem", "produc", "correct", "insid", "outsid", "result", "randomli", "chosen", "point", "think", "my", "mesh", "triangl", "are", "defin", "appropri", "howev", "polyhedronsset", "firstintersect", "polyhedron", "set", "first", "intersect", "vector3d", "point", "line", "line", "shoot", "randomli", "orient", "ray", "origin", "sometim", "give", "wrong", "mesh", "intersect", "point", "behind", "origin", "intersect", "algorithm", "sometim", "pick", "up", "face", "sphere", "shape", "mesh", "wrong", "semi", "infinit", "portion", "line", "meshintersectionpoint", "subtract", "mesh", "intersect", "point", "point", "dotproduct", "dot", "product", "line", "getdirect", "get", "direct", "where", "point", "vector3d", "at", "center", "sphere", "line", "extend", "outward", "through", "mesh", "think", "dot", "product", "abov", "alway", "posit", "multipl", "intersect", "exist", "along", "whole", "line", "then", "first", "one", "front", "line", "origin", "return", "thi", "make", "ray", "trace", "polyhedronsset", "polyhedron", "set", "possibl"], "B_title": "Fix RSRepair. ", "B_clean_title": ["fix", "rsrepair", "rs", "repair"]},
{"A_title": "Inconsistent interpretation of ambiguous time during DSTThe inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now it always returns the earlier instant (summer time) during an overlap.", "A_clean_title": ["inconsist", "interpret", "ambigu", "time", "dure", "dstthe", "dst", "inconsist", "appear", "timezon", "europ", "london", "these", "three", "datetim", "date", "time", "object", "all", "repres", "same", "moment", "time", "even", "they", "are", "ambigu", "now", "it", "alway", "return", "earlier", "instant", "summer", "time", "dure", "overlap"], "B_title": "Fixed incorrect patching. ", "B_clean_title": ["fix", "incorrect", "patch"]},
{"A_title": "function arguments should not be optimized awayNone", "A_clean_title": ["function", "argument", "not", "optim", "awaynon", "away", "none"], "B_title": "Fix days of unused vars getting deleted. ", "B_clean_title": ["fix", "day", "unus", "var", "get", "delet"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "DiscreteDistribution was acting up with a false log output. ", "B_clean_title": ["discretedistribut", "discret", "distribut", "wa", "act", "up", "fals", "log", "output"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . java. ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove sample from DiscreteDistribution. ", "B_clean_title": ["remov", "sampl", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix Object . array to avoid illegal reference. ", "B_clean_title": ["fix", "object", "array", "avoid", "illeg", "refer"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sampleSize <= 0. ", "B_clean_title": ["throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove sample from the DiscreteDistribution example .. ", "B_clean_title": ["remov", "sampl", "discretedistribut", "discret", "distribut", "exampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove sample from DiscreteDistribution. ", "B_clean_title": ["remov", "sampl", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Keep sample in looping over DiscreteDistribution. ", "B_clean_title": ["keep", "sampl", "loop", "over", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sampleSize < = 0. ", "B_clean_title": ["throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sampleSize < 0. ", "B_clean_title": ["throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix bug in DiscreteDistribution . java. ", "B_clean_title": ["fix", "bug", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove sample from patch collection. ", "B_clean_title": ["remov", "sampl", "patch", "collect"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix MWE - 7764. Updated definition of DiscreteDistribution. ", "B_clean_title": ["fix", "mwe", "7764", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Add a missing assignment. Updated definition of sample ( ) .. ", "B_clean_title": ["add", "miss", "patch", "add", "miss", "assign", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of DiscreteDistribution. ", "B_clean_title": ["updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add high precision array to ND array .. Fix the bug in MathArrays . set ( double ). Remove unused code. ", "B_clean_title": ["add", "high", "precis", "array", "nd", "array", "fix", "bug", "matharray", "math", "array", "set", "doubl", "remov", "unus", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. Remove a redundant error reported by UnStrictlyPositiveException .. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "remov", "redund", "error", "report", "by", "unstrictlypositiveexcept", "un", "strictli", "posit", "except"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for MathArrays. Added patch for DiscreteDistribution. Remove a couple incorrect lines from the code. ", "B_clean_title": ["ad", "patch", "matharray", "math", "array", "ad", "patch", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "line", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of DiscreteDistribution. Add z = 1 . 0 / 120 . 0 in GenProg_Defects4. Fix the for loop. ", "B_clean_title": ["updat", "definit", "discretedistribut", "discret", "distribut", "add", "120", "genprog", "defects4", "gen", "prog", "fix", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated DiscreteDistribution . sample ( ). Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["updat", "discretedistribut", "discret", "distribut", "sampl", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing int newSize. Updated definition of sample ( ) .. ", "B_clean_title": ["add", "miss", "int", "newsiz", "new", "size", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Remove a couple incorrect code. ", "B_clean_title": ["add", "miss", "patch", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove erroneous fallthrough in DiscreteDistribution . sample ( ). ", "B_clean_title": ["remov", "erron", "fallthrough", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Added missing int. Add a missing assignment. Remove erroneous fallthrough in DiscreteDistribution . sample ( ). ", "B_clean_title": ["ad", "miss", "patch", "ad", "miss", "int", "add", "miss", "assign", "remov", "erron", "fallthrough", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant empty line. Added missing int. ", "B_clean_title": ["remov", "redund", "empti", "line", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add zb value to infinite array length .. Fix MWE - 7764. Remove unused sample method. ", "B_clean_title": ["add", "zb", "valu", "infinit", "array", "length", "fix", "mwe", "7764", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added a patch for 157  to prevent the same problem from being ignored .. Fix a bug in DiscreteDistribution .. ", "B_clean_title": ["ad", "patch", "157", "prevent", "same", "problem", "be", "ignor", "fix", "bug", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for MathArrays . normalizeArray ( ). Add a missing assignment. Remove unused sample value. ", "B_clean_title": ["ad", "patch", "matharray", "math", "array", "normalizearray", "normal", "array", "add", "miss", "assign", "remov", "unus", "sampl", "valu"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Put the sample on the right side. ", "B_clean_title": ["put", "sampl", "right", "side"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a couple incorrect code. Added missing patch. ", "B_clean_title": ["add", "miss", "assign", "remov", "coupl", "incorrect", "code", "ad", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["updat", "sampl", "method", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for LOGNORMALIZE_NAN. Remove a redundant error reported by UnStrictlyPositiveException .. ", "B_clean_title": ["ad", "patch", "lognorm", "nan", "remov", "redund", "error", "report", "by", "unstrictlypositiveexcept", "un", "strictli", "posit", "except"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for 157. Remove a couple incorrect lines from the code. ", "B_clean_title": ["ad", "patch", "157", "remov", "coupl", "incorrect", "line", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add zb and resultHigh to NAN patch. Added patch for DiscreteDistribution. StrictlyPositiveException was not strictly positive .. ", "B_clean_title": ["add", "zb", "resulthigh", "result", "high", "nan", "patch", "ad", "patch", "discretedistribut", "discret", "distribut", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "not", "strictli", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["ad", "miss", "patch", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Removed unused code. Added missing int. ", "B_clean_title": ["add", "miss", "assign", "remov", "unus", "code", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect code. Add missing int newSize. ", "B_clean_title": ["remov", "coupl", "incorrect", "code", "add", "miss", "int", "newsiz", "new", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove unused sample method. Added missing patch. Fix NPE. ", "B_clean_title": ["add", "miss", "assign", "remov", "unus", "sampl", "method", "ad", "miss", "patch", "fix", "npe"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite .. Add missing patch. Add a missing assignment. Remove sample from the patch .. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "add", "miss", "patch", "add", "miss", "assign", "remov", "sampl", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Updated definition of sample ( ) .. Added patch for MathArrays. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "updat", "definit", "sampl", "ad", "patch", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the patch for the infinite array implementation .. Add missing int newSize. Removed some necessary code. ", "B_clean_title": ["add", "patch", "infinit", "array", "implement", "add", "miss", "int", "newsiz", "new", "size", "remov", "some", "necessari", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Keep going until I figure out the source of the numerical inaccuracies .. ", "B_clean_title": ["keep", "go", "until", "figur", "out", "sourc", "numer", "inaccuraci"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed some necessary code. Add missing patch .. Fix MWE - 7764. ", "B_clean_title": ["remov", "some", "necessari", "code", "add", "miss", "patch", "fix", "mwe", "7764"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Updated DiscreteDistribution . sample ( ). Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["ad", "miss", "patch", "updat", "discretedistribut", "discret", "distribut", "sampl", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix the bug in MathArrays . set ( double ). Remove unused sample method. ", "B_clean_title": ["fix", "bug", "matharray", "math", "array", "set", "doubl", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the patch for MathArrays . normalizeArray ( double  double  double ). Remove unused sample value. ", "B_clean_title": ["add", "patch", "matharray", "math", "array", "normalizearray", "normal", "array", "doubl", "doubl", "doubl", "remov", "unus", "sampl", "valu"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Remove a couple incorrect lines. ", "B_clean_title": ["add", "miss", "patch", "remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of DiscreteDistribution. Added patch for isInfinite. ", "B_clean_title": ["updat", "definit", "discretedistribut", "discret", "distribut", "ad", "patch", "isinfinit", "infinit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Added missing int. Fix NPE in MathArrays . java. Remove unused code. ", "B_clean_title": ["ad", "miss", "patch", "ad", "miss", "int", "fix", "npe", "matharray", "math", "array", "java", "remov", "unus", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["add", "miss", "assign", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Put back DiscreteDistribution . sample ( ). Add missing int newSize. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "put", "back", "discretedistribut", "discret", "distribut", "sampl", "add", "miss", "int", "newsiz", "new", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix a bit of code. ", "B_clean_title": ["fix", "bit", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Changed min / max range of DiscreteDistribution .. Remove a redundant error message. ", "B_clean_title": ["chang", "min", "max", "rang", "discretedistribut", "discret", "distribut", "remov", "redund", "error", "messag"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove oversampling .. Added missing patch. Added missing int. ", "B_clean_title": ["remov", "oversampl", "ad", "miss", "patch", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove oversampling .. Add one more test. ", "B_clean_title": ["remov", "oversampl", "add", "one", "more", "test"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant error reported by UnStrictlyPositiveException .. Added throw exception if it is not infinite  patched. Added patch for isInfinite / isNaN in MathArrays. Fix MWE - 7764. ", "B_clean_title": ["remov", "redund", "error", "report", "by", "unstrictlypositiveexcept", "un", "strictli", "posit", "except", "ad", "throw", "except", "it", "not", "infinit", "patch", "ad", "patch", "isinfinit", "infinit", "isnan", "na", "matharray", "math", "array", "fix", "mwe", "7764"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove 10 + 186 from DiscreteDistribution .. Added patch for isInfinite. Fix MWE - 7764. ", "B_clean_title": ["remov", "10", "186", "discretedistribut", "discret", "distribut", "ad", "patch", "isinfinit", "infinit", "fix", "mwe", "7764"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of sample ( ) .. Add missing int newSize. ", "B_clean_title": ["updat", "definit", "sampl", "add", "miss", "int", "newsiz", "new", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added throw exception if it is not infinite  patched. Updated definition of DiscreteDistribution. ", "B_clean_title": ["ad", "throw", "except", "it", "not", "infinit", "patch", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["ad", "miss", "patch", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing facta variable to MathArrays . java. Add a missing assignment. Remove unused sample method .. ", "B_clean_title": ["add", "miss", "facta", "variabl", "matharray", "math", "array", "java", "add", "miss", "assign", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of DiscreteDistribution. ", "B_clean_title": ["updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add 0 . 0 to fix the build .. Add a missing assignment. Remove unused sample method. ", "B_clean_title": ["add", "fix", "build", "add", "miss", "assign", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove a redundant line. Added patch for isInfinite. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "redund", "line", "ad", "patch", "isinfinit", "infinit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method. Add 0 . 0 to fix infinities in MathArrays. Added missing int. ", "B_clean_title": ["remov", "unus", "sampl", "method", "add", "fix", "infin", "matharray", "math", "array", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. Updated definition of DiscreteDistribution. Add NAN normalization patch. Added patch for isNaN ( ). ", "B_clean_title": ["updat", "sampl", "method", "updat", "definit", "discretedistribut", "discret", "distribut", "add", "nan", "normal", "patch", "ad", "patch", "isnan", "na"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. StrictlyPositiveException was thrown with too many samples .. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "thrown", "too", "mani", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix the for - loop of MathArrays .. Remove a couple incorrect lines. ", "B_clean_title": ["fix", "loop", "matharray", "math", "array", "remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for MathArrays . normalizeArray ( ). Added patch for DiscreteDistribution. Removed some necessary code. ", "B_clean_title": ["ad", "patch", "matharray", "math", "array", "normalizearray", "normal", "array", "ad", "patch", "discretedistribut", "discret", "distribut", "remov", "some", "necessari", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect code. Fix the for loop. ", "B_clean_title": ["remov", "coupl", "incorrect", "code", "fix", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added throw exception if it is not infinite  patched. Added patch for isInfinite / isNaN in MathArrays. Fix MWE - 7764. Remove a couple incorrect code. ", "B_clean_title": ["ad", "throw", "except", "it", "not", "infinit", "patch", "ad", "patch", "isinfinit", "infinit", "isnan", "na", "matharray", "math", "array", "fix", "mwe", "7764", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a couple incorrect code. Added missing patch. Fix month / year issue. ", "B_clean_title": ["add", "miss", "assign", "remov", "coupl", "incorrect", "code", "ad", "miss", "patch", "fix", "month", "year", "issu"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Remove a couple incorrect code. ", "B_clean_title": ["add", "miss", "patch", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Updated definition of DiscreteDistribution. ", "B_clean_title": ["ad", "miss", "patch", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove unused sample method. Add zb and resultHigh to NAN patch. ", "B_clean_title": ["add", "miss", "assign", "remov", "unus", "sampl", "method", "add", "zb", "resulthigh", "result", "high", "nan", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing patch. Removed a couple incorrect lines. ", "B_clean_title": ["add", "miss", "patch", "remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Fix NPE. Add a missing assignment. Remove sample from patch .. ", "B_clean_title": ["ad", "miss", "patch", "fix", "npe", "add", "miss", "assign", "remov", "sampl", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove a couple incorrect code. Added patch for MathArrays. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "code", "ad", "patch", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add 0 . 0 to fix the build .. Remove unused sample method .. ", "B_clean_title": ["add", "fix", "build", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated DiscreteDistribution . sample ( ). Remove a couple incorrect code. ", "B_clean_title": ["updat", "discretedistribut", "discret", "distribut", "sampl", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove a couple incorrect code. ", "B_clean_title": ["ad", "miss", "patch", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Missing patch. ", "B_clean_title": ["add", "miss", "assign", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. Added missing patch. Remove a couple incorrect lines from the code. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "ad", "miss", "patch", "remov", "coupl", "incorrect", "line", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add z / rev .. Added missing patch. Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["add", "rev", "ad", "miss", "patch", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove unused sample method. Add zb and resultHigh to NAN patch. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "unus", "sampl", "method", "add", "zb", "resulthigh", "result", "high", "nan", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Added missing patch. ", "B_clean_title": ["add", "miss", "assign", "ad", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Fix a bug in MathArrays . isNaN ( ) .. Remove a couple incorrect lines. ", "B_clean_title": ["ad", "miss", "patch", "fix", "bug", "matharray", "math", "array", "isnan", "na", "remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove unused sample method .. Added missing patch. Fix NPE in MathArrays. ", "B_clean_title": ["add", "miss", "assign", "remov", "unus", "sampl", "method", "ad", "miss", "patch", "fix", "npe", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Updated definition of sample ( ) .. Added patch for isInfinite. Add missing patch. ", "B_clean_title": ["add", "miss", "assign", "updat", "definit", "sampl", "ad", "patch", "isinfinit", "infinit", "add", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove sample from the patch .. Fix a bug in MathArrays. ", "B_clean_title": ["add", "miss", "assign", "remov", "sampl", "patch", "fix", "bug", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Added missing patch. Fix for bug 687 build .. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "ad", "miss", "patch", "fix", "bug", "687", "build"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. StrictlyPositiveException was not strictly positive .. Add zb value to infinite array fix. ", "B_clean_title": ["updat", "sampl", "method", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "not", "strictli", "posit", "add", "zb", "valu", "infinit", "array", "fix"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add zb to fix the build .. Fix NPE in MathArrays. Add a missing assignment. Remove unused variable. ", "B_clean_title": ["add", "zb", "fix", "build", "fix", "npe", "matharray", "math", "array", "add", "miss", "assign", "remov", "unus", "variabl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "StrictlyPositiveException was thrown with too few samples. Add the fix in MathArrays . isInfinite ( ) .. Add missing int newSize. ", "B_clean_title": ["strictlypositiveexcept", "strictli", "posit", "except", "wa", "thrown", "too", "few", "sampl", "add", "fix", "matharray", "math", "array", "isinfinit", "infinit", "add", "miss", "int", "newsiz", "new", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Added patch for isInfinite. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "ad", "patch", "isinfinit", "infinit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing int .. Fix a bug in DiscreteDistribution . get ( i ). Remove a redundant empty line. ", "B_clean_title": ["ad", "miss", "int", "fix", "bug", "discretedistribut", "discret", "distribut", "get", "remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for MathArrays. Added patch for DiscreteDistribution. Updated definition of sample ( ) .. ", "B_clean_title": ["ad", "patch", "matharray", "math", "array", "ad", "patch", "discretedistribut", "discret", "distribut", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Added missing int. Add a missing assignment. Remove unused sample method. ", "B_clean_title": ["ad", "miss", "patch", "ad", "miss", "int", "add", "miss", "assign", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove a redundant line. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the patch for MathArrays. Removed some necessary code. ", "B_clean_title": ["add", "patch", "matharray", "math", "array", "remov", "some", "necessari", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated DiscreteDistribution . sample ( ). Remove a couple incorrect lines. ", "B_clean_title": ["updat", "discretedistribut", "discret", "distribut", "sampl", "remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove a redundant empty line. Add missing int newSize. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "redund", "empti", "line", "add", "miss", "int", "newsiz", "new", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant empty line. ", "B_clean_title": ["remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant empty line. ", "B_clean_title": ["remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant line. Added missing patch. Fix NPE. ", "B_clean_title": ["remov", "redund", "line", "ad", "miss", "patch", "fix", "npe"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated DiscreteDistribution with new patch code. StrictlyPositiveException was not strictly positive. Add zb value to infinite array fix. ", "B_clean_title": ["updat", "discretedistribut", "discret", "distribut", "new", "patch", "code", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "not", "strictli", "posit", "add", "zb", "valu", "infinit", "array", "fix"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of DiscreteDistribution. ", "B_clean_title": ["updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove a couple incorrect lines from DiscreteDistribution . java. Add missing patch. ", "B_clean_title": ["ad", "miss", "patch", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java", "add", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Fix NPE in MathArrays .. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "fix", "npe", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add NAN to MathArrays  patched. Fix a bug in MathArrays that expanded after the expanded array became too large. Fix a bug in DiscreteDistribution . get ( i ). Remove unused sample method .. ", "B_clean_title": ["add", "nan", "matharray", "math", "array", "patch", "fix", "bug", "matharray", "math", "array", "that", "expand", "after", "expand", "array", "becam", "too", "larg", "fix", "bug", "discretedistribut", "discret", "distribut", "get", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Add a missing assignment. Remove a couple incorrect code. ", "B_clean_title": ["add", "miss", "patch", "add", "miss", "assign", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch .. Added patch for DiscreteDistribution. Remove a couple incorrect code. ", "B_clean_title": ["ad", "miss", "patch", "ad", "patch", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove sample from patch .. Added missing patch. Added missing int. ", "B_clean_title": ["add", "miss", "assign", "remov", "sampl", "patch", "ad", "miss", "patch", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of sample ( ) .. ", "B_clean_title": ["updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. Add a missing assignment. Updated definition of sample ( ) .. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "add", "miss", "assign", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Updated definition of DiscreteDistribution. ", "B_clean_title": ["add", "miss", "assign", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed patch from DiscreteDistribution . sample ( ) .. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Removed a redundant empty line. Added patch for isInfinite. Added missing patch. ", "B_clean_title": ["add", "miss", "assign", "remov", "redund", "empti", "line", "ad", "patch", "isinfinit", "infinit", "ad", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite ( ) .. Add missing patch. Updated sample method. StrictlyPositiveException was thrown with too few samples. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "add", "miss", "patch", "updat", "sampl", "method", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "thrown", "too", "few", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a redundant empty line. Add missing facta variable to fix the build .. ", "B_clean_title": ["add", "miss", "assign", "remov", "redund", "empti", "line", "add", "miss", "facta", "variabl", "fix", "build"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. StrictlyPositiveException was thrown with too few samples. Add zb value to infinite array fix. Fix the for - loop of ARRAY_SUMS_TO_ZERO. ", "B_clean_title": ["updat", "sampl", "method", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "thrown", "too", "few", "sampl", "add", "zb", "valu", "infinit", "array", "fix", "fix", "loop", "array", "sum", "zero"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. StrictlyPositiveException was not strictly positive .. Add zb and idx = 0 ;. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "not", "strictli", "posit", "add", "zb", "idx"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the missing patch. Fix a bug in DiscreteDistribution .. ", "B_clean_title": ["add", "miss", "patch", "fix", "bug", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a patch for DiscreteDistribution. Remove a redundant empty line. Added patch for isInfinite. ", "B_clean_title": ["add", "patch", "discretedistribut", "discret", "distribut", "remov", "redund", "empti", "line", "ad", "patch", "isinfinit", "infinit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a couple incorrect lines from the code. Add missing facta variable to MathArrays . java. ", "B_clean_title": ["add", "miss", "assign", "remov", "coupl", "incorrect", "line", "code", "add", "miss", "facta", "variabl", "matharray", "math", "array", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Added missing int .. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. Add a missing assignment. StrictlyPositiveException was notStrictlyPositiveException at the beginning of the file. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "add", "miss", "assign", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "at", "begin", "file"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for GROOVY - 816. Remove a couple incorrect lines. ", "B_clean_title": ["ad", "patch", "groovi", "816", "remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant line. ", "B_clean_title": ["remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). Remove a couple incorrect code. Added missing patch. Added missing int. ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl", "remov", "coupl", "incorrect", "code", "ad", "miss", "patch", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for 157. Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["ad", "patch", "157", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Updated definition of DiscreteDistribution. ", "B_clean_title": ["ad", "miss", "patch", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove unused sample method .. ", "B_clean_title": ["add", "miss", "assign", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Missing patch for DiscreteDistribution . sample ( ). ", "B_clean_title": ["add", "miss", "assign", "miss", "patch", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of DiscreteDistribution. ", "B_clean_title": ["updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing int. Remove a couple incorrect lines from the code. ", "B_clean_title": ["add", "miss", "int", "remov", "coupl", "incorrect", "line", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant empty line. ", "B_clean_title": ["remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the missing patch for MathArrays . isInfinite ( ) .. Fix a bug in DiscreteDistribution . get ( i ). Remove a redundant line. ", "B_clean_title": ["add", "miss", "patch", "matharray", "math", "array", "isinfinit", "infinit", "fix", "bug", "discretedistribut", "discret", "distribut", "get", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove unused sample method .. ", "B_clean_title": ["add", "miss", "assign", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample int. ", "B_clean_title": ["remov", "unus", "sampl", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. Remove a couple incorrect code. Added patch for isInfinite. Fix the for loop. ", "B_clean_title": ["updat", "sampl", "method", "remov", "coupl", "incorrect", "code", "ad", "patch", "isinfinit", "infinit", "fix", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove redundant sample method. ", "B_clean_title": ["ad", "miss", "patch", "remov", "redund", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix a bug in sample ( ). Add z = 1 . 0 / 120 . 0 in GenProg_Defects4. ", "B_clean_title": ["fix", "bug", "sampl", "add", "120", "genprog", "defects4", "gen", "prog"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant error reported by UnStrictlyPositiveException .. Added patch for MathArrays. ", "B_clean_title": ["remov", "redund", "error", "report", "by", "unstrictlypositiveexcept", "un", "strictli", "posit", "except", "ad", "patch", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing int newSize. Updated sample method. Updated definition of DiscreteDistribution. ", "B_clean_title": ["add", "miss", "int", "newsiz", "new", "size", "updat", "sampl", "method", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove unused sample method. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove oversampling .. ", "B_clean_title": ["remov", "oversampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Fix a bug in DiscreteDistribution .. ", "B_clean_title": ["add", "miss", "assign", "fix", "bug", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. Removed unused code. Added missing int. ", "B_clean_title": ["updat", "sampl", "method", "remov", "unus", "code", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix the for loop. Add a missing assignment. Remove a couple incorrect code. ", "B_clean_title": ["fix", "loop", "add", "miss", "assign", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. Updated probabilities. Remove a redundant line. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "updat", "probabl", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Removed some declared exceptions. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "some", "declar", "except"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. Remove a redundant line. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a couple incorrect code. Add missing patch. ", "B_clean_title": ["add", "miss", "assign", "remov", "coupl", "incorrect", "code", "add", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Added patch for DiscreteDistribution. Remove a redundant line. ", "B_clean_title": ["add", "miss", "patch", "ad", "patch", "discretedistribut", "discret", "distribut", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove erroneous loop. Add missing int newSize. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "erron", "loop", "add", "miss", "int", "newsiz", "new", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method. Add z = 1 . 0 / 120 . 0 to fix the build .. ", "B_clean_title": ["remov", "unus", "sampl", "method", "add", "120", "fix", "build"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing int index .. Added missing sample implementation. ", "B_clean_title": ["ad", "miss", "int", "index", "ad", "miss", "sampl", "implement"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a couple incorrect code. Add missing facta variable to fix the build .. ", "B_clean_title": ["add", "miss", "assign", "remov", "coupl", "incorrect", "code", "add", "miss", "facta", "variabl", "fix", "build"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing int .. Remove a couple incorrect code. Added patch for isInfinite. ", "B_clean_title": ["ad", "miss", "int", "remov", "coupl", "incorrect", "code", "ad", "patch", "isinfinit", "infinit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Add missing int newSize. Add a missing assignment. Updated definition of sample ( ) .. ", "B_clean_title": ["add", "miss", "patch", "add", "miss", "int", "newsiz", "new", "size", "add", "miss", "assign", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove redundant code. Added throw exception if it is not infinite  patched. Added patch for isInfinite. Fix MWE - 7764. ", "B_clean_title": ["remov", "redund", "code", "ad", "throw", "except", "it", "not", "infinit", "patch", "ad", "patch", "isinfinit", "infinit", "fix", "mwe", "7764"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Added patch for DiscreteDistribution. Remove a couple incorrect code. ", "B_clean_title": ["add", "miss", "patch", "ad", "patch", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix the for loop. Add a missing assignment. Updated definition of DiscreteDistribution. ", "B_clean_title": ["fix", "loop", "add", "miss", "assign", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a redundant empty line. Added patch for isInfinite. Fix NPE in MathArrays . java. ", "B_clean_title": ["add", "miss", "assign", "remov", "redund", "empti", "line", "ad", "patch", "isinfinit", "infinit", "fix", "npe", "matharray", "math", "array", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Fix a bit of code style. ", "B_clean_title": ["ad", "miss", "patch", "fix", "bit", "code", "style"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing int newSize. Added patch for DiscreteDistribution. Removed erroneous line. ", "B_clean_title": ["add", "miss", "int", "newsiz", "new", "size", "ad", "patch", "discretedistribut", "discret", "distribut", "remov", "erron", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused code. Fix the for loop. ", "B_clean_title": ["remov", "unus", "code", "fix", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the missing exception message. Updated definition of sample ( ) .. ", "B_clean_title": ["add", "miss", "except", "messag", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Fix  Too many decimal places to round to  MathArrays . toString ( ) . ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "fix", "too", "mani", "decim", "place", "round", "matharray", "math", "array", "tostr", "string"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing int . MaxValue for MathArrays .. Add a missing assignment. Remove unused sample method .. ", "B_clean_title": ["ad", "miss", "int", "maxvalu", "max", "valu", "matharray", "math", "array", "add", "miss", "assign", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Changed min / max range of DiscreteDistribution .. Remove a couple incorrect code. ", "B_clean_title": ["chang", "min", "max", "rang", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NPE in MathArrays . java. Added patch for DiscreteDistribution. Remove erroneous loop. ", "B_clean_title": ["fix", "npe", "matharray", "math", "array", "java", "ad", "patch", "discretedistribut", "discret", "distribut", "remov", "erron", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Added patch for DiscreteDistribution. Updated definition of sample ( ) .. ", "B_clean_title": ["add", "miss", "patch", "ad", "patch", "discretedistribut", "discret", "distribut", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Changed min = Integer . MAX_VALUE for DiscreteDistribution .. Remove a couple incorrect code. ", "B_clean_title": ["chang", "min", "integ", "max", "valu", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the patch for MathArrays. Add missing patch. Add a missing assignment. Updated definition of sample ( ) .. ", "B_clean_title": ["add", "patch", "matharray", "math", "array", "add", "miss", "patch", "add", "miss", "assign", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Fix NPE in DiscreteDistribution. Remove a couple incorrect lines from the code. ", "B_clean_title": ["add", "miss", "patch", "fix", "npe", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "line", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method .. ", "B_clean_title": ["remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for MathArrays. Allow NaN to be thrown in MathArrays. Added patch for DiscreteDistribution. Remove a redundant line. ", "B_clean_title": ["ad", "patch", "matharray", "math", "array", "allow", "nan", "na", "thrown", "matharray", "math", "array", "ad", "patch", "discretedistribut", "discret", "distribut", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Added missing patch. Fix NPE in MathArrays. ", "B_clean_title": ["add", "miss", "assign", "ad", "miss", "patch", "fix", "npe", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method .. Added patch for MathArrays . normalizeArray ( ). ", "B_clean_title": ["remov", "unus", "sampl", "method", "ad", "patch", "matharray", "math", "array", "normalizearray", "normal", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add z / rev .. Removesampling patch. ", "B_clean_title": ["add", "rev", "removesampl", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove a couple incorrect code. ", "B_clean_title": ["ad", "miss", "patch", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing patch. Removed erroneous fallthrough in DiscreteDistribution . sample ( ) .. ", "B_clean_title": ["add", "miss", "patch", "remov", "erron", "fallthrough", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. Fix the for loop. Updated sample method. Remove a redundant line. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "fix", "loop", "updat", "sampl", "method", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated probabilities to 0 . 8 . 0. Remove a redundant empty line. ", "B_clean_title": ["updat", "probabl", "remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add zb and resultHigh to NAN patch. Add missing int newSize. Added a patch for DiscreteDistribution. Added missing sample implementation. ", "B_clean_title": ["add", "zb", "resulthigh", "result", "high", "nan", "patch", "add", "miss", "int", "newsiz", "new", "size", "ad", "patch", "discretedistribut", "discret", "distribut", "ad", "miss", "sampl", "implement"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method. Add z = 1 . 0 / 120 . 0 in GenProg_Defects4. ", "B_clean_title": ["remov", "unus", "sampl", "method", "add", "120", "genprog", "defects4", "gen", "prog"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method. Add zb and resultHigh to NAN patch. ", "B_clean_title": ["remov", "unus", "sampl", "method", "add", "zb", "resulthigh", "result", "high", "nan", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Updated definition of DiscreteDistribution. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Updated definition of DiscreteDistribution. ", "B_clean_title": ["add", "miss", "assign", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Put the sample on the right place .. Added patch for MathArrays. Add zb patched for now .. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "put", "sampl", "right", "place", "ad", "patch", "matharray", "math", "array", "add", "zb", "patch", "now"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect code. Fix a bug in MathArrays. ", "B_clean_title": ["remov", "coupl", "incorrect", "code", "fix", "bug", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Changed min = Integer . MAX_VALUE for DiscreteDistribution .. Remove a redundant error message. ", "B_clean_title": ["chang", "min", "integ", "max", "valu", "discretedistribut", "discret", "distribut", "remov", "redund", "error", "messag"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove unused code. Fix NPE in MathArrays. ", "B_clean_title": ["add", "miss", "assign", "remov", "unus", "code", "fix", "npe", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "fixed a small bug in DiscreteDistribution. Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["fix", "small", "bug", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix a bug in MathArrays. Remove unused sample method .. ", "B_clean_title": ["fix", "bug", "matharray", "math", "array", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Added missing sample implementation. Add 0 . 0 to fix the build .. Add missing patch. ", "B_clean_title": ["add", "miss", "assign", "ad", "miss", "sampl", "implement", "add", "fix", "build", "add", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. StrictlyPositiveException was thrown with too small sample size .. Add z = 1 . 0 / 120 . 0 to fix the build .. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "thrown", "too", "small", "sampl", "size", "add", "120", "fix", "build"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NPE in MathArrays . java. Updated definition of DiscreteDistribution. ", "B_clean_title": ["fix", "npe", "matharray", "math", "array", "java", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Updated definition of sample ( ) .. Add missing patch. ", "B_clean_title": ["add", "miss", "assign", "updat", "definit", "sampl", "add", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a patch for DiscreteDistribution. Remove a couple incorrect code. ", "B_clean_title": ["add", "patch", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NPE. Add a missing assignment. Remove unused sample method .. ", "B_clean_title": ["fix", "npe", "add", "miss", "assign", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Fix MWE - 7764. Remove a redundant empty line. ", "B_clean_title": ["ad", "miss", "patch", "fix", "mwe", "7764", "remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing int. Remove 10 + 186 from DiscreteDistribution .. ", "B_clean_title": ["ad", "miss", "int", "remov", "10", "186", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a couple incorrect code. ", "B_clean_title": ["add", "miss", "assign", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect code. Added missing patch .. ", "B_clean_title": ["remov", "coupl", "incorrect", "code", "ad", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method .. ", "B_clean_title": ["remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "fixed a small bug. Fix MWE - 1296 by adding a new empty int. ", "B_clean_title": ["fix", "small", "bug", "fix", "mwe", "1296", "by", "ad", "new", "empti", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Updated sample method. Updated definition of DiscreteDistribution . sample ( ) .. ", "B_clean_title": ["add", "miss", "patch", "updat", "sampl", "method", "updat", "definit", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix a bug in DiscreteDistribution . get ( i ). Remove unused sample method .. Fix PIP. ", "B_clean_title": ["fix", "bug", "discretedistribut", "discret", "distribut", "get", "remov", "unus", "sampl", "method", "fix", "pip"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Add missing sample method. Added missing patch. ", "B_clean_title": ["add", "miss", "assign", "add", "miss", "sampl", "method", "ad", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch .. Fix MWE - 7764. Updated definition of DiscreteDistribution. ", "B_clean_title": ["add", "miss", "patch", "fix", "mwe", "7764", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add z = 1 . 0 / 120 . 0 to fix the build .. Added patch for DiscreteDistribution. StrictlyPositiveException was not strictly positive .. ", "B_clean_title": ["add", "120", "fix", "build", "ad", "patch", "discretedistribut", "discret", "distribut", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "not", "strictli", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Added missing patch. Fix a bug in MathArrays .. ", "B_clean_title": ["add", "miss", "assign", "ad", "miss", "patch", "fix", "bug", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample int. Add the infinite exception message. ", "B_clean_title": ["remov", "unus", "sampl", "int", "add", "infinit", "except", "messag"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. Remove unused sample method .. ", "B_clean_title": ["updat", "sampl", "method", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "StrictlyPositiveException was thrown with too many samples .. Add the missing patch .. ", "B_clean_title": ["strictlypositiveexcept", "strictli", "posit", "except", "wa", "thrown", "too", "mani", "sampl", "add", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed some necessary code. Fix NPE in MathArrays . java. ", "B_clean_title": ["remov", "some", "necessari", "code", "fix", "npe", "matharray", "math", "array", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for MathArrays. Remove a couple incorrect code. ", "B_clean_title": ["ad", "patch", "matharray", "math", "array", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for MathArrays. Added patch for DiscreteDistribution. Updated definition of DiscreteDistribution. ", "B_clean_title": ["ad", "patch", "matharray", "math", "array", "ad", "patch", "discretedistribut", "discret", "distribut", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NPE in MathArrays . toArray. Remove a couple incorrect lines. ", "B_clean_title": ["fix", "npe", "matharray", "math", "array", "toarray", "array", "remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix MWE - 7764. Remove redundant code. ", "B_clean_title": ["fix", "mwe", "7764", "remov", "redund", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of sample ( ) .. ", "B_clean_title": ["updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing int newSize. Remove a redundant line. ", "B_clean_title": ["add", "miss", "int", "newsiz", "new", "size", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method .. Add 0 . 0 to fix the build .. ", "B_clean_title": ["remov", "unus", "sampl", "method", "add", "fix", "build"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. StrictlyPositiveException was not strictly positive .. Fix the for loop. ", "B_clean_title": ["add", "miss", "assign", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "not", "strictli", "posit", "fix", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added throw exception if it is not infinite  patched. Added patch for isInfinite. Fix MWE - 7764. Remove a redundant empty line. ", "B_clean_title": ["ad", "throw", "except", "it", "not", "infinit", "patch", "ad", "patch", "isinfinit", "infinit", "fix", "mwe", "7764", "remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite ( ) .. Updated probabilities. Remove unused sample method. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "updat", "probabl", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove a couple incorrect code. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Add missing facta variable .. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "add", "miss", "facta", "variabl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing exception message. Remove patch from DiscreteDistribution. ", "B_clean_title": ["ad", "miss", "except", "messag", "remov", "patch", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch from DiscreteDistribution. Fix NaN in MathArrays. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "fix", "nan", "na", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patched code. Handle isInfinite in MathArrays. ", "B_clean_title": ["remov", "patch", "code", "handl", "isinfinit", "infinit", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove patched code. ", "B_clean_title": ["ad", "miss", "patch", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove overzealous call to sample ( ). Allow NaN to be set to 0 on histograms. ", "B_clean_title": ["remov", "overzeal", "call", "sampl", "allow", "nan", "na", "set", "histogram"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch from DiscreteDistribution. Fix a merge conflict caused by Double . isNaN ( normalizedSum ) being too high. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "fix", "merg", "conflict", "caus", "by", "doubl", "isnan", "na", "normalizedsum", "normal", "sum", "be", "too", "high"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove extraneous line. ", "B_clean_title": ["remov", "extran", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patch. ", "B_clean_title": ["remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patched code. Allow NaN to be defined in MathArrays  rather than NaN .. ", "B_clean_title": ["remov", "patch", "code", "allow", "nan", "na", "defin", "matharray", "math", "array", "rather", "than", "nan", "na"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix minor rounding bug in MathArrays. Remove patch from DiscreteDistribution. ", "B_clean_title": ["fix", "minor", "round", "bug", "matharray", "math", "array", "remov", "patch", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing exception message. Throw an error if sampleSize <= 0. ", "B_clean_title": ["add", "miss", "except", "messag", "throw", "error", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove patch. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing exception message. Remove overzealous call to sample ( ). ", "B_clean_title": ["add", "miss", "except", "messag", "remov", "overzeal", "call", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix POSIX - compliance issue in MathArrays. Remove patched code. ", "B_clean_title": ["fix", "posix", "complianc", "issu", "matharray", "math", "array", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove oversampling .. ", "B_clean_title": ["remov", "oversampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch from DiscreteDistribution. Fix a bug in MathArrays that was accidentally left in the last commit. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "fix", "bug", "matharray", "math", "array", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Handle isInfinite / isNaN in MathArrays. Remove accidential modification. ", "B_clean_title": ["handl", "isinfinit", "infinit", "isnan", "na", "matharray", "math", "array", "remov", "accidenti", "modif"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing exception message. remove patch. ", "B_clean_title": ["add", "miss", "except", "messag", "remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sampleSize < 0. ", "B_clean_title": ["throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing exception message. Remove patch. ", "B_clean_title": ["add", "miss", "except", "messag", "remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "removed patch from DiscreteDistribution. Remove patch from DiscreteDistribution. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "remov", "patch", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch. Fix an issue with infinities in MathArrays. ", "B_clean_title": ["remov", "patch", "fix", "issu", "infin", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch for DiscreteDistribution. Add missing exception message. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "add", "miss", "except", "messag"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove extraneous line. ", "B_clean_title": ["remov", "extran", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. throw exception if sampleSize is not positive. Fix NaNs in MathArrays. ", "B_clean_title": ["ad", "miss", "patch", "throw", "except", "samples", "sampl", "size", "not", "posit", "fix", "nan", "na", "ns", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch from DiscreteDistribution. Add NaN summaries to fix infinities in MathArrays. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "add", "nan", "na", "summari", "fix", "infin", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed patch from MathArrays . java. Remove patched code. ", "B_clean_title": ["remov", "patch", "matharray", "math", "array", "java", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patched code. Fix a bug in MathArrays that was accidentally left in the last commit .. ", "B_clean_title": ["remov", "patch", "code", "fix", "bug", "matharray", "math", "array", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Added a bit more custom error message. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "ad", "bit", "more", "custom", "error", "messag"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the fix if we can  t fix infinite numbers in MathArrays. Remove oversampling. ", "B_clean_title": ["add", "fix", "we", "fix", "infinit", "number", "matharray", "math", "array", "remov", "oversampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Throw an error if sampleSize <= 0. ", "B_clean_title": ["ad", "miss", "patch", "throw", "error", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix an issue with MathArrays . isInfinite ( ) being thrown as NaN .. throw exception if sampleSize is not positive. ", "B_clean_title": ["fix", "issu", "matharray", "math", "array", "isinfinit", "infinit", "be", "thrown", "as", "nan", "na", "throw", "except", "samples", "sampl", "size", "not", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "StrictlyPositiveException for DiscreteDistribution. ", "B_clean_title": ["strictlypositiveexcept", "strictli", "posit", "except", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove sample from definition of DiscreteDistribution. Add the missing throw check. ", "B_clean_title": ["remov", "sampl", "definit", "discretedistribut", "discret", "distribut", "add", "miss", "throw", "check"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. throw exception if sampleSize is not positive. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "throw", "except", "samples", "sampl", "size", "not", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patched exception. ", "B_clean_title": ["remov", "patch", "except"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove sample ( ). Add a throw exception if the normalized sum is not NaN. ", "B_clean_title": ["remov", "sampl", "add", "throw", "except", "normal", "sum", "not", "nan", "na"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NAN normalization in MathArrays. Remove patch. ", "B_clean_title": ["fix", "nan", "normal", "matharray", "math", "array", "remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Throw an error if sampleSize <= 0. Fix a potential NPE in MathArrays. ", "B_clean_title": ["throw", "error", "samples", "sampl", "size", "fix", "potenti", "npe", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sampleSize < 0. ", "B_clean_title": ["throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch from DiscreteDistribution. Add a throw exception if the normalized sum is not NaN. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "add", "throw", "except", "normal", "sum", "not", "nan", "na"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix a bug in MathArrays that would cause NAN normalization to fail. throw exception if sampleSize is not positive. ", "B_clean_title": ["fix", "bug", "matharray", "math", "array", "that", "would", "caus", "nan", "normal", "fail", "throw", "except", "samples", "sampl", "size", "not", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing exception message. Remove sample from definition. ", "B_clean_title": ["add", "miss", "except", "messag", "remov", "sampl", "definit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the missing exception message. throw exception if sampleSize is not positive. ", "B_clean_title": ["add", "miss", "except", "messag", "throw", "except", "samples", "sampl", "size", "not", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch. Fix a bug in MathArrays that could cause NaN values in the same way as MathArray. ", "B_clean_title": ["remov", "patch", "fix", "bug", "matharray", "math", "array", "that", "could", "caus", "nan", "na", "valu", "same", "way", "as", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Handle NaN normalization in MathArrays. throw exception if sampleSize < 0. ", "B_clean_title": ["handl", "nan", "na", "normal", "matharray", "math", "array", "throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the missing exception message. Fix MathArrays . sum ( double ) to 0. Remove a couple of unused lines. ", "B_clean_title": ["add", "miss", "except", "messag", "fix", "matharray", "math", "array", "sum", "doubl", "remov", "coupl", "unus", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch for 187  7 + 187. Added missing patch. ", "B_clean_title": ["remov", "patch", "187", "187", "ad", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch. Fix a merge conflict in MathArrays .. ", "B_clean_title": ["remov", "patch", "fix", "merg", "conflict", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove overzealous call to sample ( ). ", "B_clean_title": ["ad", "miss", "patch", "remov", "overzeal", "call", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove sample calls. ", "B_clean_title": ["remov", "sampl", "call"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing exception message. Remove patched code. ", "B_clean_title": ["add", "miss", "except", "messag", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patched code. Allow NaN normalization in MathArrays. ", "B_clean_title": ["remov", "patch", "code", "allow", "nan", "na", "normal", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch from DiscreteDistribution. Add missing exception message. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "add", "miss", "except", "messag"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove accidently removed code. Fix a numeric equality bug in MathArrays. ", "B_clean_title": ["remov", "accid", "remov", "code", "fix", "numer", "equal", "bug", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Throw an error if sampleSize <= 0. ", "B_clean_title": ["throw", "error", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NAN normalization in MathArrays. Remove patched code. ", "B_clean_title": ["fix", "nan", "normal", "matharray", "math", "array", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a thrown exception if it is not infinite .. Remove patched code. ", "B_clean_title": ["add", "thrown", "except", "it", "not", "infinit", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. remove patch. ", "B_clean_title": ["add", "miss", "patch", "remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove 10 + 186 from DiscreteDistribution .. Add missing exception message. ", "B_clean_title": ["remov", "10", "186", "discretedistribut", "discret", "distribut", "add", "miss", "except", "messag"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "removed patch for DiscreteDistribution. Remove overzealous call to sample ( ). ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "remov", "overzeal", "call", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Handle infinities in MathArrays. Remove patched code. ", "B_clean_title": ["handl", "infin", "matharray", "math", "array", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NaN in MathArrays. throw exception if sampleSize < 0. ", "B_clean_title": ["fix", "nan", "na", "matharray", "math", "array", "throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch from DiscreteDistribution. Added a throw exception if the normalized sum is not greater than the value .. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "ad", "throw", "except", "normal", "sum", "not", "greater", "than", "valu"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NAN normalization in MathArrays. throw exception if sampleSize is not positive. ", "B_clean_title": ["fix", "nan", "normal", "matharray", "math", "array", "throw", "except", "samples", "sampl", "size", "not", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove overzealous call to sample ( ). Fix minor bug in MathArrays. ", "B_clean_title": ["remov", "overzeal", "call", "sampl", "fix", "minor", "bug", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect throws. Add NaN summaries to fix infinities in MathArrays. ", "B_clean_title": ["remov", "coupl", "incorrect", "throw", "add", "nan", "na", "summari", "fix", "infin", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patch. ", "B_clean_title": ["remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix RSRepair defects4J_Math_8 .. remove patch. ", "B_clean_title": ["fix", "rsrepair", "rs", "repair", "defects4j", "math", "remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patch. Fix ARRAY_SUMS_TO_ZERO. ", "B_clean_title": ["remov", "patch", "fix", "array", "sum", "zero"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . min = Double . POSITIVE_INFINITY. ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "min", "doubl", "posit", "infin"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant line. ", "B_clean_title": ["remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . weightSum. ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "weightsum", "weight", "sum"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove sample ( ). ", "B_clean_title": ["remov", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove unused sample method. ", "B_clean_title": ["remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant line. ", "B_clean_title": ["remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NPE in DiscreteDistribution. remove patched double setting constructor. ", "B_clean_title": ["fix", "npe", "discretedistribut", "discret", "distribut", "remov", "patch", "doubl", "set", "constructor"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NPE in DiscreteDistribution. remove a redundant line. ", "B_clean_title": ["fix", "npe", "discretedistribut", "discret", "distribut", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). remove patched double value. ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl", "remov", "patch", "doubl", "valu"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix for DiscreteDistribution . get ( int ). Throw an error if sampleSize <= 0. ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "get", "int", "throw", "error", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove a redundant line. ", "B_clean_title": ["remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "removed patch for RSRepair_Defects4J_Math_8. remove unused variable. ", "B_clean_title": ["remov", "patch", "rsrepair", "defects4j", "math", "rs", "repair", "remov", "unus", "variabl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sampleSize < 0. ", "B_clean_title": ["throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove unused local variable. ", "B_clean_title": ["remov", "unus", "local", "variabl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed a couple incorrect lines. ", "B_clean_title": ["remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patch. Fix potential segfault in RSRepairDefects4J_Math_8 .. ", "B_clean_title": ["remov", "patch", "fix", "potenti", "segfault", "rsrepairdefects4j", "math", "rs", "repair", "defects4j"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed a redundant empty loop in DiscreteDistribution. ", "B_clean_title": ["remov", "redund", "empti", "loop", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed a couple incorrect lines. ", "B_clean_title": ["remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed some declared exceptions. ", "B_clean_title": ["remov", "some", "declar", "except"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patch from DiscreteDistribution. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove erroneous unused variable. ", "B_clean_title": ["remov", "erron", "unus", "variabl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove sample from definition. ", "B_clean_title": ["remov", "sampl", "definit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "replace 1 . 0d with 1 . 0d. Remove a redundant line. ", "B_clean_title": ["replac", "0d", "0d", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sample size is not > = 0. Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["throw", "except", "sampl", "size", "not", "fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patch. Add missing facta variable to out array .. ", "B_clean_title": ["remov", "patch", "add", "miss", "facta", "variabl", "out", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patch. ", "B_clean_title": ["remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove extraneous line. ", "B_clean_title": ["remov", "extran", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix RSRepair defects4J_Math_8 .. Fix DiscreteDistribution . value = 0 ; patched. ", "B_clean_title": ["fix", "rsrepair", "rs", "repair", "defects4j", "math", "fix", "discretedistribut", "discret", "distribut", "valu", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove erroneous loop. ", "B_clean_title": ["remov", "erron", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed unused sample value. ", "B_clean_title": ["remov", "unus", "sampl", "valu"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sampleSize < 0. ", "B_clean_title": ["throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix minor bug in RSRepair_Defects4J_Math_8 .. remove a redundant line. ", "B_clean_title": ["fix", "minor", "bug", "rsrepair", "defects4j", "math", "rs", "repair", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove unused sample int. ", "B_clean_title": ["remov", "unus", "sampl", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove unused sample ( ). ", "B_clean_title": ["remov", "unus", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove unused local variable. ", "B_clean_title": ["remov", "unus", "local", "variabl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove sample from definition. ", "B_clean_title": ["remov", "sampl", "definit"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix the missing patch. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "miss", "patch"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the bug in Gamma where the inverse of the reflection relation is not found .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the warning. Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "warn", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in Gamma where the inverse of 1 . 0 is not greater than - 1. ", "B_clean_title": ["fix", "bug", "gamma", "where", "invers", "not", "greater", "than"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix Gamma inverse inverse function. Fix x3max = 0 ;. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "gamma", "invers", "invers", "function", "fix", "x3max"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in Gamma where the inverse of the reflection relation is not found .. ", "B_clean_title": ["fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused var. Fix Gamma inverse inverse function. ", "B_clean_title": ["fix", "unus", "var", "fix", "gamma", "invers", "invers", "function"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in Gamma where the inverse of 1 . 0 is not greater than 1 .. ", "B_clean_title": ["fix", "bug", "gamma", "where", "invers", "not", "greater", "than"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix the bug in Gamma where the inverse of 1 . 0 is not greater than 1 .. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "bug", "gamma", "where", "invers", "not", "greater", "than"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the warning. Fix the case of Gamma ( x ) being > 1 . 0. ", "B_clean_title": ["fix", "warn", "fix", "case", "gamma", "be"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix the bug in Gamma where the inverse of 1 . 0 is not found .. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "bug", "gamma", "where", "invers", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the warning. Fix the missing patch. ", "B_clean_title": ["fix", "warn", "fix", "miss", "patch"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix Gamma function .. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "gamma", "function"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix the bug in Gamma where the inverse of 1 . 0 is not greater than - 1. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "bug", "gamma", "where", "invers", "not", "greater", "than"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the warning. Fix Gamma inverse inverse function. ", "B_clean_title": ["fix", "warn", "fix", "gamma", "invers", "invers", "function"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the bug in Gamma where the inverse of 1 . 0 is not greater than - 1. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "bug", "gamma", "where", "invers", "not", "greater", "than"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the recurrence relation in Gamma ( x ) .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused variable warning. Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "unus", "variabl", "warn", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the bug in Gamma where the inverse of the reflection relation is not found .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the recurrence relation in Gamma ( x ). ", "B_clean_title": ["fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused var. Fix the bug in Gamma where the inverse of the reflection relation is not found .. ", "B_clean_title": ["fix", "unus", "var", "fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix the recurrence relation in Gamma ( x ) .. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix Gamma function. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "gamma", "function"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the case for 1 . 0 / ( 1 . 0 + invGamma1pm1 (. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "case", "invgamma1pm1", "inv", "gamma1pm1"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused variable warning. Fix the bug in Gamma where the inverse of the reflection relation is not found .. ", "B_clean_title": ["fix", "unus", "variabl", "warn", "fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix Gamma function path. ", "B_clean_title": ["fix", "gamma", "function", "path"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the warning. Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "warn", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in Gamma where the inverse of the reflection relation is not found .. ", "B_clean_title": ["fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the bug in Gamma where the inverse of the reflection relation is not found .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "fix a warning. Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "warn", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the warning. Fix the recurrence relation in Gamma ( x ) .. ", "B_clean_title": ["fix", "warn", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the missing patch. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "miss", "patch"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the case for Gamma ( x ) where the inverse of the reflection relation is not found. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "case", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in Gamma .. Fix the bug in Gamma where the inverse of 1 . 0 is not greater than - 1. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "bug", "gamma", "where", "invers", "not", "greater", "than"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the bug in Gamma where the inverse of 1 . 0 is not found .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "bug", "gamma", "where", "invers", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix Gamma function path. ", "B_clean_title": ["fix", "gamma", "function", "path"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix memory leak. Fix the case for Gamma ( x ) where the inverse of the reflection relation is not found. ", "B_clean_title": ["fix", "memori", "leak", "fix", "case", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix the bug in Gamma ( x ) .. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "bug", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in Gamma where the inverse of 1 . 0 is not found .. ", "B_clean_title": ["fix", "bug", "gamma", "where", "invers", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix the missing patch. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "miss", "patch"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix Gamma inverse inverse function. ", "B_clean_title": ["fix", "gamma", "invers", "invers", "function"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the warning. Fix the gamma function .. ", "B_clean_title": ["fix", "warn", "fix", "gamma", "function"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the bug in Gamma ( x ) .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "bug", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the bug in Gamma ( x ) .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "bug", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Add the nend variable to the gamma function .. Fix the bug in Gamma where the inverse of 1 . 0 is not greater than - 1. ", "B_clean_title": ["fix", "bug", "gamma", "add", "nend", "variabl", "gamma", "function", "fix", "bug", "gamma", "where", "invers", "not", "greater", "than"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the case for Gamma ( x ) where the inverse of the reflection relation is not found. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "case", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused var. added fix in Gamma. ", "B_clean_title": ["fix", "unus", "var", "ad", "fix", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the warning. Fix the bug in Gamma ( x ) where the inverse of the reflection relation is not found. ", "B_clean_title": ["fix", "warn", "fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix the bug in Gamma where the inverse of 1 . 0 is not greater than 1 .. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "bug", "gamma", "where", "invers", "not", "greater", "than"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the lanczos function. Fix the bug in Gamma where the inverse of the reflection relation is not found .. ", "B_clean_title": ["fix", "lanczo", "function", "fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the recurrence relation found by JDK .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "recurr", "relat", "found", "by", "jdk"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the warning. Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "warn", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the warning. Fix the bug in Gamma ( x ) where the inverse of the reflection relation is not found. ", "B_clean_title": ["fix", "warn", "fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Allow 1 . 5 to be passed to Gamma .. ", "B_clean_title": ["fix", "bug", "gamma", "allow", "pass", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the warning. Fix the recurrence relation in Gamma ( x ) .. ", "B_clean_title": ["fix", "warn", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the bug in Gamma where the inverse of the reflection relation is not found .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "bug", "gamma", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused var. Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "unus", "var", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "added fix in Gamma function. ", "B_clean_title": ["ad", "fix", "gamma", "function"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the missing lanczos fix .. Fix the bug in Gamma where the inverse of 1 . 0 is not greater than - 1. ", "B_clean_title": ["fix", "miss", "lanczo", "fix", "fix", "bug", "gamma", "where", "invers", "not", "greater", "than"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the bug in Gamma where the inverse of the reflection relation is not found .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix unused local variable. Fix the bug in Gamma where the inverse of the reflection relation is not found .. ", "B_clean_title": ["fix", "unus", "local", "variabl", "fix", "bug", "gamma", "where", "invers", "reflect", "relat", "not", "found"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the bug in gamma ( x ). Fix the recurrence relation in Gamma ( x ). ", "B_clean_title": ["fix", "bug", "gamma", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "fix a warning. Fix the recurrence relation of Gamma ( x ) .. ", "B_clean_title": ["fix", "warn", "fix", "recurr", "relat", "gamma"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Bump the gamma patch to see if it is still failing after rebase. ", "B_clean_title": ["bump", "gamma", "patch", "see", "it", "still", "fail", "after", "rebas"]},
{"A_title": "Gamma function computationIn the gamma method when handling the case absX > 20 the computation of gammaAbs should replace x (see code below with x in bold) by absX. For large negative values of x the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);", "A_clean_title": ["gamma", "function", "computationin", "comput", "gamma", "method", "when", "handl", "case", "absx", "ab", "20", "comput", "gammaab", "gamma", "ab", "replac", "see", "code", "below", "bold", "by", "absx", "ab", "larg", "neg", "valu", "function", "return", "wrong", "sign", "final", "doubl", "gammaab", "gamma", "ab", "sqrt", "two", "pi", "fastmath", "pow", "fast", "math", "absx", "ab", "fastmath", "exp", "fast", "math", "lanczo", "absx", "ab"], "B_title": "Fix the recurrence relation patch .. ", "B_clean_title": ["fix", "recurr", "relat", "patch"]}]