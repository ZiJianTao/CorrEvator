[{"A_title": "Column-indicating caret is sometimes not in error outputNone", "A_clean_title": ["column", "indic", "caret", "sometim", "not", "error", "outputnon", "output", "none"], "B_title": "Add null check. ", "B_clean_title": ["add", "null", "check"]},
{"A_title": "Column-indicating caret is sometimes not in error outputNone", "A_clean_title": ["column", "indic", "caret", "sometim", "not", "error", "outputnon", "output", "none"], "B_title": "Remove spurious lookahead. ", "B_clean_title": ["remov", "spuriou", "lookahead"]},
{"A_title": "Column-indicating caret is sometimes not in error outputNone", "A_clean_title": ["column", "indic", "caret", "sometim", "not", "error", "outputnon", "output", "none"], "B_title": "don  t add whitespace to source experpt. ", "B_clean_title": ["don", "add", "whitespac", "sourc", "experpt"]},
{"A_title": "Column-indicating caret is sometimes not in error outputNone", "A_clean_title": ["column", "indic", "caret", "sometim", "not", "error", "outputnon", "output", "none"], "B_title": "don  t add extra space to the end of a line. ", "B_clean_title": ["don", "add", "extra", "space", "end", "line"]},
{"A_title": "DateTimeFormat.parseInto sometimes miscalculates year (2.2)The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks because the input mutable date times millis appear to be mishandled and the year for the parse is changed to 1999.", "A_clean_title": ["datetimeformat", "parseinto", "date", "time", "format", "pars", "into", "sometim", "miscalcul", "year", "follow", "code", "which", "ad", "org", "joda", "time", "format", "testdatetimeformatt", "test", "date", "time", "formatt", "break", "becaus", "input", "mutabl", "date", "time", "milli", "appear", "mishandl", "year", "pars", "chang", "1999"], "B_title": "Fixed misc problems caused by the string comparison. ", "B_clean_title": ["fix", "misc", "problem", "caus", "by", "string", "comparison"]},
{"A_title": "DateTimeFormat.parseInto sometimes miscalculates year (2.2)The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks because the input mutable date times millis appear to be mishandled and the year for the parse is changed to 1999.", "A_clean_title": ["datetimeformat", "parseinto", "date", "time", "format", "pars", "into", "sometim", "miscalcul", "year", "follow", "code", "which", "ad", "org", "joda", "time", "format", "testdatetimeformatt", "test", "date", "time", "formatt", "break", "becaus", "input", "mutabl", "date", "time", "milli", "appear", "mishandl", "year", "pars", "chang", "1999"], "B_title": "Add withUTC suffix .. ", "B_clean_title": ["add", "withutc", "utc", "suffix"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. ", "B_clean_title": ["miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction .. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction . log. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction", "log"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction .. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction .. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction .. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction .. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction .. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add logm value to FDistribution . getNumericalVariance ( ). Fix merge conflict in MathIllegalStateException. Missing return from patch 1 . 0. ", "B_clean_title": ["add", "logm", "valu", "fdistribut", "distribut", "getnumericalvari", "get", "numer", "varianc", "fix", "merg", "conflict", "mathillegalstateexcept", "math", "illeg", "state", "except", "miss", "return", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix a small bug. updated continous fraction patch. ", "B_clean_title": ["fix", "small", "bug", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "updated continous fraction patch. Missing backslash. ", "B_clean_title": ["updat", "contin", "fraction", "patch", "miss", "backslash"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch .. Missing context for format string .. Fix continousFraction . floor ( ) = > 1 . 5. ", "B_clean_title": ["miss", "patch", "miss", "context", "format", "string", "fix", "continousfract", "contin", "fraction", "floor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for MathIllegalStateException. Fix a bug in ContinuedFraction where NAN is not greater than 0 . 5. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "fix", "bug", "continuedfract", "continu", "fraction", "where", "nan", "not", "greater", "than"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. Fix a missing var. ", "B_clean_title": ["miss", "patch", "fix", "miss", "var"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix continousFraction . floor ( ) where it  s not possible to express inversely. Add localization message for MathIllegalStateException. ", "B_clean_title": ["fix", "continousfract", "contin", "fraction", "floor", "where", "it", "not", "possibl", "express", "invers", "add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing context for format string .. updated continous fraction patch. ", "B_clean_title": ["miss", "context", "format", "string", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "updated continous fraction patch. ", "B_clean_title": ["updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add logm value to numericalVariance  too .. updated continous fraction patch. ", "B_clean_title": ["add", "logm", "valu", "numericalvari", "numer", "varianc", "too", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for MathIllegalStateException. Missing patch. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "fixed formatting. Missing patch. ", "B_clean_title": ["fix", "format", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for MathIllegalStateException. updated continous fraction patch. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for MathIllegalStateException. updated continous fraction patch. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for MathIllegalStateException. updated continous fraction patch. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing MissingContextExceptionListener. Fix a minor typo in ContinuedFraction. ", "B_clean_title": ["miss", "missingcontextexceptionlisten", "miss", "context", "except", "listen", "fix", "minor", "typo", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Throw an exception if the numeratorDegreesOfFreedom is not strictly positive. Fix numerical variance being calculated in patched manner .. Missing patch. ", "B_clean_title": ["throw", "except", "numeratordegreesoffreedom", "numer", "degre", "freedom", "not", "strictli", "posit", "fix", "numer", "varianc", "be", "calcul", "patch", "manner", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "updated continous fraction patch. Fix accidental variable warning. ", "B_clean_title": ["updat", "contin", "fraction", "patch", "fix", "accident", "variabl", "warn"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for MathIllegalStateException. updated continous fraction patch. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix a small bug. updated continous fraction patch. ", "B_clean_title": ["fix", "small", "bug", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch .. Fix a missing continuedFraction patch. ", "B_clean_title": ["miss", "patch", "fix", "miss", "continuedfract", "continu", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix a small bug. Fix a missing continuedFraction patch. ", "B_clean_title": ["fix", "small", "bug", "fix", "miss", "continuedfract", "continu", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch for message getter for GenProg_Defects4J_Math_31. updated continous fraction patch. ", "B_clean_title": ["miss", "patch", "messag", "getter", "genprog", "defects4j", "math", "31", "gen", "prog", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Added patch for MathIllegalStateException. Fix continousFraction . floor ( ) where it  s not possible to express inversely. ", "B_clean_title": ["ad", "patch", "mathillegalstateexcept", "math", "illeg", "state", "except", "fix", "continousfract", "contin", "fraction", "floor", "where", "it", "not", "possibl", "express", "invers"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. Missing backslash. ", "B_clean_title": ["miss", "patch", "miss", "backslash"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix a minor typo in ContinuedFraction. fixed ExceptionContext . getMessage. ", "B_clean_title": ["fix", "minor", "typo", "continuedfract", "continu", "fraction", "fix", "exceptioncontext", "except", "context", "getmessag", "get", "messag"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. Added patch for denominator and freedom .. ", "B_clean_title": ["miss", "patch", "ad", "patch", "denomin", "freedom"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix continousFraction . floor ( ) = > 1 . 5. ", "B_clean_title": ["fix", "continousfract", "contin", "fraction", "floor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix continousFraction . pow ( n ) to log1 = 1 ;. Missing context for format string .. ", "B_clean_title": ["fix", "continousfract", "contin", "fraction", "pow", "log1", "miss", "context", "format", "string"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add a localization message for MathIllegalStateException. Missing patch. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix continousFraction . pow ( n ) to log1 = 1 ;. Missing patch .. Missing context for format string .. ", "B_clean_title": ["fix", "continousfract", "contin", "fraction", "pow", "log1", "miss", "patch", "miss", "context", "format", "string"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Remove path from fmt . getLocalizedMessage ( ). Fix continousFraction . floor ( ) = > 1 . 5. ", "B_clean_title": ["remov", "path", "fmt", "getlocalizedmessag", "get", "local", "messag", "fix", "continousfract", "contin", "fraction", "floor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Added missing patch. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["ad", "miss", "patch", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Revert previous fix. revert accidently change for 1 . 0 contemplative division. ", "B_clean_title": ["revert", "previou", "fix", "revert", "accid", "chang", "contempl", "divis"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add missing msgArguments = new ArrayList < Object > ( len ). revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["add", "miss", "msgargument", "msg", "argument", "new", "arraylist", "array", "list", "object", "len", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Revert previous patch. revert accidently change to continuedFraction where hN is NaN. ", "B_clean_title": ["revert", "previou", "patch", "revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add a line break if we don  t have any text left in the string. revert accidently change to continuedFraction where hN is NaN. ", "B_clean_title": ["add", "line", "break", "we", "don", "have", "ani", "text", "left", "string", "revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change for continued fractions. ", "B_clean_title": ["revert", "accid", "chang", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. Missing patch for message method. ", "B_clean_title": ["miss", "patch", "miss", "patch", "messag", "method"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change for 1 . 0 contemplative division. ", "B_clean_title": ["revert", "accid", "chang", "contempl", "divis"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add a localization message for MathIllegalStateException. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. revert accidently change to continuedFraction where hN is NaN. ", "B_clean_title": ["miss", "patch", "revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing context map in message patterns to avoid NPE in RTP constructor. Missing patch. ", "B_clean_title": ["miss", "context", "map", "messag", "pattern", "avoid", "npe", "rtp", "constructor", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Added patch for numerical variance. revert accidently change to continuedFraction where hN is NaN. ", "B_clean_title": ["ad", "patch", "numer", "varianc", "revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Revert previous fix. revert accidently change to continuedFraction where hN is NaN. ", "B_clean_title": ["revert", "previou", "fix", "revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change to continuedFraction where hN is NaN. Missing patch .. ", "B_clean_title": ["revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change for 1 . 0 contibutor. Fix numerical variance .. ", "B_clean_title": ["revert", "accid", "chang", "contibutor", "fix", "numer", "varianc"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. Add a line break if we don  t have any text left in the string. revert accidently change for now. ", "B_clean_title": ["miss", "patch", "add", "line", "break", "we", "don", "have", "ani", "text", "left", "string", "revert", "accid", "chang", "now"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Expose original exception context string .. revert accidently change for now. ", "B_clean_title": ["expos", "origin", "except", "context", "string", "revert", "accid", "chang", "now"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix FDistribution . getSolverAbsoluteAccuracy ( ). Missing patch. ", "B_clean_title": ["fix", "fdistribut", "distribut", "getsolverabsoluteaccuraci", "get", "solver", "absolut", "accuraci", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add patch for denominatorDF > 2. Missing return from patch. ", "B_clean_title": ["add", "patch", "denominatordf", "denomin", "df", "miss", "return", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["miss", "patch", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Allow for more message patterns in case of error. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["allow", "more", "messag", "pattern", "case", "error", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change to continuedFraction where hN is NaN. Missing patch. ", "B_clean_title": ["revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add patch for denominatorDF > 2. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["add", "patch", "denominatordf", "denomin", "df", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Set exception context to empty string ( fix # 134 ). revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["set", "except", "context", "empti", "string", "fix", "134", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Revert previous patch. revert accidently change for continued fractions. ", "B_clean_title": ["revert", "previou", "patch", "revert", "accid", "chang", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix getNumericalVariance. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["fix", "getnumericalvari", "get", "numer", "varianc", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for ARITHMETIC_EXCEPTION. revert accidently change to continuedFraction where it was not possible to set a precision thing. ", "B_clean_title": ["add", "local", "messag", "arithmet", "except", "revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "it", "wa", "not", "possibl", "set", "precis", "thing"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch .. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["miss", "patch", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Revert previous patch. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["revert", "previou", "patch", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change for 1 . 0 contibutor. Reset the ExceptionContext as well. ", "B_clean_title": ["revert", "accid", "chang", "contibutor", "reset", "exceptioncontext", "except", "context", "as", "well"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change for 1 . 0 contibutor. Revert previous patch. ", "B_clean_title": ["revert", "accid", "chang", "contibutor", "revert", "previou", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change for 1 . 0 contemplative_fraction. ", "B_clean_title": ["revert", "accid", "chang", "contempl", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Removed erroneous throw in ContinuedFraction. ", "B_clean_title": ["remov", "erron", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Updated continuedFraction patch. ", "B_clean_title": ["updat", "continuedfract", "continu", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Removed a couple incorrect exceptions. ", "B_clean_title": ["remov", "coupl", "incorrect", "except"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Updated continuedFraction patch. Missing patch .. ", "B_clean_title": ["updat", "continuedfract", "continu", "fraction", "patch", "miss", "patch"]},
{"A_title": "Check Calendar.ERA in LocalDate.fromCalendarFieldsNone", "A_clean_title": ["check", "calendar", "era", "locald", "fromcalendarfieldsnon", "local", "date", "calendar", "field", "none"], "B_title": "Fix incorrect merge. ", "B_clean_title": ["fix", "incorrect", "merg"]},
{"A_title": "RegExFilter deepCopy NullPointerExceptionIf any of the regex matcher objects are null (i.e. for example if you only specify a regex for the column family) the deepCopy call will throw a NullPointerException.", "A_clean_title": ["regexfilt", "reg", "ex", "filter", "deepcopi", "deep", "copi", "nullpointerexceptionif", "null", "pointer", "except", "ani", "regex", "matcher", "object", "are", "null", "exampl", "you", "onli", "specifi", "regex", "column", "famili", "deepcopi", "deep", "copi", "call", "will", "throw", "nullpointerexcept", "null", "pointer", "except"], "B_title": "add return. ", "B_clean_title": ["add", "return"]},
{"A_title": "BrentSolver throws IllegalArgumentExceptionI am getting this exception: java.lang.IllegalArgumentException: Function values at endpoints do not have different signs.  Endpoints: -100000.01.7976931348623157E308  Values: 0.0-101945.04630982173 at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:99) at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:62) The exception should not be thrown with values  0.0-101945.04630982173 because 0.0 is positive. According to Brent Worden the algorithm should stop and return 0 as the root instead of throwing an exception. The problem comes from this method:     public double solve(double min double max) throws MaxIterationsExceededException          FunctionEvaluationException          clearResult();         verifyInterval(min max);         double yMin = f.value(min);         double yMax = f.value(max);         // Verify bracketing         if (yMin * yMax >= 0)               throw new IllegalArgumentException             (Function values at endpoints do not have different signs. +                       Endpoints:  + min +  + max +  +                        Values:  + yMin +  + yMax + );                          // solve using only the first endpoint as initial guess         return solve(min yMin max yMax min yMin);      One way to fix it would be to add this code after the assignment of yMin and yMax:         if (yMin ==0 || yMax == 0)           return 0;        ", "A_clean_title": ["brentsolv", "brent", "solver", "throw", "illegalargumentexceptioni", "illeg", "argument", "except", "am", "get", "thi", "except", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "100000", "01", "7976931348623157e308", "valu", "101945", "04630982173", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:99", "brent", "solver", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:62", "brent", "solver", "except", "not", "thrown", "valu", "101945", "04630982173", "becaus", "posit", "accord", "brent", "worden", "algorithm", "stop", "return", "as", "root", "instead", "throw", "except", "problem", "come", "thi", "method", "public", "doubl", "solv", "doubl", "min", "doubl", "max", "throw", "maxiterationsexceededexcept", "max", "iter", "exceed", "except", "functionevaluationexcept", "function", "evalu", "except", "clearresult", "clear", "result", "verifyinterv", "verifi", "interv", "min", "max", "doubl", "ymin", "min", "valu", "min", "doubl", "ymax", "max", "valu", "max", "verifi", "bracket", "ymin", "min", "ymax", "max", "throw", "new", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "min", "max", "valu", "ymin", "min", "ymax", "max", "solv", "onli", "first", "endpoint", "as", "initi", "guess", "return", "solv", "min", "ymin", "min", "max", "ymax", "max", "min", "ymin", "min", "one", "way", "fix", "it", "would", "add", "thi", "code", "after", "assign", "ymin", "min", "ymax", "max", "ymin", "min", "==0", "ymax", "max", "return"], "B_title": "improve BrentSolver . java. ", "B_clean_title": ["improv", "brentsolv", "brent", "solver", "java"]},
{"A_title": "BrentSolver throws IllegalArgumentExceptionI am getting this exception: java.lang.IllegalArgumentException: Function values at endpoints do not have different signs.  Endpoints: -100000.01.7976931348623157E308  Values: 0.0-101945.04630982173 at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:99) at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:62) The exception should not be thrown with values  0.0-101945.04630982173 because 0.0 is positive. According to Brent Worden the algorithm should stop and return 0 as the root instead of throwing an exception. The problem comes from this method:     public double solve(double min double max) throws MaxIterationsExceededException          FunctionEvaluationException          clearResult();         verifyInterval(min max);         double yMin = f.value(min);         double yMax = f.value(max);         // Verify bracketing         if (yMin * yMax >= 0)               throw new IllegalArgumentException             (Function values at endpoints do not have different signs. +                       Endpoints:  + min +  + max +  +                        Values:  + yMin +  + yMax + );                          // solve using only the first endpoint as initial guess         return solve(min yMin max yMax min yMin);      One way to fix it would be to add this code after the assignment of yMin and yMax:         if (yMin ==0 || yMax == 0)           return 0;        ", "A_clean_title": ["brentsolv", "brent", "solver", "throw", "illegalargumentexceptioni", "illeg", "argument", "except", "am", "get", "thi", "except", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "100000", "01", "7976931348623157e308", "valu", "101945", "04630982173", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:99", "brent", "solver", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:62", "brent", "solver", "except", "not", "thrown", "valu", "101945", "04630982173", "becaus", "posit", "accord", "brent", "worden", "algorithm", "stop", "return", "as", "root", "instead", "throw", "except", "problem", "come", "thi", "method", "public", "doubl", "solv", "doubl", "min", "doubl", "max", "throw", "maxiterationsexceededexcept", "max", "iter", "exceed", "except", "functionevaluationexcept", "function", "evalu", "except", "clearresult", "clear", "result", "verifyinterv", "verifi", "interv", "min", "max", "doubl", "ymin", "min", "valu", "min", "doubl", "ymax", "max", "valu", "max", "verifi", "bracket", "ymin", "min", "ymax", "max", "throw", "new", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "min", "max", "valu", "ymin", "min", "ymax", "max", "solv", "onli", "first", "endpoint", "as", "initi", "guess", "return", "solv", "min", "ymin", "min", "max", "ymax", "max", "min", "ymin", "min", "one", "way", "fix", "it", "would", "add", "thi", "code", "after", "assign", "ymin", "min", "ymax", "max", "ymin", "min", "==0", "ymax", "max", "return"], "B_title": "Added missing throw exception check. ", "B_clean_title": ["ad", "miss", "throw", "except", "check"]},
{"A_title": "BrentSolver throws IllegalArgumentExceptionI am getting this exception: java.lang.IllegalArgumentException: Function values at endpoints do not have different signs.  Endpoints: -100000.01.7976931348623157E308  Values: 0.0-101945.04630982173 at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:99) at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:62) The exception should not be thrown with values  0.0-101945.04630982173 because 0.0 is positive. According to Brent Worden the algorithm should stop and return 0 as the root instead of throwing an exception. The problem comes from this method:     public double solve(double min double max) throws MaxIterationsExceededException          FunctionEvaluationException          clearResult();         verifyInterval(min max);         double yMin = f.value(min);         double yMax = f.value(max);         // Verify bracketing         if (yMin * yMax >= 0)               throw new IllegalArgumentException             (Function values at endpoints do not have different signs. +                       Endpoints:  + min +  + max +  +                        Values:  + yMin +  + yMax + );                          // solve using only the first endpoint as initial guess         return solve(min yMin max yMax min yMin);      One way to fix it would be to add this code after the assignment of yMin and yMax:         if (yMin ==0 || yMax == 0)           return 0;        ", "A_clean_title": ["brentsolv", "brent", "solver", "throw", "illegalargumentexceptioni", "illeg", "argument", "except", "am", "get", "thi", "except", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "100000", "01", "7976931348623157e308", "valu", "101945", "04630982173", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:99", "brent", "solver", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:62", "brent", "solver", "except", "not", "thrown", "valu", "101945", "04630982173", "becaus", "posit", "accord", "brent", "worden", "algorithm", "stop", "return", "as", "root", "instead", "throw", "except", "problem", "come", "thi", "method", "public", "doubl", "solv", "doubl", "min", "doubl", "max", "throw", "maxiterationsexceededexcept", "max", "iter", "exceed", "except", "functionevaluationexcept", "function", "evalu", "except", "clearresult", "clear", "result", "verifyinterv", "verifi", "interv", "min", "max", "doubl", "ymin", "min", "valu", "min", "doubl", "ymax", "max", "valu", "max", "verifi", "bracket", "ymin", "min", "ymax", "max", "throw", "new", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "min", "max", "valu", "ymin", "min", "ymax", "max", "solv", "onli", "first", "endpoint", "as", "initi", "guess", "return", "solv", "min", "ymin", "min", "max", "ymax", "max", "min", "ymin", "min", "one", "way", "fix", "it", "would", "add", "thi", "code", "after", "assign", "ymin", "min", "ymax", "max", "ymin", "min", "==0", "ymax", "max", "return"], "B_title": "Added fix for bracketing in model data. ", "B_clean_title": ["ad", "fix", "bracket", "model", "data"]},
{"A_title": "closure compiled swfobject errorNone", "A_clean_title": ["closur", "compil", "swfobject", "errornon", "error", "none"], "B_title": "Allow 0 . 9 . 0 - > - X in Strings. ", "B_clean_title": ["allow", "string"]},
{"A_title": "closure compiled swfobject errorNone", "A_clean_title": ["closur", "compil", "swfobject", "errornon", "error", "none"], "B_title": "Removing old and unused local variable .. ", "B_clean_title": ["remov", "old", "unus", "local", "variabl"]},
{"A_title": "closure compiled swfobject errorNone", "A_clean_title": ["closur", "compil", "swfobject", "errornon", "error", "none"], "B_title": "Remove the missing semicolon in POS signs. Remove reported code change of PeepholeFoldConstants. Updated isStrWhiteSpaceChar method .. ", "B_clean_title": ["remov", "miss", "semicolon", "po", "sign", "remov", "report", "code", "chang", "peepholefoldconst", "peephol", "fold", "constant", "updat", "isstrwhitespacechar", "str", "white", "space", "char", "method"]},
{"A_title": "Mann-Whitney U Test Suffers From Integer Overflow With Large Data SetsWhen performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets) intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations. Attached is a patch including a test and a fix which modifies the affected code to use doubles", "A_clean_title": ["mann", "whitney", "test", "suffer", "integ", "overflow", "larg", "data", "setswhen", "set", "when", "perform", "mann", "whitney", "test", "larg", "data", "set", "attach", "test", "use", "two", "1500", "element", "set", "intermedi", "integ", "valu", "use", "calculateasymptoticpvalu", "calcul", "asymptot", "valu", "overflow", "lead", "invalid", "result", "such", "as", "valu", "nan", "na", "or", "incorrect", "calcul", "attach", "patch", "includ", "test", "fix", "which", "modifi", "affect", "code", "use", "doubl"], "B_title": "Add ( double ) cast to avoid warning ( varU = ( double ) n1n2. ", "B_clean_title": ["add", "doubl", "cast", "avoid", "warn", "varu", "var", "doubl", "n1n2"]},
{"A_title": "--language_in=ECMASCRIPT5_STRICT results in 1 use strict per input fileNone", "A_clean_title": ["languag", "in=ecmascript5", "strict", "result", "use", "strict", "per", "input", "filenon", "file", "none"], "B_title": "Allow for more freedom from the closure compiler. ", "B_clean_title": ["allow", "more", "freedom", "closur", "compil"]},
{"A_title": "Wrong parameter for first step size guess for Embedded Runge Kutta methodsIn a space application using DOP853 i detected what seems to be a bad parameter in the call to the method  initializeStep of class AdaptiveStepsizeIntegrator.  Here DormandPrince853Integrator is a subclass for EmbeddedRungeKuttaIntegrator which perform the call to initializeStep at the beginning of its method integrate(...)  The problem comes from the array scale that is used as a parameter in the call off initializeStep(..)  Following the theory described by Hairer in his book Solving Ordinary Differential Equations 1 : Nonstiff Problems the scaling should be :  sci = Atol i + |y0i| * Rtoli  Whereas EmbeddedRungeKuttaIntegrator uses :  sci = Atoli  Note that the Gragg-Bulirsch-Stoer integrator uses the good implementation sci = Atol i + |y0i| * Rtoli   when he performs the call to the same method initializeStep(..)  In the method initializeStep the error leads to a wrong step size h used to perform an  Euler step. Most of the time it is unvisible for the user. But in my space application the Euler step with this wrong step size h (much bigger than it should be)  makes an exception occur (my satellite hits the ground...)   To fix the bug one should use the same algorithm as in the rescale method in GraggBulirschStoerIntegrator For exemple :   final double scale= new doubley0.length;;                      if (vecAbsoluteTolerance == null)                for (int i = 0; i < scale.length; ++i)                  final double yi = Math.max(Math.abs(y0i) Math.abs(y0i));                 scalei = scalAbsoluteTolerance + scalRelativeTolerance * yi;                             else                for (int i = 0; i < scale.length; ++i)                  final double yi = Math.max(Math.abs(y0i) Math.abs(y0i));                 scalei = vecAbsoluteTolerancei + vecRelativeTolerancei * yi;                                                  hNew = initializeStep(equations forward getOrder() scale                            stepStart y yDotK0 yTmp yDotK1);    Sorry for the length of this message looking forward to hearing from you soon  Vincent Morand", "A_clean_title": ["wrong", "paramet", "first", "step", "size", "guess", "embed", "rung", "kutta", "methodsin", "method", "space", "applic", "dop853", "detect", "what", "seem", "bad", "paramet", "call", "method", "initializestep", "initi", "step", "class", "adaptivestepsizeintegr", "adapt", "stepsiz", "integr", "here", "dormandprince853integr", "dormand", "prince853integr", "subclass", "embeddedrungekuttaintegr", "embed", "rung", "kutta", "integr", "which", "perform", "call", "initializestep", "initi", "step", "at", "begin", "it", "method", "integr", "problem", "come", "array", "scale", "that", "use", "as", "paramet", "call", "off", "initializestep", "initi", "step", "follow", "theori", "describ", "by", "hairer", "hi", "book", "solv", "ordinari", "differenti", "equat", "nonstiff", "problem", "scale", "sci", "atol", "|y0i|", "rtoli", "wherea", "embeddedrungekuttaintegr", "embed", "rung", "kutta", "integr", "use", "sci", "atoli", "note", "that", "gragg", "bulirsch", "stoer", "integr", "use", "good", "implement", "sci", "atol", "|y0i|", "rtoli", "when", "he", "perform", "call", "same", "method", "initializestep", "initi", "step", "method", "initializestep", "initi", "step", "error", "lead", "wrong", "step", "size", "use", "perform", "euler", "step", "most", "time", "it", "unvis", "user", "but", "my", "space", "applic", "euler", "step", "thi", "wrong", "step", "size", "much", "bigger", "than", "it", "make", "except", "occur", "my", "satellit", "hit", "ground", "fix", "bug", "one", "use", "same", "algorithm", "as", "rescal", "method", "graggbulirschstoerintegr", "gragg", "bulirsch", "stoer", "integr", "exempl", "final", "doubl", "scale=", "new", "doubley0", "length", "vecabsolutetoler", "vec", "absolut", "toler", "null", "int", "scale", "length", "++i", "final", "doubl", "yi", "math", "max", "math", "ab", "y0i", "math", "ab", "y0i", "scalei", "scalabsolutetoler", "scal", "absolut", "toler", "scalrelativetoler", "scal", "rel", "toler", "yi", "int", "scale", "length", "++i", "final", "doubl", "yi", "math", "max", "math", "ab", "y0i", "math", "ab", "y0i", "scalei", "vecabsolutetolerancei", "vec", "absolut", "tolerancei", "vecrelativetolerancei", "vec", "rel", "tolerancei", "yi", "hnew", "new", "initializestep", "initi", "step", "equat", "forward", "getord", "get", "order", "scale", "stepstart", "step", "start", "ydotk0", "dot", "k0", "ytmp", "tmp", "ydotk1", "dot", "k1", "sorri", "length", "thi", "messag", "look", "forward", "hear", "you", "soon", "vincent", "morand"], "B_title": "increased the maximum growth from the patched code. ", "B_clean_title": ["increas", "maximum", "growth", "patch", "code"]},
{"A_title": "RuntimeException when compiling with extern prototypeNone", "A_clean_title": ["runtimeexcept", "runtim", "except", "when", "compil", "extern", "prototypenon", "prototyp", "none"], "B_title": "Fix findbugs issue. ", "B_clean_title": ["fix", "findbug", "issu"]},
{"A_title": "math  SimpleRegression getSumSquaredErrorsgetSumSquaredErrors returns -ve value. See test below: public void testSimpleRegression()  double y =    8915.102 8919.302 8923.502 ; double x =   1.107178495 1.107264895 1.107351295 ; double x2 =   1.107178495E2 1.107264895E2 1.107351295E2 ; SimpleRegression reg = new SimpleRegression(); for (int i = 0; i < x.length; i++)   reg.addData(xiyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // OK reg.clear(); for (int i = 0; i < x.length; i++)   reg.addData(x2iyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // FAIL ", "A_clean_title": ["math", "simpleregress", "simpl", "regress", "getsumsquarederrorsgetsumsquarederror", "get", "sum", "squar", "errorsget", "sum", "squar", "error", "return", "ve", "valu", "see", "test", "below", "public", "void", "testsimpleregress", "test", "simpl", "regress", "doubl", "8915", "102", "8919", "302", "8923", "502", "doubl", "107178495", "107264895", "107351295", "doubl", "x2", "107178495e2", "107264895e2", "107351295e2", "simpleregress", "simpl", "regress", "reg", "new", "simpleregress", "simpl", "regress", "int", "length", "i++", "reg", "adddata", "add", "data", "xiyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "ok", "reg", "clear", "int", "length", "i++", "reg", "adddata", "add", "data", "x2iyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "fail"], "B_title": "fixed a small bug in SimpleRegression. ", "B_clean_title": ["fix", "small", "bug", "simpleregress", "simpl", "regress"]},
{"A_title": "math  SimpleRegression getSumSquaredErrorsgetSumSquaredErrors returns -ve value. See test below: public void testSimpleRegression()  double y =    8915.102 8919.302 8923.502 ; double x =   1.107178495 1.107264895 1.107351295 ; double x2 =   1.107178495E2 1.107264895E2 1.107351295E2 ; SimpleRegression reg = new SimpleRegression(); for (int i = 0; i < x.length; i++)   reg.addData(xiyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // OK reg.clear(); for (int i = 0; i < x.length; i++)   reg.addData(x2iyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // FAIL ", "A_clean_title": ["math", "simpleregress", "simpl", "regress", "getsumsquarederrorsgetsumsquarederror", "get", "sum", "squar", "errorsget", "sum", "squar", "error", "return", "ve", "valu", "see", "test", "below", "public", "void", "testsimpleregress", "test", "simpl", "regress", "doubl", "8915", "102", "8919", "302", "8923", "502", "doubl", "107178495", "107264895", "107351295", "doubl", "x2", "107178495e2", "107264895e2", "107351295e2", "simpleregress", "simpl", "regress", "reg", "new", "simpleregress", "simpl", "regress", "int", "length", "i++", "reg", "adddata", "add", "data", "xiyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "ok", "reg", "clear", "int", "length", "i++", "reg", "adddata", "add", "data", "x2iyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "fail"], "B_title": "Added test case for 1 . 5. ", "B_clean_title": ["ad", "test", "case"]},
{"A_title": "math  SimpleRegression getSumSquaredErrorsgetSumSquaredErrors returns -ve value. See test below: public void testSimpleRegression()  double y =    8915.102 8919.302 8923.502 ; double x =   1.107178495 1.107264895 1.107351295 ; double x2 =   1.107178495E2 1.107264895E2 1.107351295E2 ; SimpleRegression reg = new SimpleRegression(); for (int i = 0; i < x.length; i++)   reg.addData(xiyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // OK reg.clear(); for (int i = 0; i < x.length; i++)   reg.addData(x2iyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // FAIL ", "A_clean_title": ["math", "simpleregress", "simpl", "regress", "getsumsquarederrorsgetsumsquarederror", "get", "sum", "squar", "errorsget", "sum", "squar", "error", "return", "ve", "valu", "see", "test", "below", "public", "void", "testsimpleregress", "test", "simpl", "regress", "doubl", "8915", "102", "8919", "302", "8923", "502", "doubl", "107178495", "107264895", "107351295", "doubl", "x2", "107178495e2", "107264895e2", "107351295e2", "simpleregress", "simpl", "regress", "reg", "new", "simpleregress", "simpl", "regress", "int", "length", "i++", "reg", "adddata", "add", "data", "xiyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "ok", "reg", "clear", "int", "length", "i++", "reg", "adddata", "add", "data", "x2iyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "fail"], "B_title": "Fix a bug in the SimpleRegression test .. ", "B_clean_title": ["fix", "bug", "simpleregress", "simpl", "regress", "test"]},
{"A_title": "CMAESOptimizer with bounds fits finely near lower bound and coarsely near upper bound.When fitting with bounds the CMAESOptimizer fits finely near the lower bound and coarsely near the upper bound.  This is because it internally maps the fitted parameter range into the interval 01.  The unit of least precision (ulp) between floating point numbers is much smaller near zero than near one.  Thus fits have much better resolution near the lower bound (which is mapped to zero) than the upper bound (which is mapped to one).  I will attach a example program to demonstrate.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "bound", "fit", "fine", "near", "lower", "bound", "coars", "near", "upper", "bound", "when", "fit", "bound", "cmaesoptim", "cmae", "optim", "fit", "fine", "near", "lower", "bound", "coars", "near", "upper", "bound", "thi", "becaus", "it", "intern", "map", "fit", "paramet", "rang", "into", "interv", "01", "unit", "least", "precis", "ulp", "between", "float", "point", "number", "much", "smaller", "near", "zero", "than", "near", "one", "thu", "fit", "have", "much", "better", "resolut", "near", "lower", "bound", "which", "map", "zero", "than", "upper", "bound", "which", "map", "one", "will", "attach", "exampl", "program", "demonstr"], "B_title": "Fix wrong import .. Fix NPE in CMAESOptimizer. ", "B_clean_title": ["fix", "wrong", "import", "fix", "npe", "cmaesoptim", "cmae", "optim"]},
{"A_title": "@enum does not type correctlyNone", "A_clean_title": ["enum", "not", "type", "correctlynon", "correctli", "none"], "B_title": "Fix typo in TypeCheck . getTypedPercent. ", "B_clean_title": ["fix", "typo", "typecheck", "type", "check", "gettypedperc", "get", "type", "percent"]},
{"A_title": "Cannot exclude globalThis checks through command lineNone", "A_clean_title": ["not", "exclud", "globalthi", "global", "thi", "check", "through", "command", "linenon", "line", "none"], "B_title": "Allow changes through to pass through to fix stones. ", "B_clean_title": ["allow", "chang", "through", "pass", "through", "fix", "stone"]},
{"A_title": "Cannot exclude globalThis checks through command lineNone", "A_clean_title": ["not", "exclud", "globalthi", "global", "thi", "check", "through", "command", "linenon", "line", "none"], "B_title": "Remove old definition of checkGlobalThisLevel from options . checkSuspiciousCode. ", "B_clean_title": ["remov", "old", "definit", "checkglobalthislevel", "check", "global", "thi", "level", "option", "checksuspiciouscod", "check", "suspici", "code"]},
{"A_title": "Cannot exclude globalThis checks through command lineNone", "A_clean_title": ["not", "exclud", "globalthi", "global", "thi", "check", "through", "command", "linenon", "line", "none"], "B_title": "Fix checkSuspiciousCode. ", "B_clean_title": ["fix", "checksuspiciouscod", "check", "suspici", "code"]},
{"A_title": "Cannot exclude globalThis checks through command lineNone", "A_clean_title": ["not", "exclud", "globalthi", "global", "thi", "check", "through", "command", "linenon", "line", "none"], "B_title": "Add  addVerboseWarnings ( )  to closure compiler warnings. ", "B_clean_title": ["add", "addverbosewarn", "add", "verbos", "warn", "closur", "compil", "warn"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix parseLong ( ) where - > parseLong ( ) works. ", "B_clean_title": ["fix", "parselong", "pars", "long", "where", "parselong", "pars", "long", "work"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix null precision thingie in StringUtils. ", "B_clean_title": ["fix", "null", "precis", "thingi", "stringutil", "string", "util"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix null - penalty in long precision spotting. ", "B_clean_title": ["fix", "null", "penalti", "long", "precis", "spot"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Manchester United FC = > NumberUtils copy ( ). ", "B_clean_title": ["manchest", "unit", "fc", "numberutil", "number", "util", "copi"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix typo in patch. ", "B_clean_title": ["fix", "typo", "patch"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix erroneous fallthrough in NumberUtils. ", "B_clean_title": ["fix", "erron", "fallthrough", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix error in last commit. ", "B_clean_title": ["fix", "error", "last", "commit"]},
{"A_title": "Assignment removed when used as an expression result to Array.pushNone", "A_clean_title": ["assign", "remov", "when", "use", "as", "express", "result", "array", "pushnon", "push", "none"], "B_title": "Add one more fix to the case statement. ", "B_clean_title": ["add", "one", "more", "fix", "case", "statement"]},
{"A_title": "Assignment removed when used as an expression result to Array.pushNone", "A_clean_title": ["assign", "remov", "when", "use", "as", "express", "result", "array", "pushnon", "push", "none"], "B_title": "Remove unused vars that are not used any more .. ", "B_clean_title": ["remov", "unus", "var", "that", "are", "not", "use", "ani", "more"]},
{"A_title": "Assignment removed when used as an expression result to Array.pushNone", "A_clean_title": ["assign", "remov", "when", "use", "as", "express", "result", "array", "pushnon", "push", "none"], "B_title": "fix bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Remove unused incompilable code. Remove inconsistent check for group strategy. ", "B_clean_title": ["remov", "old", "patch", "remov", "unus", "incompil", "code", "remov", "inconsist", "check", "group", "strategi"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Updated toString patch. Remove badly placed patch. Remove inconsistent check for group strategy. Remove redundant initProperties call. Remove redundant merge of GroupReduceWithCombineProperties .. ", "B_clean_title": ["updat", "tostr", "string", "patch", "remov", "badli", "place", "patch", "remov", "inconsist", "check", "group", "strategi", "remov", "redund", "initproperti", "init", "properti", "call", "remov", "redund", "merg", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Removed patch from source files. Remove inconsistent check for group strategy. Remove redundant patch. ", "B_clean_title": ["remov", "old", "patch", "remov", "patch", "sourc", "file", "remov", "inconsist", "check", "group", "strategi", "remov", "redund", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. update marker. Removed patch from source files. Remove inconsistent check for group strategy. ", "B_clean_title": ["remov", "old", "patch", "updat", "marker", "remov", "patch", "sourc", "file", "remov", "inconsist", "check", "group", "strategi"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove inconsistent check for group strategy. update marker. Remove forced rebalancing from PartitionNode. ", "B_clean_title": ["remov", "inconsist", "check", "group", "strategi", "updat", "marker", "remov", "forc", "rebalanc", "partitionnod", "partit", "node"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove local strategy from group reduce node. Remove patch for compiler error. Removed patch for compiler node. Remove unused patch. Remove patch from rgps. ", "B_clean_title": ["remov", "local", "strategi", "group", "reduc", "node", "remov", "patch", "compil", "error", "remov", "patch", "compil", "node", "remov", "unus", "patch", "remov", "patch", "rgp"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove redundant patch. Remove old patch. Remove redundant merge of GroupReduceWithCombineProperties .. ", "B_clean_title": ["remov", "redund", "patch", "remov", "old", "patch", "remov", "redund", "merg", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Updated patch for compiler toString. Remove forced rebalancing from PartitionNode. Remove inconsistent check for group strategy. ", "B_clean_title": ["updat", "patch", "compil", "tostr", "string", "remov", "forc", "rebalanc", "partitionnod", "partit", "node", "remov", "inconsist", "check", "group", "strategi"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove redundant patch. Remove old merge conflict. Remove patch from rgps. Updated patch for compiler debug information. ", "B_clean_title": ["remov", "redund", "patch", "remov", "old", "merg", "conflict", "remov", "patch", "rgp", "updat", "patch", "compil", "debug", "inform"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Allow restrictive plan hints at compile time. Remove redundant patch. Remove inconsistent check for group strategy. Remove redundant initProperties call. ", "B_clean_title": ["allow", "restrict", "plan", "hint", "at", "compil", "time", "remov", "redund", "patch", "remov", "inconsist", "check", "group", "strategi", "remov", "redund", "initproperti", "init", "properti", "call"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Remove inconsistent check for group strategy. Remove unnecessary call to setGroupedFields ( ) in GroupReduceWithCombineProperties. ", "B_clean_title": ["remov", "old", "patch", "remov", "inconsist", "check", "group", "strategi", "remov", "unnecessari", "call", "setgroupedfield", "set", "group", "field", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove forced rebalancing from PartitionNode. update tmp. Fix inconsistent sort for group strategy. ", "B_clean_title": ["remov", "forc", "rebalanc", "partitionnod", "partit", "node", "updat", "tmp", "fix", "inconsist", "sort", "group", "strategi"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Remove inconsistent check for group strategy. ", "B_clean_title": ["remov", "old", "patch", "remov", "inconsist", "check", "group", "strategi"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove badly placed patch. Fix inconsistent sort for group strategy. Remove old combiner node setDegreeOfParallelism. ", "B_clean_title": ["remov", "badli", "place", "patch", "fix", "inconsist", "sort", "group", "strategi", "remov", "old", "combin", "node", "setdegreeofparallel", "set", "degre", "parallel"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove inconsistent check for group strategy. Remove old patch. Removed break line. ", "B_clean_title": ["remov", "inconsist", "check", "group", "strategi", "remov", "old", "patch", "remov", "break", "line"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Removed patch from source files. Remove forced rebalancing from PartitionNode. Fix inconsistent sort for group strategy. Fix bug in GroupReduceWithCombineProperties. ", "B_clean_title": ["remov", "patch", "sourc", "file", "remov", "forc", "rebalanc", "partitionnod", "partit", "node", "fix", "inconsist", "sort", "group", "strategi", "fix", "bug", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove inconsistent check for group strategy. Remove unnecessary call to setGroupedFields ( ) in GroupReduceWithCombineProperties. Remove patch from rgps. ", "B_clean_title": ["remov", "inconsist", "check", "group", "strategi", "remov", "unnecessari", "call", "setgroupedfield", "set", "group", "field", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti", "remov", "patch", "rgp"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Removed two redundant lines. Remove patch .. Fix broken patch. ", "B_clean_title": ["remov", "old", "patch", "remov", "two", "redund", "line", "remov", "patch", "fix", "broken", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Remove inconsistent check for group strategy. Remove over - aggressive merge of GroupReduceWithCombineProperties .. ", "B_clean_title": ["remov", "old", "patch", "remov", "inconsist", "check", "group", "strategi", "remov", "over", "aggress", "merg", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Fix inconsistent sort for group strategy. Remove badly placed patch. ", "B_clean_title": ["fix", "inconsist", "sort", "group", "strategi", "remov", "badli", "place", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove a redundant check. Remove old patch. Remove unused incompilable code. Remove inconsistent check for group strategy. ", "B_clean_title": ["remov", "redund", "check", "remov", "old", "patch", "remov", "unus", "incompil", "code", "remov", "inconsist", "check", "group", "strategi"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Fix inconsistent sort for group strategy. remove old combiner init property. Remove forced rebalancing from PartitionNode. ", "B_clean_title": ["fix", "inconsist", "sort", "group", "strategi", "remov", "old", "combin", "init", "properti", "remov", "forc", "rebalanc", "partitionnod", "partit", "node"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old merge conflict. Removed local improvements. Remove patch from rgps. ", "B_clean_title": ["remov", "old", "merg", "conflict", "remov", "local", "improv", "remov", "patch", "rgp"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. remove redundant initProperties call. Remove unused incompilable code. Remove redundant patch. ", "B_clean_title": ["remov", "old", "patch", "remov", "redund", "initproperti", "init", "properti", "call", "remov", "unus", "incompil", "code", "remov", "redund", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "remove redundant initProperties call. Remove patch from rgps. Remove unused incompilable code. ", "B_clean_title": ["remov", "redund", "initproperti", "init", "properti", "call", "remov", "patch", "rgp", "remov", "unus", "incompil", "code"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove inconsistent check for group strategy. Remove old patch. ", "B_clean_title": ["remov", "inconsist", "check", "group", "strategi", "remov", "old", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove redundant patch. update tmp. Remove old patch. ", "B_clean_title": ["remov", "redund", "patch", "updat", "tmp", "remov", "old", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "remove old combiner init property. Remove unused patch .. Remove old patch. ", "B_clean_title": ["remov", "old", "combin", "init", "properti", "remov", "unus", "patch", "remov", "old", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "remove old combiner init properties. Remove old patch. Remove redundant patch. ", "B_clean_title": ["remov", "old", "combin", "init", "properti", "remov", "old", "patch", "remov", "redund", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Fix a bug inOptimizerNode . toString ( ). Remove old patch. Remove redundant merge of GroupReduceWithCombineProperties .. ", "B_clean_title": ["fix", "bug", "inoptimizernod", "optim", "node", "tostr", "string", "remov", "old", "patch", "remov", "redund", "merg", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove redundant merge of GroupReduceWithCombineProperties .. Removed local testing patch. Remove unused incompilable code. Remove old patch. ", "B_clean_title": ["remov", "redund", "merg", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti", "remov", "local", "test", "patch", "remov", "unus", "incompil", "code", "remov", "old", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Remove inconsistent check for group strategy. remove old combiner init properties. Remove redundant merge of GroupReduceWithCombineProperties .. ", "B_clean_title": ["remov", "old", "patch", "remov", "inconsist", "check", "group", "strategi", "remov", "old", "combin", "init", "properti", "remov", "redund", "merg", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Removed patch for compiler class name. Remove forced rebalancing from PartitionNode. Remove inconsistent check for group strategy. ", "B_clean_title": ["remov", "patch", "compil", "class", "name", "remov", "forc", "rebalanc", "partitionnod", "partit", "node", "remov", "inconsist", "check", "group", "strategi"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove inconsistent check for group strategy. Remove old patch. Updated patch for compiler test. ", "B_clean_title": ["remov", "inconsist", "check", "group", "strategi", "remov", "old", "patch", "updat", "patch", "compil", "test"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Fix inconsistent sort for group strategy. Allow restrictive plan hints at compile time. Remove old patch. ", "B_clean_title": ["fix", "inconsist", "sort", "group", "strategi", "allow", "restrict", "plan", "hint", "at", "compil", "time", "remov", "old", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Fix inconsistent sort for group strategy. Remove patched code .. Remove old patch. ", "B_clean_title": ["fix", "inconsist", "sort", "group", "strategi", "remov", "patch", "code", "remov", "old", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove inconsistent check for group strategy. Remove patch .. Remove patch from rgps. ", "B_clean_title": ["remov", "inconsist", "check", "group", "strategi", "remov", "patch", "remov", "patch", "rgp"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove redundant patch. Remove old patch. Remove old toString patch. ", "B_clean_title": ["remov", "redund", "patch", "remov", "old", "patch", "remov", "old", "tostr", "string", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove badly placed patch. Remove inconsistent check for group strategy. Remove old merge conflict. ", "B_clean_title": ["remov", "badli", "place", "patch", "remov", "inconsist", "check", "group", "strategi", "remov", "old", "merg", "conflict"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Removed patch from source files. Remove old patch. Remove inconsistent check for group strategy. ", "B_clean_title": ["remov", "patch", "sourc", "file", "remov", "old", "patch", "remov", "inconsist", "check", "group", "strategi"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Removed patch for compiler class name. Remove patch from rgps. Remove redundant patch. ", "B_clean_title": ["remov", "patch", "compil", "class", "name", "remov", "patch", "rgp", "remov", "redund", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Remove unused incompilable code. Remove local strategy from group reduce node. ", "B_clean_title": ["remov", "old", "patch", "remov", "unus", "incompil", "code", "remov", "local", "strategi", "group", "reduc", "node"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Remove unused incompilable code. Remove redundant patch. Remove old merge conflict. ", "B_clean_title": ["remov", "old", "patch", "remov", "unus", "incompil", "code", "remov", "redund", "patch", "remov", "old", "merg", "conflict"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove inconsistent check for group strategy. Removed patch from source files. Updated toString patch. Remove old patch. ", "B_clean_title": ["remov", "inconsist", "check", "group", "strategi", "remov", "patch", "sourc", "file", "updat", "tostr", "string", "patch", "remov", "old", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove redundant patch. Remove old patch. Remove unused patch. ", "B_clean_title": ["remov", "redund", "patch", "remov", "old", "patch", "remov", "unus", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Removed local testing. Remove redundant patch. Remove redundant merge of GroupReduceWithCombineProperties .. ", "B_clean_title": ["remov", "old", "patch", "remov", "local", "test", "remov", "redund", "patch", "remov", "redund", "merg", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Fix swapped joins. Remove redundant patch. Remove old patch. ", "B_clean_title": ["fix", "swap", "join", "remov", "redund", "patch", "remov", "old", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Removed patch fromOptimizerNode. Remove old patch. Remove old merge conflict. ", "B_clean_title": ["remov", "patch", "fromoptimizernod", "optim", "node", "remov", "old", "patch", "remov", "old", "merg", "conflict"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove local strategy from group reduce node. Remove old patch. Updated patch for compiler test. ", "B_clean_title": ["remov", "local", "strategi", "group", "reduc", "node", "remov", "old", "patch", "updat", "patch", "compil", "test"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Allow restrictive plan hints at compile time. Remove unused incompilable code. Remove inconsistent check for group strategy. ", "B_clean_title": ["remov", "old", "patch", "allow", "restrict", "plan", "hint", "at", "compil", "time", "remov", "unus", "incompil", "code", "remov", "inconsist", "check", "group", "strategi"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Fix inconsistent sort for group strategy. Remove old patch. Removed local improvements. Remove unused patch. ", "B_clean_title": ["fix", "inconsist", "sort", "group", "strategi", "remov", "old", "patch", "remov", "local", "improv", "remov", "unus", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove inconsistent check for group strategy. Remove patch from plan graph. Remove unused patch .. Remove patch from rgps. ", "B_clean_title": ["remov", "inconsist", "check", "group", "strategi", "remov", "patch", "plan", "graph", "remov", "unus", "patch", "remov", "patch", "rgp"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Removed two redundant lines. Remove unused patch. Remove old patch. Remove redundant merge of GroupReduceWithCombineProperties .. ", "B_clean_title": ["remov", "two", "redund", "line", "remov", "unus", "patch", "remov", "old", "patch", "remov", "redund", "merg", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove forced rebalancing from PartitionNode. Removed patch from source files. Remove inconsistent check for group strategy. ", "B_clean_title": ["remov", "forc", "rebalanc", "partitionnod", "partit", "node", "remov", "patch", "sourc", "file", "remov", "inconsist", "check", "group", "strategi"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Removed local improvements. remove redundant initProperties call. ", "B_clean_title": ["remov", "old", "patch", "remov", "local", "improv", "remov", "redund", "initproperti", "init", "properti", "call"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove inconsistent check for group strategy. Fix bug in GroupReduceWithCombineProperties. Removed a couple of unused lines. Remove patch from rgps. ", "B_clean_title": ["remov", "inconsist", "check", "group", "strategi", "fix", "bug", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti", "remov", "coupl", "unus", "line", "remov", "patch", "rgp"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Remove redundant patch. ", "B_clean_title": ["remov", "old", "patch", "remov", "redund", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove redundant initProperties call. Updated patch for compiler test. Remove old patch. ", "B_clean_title": ["remov", "redund", "initproperti", "init", "properti", "call", "updat", "patch", "compil", "test", "remov", "old", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Remove unused patch. Fix inconsistent sort for group strategy. ", "B_clean_title": ["remov", "old", "patch", "remov", "unus", "patch", "fix", "inconsist", "sort", "group", "strategi"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove forced rebalancing from PartitionNode. update marker. Remove redundant patch. ", "B_clean_title": ["remov", "forc", "rebalanc", "partitionnod", "partit", "node", "updat", "marker", "remov", "redund", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Fix inconsistent sort for group strategy. Remove forced rebalancing from PartitionNode. Removed break line. ", "B_clean_title": ["fix", "inconsist", "sort", "group", "strategi", "remov", "forc", "rebalanc", "partitionnod", "partit", "node", "remov", "break", "line"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove inconsistent check for group strategy. Remove old patch. update marker. ", "B_clean_title": ["remov", "inconsist", "check", "group", "strategi", "remov", "old", "patch", "updat", "marker"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Fix inconsistent sort for group strategy. Remove old patch. Removed local improvements. ", "B_clean_title": ["fix", "inconsist", "sort", "group", "strategi", "remov", "old", "patch", "remov", "local", "improv"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove redundant initProperties call. Remove forced rebalancing from PartitionNode. ", "B_clean_title": ["remov", "redund", "initproperti", "init", "properti", "call", "remov", "forc", "rebalanc", "partitionnod", "partit", "node"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove redundant patch. Remove forced rebalancing from PartitionNode. Remove inconsistent check for group strategy. Remove redundant patch. ", "B_clean_title": ["remov", "redund", "patch", "remov", "forc", "rebalanc", "partitionnod", "partit", "node", "remov", "inconsist", "check", "group", "strategi", "remov", "redund", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove unused incompilable code. Remove old patch. Remove redundant patch. ", "B_clean_title": ["remov", "unus", "incompil", "code", "remov", "old", "patch", "remov", "redund", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Remove redundant patch. Updated toString patch. Remove inconsistent check for group strategy. ", "B_clean_title": ["remov", "old", "patch", "remov", "redund", "patch", "updat", "tostr", "string", "patch", "remov", "inconsist", "check", "group", "strategi"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Fix inconsistent sort for group strategy. Fix bug in GroupReduceWithCombineProperties. update tmp. Remove old patch. ", "B_clean_title": ["fix", "inconsist", "sort", "group", "strategi", "fix", "bug", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti", "updat", "tmp", "remov", "old", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove redundant patch. Allow restrictive plan hints at compile time. Removed break line. Remove old patch. ", "B_clean_title": ["remov", "redund", "patch", "allow", "restrict", "plan", "hint", "at", "compil", "time", "remov", "break", "line", "remov", "old", "patch"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove inconsistent check for group strategy. Remove old patch. Allow restrictive plan hints at compile time. ", "B_clean_title": ["remov", "inconsist", "check", "group", "strategi", "remov", "old", "patch", "allow", "restrict", "plan", "hint", "at", "compil", "time"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove redundant mark on GroupReduceWithCombineProperties node. Remove forced rebalancing from PartitionNode. Allow restrictive plan hints at compile time. ", "B_clean_title": ["remov", "redund", "mark", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti", "node", "remov", "forc", "rebalanc", "partitionnod", "partit", "node", "allow", "restrict", "plan", "hint", "at", "compil", "time"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Fix bug in GroupReduceWithCombineProperties. Remove patch from rgps. Updated patch for compiler toString. ", "B_clean_title": ["fix", "bug", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti", "remov", "patch", "rgp", "updat", "patch", "compil", "tostr", "string"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove forced rebalancing from PartitionNode. add a heuristic disk cost comparison to the disk cost comparison. Remove redundant initProperties call. ", "B_clean_title": ["remov", "forc", "rebalanc", "partitionnod", "partit", "node", "add", "heurist", "disk", "cost", "comparison", "disk", "cost", "comparison", "remov", "redund", "initproperti", "init", "properti", "call"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove old patch. Remove patch. Fix inconsistent sort for group strategy. Remove redundant patch. Remove redundant merge of GroupReduceWithCombineProperties .. ", "B_clean_title": ["remov", "old", "patch", "remov", "patch", "fix", "inconsist", "sort", "group", "strategi", "remov", "redund", "patch", "remov", "redund", "merg", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove forced rebalancing from PartitionNode. Remove redundant patch. Remove redundant merge of GroupReduceWithCombineProperties .. ", "B_clean_title": ["remov", "forc", "rebalanc", "partitionnod", "partit", "node", "remov", "redund", "patch", "remov", "redund", "merg", "groupreducewithcombineproperti", "group", "reduc", "combin", "properti"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove inconsistent check for group strategy. Remove old patch. Removed a couple incorrect lines from a previous commit that prevents you from using an old one. Removed a couple of unused lines. ", "B_clean_title": ["remov", "inconsist", "check", "group", "strategi", "remov", "old", "patch", "remov", "coupl", "incorrect", "line", "previou", "commit", "that", "prevent", "you", "old", "one", "remov", "coupl", "unus", "line"]},
{"A_title": "Optimizer prunes all candidates when unable to reuse sort propertiesPrograms fail with an exception that no plan could be created. The bug can be reproduced by the following code:  code val data : DataSet(Long Long) = ...  data.distinct(0 1).groupBy(0).reduceGroup(...) code", "A_clean_title": ["optim", "prune", "all", "candid", "when", "unabl", "reus", "sort", "propertiesprogram", "properti", "program", "fail", "except", "that", "no", "plan", "could", "creat", "bug", "reproduc", "by", "follow", "code", "code", "val", "data", "dataset", "data", "set", "long", "long", "data", "distinct", "groupbi", "group", "by", "reducegroup", "reduc", "group", "code"], "B_title": "Remove a redundant check. Allow restrictive plan hints at compile time. Remove patch from rgps. Remove redundant patch. ", "B_clean_title": ["remov", "redund", "check", "allow", "restrict", "plan", "hint", "at", "compil", "time", "remov", "patch", "rgp", "remov", "redund", "patch"]},
{"A_title": "MathUtils.gcd(u v) fails when u and v both contain a high power of 2The test at the beginning of MathUtils.gcd(u v) for arguments equal to zero fails when u and v contain high enough powers of 2 so that their product overflows to zero.         assertEquals(3 * (1<<15) MathUtils.gcd(3 * (1<<20) 9 * (1<<15))); Fix: Replace the test at the start of MathUtils.gcd()         if (u * v == 0)  by         if (u == 0 || v == 0) ", "A_clean_title": ["mathutil", "gcd", "math", "util", "fail", "when", "both", "contain", "high", "power", "2the", "test", "at", "begin", "mathutil", "gcd", "math", "util", "argument", "equal", "zero", "fail", "when", "contain", "high", "enough", "power", "so", "that", "their", "product", "overflow", "zero", "assertequ", "assert", "equal", "15", "mathutil", "gcd", "math", "util", "20", "15", "fix", "replac", "test", "at", "start", "mathutil", "gcd", "math", "util", "by"], "B_title": "Fix gcd ( ). ", "B_clean_title": ["fix", "gcd"]},
{"A_title": "MathUtils.gcd(u v) fails when u and v both contain a high power of 2The test at the beginning of MathUtils.gcd(u v) for arguments equal to zero fails when u and v contain high enough powers of 2 so that their product overflows to zero.         assertEquals(3 * (1<<15) MathUtils.gcd(3 * (1<<20) 9 * (1<<15))); Fix: Replace the test at the start of MathUtils.gcd()         if (u * v == 0)  by         if (u == 0 || v == 0) ", "A_clean_title": ["mathutil", "gcd", "math", "util", "fail", "when", "both", "contain", "high", "power", "2the", "test", "at", "begin", "mathutil", "gcd", "math", "util", "argument", "equal", "zero", "fail", "when", "contain", "high", "enough", "power", "so", "that", "their", "product", "overflow", "zero", "assertequ", "assert", "equal", "15", "mathutil", "gcd", "math", "util", "20", "15", "fix", "replac", "test", "at", "start", "mathutil", "gcd", "math", "util", "by"], "B_title": "Fix gcd with System . currentTimeMillis ( ). ", "B_clean_title": ["fix", "gcd", "system", "currenttimemilli", "current", "time", "milli"]},
{"A_title": "FastMath.pow deviates from Math.pow for negative finite base values with an exponent 2^52 < y < 2^53As reported by Jeff Hain: pow(doubledouble): Math.pow(-1.05.000000000000001E15) = -1.0 FastMath.pow(-1.05.000000000000001E15) = 1.0 ===> This is due to considering that power is an even integer if it is >= 2^52 while you need to test that it is >= 2^53 for it. ===> replace if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) with if (y >= 2*TWO_POWER_52 || y <= -2*TWO_POWER_52) and that solves it.", "A_clean_title": ["fastmath", "pow", "fast", "math", "deviat", "math", "pow", "neg", "finit", "base", "valu", "expon", "2^52", "2^53a", "report", "by", "jeff", "hain", "pow", "doubledoubl", "math", "pow", "05", "000000000000001e15", "fastmath", "pow", "fast", "math", "05", "000000000000001e15", "thi", "due", "consid", "that", "power", "even", "integ", "it", "2^52", "while", "you", "need", "test", "that", "it", "2^53", "it", "replac", "two", "power", "52", "two", "power", "52", "two", "power", "52", "two", "power", "52", "that", "solv", "it"], "B_title": "FastMath . pow ( - x  y ) doesn  t handle long precision precision thing. ", "B_clean_title": ["fastmath", "fast", "math", "pow", "doesn", "handl", "long", "precis", "precis", "thing"]},
{"A_title": "FastMath.pow deviates from Math.pow for negative finite base values with an exponent 2^52 < y < 2^53As reported by Jeff Hain: pow(doubledouble): Math.pow(-1.05.000000000000001E15) = -1.0 FastMath.pow(-1.05.000000000000001E15) = 1.0 ===> This is due to considering that power is an even integer if it is >= 2^52 while you need to test that it is >= 2^53 for it. ===> replace if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) with if (y >= 2*TWO_POWER_52 || y <= -2*TWO_POWER_52) and that solves it.", "A_clean_title": ["fastmath", "pow", "fast", "math", "deviat", "math", "pow", "neg", "finit", "base", "valu", "expon", "2^52", "2^53a", "report", "by", "jeff", "hain", "pow", "doubledoubl", "math", "pow", "05", "000000000000001e15", "fastmath", "pow", "fast", "math", "05", "000000000000001e15", "thi", "due", "consid", "that", "power", "even", "integ", "it", "2^52", "while", "you", "need", "test", "that", "it", "2^53", "it", "replac", "two", "power", "52", "two", "power", "52", "two", "power", "52", "two", "power", "52", "that", "solv", "it"], "B_title": "Fix pow ( x  y ). ", "B_clean_title": ["fix", "pow"]},
{"A_title": "FastMath.pow deviates from Math.pow for negative finite base values with an exponent 2^52 < y < 2^53As reported by Jeff Hain: pow(doubledouble): Math.pow(-1.05.000000000000001E15) = -1.0 FastMath.pow(-1.05.000000000000001E15) = 1.0 ===> This is due to considering that power is an even integer if it is >= 2^52 while you need to test that it is >= 2^53 for it. ===> replace if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) with if (y >= 2*TWO_POWER_52 || y <= -2*TWO_POWER_52) and that solves it.", "A_clean_title": ["fastmath", "pow", "fast", "math", "deviat", "math", "pow", "neg", "finit", "base", "valu", "expon", "2^52", "2^53a", "report", "by", "jeff", "hain", "pow", "doubledoubl", "math", "pow", "05", "000000000000001e15", "fastmath", "pow", "fast", "math", "05", "000000000000001e15", "thi", "due", "consid", "that", "power", "even", "integ", "it", "2^52", "while", "you", "need", "test", "that", "it", "2^53", "it", "replac", "two", "power", "52", "two", "power", "52", "two", "power", "52", "two", "power", "52", "that", "solv", "it"], "B_title": "Fix output of Math . pow ( x  y ). ", "B_clean_title": ["fix", "output", "math", "pow"]},
{"A_title": "FastMath.pow deviates from Math.pow for negative finite base values with an exponent 2^52 < y < 2^53As reported by Jeff Hain: pow(doubledouble): Math.pow(-1.05.000000000000001E15) = -1.0 FastMath.pow(-1.05.000000000000001E15) = 1.0 ===> This is due to considering that power is an even integer if it is >= 2^52 while you need to test that it is >= 2^53 for it. ===> replace if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) with if (y >= 2*TWO_POWER_52 || y <= -2*TWO_POWER_52) and that solves it.", "A_clean_title": ["fastmath", "pow", "fast", "math", "deviat", "math", "pow", "neg", "finit", "base", "valu", "expon", "2^52", "2^53a", "report", "by", "jeff", "hain", "pow", "doubledoubl", "math", "pow", "05", "000000000000001e15", "fastmath", "pow", "fast", "math", "05", "000000000000001e15", "thi", "due", "consid", "that", "power", "even", "integ", "it", "2^52", "while", "you", "need", "test", "that", "it", "2^53", "it", "replac", "two", "power", "52", "two", "power", "52", "two", "power", "52", "two", "power", "52", "that", "solv", "it"], "B_title": "FastMath . pow ( - x  y ) doesn  t handle exponent range in JS backend. ", "B_clean_title": ["fastmath", "fast", "math", "pow", "doesn", "handl", "expon", "rang", "js", "backend"]},
{"A_title": "DateUtils.isSameLocalTime does not work correctHi I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)", "A_clean_title": ["dateutil", "issamelocaltim", "date", "util", "same", "local", "time", "not", "work", "correcthi", "correct", "hi", "think", "found", "bug", "dateutil", "date", "util", "class", "method", "issamelocaltim", "same", "local", "time", "exampl", "calendar", "calendar", "getinst", "get", "instanc", "settimeinmilli", "set", "time", "milli", "1297364400000l", "calendar", "calendar", "getinst", "get", "instanc", "settimeinmilli", "set", "time", "milli", "1297321200000l", "assert", "assertfals", "assert", "fals", "dateutil", "issamelocaltim", "date", "util", "same", "local", "time", "thi", "becaus", "method", "compar", "cal1", "get", "calendar", "hour", "cal2", "get", "calendar", "hour", "but", "think", "it", "ha", "cal1", "get", "calendar", "hour", "day", "cal2", "get", "calendar", "hour", "day"], "B_title": "Fixed bug for calendars with the same HOUR value. ", "B_clean_title": ["fix", "bug", "calendar", "same", "hour", "valu"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fix previous patch. ", "B_clean_title": ["fix", "previou", "patch"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fix FDistributionImpl . getDenominatorDegreesOfFreedom ( ). ", "B_clean_title": ["fix", "fdistributionimpl", "distribut", "impl", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fix FDistributionImpl . getDenominatorDegreesOfFreedom ( ). ", "B_clean_title": ["fix", "fdistributionimpl", "distribut", "impl", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fix POSIX issue in FDistributionImpl . getInitialDomain ( ). ", "B_clean_title": ["fix", "posix", "issu", "fdistributionimpl", "distribut", "impl", "getinitialdomain", "get", "initi", "domain"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "fix a minor bug in Controllers. ", "B_clean_title": ["fix", "minor", "bug", "control"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "removed erroneous legacy change .. ", "B_clean_title": ["remov", "erron", "legaci", "chang"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "remove extraneous line. ", "B_clean_title": ["remov", "extran", "line"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fix FDistributionImpl . getDenominatorDegreesOfFreedom ( ). ", "B_clean_title": ["fix", "fdistributionimpl", "distribut", "impl", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fixed incorrect patch. ", "B_clean_title": ["fix", "incorrect", "patch"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fix case. ", "B_clean_title": ["fix", "case"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "fix bug in double precision functions. ", "B_clean_title": ["fix", "bug", "doubl", "precis", "function"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "removed erroneous import. Fix my bad in this case. fixed return type for FDistributionImpl # getDenominatorDegreesOfFreedom. ", "B_clean_title": ["remov", "erron", "import", "fix", "my", "bad", "thi", "case", "fix", "return", "type", "fdistributionimpl", "distribut", "impl", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom"]}]