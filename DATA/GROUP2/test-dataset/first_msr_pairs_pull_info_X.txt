[{"A_title": "Column-indicating caret is sometimes not in error outputNone", "A_clean_title": ["column", "indic", "caret", "sometim", "not", "error", "outputnon", "output", "none"], "B_title": "Remove whitespaces from sourceExcerpt. ", "B_clean_title": ["remov", "whitespac", "sourceexcerpt", "sourc", "excerpt"]},
{"A_title": "Generate change list separated by types using labelsAs discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like question or refactoring). There is also headerForOtherChanges method to override default Other header.", "A_clean_title": ["gener", "chang", "list", "separ", "by", "type", "labelsa", "label", "as", "discuss", "mail", "list", "instead", "one", "big", "list", "improv", "chang", "list", "releas", "divid", "into", "chang", "type", "base", "label", "it", "requir", "specifi", "which", "label", "consid", "separ", "some", "other", "label", "exclud", "like", "question", "or", "refactor", "there", "also", "headerforotherchang", "header", "other", "chang", "method", "overrid", "default", "other", "header"], "B_title": "Fix toStringEquals with null arg. ", "B_clean_title": ["fix", "tostringequ", "string", "equal", "null", "arg"]},
{"A_title": "Generate change list separated by types using labelsAs discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like question or refactoring). There is also headerForOtherChanges method to override default Other header.", "A_clean_title": ["gener", "chang", "list", "separ", "by", "type", "labelsa", "label", "as", "discuss", "mail", "list", "instead", "one", "big", "list", "improv", "chang", "list", "releas", "divid", "into", "chang", "type", "base", "label", "it", "requir", "specifi", "which", "label", "consid", "separ", "some", "other", "label", "exclud", "like", "question", "or", "refactor", "there", "also", "headerforotherchang", "header", "other", "chang", "method", "overrid", "default", "other", "header"], "B_title": "Fix toStringEquals in ArgumentMatchingTool. ", "B_clean_title": ["fix", "tostringequ", "string", "equal", "argumentmatchingtool", "argument", "match", "tool"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. ", "B_clean_title": ["fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a typo in solve ( ). ", "B_clean_title": ["fix", "typo", "solv"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Added missing throws. ", "B_clean_title": ["ad", "miss", "throw"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated imports. Added missing closing parenthesis .. ", "B_clean_title": ["updat", "import", "ad", "miss", "close", "parenthesi"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "formatting of numbers with spaces does not make much sense for number utils. ", "B_clean_title": ["format", "number", "space", "not", "make", "much", "sens", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix BigDecimal from string startsWith ( # 77 ). ", "B_clean_title": ["fix", "bigdecim", "big", "decim", "string", "startswith", "start", "77"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Handle early NPE when NumberUtils . startsWith ( ) is true. ", "B_clean_title": ["handl", "earli", "npe", "when", "numberutil", "number", "util", "startswith", "start", "true"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  --  from NumberUtils . startsWith ( )  it was restricting our. ", "B_clean_title": ["remov", "unnecessari", "numberutil", "number", "util", "startswith", "start", "it", "wa", "restrict", "our"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix 0x mistake in patch. ", "B_clean_title": ["fix", "0x", "mistak", "patch"]},
{"A_title": "Bugs in Frequency APII think the existing Frequency API has some bugs in it. The addValue(Object v) method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException. In fact the problem is with the first call to addValue(Object) which should not allow a plain Object to be added - it should only allow Comparable objects. This could be fixed by checking that the object is Comparable. Similar considerations apply to the getCumFreq(Object) and getCumPct(Object) methods - they will only work with objects that implement Comparable. The getCount(Object) and getPct(Object) methods dont fail when given a non-Comparable object (because the class cast exception is caught) however they just return 0 as if the object was not present:          final Object OBJ = new Object();         f.addValue(OBJ); // This ought to fail but doesnt causing the unexpected behaviour below         System.out.println(f.getCount(OBJ)); // 0         System.out.println(f.getPct(OBJ)); // 0.0   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object. Also it should make it easier to implement generics. However this would cause compilation failures for some programs that pass Object rather than Comparable to the class. These would need recoding but I think they would continue to run OK against the new API. It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object. But is that a viable program? It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail.", "A_clean_title": ["bug", "frequenc", "apii", "think", "exist", "frequenc", "api", "ha", "some", "bug", "it", "addvalu", "add", "valu", "object", "method", "allow", "one", "add", "plain", "object", "but", "one", "not", "add", "anyth", "further", "instanc", "as", "second", "add", "fail", "illegalargumentexcept", "illeg", "argument", "except", "fact", "problem", "first", "call", "addvalu", "add", "valu", "object", "which", "not", "allow", "plain", "object", "ad", "it", "onli", "allow", "compar", "object", "thi", "could", "fix", "by", "check", "that", "object", "compar", "similar", "consider", "appli", "getcumfreq", "get", "cum", "freq", "object", "getcumpct", "get", "cum", "pct", "object", "method", "they", "will", "onli", "work", "object", "that", "implement", "compar", "getcount", "get", "count", "object", "getpct", "get", "pct", "object", "method", "dont", "fail", "when", "given", "non", "compar", "object", "becaus", "class", "cast", "except", "caught", "howev", "they", "just", "return", "as", "object", "wa", "not", "present", "final", "object", "obj", "new", "object", "addvalu", "add", "valu", "obj", "thi", "ought", "fail", "but", "doesnt", "caus", "unexpect", "behaviour", "below", "system", "out", "println", "getcount", "get", "count", "obj", "system", "out", "println", "getpct", "get", "pct", "obj", "rather", "than", "ad", "extra", "check", "compar", "it", "seem", "me", "that", "api", "would", "much", "improv", "by", "compar", "instead", "object", "also", "it", "make", "it", "easier", "implement", "gener", "howev", "thi", "would", "caus", "compil", "failur", "some", "program", "that", "pass", "object", "rather", "than", "compar", "class", "these", "would", "need", "recod", "but", "think", "they", "would", "continu", "run", "ok", "against", "new", "api", "it", "would", "also", "affect", "run", "time", "behaviour", "slightli", "as", "first", "attempt", "add", "non", "compar", "object", "would", "fail", "rather", "than", "second", "add", "possibl", "valid", "object", "but", "that", "viabl", "program", "it", "onli", "add", "one", "object", "ani", "attempt", "get", "statist", "will", "either", "return", "or", "except", "appli", "instanceof", "fix", "would", "also", "caus", "it", "fail"], "B_title": "Fix a bug in Frequency . put ( Object  Long ). ", "B_clean_title": ["fix", "bug", "frequenc", "put", "object", "long"]},
{"A_title": "Bugs in Frequency APII think the existing Frequency API has some bugs in it. The addValue(Object v) method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException. In fact the problem is with the first call to addValue(Object) which should not allow a plain Object to be added - it should only allow Comparable objects. This could be fixed by checking that the object is Comparable. Similar considerations apply to the getCumFreq(Object) and getCumPct(Object) methods - they will only work with objects that implement Comparable. The getCount(Object) and getPct(Object) methods dont fail when given a non-Comparable object (because the class cast exception is caught) however they just return 0 as if the object was not present:          final Object OBJ = new Object();         f.addValue(OBJ); // This ought to fail but doesnt causing the unexpected behaviour below         System.out.println(f.getCount(OBJ)); // 0         System.out.println(f.getPct(OBJ)); // 0.0   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object. Also it should make it easier to implement generics. However this would cause compilation failures for some programs that pass Object rather than Comparable to the class. These would need recoding but I think they would continue to run OK against the new API. It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object. But is that a viable program? It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail.", "A_clean_title": ["bug", "frequenc", "apii", "think", "exist", "frequenc", "api", "ha", "some", "bug", "it", "addvalu", "add", "valu", "object", "method", "allow", "one", "add", "plain", "object", "but", "one", "not", "add", "anyth", "further", "instanc", "as", "second", "add", "fail", "illegalargumentexcept", "illeg", "argument", "except", "fact", "problem", "first", "call", "addvalu", "add", "valu", "object", "which", "not", "allow", "plain", "object", "ad", "it", "onli", "allow", "compar", "object", "thi", "could", "fix", "by", "check", "that", "object", "compar", "similar", "consider", "appli", "getcumfreq", "get", "cum", "freq", "object", "getcumpct", "get", "cum", "pct", "object", "method", "they", "will", "onli", "work", "object", "that", "implement", "compar", "getcount", "get", "count", "object", "getpct", "get", "pct", "object", "method", "dont", "fail", "when", "given", "non", "compar", "object", "becaus", "class", "cast", "except", "caught", "howev", "they", "just", "return", "as", "object", "wa", "not", "present", "final", "object", "obj", "new", "object", "addvalu", "add", "valu", "obj", "thi", "ought", "fail", "but", "doesnt", "caus", "unexpect", "behaviour", "below", "system", "out", "println", "getcount", "get", "count", "obj", "system", "out", "println", "getpct", "get", "pct", "obj", "rather", "than", "ad", "extra", "check", "compar", "it", "seem", "me", "that", "api", "would", "much", "improv", "by", "compar", "instead", "object", "also", "it", "make", "it", "easier", "implement", "gener", "howev", "thi", "would", "caus", "compil", "failur", "some", "program", "that", "pass", "object", "rather", "than", "compar", "class", "these", "would", "need", "recod", "but", "think", "they", "would", "continu", "run", "ok", "against", "new", "api", "it", "would", "also", "affect", "run", "time", "behaviour", "slightli", "as", "first", "attempt", "add", "non", "compar", "object", "would", "fail", "rather", "than", "second", "add", "possibl", "valid", "object", "but", "that", "viabl", "program", "it", "onli", "add", "one", "object", "ani", "attempt", "get", "statist", "will", "either", "return", "or", "except", "appli", "instanceof", "fix", "would", "also", "caus", "it", "fail"], "B_title": "Fixing rat phase. ", "B_clean_title": ["fix", "rat", "phase"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Use availableLocaleList ( ) instead of cAvailableLocaleSet. ", "B_clean_title": ["use", "availablelocalelist", "avail", "local", "list", "instead", "cavailablelocaleset", "avail", "local", "set"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Fixed LocaleUtils # isAvailableLocale ( ). ", "B_clean_title": ["fix", "localeutil", "local", "util", "isavailablelocal", "avail", "local"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "@@ isAvailableLocale ( )  removed 222 from the comment. ", "B_clean_title": ["isavailablelocal", "avail", "local", "remov", "222", "comment"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Use the available locale list. ", "B_clean_title": ["use", "avail", "local", "list"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Use new java . util . HashSet ( ) instead of cAvailableLocaleSet. ", "B_clean_title": ["use", "new", "java", "util", "hashset", "hash", "set", "instead", "cavailablelocaleset", "avail", "local", "set"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Fixed bug in LocaleUtils. ", "B_clean_title": ["fix", "bug", "localeutil", "local", "util"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Improved javadoc in LocaleUtils. ", "B_clean_title": ["improv", "javadoc", "localeutil", "local", "util"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Add null check. ", "B_clean_title": ["add", "null", "check"]},
{"A_title": "StringIndexOutOfBoundsException in CharSequenceTranslatorI found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. uD83DuDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception      assertEquals(uD83DuDE30 StringEscapeUtils.escapeCsv(uD83DuDE30));    Youll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 at java.lang.String.charAt(String.java:658) at java.lang.Character.codePointAt(Character.java:4668) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached the method affected:  public final void translate(CharSequence input Writer out) throws IOException", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "charsequencetranslatori", "char", "sequenc", "translat", "found", "that", "there", "bad", "surrog", "pair", "handl", "charsequencetransl", "char", "sequenc", "translat", "thi", "simpl", "test", "case", "thi", "problem", "ud83dude30", "d83du", "de30", "surrog", "pair", "test", "public", "void", "testescapesurrogatepair", "test", "escap", "surrog", "pair", "throw", "except", "assertequ", "assert", "equal", "ud83dude30", "d83du", "de30", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "ud83dude30", "d83du", "de30", "youll", "get", "except", "as", "shown", "below", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:658", "at", "java", "lang", "charact", "codepointat", "code", "point", "at", "charact", "java:4668", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:95", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:59", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "stringescapeutil", "java:556", "string", "escap", "util", "patch", "attach", "method", "affect", "public", "final", "void", "translat", "charsequ", "char", "sequenc", "input", "writer", "out", "throw", "ioexcept", "io", "except"], "B_title": "Remove excess code point in source string. ", "B_clean_title": ["remov", "excess", "code", "point", "sourc", "string"]},
{"A_title": "StringIndexOutOfBoundsException in CharSequenceTranslatorI found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. uD83DuDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception      assertEquals(uD83DuDE30 StringEscapeUtils.escapeCsv(uD83DuDE30));    Youll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 at java.lang.String.charAt(String.java:658) at java.lang.Character.codePointAt(Character.java:4668) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached the method affected:  public final void translate(CharSequence input Writer out) throws IOException", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "charsequencetranslatori", "char", "sequenc", "translat", "found", "that", "there", "bad", "surrog", "pair", "handl", "charsequencetransl", "char", "sequenc", "translat", "thi", "simpl", "test", "case", "thi", "problem", "ud83dude30", "d83du", "de30", "surrog", "pair", "test", "public", "void", "testescapesurrogatepair", "test", "escap", "surrog", "pair", "throw", "except", "assertequ", "assert", "equal", "ud83dude30", "d83du", "de30", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "ud83dude30", "d83du", "de30", "youll", "get", "except", "as", "shown", "below", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:658", "at", "java", "lang", "charact", "codepointat", "code", "point", "at", "charact", "java:4668", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:95", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:59", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "stringescapeutil", "java:556", "string", "escap", "util", "patch", "attach", "method", "affect", "public", "final", "void", "translat", "charsequ", "char", "sequenc", "input", "writer", "out", "throw", "ioexcept", "io", "except"], "B_title": "Fix bug in CharSequenceTranslator. ", "B_clean_title": ["fix", "bug", "charsequencetransl", "char", "sequenc", "translat"]},
{"A_title": "StringIndexOutOfBoundsException in CharSequenceTranslatorI found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. uD83DuDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception      assertEquals(uD83DuDE30 StringEscapeUtils.escapeCsv(uD83DuDE30));    Youll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 at java.lang.String.charAt(String.java:658) at java.lang.Character.codePointAt(Character.java:4668) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached the method affected:  public final void translate(CharSequence input Writer out) throws IOException", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "charsequencetranslatori", "char", "sequenc", "translat", "found", "that", "there", "bad", "surrog", "pair", "handl", "charsequencetransl", "char", "sequenc", "translat", "thi", "simpl", "test", "case", "thi", "problem", "ud83dude30", "d83du", "de30", "surrog", "pair", "test", "public", "void", "testescapesurrogatepair", "test", "escap", "surrog", "pair", "throw", "except", "assertequ", "assert", "equal", "ud83dude30", "d83du", "de30", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "ud83dude30", "d83du", "de30", "youll", "get", "except", "as", "shown", "below", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:658", "at", "java", "lang", "charact", "codepointat", "code", "point", "at", "charact", "java:4668", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:95", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:59", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "stringescapeutil", "java:556", "string", "escap", "util", "patch", "attach", "method", "affect", "public", "final", "void", "translat", "charsequ", "char", "sequenc", "input", "writer", "out", "throw", "ioexcept", "io", "except"], "B_title": "Missing import. Fix bug in CharSequenceTranslator. ", "B_clean_title": ["miss", "import", "fix", "bug", "charsequencetransl", "char", "sequenc", "translat"]},
{"A_title": "bug with implicit namespaces across modulesNone", "A_clean_title": ["bug", "implicit", "namespac", "across", "modulesnon", "modul", "none"], "B_title": "remove lastIndexOf. ", "B_clean_title": ["remov", "lastindexof", "last", "index"]},
{"A_title": "1.10 regression (StackOverflowError) with interface where generic type has itself as upper bound.None", "A_clean_title": ["10", "regress", "stackoverflowerror", "stack", "overflow", "error", "interfac", "where", "gener", "type", "ha", "itself", "as", "upper", "bound", "none"], "B_title": "Fix contextualActualTypeParameters . put ( typeParameter  actualTypeArgument ). ", "B_clean_title": ["fix", "contextualactualtypeparamet", "contextu", "actual", "type", "paramet", "put", "typeparamet", "type", "paramet", "actualtypeargu", "actual", "type", "argument"]},
{"A_title": "possibly a bug in org.joda.time.field.FieldUtils.safeMultiplyIt seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1 int scalar) doesnt detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldnt see anything that looked relevant.", "A_clean_title": ["possibl", "bug", "org", "joda", "time", "field", "fieldutil", "safemultiplyit", "field", "util", "safe", "multipli", "it", "seem", "me", "that", "as", "current", "written", "joda", "time", "jar", "org", "joda", "time", "field", "fieldutil", "safemultipli", "field", "util", "safe", "multipli", "long", "val1", "int", "scalar", "doesnt", "detect", "overflow", "long", "val1", "long", "min", "valu", "int", "scalar", "attach", "file", "demonstr", "what", "think", "bug", "suggest", "patch", "look", "at", "joda", "time", "bug", "list", "sourceforg", "sourc", "forg", "but", "couldnt", "see", "anyth", "that", "look", "relev"], "B_title": "Fix fieldUtils. ", "B_clean_title": ["fix", "fieldutil", "field", "util"]},
{"A_title": "possibly a bug in org.joda.time.field.FieldUtils.safeMultiplyIt seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1 int scalar) doesnt detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldnt see anything that looked relevant.", "A_clean_title": ["possibl", "bug", "org", "joda", "time", "field", "fieldutil", "safemultiplyit", "field", "util", "safe", "multipli", "it", "seem", "me", "that", "as", "current", "written", "joda", "time", "jar", "org", "joda", "time", "field", "fieldutil", "safemultipli", "field", "util", "safe", "multipli", "long", "val1", "int", "scalar", "doesnt", "detect", "overflow", "long", "val1", "long", "min", "valu", "int", "scalar", "attach", "file", "demonstr", "what", "think", "bug", "suggest", "patch", "look", "at", "joda", "time", "bug", "list", "sourceforg", "sourc", "forg", "but", "couldnt", "see", "anyth", "that", "look", "relev"], "B_title": "Allow negative numbers in FieldUtils. ", "B_clean_title": ["allow", "neg", "number", "fieldutil", "field", "util"]},
{"A_title": "possibly a bug in org.joda.time.field.FieldUtils.safeMultiplyIt seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1 int scalar) doesnt detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldnt see anything that looked relevant.", "A_clean_title": ["possibl", "bug", "org", "joda", "time", "field", "fieldutil", "safemultiplyit", "field", "util", "safe", "multipli", "it", "seem", "me", "that", "as", "current", "written", "joda", "time", "jar", "org", "joda", "time", "field", "fieldutil", "safemultipli", "field", "util", "safe", "multipli", "long", "val1", "int", "scalar", "doesnt", "detect", "overflow", "long", "val1", "long", "min", "valu", "int", "scalar", "attach", "file", "demonstr", "what", "think", "bug", "suggest", "patch", "look", "at", "joda", "time", "bug", "list", "sourceforg", "sourc", "forg", "but", "couldnt", "see", "anyth", "that", "look", "relev"], "B_title": "Fix a bug in FieldUtils. ", "B_clean_title": ["fix", "bug", "fieldutil", "field", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Optimize toBoolean ( ). ", "B_clean_title": ["optim", "toboolean", "boolean"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing return statement. ", "B_clean_title": ["ad", "miss", "return", "statement"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing break. ", "B_clean_title": ["miss", "break"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing bracket. ", "B_clean_title": ["miss", "bracket"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing case in BooleanUtils. ", "B_clean_title": ["ad", "miss", "case", "booleanutil", "boolean", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing break. ", "B_clean_title": ["miss", "break"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing test for Y. ", "B_clean_title": ["miss", "test"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing break. ", "B_clean_title": ["miss", "break"]},
{"A_title": "combining @interface and multiple @extends can crash compilerNone", "A_clean_title": ["combin", "interfac", "multipl", "extend", "crash", "compilernon", "compil", "none"], "B_title": "Add null check in TypeCheck . java. Added missing for loop. ", "B_clean_title": ["add", "null", "check", "typecheck", "type", "check", "java", "ad", "miss", "loop"]},
{"A_title": "combining @interface and multiple @extends can crash compilerNone", "A_clean_title": ["combin", "interfac", "multipl", "extend", "crash", "compilernon", "compil", "none"], "B_title": "Added TypeCheck copy check. Added TypeCheck copy .. ", "B_clean_title": ["ad", "typecheck", "type", "check", "copi", "check", "ad", "typecheck", "type", "check", "copi"]},
{"A_title": "Dangerous code in PoissonDistributionImplIn the following excerpt from class PoissonDistributionImpl: PoissonDistributionImpl.java     public PoissonDistributionImpl(double p NormalDistribution z)          super();         setNormal(z);         setMean(p);        (1) Overridable methods are called within the constructor. (2) The reference z is stored and modified within the class. Ive encountered problem (1) in several classes while working on issue 348. In those cases in order to remove potential problems I copied/pasted the body of the setter methods inside the constructor but I think that a more elegant solution would be to remove the setters altogether (i.e. make the classes immutable). Problem (2) can also create unexpected behaviour. Is it really necessary to pass the NormalDistribution object; cant it be always created within the class?", "A_clean_title": ["danger", "code", "poissondistributionimplin", "poisson", "distribut", "impl", "follow", "excerpt", "class", "poissondistributionimpl", "poisson", "distribut", "impl", "poissondistributionimpl", "java", "poisson", "distribut", "impl", "public", "poissondistributionimpl", "poisson", "distribut", "impl", "doubl", "normaldistribut", "normal", "distribut", "super", "setnorm", "set", "normal", "setmean", "set", "mean", "overrid", "method", "are", "call", "within", "constructor", "refer", "store", "modifi", "within", "class", "ive", "encount", "problem", "sever", "class", "while", "work", "issu", "348", "those", "case", "order", "remov", "potenti", "problem", "copi", "past", "bodi", "setter", "method", "insid", "constructor", "but", "think", "that", "more", "eleg", "solut", "would", "remov", "setter", "altogeth", "make", "class", "immut", "problem", "also", "creat", "unexpect", "behaviour", "it", "realli", "necessari", "pass", "normaldistribut", "normal", "distribut", "object", "cant", "it", "alway", "creat", "within", "class"], "B_title": "Add missing import. Add a check for strictly positive p = 0 .. ", "B_clean_title": ["add", "miss", "import", "add", "check", "strictli", "posit"]},
{"A_title": "Reindex removes all nodes under index definition nodeReindex logic in IndexUpdate removes all child node from index definition node thus removing valid nodes which might be part of index defintion. It should only remove hidden nodes", "A_clean_title": ["reindex", "remov", "all", "node", "under", "index", "definit", "nodereindex", "node", "reindex", "logic", "indexupd", "index", "updat", "remov", "all", "child", "node", "index", "definit", "node", "thu", "remov", "valid", "node", "which", "might", "part", "index", "defint", "it", "onli", "remov", "hidden", "node"], "B_title": "- Reindex removes all nodes under index defenition node", "B_clean_title": ["reindex", "remov", "all", "node", "under", "index", "defenit", "node"]},
{"A_title": "Ignore the path parameters when reading the page classhttp://localhost:8080/linkomatic/wicket/bookmarkable/org.apache.wicket.examples.linkomatic.Page3;myjsessionid=123456 leads to :  WARN  - AbstractRepeater           - Child component of repeater org.apache.wicket.markup.repeater.RepeatingView:area has a non-safe child id of page1. Safe child ids must be composed of digits only. WARN  - WicketObjects              - Could not resolve class org.apache.wicket.examples.linkomatic.Page3;blass=koko java.lang.ClassNotFoundException: org/apache/wicket/examples/linkomatic/Page3;blass=koko at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:264) at org.apache.wicket.application.AbstractClassResolver.resolveClass(AbstractClassResolver.java:108) at org.apache.wicket.core.util.lang.WicketObjects.resolveClass(WicketObjects.java:72) at org.apache.wicket.core.request.mapper.AbstractComponentMapper.getPageClass(AbstractComponentMapper.java:139) at org.apache.wicket.core.request.mapper.BookmarkableMapper.parseRequest(BookmarkableMapper.java:118) at org.apache.wicket.core.request.mapper.AbstractBookmarkableMapper.mapRequest(AbstractBookmarkableMapper.java:292) at org.apache.wicket.request.mapper.CompoundRequestMapper.mapRequest(CompoundRequestMapper.java:152) at org.apache.wicket.request.cycle.RequestCycle.resolveRequestHandler(RequestCycle.java:190) ...  Such request at the moment works only if the the path parameter name is jsessionid", "A_clean_title": ["ignor", "path", "paramet", "when", "read", "page", "classhttp", "apach", "wicket", "exampl", "linkomat", "page3", "localhost:8080", "linkomat", "wicket", "bookmark", "org", "myjsessionid=123456", "lead", "warn", "abstractrepeat", "abstract", "repeat", "child", "compon", "repeat", "org", "apach", "wicket", "markup", "repeat", "repeatingview", "repeat", "view", "area", "ha", "non", "safe", "child", "id", "page1", "safe", "child", "id", "must", "compos", "digit", "onli", "warn", "wicketobject", "wicket", "object", "could", "not", "resolv", "class", "org", "apach", "wicket", "exampl", "linkomat", "page3", "blass=koko", "java", "lang", "classnotfoundexcept", "class", "not", "found", "except", "org", "apach", "wicket", "exampl", "linkomat", "page3", "blass=koko", "at", "java", "lang", "class", "forname0", "name0", "nativ", "method", "at", "java", "lang", "class", "fornam", "name", "class", "java:264", "at", "org", "apach", "wicket", "applic", "abstractclassresolv", "resolveclass", "abstract", "class", "resolv", "resolv", "class", "abstractclassresolv", "java:108", "abstract", "class", "resolv", "at", "org", "apach", "wicket", "core", "util", "lang", "wicketobject", "resolveclass", "wicket", "object", "resolv", "class", "wicketobject", "java:72", "wicket", "object", "at", "org", "apach", "wicket", "core", "request", "mapper", "abstractcomponentmapp", "getpageclass", "abstract", "compon", "mapper", "get", "page", "class", "abstractcomponentmapp", "java:139", "abstract", "compon", "mapper", "at", "org", "apach", "wicket", "core", "request", "mapper", "bookmarkablemapp", "parserequest", "bookmark", "mapper", "pars", "request", "bookmarkablemapp", "java:118", "bookmark", "mapper", "at", "org", "apach", "wicket", "core", "request", "mapper", "abstractbookmarkablemapp", "maprequest", "abstract", "bookmark", "mapper", "map", "request", "abstractbookmarkablemapp", "java:292", "abstract", "bookmark", "mapper", "at", "org", "apach", "wicket", "request", "mapper", "compoundrequestmapp", "maprequest", "compound", "request", "mapper", "map", "request", "compoundrequestmapp", "java:152", "compound", "request", "mapper", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "resolverequesthandl", "request", "cycl", "resolv", "request", "handler", "requestcycl", "java:190", "request", "cycl", "such", "request", "at", "moment", "work", "onli", "path", "paramet", "name", "jsessionid"], "B_title": "Ignore the path parameters when reading the page class", "B_clean_title": ["ignor", "path", "paramet", "when", "read", "page", "class"]},
{"A_title": "Index path property should be considered optional for copy on read logicAs part of changes done for OAK-4347 logic assumes that indexPath is always non null. This works fine for fresh setup where the indexPath would have been set by the initial indexing. However for upgraded setup this assumption would break as it might happen that index does not get updated with new approach and before that a read is performed.  Currently with updated code on upgraded setup following exception is seen   noformat Caused by: javax.security.auth.login.LoginException: java.lang.NullPointerException: Index path property :indexPath not found         at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:236)         at org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getIndexPathFromConfig(IndexDefinition.java:664)         at org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getSharedWorkingSet(IndexCopier.java:242)         at org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.wrapForRead(IndexCopier.java:140)         at org.apache.jackrabbit.oak.plugins.index.lucene.IndexNode.open(IndexNode.java:53)         at org.apache.jackrabbit.oak.plugins.index.lucene.IndexTracker.findIndexNode(IndexTracker.java:179)         at org.apache.jackrabbit.oak.plugins.index.lucene.IndexTracker.acquireIndexNode(IndexTracker.java:154)         at org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlans(LucenePropertyIndex.java:250) noformat  For this specific flow the indexPath can be passed in and not looked up from IndexDefinition", "A_clean_title": ["index", "path", "properti", "consid", "option", "copi", "read", "logica", "logic", "as", "part", "chang", "done", "oak", "4347", "logic", "assum", "that", "indexpath", "index", "path", "alway", "non", "null", "thi", "work", "fine", "fresh", "setup", "where", "indexpath", "index", "path", "would", "have", "been", "set", "by", "initi", "index", "howev", "upgrad", "setup", "thi", "assumpt", "would", "break", "as", "it", "might", "happen", "that", "index", "not", "get", "updat", "new", "approach", "befor", "that", "read", "perform", "current", "updat", "code", "upgrad", "setup", "follow", "except", "seen", "noformat", "caus", "by", "javax", "secur", "auth", "login", "loginexcept", "login", "except", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "index", "path", "properti", "indexpath", "index", "path", "not", "found", "at", "com", "googl", "common", "base", "precondit", "checknotnul", "check", "not", "null", "precondit", "java:236", "at", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "indexdefinit", "getindexpathfromconfig", "index", "definit", "get", "index", "path", "config", "indexdefinit", "java:664", "index", "definit", "at", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "indexcopi", "getsharedworkingset", "index", "copier", "get", "share", "work", "set", "indexcopi", "java:242", "index", "copier", "at", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "indexcopi", "wrapforread", "index", "copier", "wrap", "read", "indexcopi", "java:140", "index", "copier", "at", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "indexnod", "open", "index", "node", "indexnod", "java:53", "index", "node", "at", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "indextrack", "findindexnod", "index", "tracker", "find", "index", "node", "indextrack", "java:179", "index", "tracker", "at", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "indextrack", "acquireindexnod", "index", "tracker", "acquir", "index", "node", "indextrack", "java:154", "index", "tracker", "at", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "lucenepropertyindex", "getplan", "lucen", "properti", "index", "get", "plan", "lucenepropertyindex", "java:250", "lucen", "properti", "index", "noformat", "thi", "specif", "flow", "indexpath", "index", "path", "pass", "not", "look", "up", "indexdefinit", "index", "definit"], "B_title": "- Index path property should be considered optional for copy on read logic", "B_clean_title": ["index", "path", "properti", "consid", "option", "copi", "read", "logic"]},
{"A_title": "StringResourceModels doesnt seem to detach properlyIf a StringResourceModel contains a model for property substitutions and there has not been assigned a component it is relative to on construction time it will not detach the property substitution model.  See this thread for a full explanation http://apache-wicket.1842946.n4.nabble.com/StringResourceModels-doesn-t-seem-to-detach-properly-td4257267.html", "A_clean_title": ["stringresourcemodel", "string", "resourc", "model", "doesnt", "seem", "detach", "properlyif", "properli", "stringresourcemodel", "string", "resourc", "model", "contain", "model", "properti", "substitut", "there", "ha", "not", "been", "assign", "compon", "it", "rel", "construct", "time", "it", "will", "not", "detach", "properti", "substitut", "model", "see", "thi", "thread", "full", "explan", "http", "doesn", "seem", "detach", "properli", "apach", "wicket", "1842946", "n4", "nabbl", "td4257267", "html", "com", "stringresourcemodel", "string", "resourc", "model"], "B_title": "StringResourceModels doesnt seem to detach properly", "B_clean_title": ["stringresourcemodel", "string", "resourc", "model", "doesnt", "seem", "detach", "properli"]},
{"A_title": "Rare case for updateMembershipMatrix() in FuzzyKMeansClustererThe function updateMembershipMatrix() in FuzzyKMeansClusterer assigns the points to the cluster with the highest membership. Consider the following case:  If the distance between a point and the cluster center is zero then we will have a cluster membership of one and all other membership values will be zero.  So the if condition: if (membershipMatrixij > maxMembership)                      maxMembership = membershipMatrixij;                     newCluster = j;  will never be true during the for loop and newCluster will remain -1. This will throw an exception because of the line: clusters.get(newCluster)                     .addPoint(point);  Adding the following condition can solve the problem: double d; if (sum == 0) d = 1; else d = 1.0/sum;", "A_clean_title": ["rare", "case", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeansclustererth", "fuzzi", "mean", "cluster", "function", "updatemembershipmatrix", "updat", "membership", "matrix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "assign", "point", "cluster", "highest", "membership", "consid", "follow", "case", "distanc", "between", "point", "cluster", "center", "zero", "then", "we", "will", "have", "cluster", "membership", "one", "all", "other", "membership", "valu", "will", "zero", "so", "condit", "membershipmatrixij", "membership", "matrixij", "maxmembership", "max", "membership", "maxmembership", "max", "membership", "membershipmatrixij", "membership", "matrixij", "newclust", "new", "cluster", "will", "never", "true", "dure", "loop", "newclust", "new", "cluster", "will", "remain", "thi", "will", "throw", "except", "becaus", "line", "cluster", "get", "newclust", "new", "cluster", "addpoint", "add", "point", "point", "ad", "follow", "condit", "solv", "problem", "doubl", "sum", "sum"], "B_title": "Fix FuzzyKMeansClusterer when data points equal a cluster center. Thanks to Pashutan Modaresi", "B_clean_title": ["fix", "fuzzykmeanscluster", "fuzzi", "mean", "cluster", "when", "data", "point", "equal", "cluster", "center", "thank", "pashutan", "modaresi"]},
{"A_title": "BookmarkablePageLinks not working on a forwarded pageWhile migrating our app from 1.4 to 1.5 we have discovered a problem with how BookmarkablePageLinks are rendered.  The attached quickstart demonstrates the problem:  Two pages: HomePage and OtherPage mounted at: /content/home and /content/other respectively.  These are mounted using the encoder UrlPathPageParametersEncoder for backwards compatibility with existing 1.4 style URLs.  A filter has been established in web.xml to forward requests to root (eg. localhost) to localhost/content/home Note: I have left out the port :8080 part from all URL references so please insert when testing  Point browser to http://localhost and the page is forwarded to http://localhost/content/home and displays correctly (browser URL still shows http://localhost as desired) but the links do not work because they remove the content segment of the URL:  eg. Home link -> http://localhost/home - fails - should have been http://localhost/content/home  If you type in the full URL: http://localhost/content/home  then the home page displays and the links work correctly.  A similar page set  up works fine in 1.4.", "A_clean_title": ["bookmarkablepagelink", "bookmark", "page", "link", "not", "work", "forward", "pagewhil", "page", "while", "migrat", "our", "app", "we", "have", "discov", "problem", "how", "bookmarkablepagelink", "bookmark", "page", "link", "are", "render", "attach", "quickstart", "demonstr", "problem", "two", "page", "homepag", "home", "page", "otherpag", "other", "page", "mount", "at", "content", "home", "content", "other", "respect", "these", "are", "mount", "encod", "urlpathpageparametersencod", "url", "path", "page", "paramet", "encod", "backward", "compat", "exist", "style", "url", "ur", "ls", "filter", "ha", "been", "establish", "web", "xml", "forward", "request", "root", "eg", "localhost", "localhost", "content", "home", "note", "have", "left", "out", "port", ":8080", "part", "all", "url", "refer", "so", "pleas", "insert", "when", "test", "point", "browser", "http", "localhost", "page", "forward", "http", "localhost", "content", "home", "display", "correctli", "browser", "url", "still", "show", "http", "localhost", "as", "desir", "but", "link", "not", "work", "becaus", "they", "remov", "content", "segment", "url", "eg", "home", "link", "http", "localhost", "home", "fail", "have", "been", "http", "localhost", "content", "home", "you", "type", "full", "url", "http", "localhost", "content", "home", "then", "home", "page", "display", "link", "work", "correctli", "similar", "page", "set", "up", "work", "fine"], "B_title": "BookmarkablePageLinks not working on a forwarded page", "B_clean_title": ["bookmarkablepagelink", "bookmark", "page", "link", "not", "work", "forward", "page"]},
{"A_title": "BinomialDistribution deals with degenerate cases incorrectlyThe following calculation returns false results:  new BinomialDistribution(0 0.01).logProbability(0)  It evaluates to Double.NaN when it should be 0 (cf. for example dbinom(0 0 0.01 log=T) in R).  I attach a patch dealing with the problem. The patch also adds a test for this bug.", "A_clean_title": ["binomialdistribut", "binomi", "distribut", "deal", "degener", "case", "incorrectlyth", "incorrectli", "follow", "calcul", "return", "fals", "result", "new", "binomialdistribut", "binomi", "distribut", "01", "logprob", "log", "probabl", "it", "evalu", "doubl", "nan", "na", "when", "it", "cf", "exampl", "dbinom", "01", "log=t", "attach", "patch", "deal", "problem", "patch", "also", "add", "test", "thi", "bug"], "B_title": "Fixed BinomialDistribution to deal with degenerate cases correctly.", "B_clean_title": ["fix", "binomialdistribut", "binomi", "distribut", "deal", "degener", "case", "correctli"]},
{"A_title": "Wicket 1.5 RC-3 Bug with conditional commentsIE Conditional Comments with script block causes malformed HTML on Chrome and Firefox.", "A_clean_title": ["wicket", "rc", "bug", "condit", "commentsi", "comment", "ie", "condit", "comment", "script", "block", "caus", "malform", "html", "chrome", "firefox"], "B_title": "Wicket 1.5 RC-3 Bug with conditional comments", "B_clean_title": ["wicket", "rc", "bug", "condit", "comment"]},
{"A_title": "BufferedWebResponse fails to add/clear cookie in redirectbufferedWebResponse.addCookie( cookie );  That fails under certain conditions: (1) when called on the last of three 302 redirects during OpenID login; and (2) on single redirect immediately after container startup though it later recovers.  Failure confirmed in Firebug; no cookies sent in any of the response headers.  My workaround is to bypass the buffered response.  This works:  ((HttpServletResponse)bufferedWebResponse.getContainerResponse()).addCookie( cookie );", "A_clean_title": ["bufferedwebrespons", "buffer", "web", "respons", "fail", "add", "clear", "cooki", "redirectbufferedwebrespons", "addcooki", "redirectbuff", "web", "respons", "add", "cooki", "cooki", "that", "fail", "under", "certain", "condit", "when", "call", "last", "three", "302", "redirect", "dure", "openid", "open", "id", "login", "singl", "redirect", "immedi", "after", "contain", "startup", "though", "it", "later", "recov", "failur", "confirm", "firebug", "no", "cooki", "sent", "ani", "respons", "header", "my", "workaround", "bypass", "buffer", "respons", "thi", "work", "httpservletrespons", "http", "servlet", "respons", "bufferedwebrespons", "getcontainerrespons", "buffer", "web", "respons", "get", "contain", "respons", "addcooki", "add", "cooki", "cooki"], "B_title": "BufferedWebResponse fails to add/clear cookie in redirect", "B_clean_title": ["bufferedwebrespons", "buffer", "web", "respons", "fail", "add", "clear", "cooki", "redirect"]},
{"A_title": "MiniMap.iterator().next() should throw NoSuchElementExceptionThe wicket.util.collections.MiniMap.iterator().next() should throw NoSuchElementException when there are no more elements to return (line 235) please add: if(i >= size)     throw new NoSuchElementException();", "A_clean_title": ["minimap", "iter", "mini", "map", "next", "throw", "nosuchelementexceptionth", "no", "such", "element", "except", "wicket", "util", "collect", "minimap", "iter", "mini", "map", "next", "throw", "nosuchelementexcept", "no", "such", "element", "except", "when", "there", "are", "no", "more", "element", "return", "line", "235", "pleas", "add", "size", "throw", "new", "nosuchelementexcept", "no", "such", "element", "except"], "B_title": "More fixes off the back of WICKET-428 this time for MicroMap.", "B_clean_title": ["more", "fix", "off", "back", "wicket", "428", "thi", "time", "micromap", "micro", "map"]},
{"A_title": "Revisit PrivilegeDefinitionStores use of null as a child name parameterAs discussed on OAK-635 Im extracting the PrivilegeDefinitionStore code&patch into a dedicated issue.  Following the discussion on the dev list Ive filed it as a bug as nulls are not considered valid input parameters.", "A_clean_title": ["revisit", "privilegedefinitionstor", "privileg", "definit", "store", "use", "null", "as", "child", "name", "parametera", "paramet", "as", "discuss", "oak", "635", "im", "extract", "privilegedefinitionstor", "privileg", "definit", "store", "code", "patch", "into", "dedic", "issu", "follow", "discuss", "dev", "list", "ive", "file", "it", "as", "bug", "as", "null", "are", "not", "consid", "valid", "input", "paramet"], "B_title": ": Revisit PrivilegeDefinitionStores use of null as a child name parameter", "B_clean_title": ["revisit", "privilegedefinitionstor", "privileg", "definit", "store", "use", "null", "as", "child", "name", "paramet"]},
{"A_title": "Wide bounds to CMAESOptimizer result in NaN parameters passed to fitness functionIf you give large values as lower/upper bounds (for example -Double.MAX_VALUE as a lower bound) the optimizer can call the fitness function with parameters set to NaN.  My guess is this is due to FitnessFunction.encode/decode generating NaN when normalizing/denormalizing parameters.  For example if the difference between the lower and upper bound is greater than Double.MAX_VALUE encode could divide infinity by infinity.", "A_clean_title": ["wide", "bound", "cmaesoptim", "cmae", "optim", "result", "nan", "na", "paramet", "pass", "fit", "functionif", "function", "you", "give", "larg", "valu", "as", "lower", "upper", "bound", "exampl", "doubl", "max", "valu", "as", "lower", "bound", "optim", "call", "fit", "function", "paramet", "set", "nan", "na", "my", "guess", "thi", "due", "fitnessfunct", "fit", "function", "encod", "decod", "gener", "nan", "na", "when", "normal", "denorm", "paramet", "exampl", "differ", "between", "lower", "upper", "bound", "greater", "than", "doubl", "max", "valu", "encod", "could", "divid", "infin", "by", "infin"], "B_title": "Early detection that overflow will occur in the variables normalization procedure (encode method). Warning mentioned in the documentation.", "B_clean_title": ["earli", "detect", "that", "overflow", "will", "occur", "variabl", "normal", "procedur", "encod", "method", "warn", "mention", "document"]},
{"A_title": "Generate change list separated by types using labelsAs discussed on the mailing list instead of one big list of Improvements the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like question or refactoring). There is also headerForOtherChanges method to override default Other header.", "A_clean_title": ["gener", "chang", "list", "separ", "by", "type", "labelsa", "label", "as", "discuss", "mail", "list", "instead", "one", "big", "list", "improv", "chang", "list", "releas", "divid", "into", "chang", "type", "base", "label", "it", "requir", "specifi", "which", "label", "consid", "separ", "some", "other", "label", "exclud", "like", "question", "or", "refactor", "there", "also", "headerforotherchang", "header", "other", "chang", "method", "overrid", "default", "other", "header"], "B_title": "In order to fixed issue 79 (NPE) added null handling code", "B_clean_title": ["order", "fix", "issu", "79", "npe", "ad", "null", "handl", "code"]},
{"A_title": "NPE in BSPTree#fitToCell()Hello  I faced a NPE using  BSPTree#fitToCell() from the SVN trunk. I fixed the problem using a small patch I will attach to the ticket.", "A_clean_title": ["npe", "bsptree", "bsp", "tree", "fittocel", "fit", "cell", "hello", "face", "npe", "bsptree", "bsp", "tree", "fittocel", "fit", "cell", "svn", "trunk", "fix", "problem", "small", "patch", "will", "attach", "ticket"], "B_title": "Fixed NullPointerException in BSPTree.", "B_clean_title": ["fix", "nullpointerexcept", "null", "pointer", "except", "bsptree", "bsp", "tree"]},
{"A_title": "In wicket 1.5 urlFor returns incorrect string for package mounted pagesAttached two quickstart projects for 1.4 and 1.5.  Then access http://localhost:8080/app/Page1 and see 1.5 returns wrong address.", "A_clean_title": ["wicket", "urlfor", "url", "return", "incorrect", "string", "packag", "mount", "pagesattach", "page", "attach", "two", "quickstart", "project", "then", "access", "http", "localhost:8080", "app", "page1", "see", "return", "wrong", "address"], "B_title": "In wicket 1.5 urlFor returns incorrect string for package mounted pages", "B_clean_title": ["wicket", "urlfor", "url", "return", "incorrect", "string", "packag", "mount", "page"]},
{"A_title": "MemoryNodeBuilder.setNode() loses property valuescode builder.setNode(a nodeA); builder.child(a).setProperty(...); code  After the 2nd line executed properties initially present on nodeA are gone on builder.getNodeState().", "A_clean_title": ["memorynodebuild", "setnod", "memori", "node", "builder", "set", "node", "lose", "properti", "valuescod", "builder", "setnod", "set", "node", "nodea", "node", "builder", "child", "setproperti", "set", "properti", "code", "after", "2nd", "line", "execut", "properti", "initi", "present", "nodea", "node", "are", "gone", "builder", "getnodest", "get", "node", "state"], "B_title": "MemoryNodeBuilder.setNode() loses property values", "B_clean_title": ["memorynodebuild", "setnod", "memori", "node", "builder", "set", "node", "lose", "properti", "valu"]},
{"A_title": "XPath queries with ISO9075 escaped properties dont workXPath queries with ISO9075 escaped properties or relative path dont work as expected. Example:   code /jcr:root//*/element(*rep:User)_x002e_tokens/@jcr:primaryType code  The relative property should be converted to .tokens/@jcr:primaryType but is not.  This issue is similar to OAK-1000 but for property names or relative properties.", "A_clean_title": ["xpath", "path", "queri", "iso9075", "escap", "properti", "dont", "workxpath", "work", "path", "queri", "iso9075", "escap", "properti", "or", "rel", "path", "dont", "work", "as", "expect", "exampl", "code", "jcr", "root", "element", "rep", "user", "x002e", "token", "jcr", "primarytyp", "primari", "type", "code", "rel", "properti", "convert", "token", "jcr", "primarytyp", "primari", "type", "but", "not", "thi", "issu", "similar", "oak", "1000", "but", "properti", "name", "or", "rel", "properti"], "B_title": "XPath queries with ISO9075 escaped properties dont work", "B_clean_title": ["xpath", "path", "queri", "iso9075", "escap", "properti", "dont", "work"]},
{"A_title": "AbstractRandomGenerator nextInt() and nextLong() default implementations generate only positive valuesThe javadoc for these methods (and what is specified in the RandomGenerator interface) says that all int / long values should be in the range of these methods.  The default implementations provided in this class do not generate negative values.", "A_clean_title": ["abstractrandomgener", "abstract", "random", "gener", "nextint", "next", "int", "nextlong", "next", "long", "default", "implement", "gener", "onli", "posit", "valuesth", "valu", "javadoc", "these", "method", "what", "specifi", "randomgener", "random", "gener", "interfac", "say", "that", "all", "int", "long", "valu", "rang", "these", "method", "default", "implement", "provid", "thi", "class", "not", "gener", "neg", "valu"], "B_title": "Fixed bugs in AbstractRandomGenerator nextInt() and nextLong() default implementations.  Prior to the fix for this issue these methods generated only positive values.", "B_clean_title": ["fix", "bug", "abstractrandomgener", "abstract", "random", "gener", "nextint", "next", "int", "nextlong", "next", "long", "default", "implement", "prior", "fix", "thi", "issu", "these", "method", "gener", "onli", "posit", "valu"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "NumberUtils#createNumber - bad behaviour for leading --", "B_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead"]},
{"A_title": "ZooKeeperCheckpointIDCounter.start() can block JobManager actorIn HA mode the job manager enables checkpoints during submission of streaming programs.  This leads to call to ZooKeeperCheckpointIDCounter.start() which communicates with ZooKeeper. This can block the job manager actor.  A solution is to start the counter later instead of the CheckpointCoordinator constructor.", "A_clean_title": ["zookeepercheckpointidcount", "start", "zoo", "keeper", "checkpoint", "id", "counter", "block", "jobmanag", "job", "manag", "actorin", "actor", "mode", "job", "manag", "enabl", "checkpoint", "dure", "submiss", "stream", "program", "thi", "lead", "call", "zookeepercheckpointidcount", "start", "zoo", "keeper", "checkpoint", "id", "counter", "which", "commun", "zookeep", "zoo", "keeper", "thi", "block", "job", "manag", "actor", "solut", "start", "counter", "later", "instead", "checkpointcoordin", "checkpoint", "coordin", "constructor"], "B_title": "runtime Defer start of checkpoint ID counter", "B_clean_title": ["runtim", "defer", "start", "checkpoint", "id", "counter"]},
{"A_title": "Missing properties from base class when recursive types are involved.When a type hierarchy as follows is constructed and the base class type is constructed first by the TypeFactory then serializing the sub class fails due to missing properties from the base class.   Serializes sub as  sub:2 where base:1sub:2 is expected. Ive created a minimal scenario of this bug here:  https://github.com/slobo-showbie/jackson-recursive-type-bug Ive experienced this bug in 2.7.8 2.8.8 and 2.8.8.1", "A_clean_title": ["miss", "properti", "base", "class", "when", "recurs", "type", "are", "involv", "when", "type", "hierarchi", "as", "follow", "construct", "base", "class", "type", "construct", "first", "by", "typefactori", "type", "factori", "then", "serial", "sub", "class", "fail", "due", "miss", "properti", "base", "class", "serial", "sub", "as", "sub:2", "where", "base:1sub:2", "expect", "ive", "creat", "minim", "scenario", "thi", "bug", "here", "http", "recurs", "type", "bug", "showbi", "jackson", "github", "com", "slobo", "ive", "experienc", "thi", "bug"], "B_title": "Merge pull request #1650 from slobo-showbie/2.8  Fix #1647: Missing properties from base class when recursive types are involved", "B_clean_title": ["merg", "pull", "request", "1650", "slobo", "showbi", "fix", "1647", "miss", "properti", "base", "class", "when", "recurs", "type", "are", "involv"]},
{"A_title": "ConditionalWriterIT is failingI noticed that the ConditionalWriterIT was failing in master.   Using the following command with git bisect I tracked it down to commit 3af75fc for ACCUMULO-4077 as the change which broke the IT.  Have not looked into why its failing yet.  noformat mvn clean verify -Dit.test=ConditionalWriterIT -Dfindbugs.skip -Dcheckstyle.skip -Dtest=foo -DfailIfNoTests=false noformat", "A_clean_title": ["conditionalwriterit", "condit", "writer", "it", "failingi", "fail", "notic", "that", "conditionalwriterit", "condit", "writer", "it", "wa", "fail", "master", "follow", "command", "git", "bisect", "track", "it", "down", "commit", "3af75fc", "accumulo", "4077", "as", "chang", "which", "broke", "it", "have", "not", "look", "into", "whi", "it", "fail", "yet", "noformat", "mvn", "clean", "verifi", "dit", "test=conditionalwriterit", "test=condit", "writer", "it", "dfindbug", "skip", "dcheckstyl", "skip", "dtest=foo", "dfailifnotests=fals", "dfail", "no", "tests=fals", "noformat"], "B_title": "Fixed bug with ByteBuffers thats do not start at 0", "B_clean_title": ["fix", "bug", "bytebuff", "byte", "buffer", "that", "not", "start", "at"]},
{"A_title": "RequestCycleListenerCollection.onException should not throw an exception when multiple listeners handle the exceptionWhen multiple listeners handle the exception RequestCycleListenerCollection should simple take the first handler. The current approach makes it impossible to add a listener that handles all exceptions and later add listeners for specific exceptions. Simply removing the if (handlers.size() > 1) should suffice.", "A_clean_title": ["requestcyclelistenercollect", "onexcept", "request", "cycl", "listen", "collect", "except", "not", "throw", "except", "when", "multipl", "listen", "handl", "exceptionwhen", "except", "when", "multipl", "listen", "handl", "except", "requestcyclelistenercollect", "request", "cycl", "listen", "collect", "simpl", "take", "first", "handler", "current", "approach", "make", "it", "imposs", "add", "listen", "that", "handl", "all", "except", "later", "add", "listen", "specif", "except", "simpli", "remov", "handler", "size", "suffic"], "B_title": "Improved exception handling strategy to not fail when multiple handlers are returned: just use the first one that is available. Issue: WICKET-3644", "B_clean_title": ["improv", "except", "handl", "strategi", "not", "fail", "when", "multipl", "handler", "are", "return", "just", "use", "first", "one", "that", "avail", "issu", "wicket", "3644"]},
{"A_title": "Unable to assign single tablet table migrated to 1.6.0Sorry for the screen caps no copy/paste from machines.  Background- several tables migrated from 1.5.1 to 1.6.0. Only one of which was a single tablet. Upon starting we noticed that that single table was not loading and the master was reporting an unassigned tablet. Had a stack trace in the monitor (attached).  Also attached is a a metadata scan of the table in question (ID: 12). I was able to get a functional copy of the table by offlining 12 and cloning it. It functioned without issues. Attached is a copy of its metadata scan as well (ID: 9o)  The stack trace leads me to it being a specific issue with the contents of srv:dir and the only difference is the relative vs. absolute file names. This cluster was not changed to multiple namenodes and ../tables/default_tablet does not exist. There are other tables which still use the relative naming scheme and the system does not seem to be having issues with them.", "A_clean_title": ["unabl", "assign", "singl", "tablet", "tabl", "migrat", "0sorri", "screen", "cap", "no", "copi", "past", "machin", "background", "sever", "tabl", "migrat", "onli", "one", "which", "wa", "singl", "tablet", "upon", "start", "we", "notic", "that", "that", "singl", "tabl", "wa", "not", "load", "master", "wa", "report", "unassign", "tablet", "had", "stack", "trace", "monitor", "attach", "also", "attach", "metadata", "scan", "tabl", "question", "id", "12", "wa", "abl", "get", "function", "copi", "tabl", "by", "offlin", "12", "clone", "it", "it", "function", "without", "issu", "attach", "copi", "it", "metadata", "scan", "as", "well", "id", "9o", "stack", "trace", "lead", "me", "it", "be", "specif", "issu", "content", "srv", "dir", "onli", "differ", "rel", "vs", "absolut", "file", "name", "thi", "cluster", "wa", "not", "chang", "multipl", "namenod", "tablet", "tabl", "default", "not", "exist", "there", "are", "other", "tabl", "which", "still", "use", "rel", "name", "scheme", "system", "not", "seem", "have", "issu", "them"], "B_title": "Include the table id when constructing an absolute path from a relative.", "B_clean_title": ["includ", "tabl", "id", "when", "construct", "absolut", "path", "rel"]},
{"A_title": "Original source line numbers are one-based in source maps.None", "A_clean_title": ["origin", "sourc", "line", "number", "are", "one", "base", "sourc", "map", "none"], "B_title": "Fix how source line numbers are stored in the source files. Fixes issue 575", "B_clean_title": ["fix", "how", "sourc", "line", "number", "are", "store", "sourc", "file", "fix", "issu", "575"]},
{"A_title": "ParentNotInitializedException on CtCommentsHello  When I build JavaFileTest from javapoet with comments enabled the build throw me the following error:   snippet example:   assertThat(source)", "A_clean_title": ["parentnotinitializedexcept", "parent", "not", "initi", "except", "ctcommentshello", "ct", "comment", "hello", "when", "build", "javafiletest", "java", "file", "test", "javapoet", "comment", "enabl", "build", "throw", "me", "follow", "error", "snippet", "exampl", "assertthat", "assert", "that", "sourc"], "B_title": "fix(comment): support comment on string concatenation (#1124)  fix #1123", "B_clean_title": ["fix", "comment", "support", "comment", "string", "concaten", "1124", "fix", "1123"]},
{"A_title": "Unable to set a compression input/output decorator to a  SmileFactoryI have a special need for the  riak-java-client which only allows me to use an ObjectMapper to serialize/deserialize key-values I would like to decorate a SmileFactory with compressors like LZ4 Snappy or GZip but at the moment this is not possible when I try a mapper like the following:   This is the exception I get:  I used Gzip as an example in reality Im using both LZ4 and Gzip and both throw exceptions when I try with a  SmileFactory  this works perfectly with a JsonFactory  the reason for me to prefer a SmileFactory over a JsonFactory is because it is notice-able faster than the JsonFactory so basically itll help compensate the price I pay for compression.", "A_clean_title": ["unabl", "set", "compress", "input", "output", "decor", "smilefactoryi", "smile", "factori", "have", "special", "need", "riak", "java", "client", "which", "onli", "allow", "me", "use", "objectmapp", "object", "mapper", "serial", "deseri", "key", "valu", "would", "like", "decor", "smilefactori", "smile", "factori", "compressor", "like", "lz4", "snappi", "or", "gzip", "zip", "but", "at", "moment", "thi", "not", "possibl", "when", "tri", "mapper", "like", "follow", "thi", "except", "get", "use", "gzip", "as", "exampl", "realiti", "im", "both", "lz4", "gzip", "both", "throw", "except", "when", "tri", "smilefactori", "smile", "factori", "thi", "work", "perfectli", "jsonfactori", "json", "factori", "reason", "me", "prefer", "smilefactori", "smile", "factori", "over", "jsonfactori", "json", "factori", "becaus", "it", "notic", "abl", "faster", "than", "jsonfactori", "json", "factori", "so", "basic", "itll", "help", "compens", "price", "pay", "compress"], "B_title": "Fix #153", "B_clean_title": ["fix", "153"]},
{"A_title": "arcs set split covers full circle instead of being emptyWhen splitting an arcs set using an arc very close to one of the boundaries (but not at the boundary) the algorithm confuses cases for which end - start = 2pi from cases for which end - start = epsilon.  The following test case shows such a failure: code     @Test     public void testSplitWithinEpsilon()          double epsilon = 1.0e-10;         double a = 6.25;         double b = a - 0.5 * epsilon;         ArcsSet set = new ArcsSet(a - 1 a epsilon);         Arc arc = new Arc(b b + FastMath.PI epsilon);         ArcsSet.Split split = set.split(arc);         Assert.assertEquals(set.getSize() split.getPlus().getSize()  epsilon);         Assert.assertNull(split.getMinus());      code  The last assertion (split.getMinus() being null) fails as with current code split.getMinus() covers the full circle from 0 to 2pi.", "A_clean_title": ["arc", "set", "split", "cover", "full", "circl", "instead", "be", "emptywhen", "empti", "when", "split", "arc", "set", "arc", "veri", "close", "one", "boundari", "but", "not", "at", "boundari", "algorithm", "confus", "case", "which", "end", "start", "2pi", "case", "which", "end", "start", "epsilon", "follow", "test", "case", "show", "such", "failur", "code", "test", "public", "void", "testsplitwithinepsilon", "test", "split", "within", "epsilon", "doubl", "epsilon", "10", "0e", "doubl", "25", "doubl", "epsilon", "arcsset", "arc", "set", "set", "new", "arcsset", "arc", "set", "epsilon", "arc", "arc", "new", "arc", "fastmath", "pi", "fast", "math", "epsilon", "arcsset", "split", "arc", "set", "split", "set", "split", "arc", "assert", "assertequ", "assert", "equal", "set", "getsiz", "get", "size", "split", "getplu", "get", "plu", "getsiz", "get", "size", "epsilon", "assert", "assertnul", "assert", "null", "split", "getminu", "get", "minu", "code", "last", "assert", "split", "getminu", "get", "minu", "be", "null", "fail", "as", "current", "code", "split", "getminu", "get", "minu", "cover", "full", "circl", "2pi"], "B_title": "Fixed error when splitting an arc close to its end.", "B_clean_title": ["fix", "error", "when", "split", "arc", "close", "it", "end"]},
{"A_title": "Wicket does not correctly handle http OPTIONS requestscurrently these requests cause regular processing (page rendering) when in fact they should have a special response.  rendering the page in OPTIONS causes renderCount to be incremented and this messes with the subsequent request to the same url via a GET or POST", "A_clean_title": ["wicket", "not", "correctli", "handl", "http", "option", "requestscurr", "these", "request", "caus", "regular", "process", "page", "render", "when", "fact", "they", "have", "special", "respons", "render", "page", "option", "caus", "rendercount", "render", "count", "increment", "thi", "mess", "subsequ", "request", "same", "url", "via", "get", "or", "post"], "B_title": "", "B_clean_title": []},
{"A_title": "Cannot cancel failing/restarting streaming job from the command lineI cannot seem to be able to cancel a failing/restarting job from the command line client. The job cannot be rescheduled so it keeps failing:  The exception I get: 13:58:11240 INFO  org.apache.flink.runtime.jobmanager.JobManager                - Status of job 0c895d22c632de5dfe16c42a9ba818d5 (player-id) changed to RESTARTING. 13:58:25234 INFO  org.apache.flink.runtime.jobmanager.JobManager                - Trying to cancel job with ID 0c895d22c632de5dfe16c42a9ba818d5. 13:58:25561 WARN  akka.remote.ReliableDeliverySupervisor                        - Association with remote system akka.tcp://flink@127.0.0.1:42012 has failed address is now gated for 5000 ms. Reason is: Disassociated.", "A_clean_title": ["not", "cancel", "fail", "restart", "stream", "job", "command", "linei", "line", "not", "seem", "abl", "cancel", "fail", "restart", "job", "command", "line", "client", "job", "not", "reschedul", "so", "it", "keep", "fail", "except", "get", "13:58:11240", "info", "org", "apach", "flink", "runtim", "jobmanag", "jobmanag", "job", "manag", "statu", "job", "0c895d22c632de5dfe16c42a9ba818d5", "player", "id", "chang", "restart", "13:58:25234", "info", "org", "apach", "flink", "runtim", "jobmanag", "jobmanag", "job", "manag", "tri", "cancel", "job", "id", "0c895d22c632de5dfe16c42a9ba818d5", "13:58:25561", "warn", "akka", "remot", "reliabledeliverysupervisor", "reliabl", "deliveri", "supervisor", "associ", "remot", "system", "akka", "tcp", "flink", "127", "1:42012", "ha", "fail", "address", "now", "gate", "5000", "ms", "reason", "disassoci"], "B_title": "runtime Disallow ExecutionGraph state transition from FAILED to RESTARTING", "B_clean_title": ["runtim", "disallow", "executiongraph", "execut", "graph", "state", "transit", "fail", "restart"]},
{"A_title": "Convergence Checker FixesNone", "A_clean_title": ["converg", "checker", "fixesnon", "fix", "none"], "B_title": "Fix checker seeing not old point", "B_clean_title": ["fix", "checker", "see", "not", "old", "point"]},
{"A_title": "Custom StateCheckpointers should be included in the snapshotsCurrently the restoreInitialState call fails when the user uses a custom StateCheckpointer to create the snapshot because the state is restored before the StateCheckpointer is set for the StreamOperatorState. (because the restoreInitialState() call precedes the open() call)  To avoid this issue the custom StateCheckpointer instance should be stored within the snapshot and should be set in the StreamOperatorState before calling restoreState(..).  To reduce the overhead induced by this we can do 2 optimizations:  - We only include custom StateCheckpointers (the default java serializer one is always available)  - We only serialize the checkpointer once and store the byte array in the snapshot", "A_clean_title": ["custom", "statecheckpoint", "state", "checkpoint", "includ", "snapshotscurr", "snapshot", "current", "restoreinitialst", "restor", "initi", "state", "call", "fail", "when", "user", "use", "custom", "statecheckpoint", "state", "checkpoint", "creat", "snapshot", "becaus", "state", "restor", "befor", "statecheckpoint", "state", "checkpoint", "set", "streamoperatorst", "stream", "oper", "state", "becaus", "restoreinitialst", "restor", "initi", "state", "call", "preced", "open", "call", "avoid", "thi", "issu", "custom", "statecheckpoint", "state", "checkpoint", "instanc", "store", "within", "snapshot", "set", "streamoperatorst", "stream", "oper", "state", "befor", "call", "restorest", "restor", "state", "reduc", "overhead", "induc", "by", "thi", "we", "optim", "we", "onli", "includ", "custom", "statecheckpoint", "state", "checkpoint", "default", "java", "serial", "one", "alway", "avail", "we", "onli", "serial", "checkpoint", "onc", "store", "byte", "array", "snapshot"], "B_title": "streaming Set state restore to lazy to avoid StateCheckpointer issues and reduce checkpoint overhead", "B_clean_title": ["stream", "set", "state", "restor", "lazi", "avoid", "statecheckpoint", "state", "checkpoint", "issu", "reduc", "checkpoint", "overhead"]},
{"A_title": "LuceneIndexProviderService may miss on registering PreExtractedTextProviderLuceneIndexProviderService has an optional dependency on PreExtractedTextProvider. In such a case it can happen that bind for the provided is invoked before the activate is called. In such a case the provider would not be registered.", "A_clean_title": ["luceneindexproviderservic", "lucen", "index", "provid", "servic", "may", "miss", "regist", "preextractedtextproviderluceneindexproviderservic", "pre", "extract", "text", "provid", "lucen", "index", "provid", "servic", "ha", "option", "depend", "preextractedtextprovid", "pre", "extract", "text", "provid", "such", "case", "it", "happen", "that", "bind", "provid", "invok", "befor", "activ", "call", "such", "case", "provid", "would", "not", "regist"], "B_title": "- LuceneIndexProviderService may miss on registering PreExtractedTextProvider", "B_clean_title": ["luceneindexproviderservic", "lucen", "index", "provid", "servic", "may", "miss", "regist", "preextractedtextprovid", "pre", "extract", "text", "provid"]},
{"A_title": "lang DateUtils.truncate method is buggy when dealing with DST switching hoursTry to truncate 2004-10-31 01:00:00 MDT by hour and youll actually get 2004-10- 31 01:00:00 MST which is one hour after the input hour.     // truncate 2004-10-31 01:00:00 MDT     Date oct31_01MDT = new Date(1099206000000L);         Date result = DateUtils.truncate(oct31_01MDT Calendar.HOUR_OF_DAY);     assertEquals(oct31_01MDT result);", "A_clean_title": ["lang", "dateutil", "truncat", "date", "util", "method", "buggi", "when", "deal", "dst", "switch", "hourstri", "hour", "tri", "truncat", "2004", "10", "31", "01:00:00", "mdt", "by", "hour", "youll", "actual", "get", "2004", "10", "31", "01:00:00", "mst", "which", "one", "hour", "after", "input", "hour", "truncat", "2004", "10", "31", "01:00:00", "mdt", "date", "oct31", "01mdt", "new", "date", "1099206000000l", "date", "result", "dateutil", "truncat", "date", "util", "oct31", "01mdt", "calendar", "hour", "day", "assertequ", "assert", "equal", "oct31", "01mdt", "result"], "B_title": "Adding Nialls fix for LANG-59 - an edge case in date truncation - and his enhancement for the unit test that was there.", "B_clean_title": ["ad", "niall", "fix", "lang", "59", "edg", "case", "date", "truncat", "hi", "enhanc", "unit", "test", "that", "wa", "there"]},
{"A_title": "IResourceCachingStrategy implementations should only set caching if version matchesImplementations of IResourceCachingStrategy (FilenameWithVersionResourceCachingStrategy and QueryStringWithVersionResourceCachingStrategy) should only set cache duration to maximum if the version matches. Currently if a user requests a resource with an arbitrary version the version will be cached for one year (WebResponse.MAX_CACHE_DURATION). So people could polute proxy caches with potentially upcoming version.", "A_clean_title": ["iresourcecachingstrategi", "resourc", "cach", "strategi", "implement", "onli", "set", "cach", "version", "matchesimplement", "match", "implement", "iresourcecachingstrategi", "resourc", "cach", "strategi", "filenamewithversionresourcecachingstrategi", "filenam", "version", "resourc", "cach", "strategi", "querystringwithversionresourcecachingstrategi", "queri", "string", "version", "resourc", "cach", "strategi", "onli", "set", "cach", "durat", "maximum", "version", "match", "current", "user", "request", "resourc", "arbitrari", "version", "version", "will", "cach", "one", "year", "webrespons", "web", "respons", "max", "cach", "durat", "so", "peopl", "could", "polut", "proxi", "cach", "potenti", "upcom", "version"], "B_title": "IResourceCachingStrategy implementations should only set caching if version matches", "B_clean_title": ["iresourcecachingstrategi", "resourc", "cach", "strategi", "implement", "onli", "set", "cach", "version", "match"]},
{"A_title": "Uploading large number of files to single folder fails.Repository: OAK with TarPM  Upload is successful till 254 files and it started failing afterwards with exception in server logs.  1  code 14.11.2013 12:36:34.608 *ERROR* 10.40.146.206 1384412794576 POST /content/dam/cq9032/./Coconut-5mb-110.jpg HTTP/1.1 org.apache.sling.servlets.post.impl.operations.ModifyOperation Exception during response processing. java.lang.IllegalStateException: null at com.google.common.base.Preconditions.checkState(Preconditions.java:133) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentWriter.writeRecordId(SegmentWriter.java:259) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentWriter.writeListBucket(SegmentWriter.java:346) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentWriter.writeList(SegmentWriter.java:508) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentWriter.writeProperty(SegmentWriter.java:669) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentWriter.writeNode(SegmentWriter.java:847) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentWriter 3.childNodeChanged(SegmentWriter.java:806) ~na:na at org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState.compareAgainstBaseState(ModifiedNodeState.java:387) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentWriter.writeNode(SegmentWriter.java:797) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentWriter 3.childNodeChanged(SegmentWriter.java:806) ~na:na at org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState.compareAgainstBaseState(ModifiedNodeState.java:387) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentWriter.writeNode(SegmentWriter.java:797) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentWriter 3.childNodeChanged(SegmentWriter.java:806) ~na:na at org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState.compareAgainstBaseState(ModifiedNodeState.java:387) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentWriter.writeNode(SegmentWriter.java:797) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentRootBuilder.getNodeState(SegmentRootBuilder.java:53) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentRootBuilder.getNodeState(SegmentRootBuilder.java:21) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeStore.rebase(SegmentNodeStore.java:135) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeStore.merge(SegmentNodeStore.java:113) ~na:na at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeStoreService.merge(SegmentNodeStoreService.java:174) ~na:na at org.apache.jackrabbit.oak.core.AbstractRoot.commit(AbstractRoot.java:260) ~na:na at org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate.commit(SessionDelegate.java:224) ~na:na at org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate.commit(SessionDelegate.java:219) ~na:na at org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate.commit(SessionDelegate.java:207) ~na:na at org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate.save(SessionDelegate.java:332) ~na:na at org.apache.jackrabbit.oak.jcr.session.SessionImpl 8.perform(SessionImpl.java:399) ~na:na at org.apache.jackrabbit.oak.jcr.session.SessionImpl 8.perform(SessionImpl.java:396) ~na:na at org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate.perform(SessionDelegate.java:128) ~na:na at org.apache.jackrabbit.oak.jcr.session.SessionImpl.perform(SessionImpl.java:117) ~na:na at org.apache.jackrabbit.oak.jcr.session.SessionImpl.save(SessionImpl.java:396) ~na:na at sun.reflect.GeneratedMethodAccessor18.invoke(Unknown Source) ~na:na at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) ~na:1.6.0_26 at java.lang.reflect.Method.invoke(Unknown Source) ~na:1.6.0_26 at org.apache.sling.jcr.base.SessionProxyHandler SessionProxyInvocationHandler.invoke(SessionProxyHandler.java:109) ~na:na at  Proxy9.save(Unknown Source) ~na:na code", "A_clean_title": ["upload", "larg", "number", "file", "singl", "folder", "fail", "repositori", "oak", "tarpm", "tar", "pm", "upload", "success", "till", "254", "file", "it", "start", "fail", "afterward", "except", "server", "log", "code", "14", "11", "2013", "12:36:34", "608", "error", "10", "40", "146", "206", "1384412794576", "post", "5mb", "110", "jpg", "content", "dam", "cq9032", "coconut", "http", "org", "apach", "sling", "servlet", "post", "impl", "oper", "modifyoper", "modifi", "oper", "except", "dure", "respons", "process", "java", "lang", "illegalstateexcept", "illeg", "state", "except", "null", "at", "com", "googl", "common", "base", "precondit", "checkstat", "check", "state", "precondit", "java:133", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentwrit", "writerecordid", "segment", "writer", "write", "record", "id", "segmentwrit", "java:259", "segment", "writer", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentwrit", "writelistbucket", "segment", "writer", "write", "list", "bucket", "segmentwrit", "java:346", "segment", "writer", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentwrit", "writelist", "segment", "writer", "write", "list", "segmentwrit", "java:508", "segment", "writer", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentwrit", "writeproperti", "segment", "writer", "write", "properti", "segmentwrit", "java:669", "segment", "writer", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentwrit", "writenod", "segment", "writer", "write", "node", "segmentwrit", "java:847", "segment", "writer", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentwrit", "segment", "writer", "childnodechang", "child", "node", "chang", "segmentwrit", "java:806", "segment", "writer", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "memori", "modifiednodest", "compareagainstbasest", "modifi", "node", "state", "compar", "against", "base", "state", "modifiednodest", "java:387", "modifi", "node", "state", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentwrit", "writenod", "segment", "writer", "write", "node", "segmentwrit", "java:797", "segment", "writer", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentwrit", "segment", "writer", "childnodechang", "child", "node", "chang", "segmentwrit", "java:806", "segment", "writer", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "memori", "modifiednodest", "compareagainstbasest", "modifi", "node", "state", "compar", "against", "base", "state", "modifiednodest", "java:387", "modifi", "node", "state", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentwrit", "writenod", "segment", "writer", "write", "node", "segmentwrit", "java:797", "segment", "writer", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentwrit", "segment", "writer", "childnodechang", "child", "node", "chang", "segmentwrit", "java:806", "segment", "writer", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "memori", "modifiednodest", "compareagainstbasest", "modifi", "node", "state", "compar", "against", "base", "state", "modifiednodest", "java:387", "modifi", "node", "state", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentwrit", "writenod", "segment", "writer", "write", "node", "segmentwrit", "java:797", "segment", "writer", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentrootbuild", "getnodest", "segment", "root", "builder", "get", "node", "state", "segmentrootbuild", "java:53", "segment", "root", "builder", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentrootbuild", "getnodest", "segment", "root", "builder", "get", "node", "state", "segmentrootbuild", "java:21", "segment", "root", "builder", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentnodestor", "rebas", "segment", "node", "store", "segmentnodestor", "java:135", "segment", "node", "store", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentnodestor", "merg", "segment", "node", "store", "segmentnodestor", "java:113", "segment", "node", "store", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentnodestoreservic", "merg", "segment", "node", "store", "servic", "segmentnodestoreservic", "java:174", "segment", "node", "store", "servic", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "core", "abstractroot", "commit", "abstract", "root", "abstractroot", "java:260", "abstract", "root", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "jcr", "deleg", "sessiondeleg", "commit", "session", "deleg", "sessiondeleg", "java:224", "session", "deleg", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "jcr", "deleg", "sessiondeleg", "commit", "session", "deleg", "sessiondeleg", "java:219", "session", "deleg", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "jcr", "deleg", "sessiondeleg", "commit", "session", "deleg", "sessiondeleg", "java:207", "session", "deleg", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "jcr", "deleg", "sessiondeleg", "save", "session", "deleg", "sessiondeleg", "java:332", "session", "deleg", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "jcr", "session", "sessionimpl", "session", "impl", "perform", "sessionimpl", "java:399", "session", "impl", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "jcr", "session", "sessionimpl", "session", "impl", "perform", "sessionimpl", "java:396", "session", "impl", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "jcr", "deleg", "sessiondeleg", "perform", "session", "deleg", "sessiondeleg", "java:128", "session", "deleg", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "jcr", "session", "sessionimpl", "perform", "session", "impl", "sessionimpl", "java:117", "session", "impl", "~na", "na", "at", "org", "apach", "jackrabbit", "oak", "jcr", "session", "sessionimpl", "save", "session", "impl", "sessionimpl", "java:396", "session", "impl", "~na", "na", "at", "sun", "reflect", "generatedmethodaccessor18", "invok", "gener", "method", "accessor18", "unknown", "sourc", "~na", "na", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "unknown", "sourc", "~na:1", "26", "at", "java", "lang", "reflect", "method", "invok", "unknown", "sourc", "~na:1", "26", "at", "org", "apach", "sling", "jcr", "base", "sessionproxyhandl", "session", "proxi", "handler", "sessionproxyinvocationhandl", "invok", "session", "proxi", "invoc", "handler", "sessionproxyhandl", "java:109", "session", "proxi", "handler", "~na", "na", "at", "proxy9", "save", "unknown", "sourc", "~na", "na", "code"], "B_title": "Uploading large number of files to single folder fails.", "B_clean_title": ["upload", "larg", "number", "file", "singl", "folder", "fail"]},
{"A_title": "Field boost not working if the property for indexing is picked using aggregate index rulesFor below index definition -  code       jcr:primaryType:oak:QueryIndexDefinition    compatVersion:2    type:lucene    async:async    reindex:false    reindexCount:12    aggregates:         jcr:primaryType:oak:Unstructured       app:Asset:            jcr:primaryType:oak:Unstructured          include0:               jcr:primaryType:oak:Unstructured             path:jcr:content/metadata/*                         indexRules:         jcr:primaryType:nt:unstructured       app:Asset:            jcr:primaryType:nt:unstructured          properties:               jcr:primaryType:nt:unstructured             foo:                  jcr:primaryType:nt:unstructured                nodeScopeIndex:true                ordered:true                propertyIndex:true                name:jcr:content/metadata/foo                type:Long                boost:3                nodeName:foo                                    code  On executing query of form -   code //element(* app:Asset)       jcr:contains(. bar )  code  should boost the results containing property - jcr:content/metadata/foo but its ignoring index time boosting for it.", "A_clean_title": ["field", "boost", "not", "work", "properti", "index", "pick", "aggreg", "index", "rulesfor", "rule", "below", "index", "definit", "code", "jcr", "primarytyp", "primari", "type", "oak", "queryindexdefinit", "queri", "index", "definit", "compatversion:2", "compat", "version:2", "type", "lucen", "async", "async", "reindex", "fals", "reindexcount:12", "reindex", "count:12", "aggreg", "jcr", "primarytyp", "primari", "type", "oak", "unstructur", "app", "asset", "jcr", "primarytyp", "primari", "type", "oak", "unstructur", "include0", "jcr", "primarytyp", "primari", "type", "oak", "unstructur", "path", "jcr", "content", "metadata", "indexrul", "index", "rule", "jcr", "primarytyp", "primari", "type", "nt", "unstructur", "app", "asset", "jcr", "primarytyp", "primari", "type", "nt", "unstructur", "properti", "jcr", "primarytyp", "primari", "type", "nt", "unstructur", "foo", "jcr", "primarytyp", "primari", "type", "nt", "unstructur", "nodescopeindex", "node", "scope", "index", "true", "order", "true", "propertyindex", "properti", "index", "true", "name", "jcr", "content", "metadata", "foo", "type", "long", "boost:3", "nodenam", "node", "name", "foo", "code", "execut", "queri", "form", "code", "element", "app", "asset", "jcr", "contain", "bar", "code", "boost", "result", "contain", "properti", "jcr", "content", "metadata", "foo", "but", "it", "ignor", "index", "time", "boost", "it"], "B_title": "- Field boost not working if the property for indexing is picked using aggregate index rules", "B_clean_title": ["field", "boost", "not", "work", "properti", "index", "pick", "aggreg", "index", "rule"]},
{"A_title": "org.apache.wicket.validation.ValidatorAdapter class causes problem with validator properties to be loadedPROBLEM: <e1nPL> hi I am having such problem:  <e1nPL> I have implemented validator by implementing IValidator<T> interface <e1nPL> and I have impelemnted the same validator by extending AbstractValidator<T> class  CODE:     ===================== VALIDATOR EXTENDED FROM AbstractValidator =====================     package com.mycompany;           import java.util.regex.Pattern;     import org.apache.wicket.IClusterable;     import org.apache.wicket.util.lang.Classes;     import org.apache.wicket.validation.IValidatable;     import org.apache.wicket.validation.IValidator;     import org.apache.wicket.validation.ValidationError;     import org.apache.wicket.validation.validator.AbstractValidator;           /**      *      * @author e1n      */     public class PasswordPolicyValidator<T> extends AbstractValidator<T>                private static final Pattern UPPER = Pattern.compile(A-Z);         private static final Pattern LOWER = Pattern.compile(a-z);         private static final Pattern NUMBER = Pattern.compile(0-9);                 @Override         public void onValidate(IValidatable<T> validatable)              final String password = (String)validatable.getValue();                         if (!NUMBER.matcher(password).find())                  error(validatable no-digit);                          if (!LOWER.matcher(password).find())                  error(validatable no-lower);                          if (!UPPER.matcher(password).find())                  error(validatable no-upper);                                             @Override         public void error(IValidatable<T> validatable String errorKey)              ValidationError err = new ValidationError();             err.addMessageKey(Classes.simpleName(getClass()) + . + errorKey);             validatable.error(err);                                       =============== VALIDATOR directly implementing IValidator interfce ====================     package com.mycompany;           import java.util.regex.Pattern;     import org.apache.wicket.IClusterable;     import org.apache.wicket.util.lang.Classes;     import org.apache.wicket.validation.IValidatable;     import org.apache.wicket.validation.IValidator;     import org.apache.wicket.validation.ValidationError;     import org.apache.wicket.validation.validator.AbstractValidator;           /**      *      * @author e1n      */     public class PasswordPolicyValidator<T> implements IValidator<T>                private static final Pattern UPPER = Pattern.compile(A-Z);         private static final Pattern LOWER = Pattern.compile(a-z);         private static final Pattern NUMBER = Pattern.compile(0-9);               public void validate(IValidatable<T> validatable)              final String password = (String)validatable.getValue();                         if (!NUMBER.matcher(password).find())                  error(validatable no-digit);                          if (!LOWER.matcher(password).find())                  error(validatable no-lower);                          if (!UPPER.matcher(password).find())                  error(validatable no-upper);                                             public void error(IValidatable<T> validatable String errorKey)              ValidationError err = new ValidationError();             err.addMessageKey(Classes.simpleName(getClass()) + . + errorKey);             validatable.error(err);                          <e1nPL> I also have properties file which is named after validator class <e1nPL> and placed in the same package <e1nPL> my problem is that when i use to validate my form field validator which implements IValidator interface it is not capable of loading error messages from properties file <e1nPL> but when i am using validator which is extending AbstractValidator class <e1nPL> properties file with error msgs gets loaded POSSIBLE FIX: <e1nPL> ok i have found class which is responsible for my problem and it is probably a bug <e1nPL> org.apache.wicket.validation.ValidatorAdapter <e1nPL> which wraps classes that directly implements IValidator interface <e1nPL> then when resources are loaded and properties file are searched in class path etc. loaders search in wrong path that is build against org.apache.wicket.validation.ValidatorAdapter  PLACE WHER FIX SHOULD OCCOUR org.apache.wicket.resource.loader.ValidatorStringResourceLoader::loadStringResource(java.lang.Classjava.lang.Stringjava.util.Localejava.lang.Stringjava.lang.String)", "A_clean_title": ["org", "apach", "wicket", "valid", "validatoradapt", "valid", "adapt", "class", "caus", "problem", "valid", "properti", "loadedproblem", "load", "problem", "e1npl", "e1n", "pl", "hi", "am", "have", "such", "problem", "e1npl", "e1n", "pl", "have", "implement", "valid", "by", "implement", "ivalid", "valid", "interfac", "e1npl", "e1n", "pl", "have", "impelemnt", "same", "valid", "by", "extend", "abstractvalid", "abstract", "valid", "class", "code", "valid", "extend", "abstractvalid", "abstract", "valid", "packag", "com", "mycompani", "import", "java", "util", "regex", "pattern", "import", "org", "apach", "wicket", "icluster", "cluster", "import", "org", "apach", "wicket", "util", "lang", "class", "import", "org", "apach", "wicket", "valid", "ivalidat", "validat", "import", "org", "apach", "wicket", "valid", "ivalid", "valid", "import", "org", "apach", "wicket", "valid", "validationerror", "valid", "error", "import", "org", "apach", "wicket", "valid", "valid", "abstractvalid", "abstract", "valid", "author", "e1n", "public", "class", "passwordpolicyvalid", "password", "polici", "valid", "extend", "abstractvalid", "abstract", "valid", "privat", "static", "final", "pattern", "upper", "pattern", "compil", "privat", "static", "final", "pattern", "lower", "pattern", "compil", "privat", "static", "final", "pattern", "number", "pattern", "compil", "overrid", "public", "void", "onvalid", "valid", "ivalidat", "validat", "validat", "final", "string", "password", "string", "validat", "getvalu", "get", "valu", "number", "matcher", "password", "find", "error", "validat", "no", "digit", "lower", "matcher", "password", "find", "error", "validat", "no", "lower", "upper", "matcher", "password", "find", "error", "validat", "no", "upper", "overrid", "public", "void", "error", "ivalidat", "validat", "validat", "string", "errorkey", "error", "key", "validationerror", "valid", "error", "err", "new", "validationerror", "valid", "error", "err", "addmessagekey", "add", "messag", "key", "class", "simplenam", "simpl", "name", "getclass", "get", "class", "errorkey", "error", "key", "validat", "error", "err", "valid", "directli", "implement", "ivalid", "valid", "interfc", "packag", "com", "mycompani", "import", "java", "util", "regex", "pattern", "import", "org", "apach", "wicket", "icluster", "cluster", "import", "org", "apach", "wicket", "util", "lang", "class", "import", "org", "apach", "wicket", "valid", "ivalidat", "validat", "import", "org", "apach", "wicket", "valid", "ivalid", "valid", "import", "org", "apach", "wicket", "valid", "validationerror", "valid", "error", "import", "org", "apach", "wicket", "valid", "valid", "abstractvalid", "abstract", "valid", "author", "e1n", "public", "class", "passwordpolicyvalid", "password", "polici", "valid", "implement", "ivalid", "valid", "privat", "static", "final", "pattern", "upper", "pattern", "compil", "privat", "static", "final", "pattern", "lower", "pattern", "compil", "privat", "static", "final", "pattern", "number", "pattern", "compil", "public", "void", "valid", "ivalidat", "validat", "validat", "final", "string", "password", "string", "validat", "getvalu", "get", "valu", "number", "matcher", "password", "find", "error", "validat", "no", "digit", "lower", "matcher", "password", "find", "error", "validat", "no", "lower", "upper", "matcher", "password", "find", "error", "validat", "no", "upper", "public", "void", "error", "ivalidat", "validat", "validat", "string", "errorkey", "error", "key", "validationerror", "valid", "error", "err", "new", "validationerror", "valid", "error", "err", "addmessagekey", "add", "messag", "key", "class", "simplenam", "simpl", "name", "getclass", "get", "class", "errorkey", "error", "key", "validat", "error", "err", "e1npl", "e1n", "pl", "also", "have", "properti", "file", "which", "name", "after", "valid", "class", "e1npl", "e1n", "pl", "place", "same", "packag", "e1npl", "e1n", "pl", "my", "problem", "that", "when", "use", "valid", "my", "form", "field", "valid", "which", "implement", "ivalid", "valid", "interfac", "it", "not", "capabl", "load", "error", "messag", "properti", "file", "e1npl", "e1n", "pl", "but", "when", "am", "valid", "which", "extend", "abstractvalid", "abstract", "valid", "class", "e1npl", "e1n", "pl", "properti", "file", "error", "msg", "get", "load", "possibl", "fix", "e1npl", "e1n", "pl", "ok", "have", "found", "class", "which", "respons", "my", "problem", "it", "probabl", "bug", "e1npl", "e1n", "pl", "org", "apach", "wicket", "valid", "validatoradapt", "valid", "adapt", "e1npl", "e1n", "pl", "which", "wrap", "class", "that", "directli", "implement", "ivalid", "valid", "interfac", "e1npl", "e1n", "pl", "then", "when", "resourc", "are", "load", "properti", "file", "are", "search", "class", "path", "etc", "loader", "search", "wrong", "path", "that", "build", "against", "org", "apach", "wicket", "valid", "validatoradapt", "valid", "adapt", "place", "wher", "fix", "occour", "org", "apach", "wicket", "resourc", "loader", "validatorstringresourceload", "valid", "string", "resourc", "loader", ":loadstringresourc", ":load", "string", "resourc", "java", "lang", "classjava", "lang", "stringjava", "util", "localejava", "lang", "stringjava", "lang", "string"], "B_title": "org.apache.wicket.validation.ValidatorAdapter class causes problem with validator properties to be loaded", "B_clean_title": ["org", "apach", "wicket", "valid", "validatoradapt", "valid", "adapt", "class", "caus", "problem", "valid", "properti", "load"]},
{"A_title": "AjaxEventBehavior#onEvent is invoked on disabled behaviorSecurity bug  AjaxEventBehavior#onEvent is invoked on disabled behavior. It should not be - it is really dangerous can you fix it.  I think it is security bug.", "A_clean_title": ["ajaxeventbehavior", "ajax", "event", "behavior", "onev", "event", "invok", "disabl", "behaviorsecur", "behavior", "secur", "bug", "ajaxeventbehavior", "ajax", "event", "behavior", "onev", "event", "invok", "disabl", "behavior", "it", "not", "it", "realli", "danger", "you", "fix", "it", "think", "it", "secur", "bug"], "B_title": "Issue: WICKET-3098", "B_clean_title": ["issu", "wicket", "3098"]},
{"A_title": "CreditCardValidator returns incorrect cardId for VISAWhen the validation for a VISA is correct it returns a SWITCH cardId instead of a VISA. This error occurs in both 1.4.x and 1.5.X", "A_clean_title": ["creditcardvalid", "credit", "card", "valid", "return", "incorrect", "cardid", "card", "id", "visawhen", "visa", "when", "valid", "visa", "correct", "it", "return", "switch", "cardid", "card", "id", "instead", "visa", "thi", "error", "occur", "both"], "B_title": "CreditCardValidator returns incorrect cardId for VISA", "B_clean_title": ["creditcardvalid", "credit", "card", "valid", "return", "incorrect", "cardid", "card", "id", "visa"]},
{"A_title": "DocumentNodeStore.diffManyChildren() reads too many nodesDocumentNodeStore.diffManyChildren() compares too many nodes when running in a non-clustered setup and there are many changes below a location with many children.  This is a regression introduced by OAK-2232. The fix changed the way how the minimum revision is calculated based on the two revisions to compare. The seen-at revision of the RevisionComparator is taken into account. However in a single cluster node setup the revision range for the current clusterId is never updated. This means the minimum revision is calculated too far back and causes queries with too many nodes than necessary.", "A_clean_title": ["documentnodestor", "diffmanychildren", "document", "node", "store", "diff", "mani", "children", "read", "too", "mani", "nodesdocumentnodestor", "diffmanychildren", "node", "document", "node", "store", "diff", "mani", "children", "compar", "too", "mani", "node", "when", "run", "non", "cluster", "setup", "there", "are", "mani", "chang", "below", "locat", "mani", "children", "thi", "regress", "introduc", "by", "oak", "2232", "fix", "chang", "way", "how", "minimum", "revis", "calcul", "base", "two", "revis", "compar", "seen", "at", "revis", "revisioncompar", "revis", "compar", "taken", "into", "account", "howev", "singl", "cluster", "node", "setup", "revis", "rang", "current", "clusterid", "cluster", "id", "never", "updat", "thi", "mean", "minimum", "revis", "calcul", "too", "far", "back", "caus", "queri", "too", "mani", "node", "than", "necessari"], "B_title": "DocumentNodeStore.diffManyChildren() reads too many nodes", "B_clean_title": ["documentnodestor", "diffmanychildren", "document", "node", "store", "diff", "mani", "children", "read", "too", "mani", "node"]},
{"A_title": "NodeStoreKernel doesnt handle array properties correctlyNodeStoreKernel currently only supports array properties of type long. For other types it will fail with an IllegalStateException. See also the FIXME in the code.", "A_clean_title": ["nodestorekernel", "node", "store", "kernel", "doesnt", "handl", "array", "properti", "correctlynodestorekernel", "correctli", "node", "store", "kernel", "current", "onli", "support", "array", "properti", "type", "long", "other", "type", "it", "will", "fail", "illegalstateexcept", "illeg", "state", "except", "see", "also", "fixm", "code"], "B_title": "NodeStoreKernel doesnt handle array properties correctly", "B_clean_title": ["nodestorekernel", "node", "store", "kernel", "doesnt", "handl", "array", "properti", "correctli"]},
{"A_title": "EigenDecomposition may not converge for certain matricesJama-1.0.3 contains a bugfix for certain matrices where the original code goes into an infinite loop.  The commons-math translations would throw a MaxCountExceededException so fails to compute the eigen decomposition.  Port the fix from jama to CM.", "A_clean_title": ["eigendecomposit", "eigen", "decomposit", "may", "not", "converg", "certain", "matricesjama", "matric", "jama", "contain", "bugfix", "certain", "matric", "where", "origin", "code", "goe", "into", "infinit", "loop", "common", "math", "translat", "would", "throw", "maxcountexceededexcept", "max", "count", "exceed", "except", "so", "fail", "comput", "eigen", "decomposit", "port", "fix", "jama", "cm"], "B_title": "Fix EigenDecomposition for certain non-symmetric matrices.", "B_clean_title": ["fix", "eigendecomposit", "eigen", "decomposit", "certain", "non", "symmetr", "matric"]},
{"A_title": "DiskDataStore returns the wrong page when the page disk space is fullIf the configured file size for the session data is overflowed (see org.apache.wicket.settings.IStoreSettings#setMaxSizePerSession(Bytes)) then Wicket may return wrong page data (bytes) for a expired page.  The problem is in org.apache.wicket.pageStore.PageWindowManager#idToWindowIndex which may have several page ids (the keys) pointing to the same window index (values).", "A_clean_title": ["diskdatastor", "disk", "data", "store", "return", "wrong", "page", "when", "page", "disk", "space", "fullif", "full", "configur", "file", "size", "session", "data", "overflow", "see", "org", "apach", "wicket", "set", "istoreset", "store", "set", "setmaxsizepersess", "set", "max", "size", "per", "session", "byte", "then", "wicket", "may", "return", "wrong", "page", "data", "byte", "expir", "page", "problem", "org", "apach", "wicket", "pagestor", "pagewindowmanag", "page", "store", "page", "window", "manag", "idtowindowindex", "id", "window", "index", "which", "may", "have", "sever", "page", "id", "key", "point", "same", "window", "index", "valu"], "B_title": "DiskDataStore returns the wrong page when the page disk space is full", "B_clean_title": ["diskdatastor", "disk", "data", "store", "return", "wrong", "page", "when", "page", "disk", "space", "full"]},
{"A_title": "Long overflow in PermissionEntryProviderImplPermissionEntryProviderImpl#init can end up in a Long overflow if the underlying implementation does not know the exact value of the number children and the child node count is higher than maxSize.  I will attach a patch with a test case", "A_clean_title": ["long", "overflow", "permissionentryproviderimplpermissionentryproviderimpl", "permiss", "entri", "provid", "impl", "permiss", "entri", "provid", "impl", "init", "end", "up", "long", "overflow", "underli", "implement", "not", "know", "exact", "valu", "number", "children", "child", "node", "count", "higher", "than", "maxsiz", "max", "size", "will", "attach", "patch", "test", "case"], "B_title": ": Long overflow in PermissionEntryProviderImpl", "B_clean_title": ["long", "overflow", "permissionentryproviderimpl", "permiss", "entri", "provid", "impl"]},
{"A_title": "Bugs in Frequency APII think the existing Frequency API has some bugs in it. The addValue(Object v) method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException. In fact the problem is with the first call to addValue(Object) which should not allow a plain Object to be added - it should only allow Comparable objects. This could be fixed by checking that the object is Comparable. Similar considerations apply to the getCumFreq(Object) and getCumPct(Object) methods - they will only work with objects that implement Comparable. The getCount(Object) and getPct(Object) methods dont fail when given a non-Comparable object (because the class cast exception is caught) however they just return 0 as if the object was not present:          final Object OBJ = new Object();         f.addValue(OBJ); // This ought to fail but doesnt causing the unexpected behaviour below         System.out.println(f.getCount(OBJ)); // 0         System.out.println(f.getPct(OBJ)); // 0.0   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object. Also it should make it easier to implement generics. However this would cause compilation failures for some programs that pass Object rather than Comparable to the class. These would need recoding but I think they would continue to run OK against the new API. It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object. But is that a viable program? It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail.", "A_clean_title": ["bug", "frequenc", "apii", "think", "exist", "frequenc", "api", "ha", "some", "bug", "it", "addvalu", "add", "valu", "object", "method", "allow", "one", "add", "plain", "object", "but", "one", "not", "add", "anyth", "further", "instanc", "as", "second", "add", "fail", "illegalargumentexcept", "illeg", "argument", "except", "fact", "problem", "first", "call", "addvalu", "add", "valu", "object", "which", "not", "allow", "plain", "object", "ad", "it", "onli", "allow", "compar", "object", "thi", "could", "fix", "by", "check", "that", "object", "compar", "similar", "consider", "appli", "getcumfreq", "get", "cum", "freq", "object", "getcumpct", "get", "cum", "pct", "object", "method", "they", "will", "onli", "work", "object", "that", "implement", "compar", "getcount", "get", "count", "object", "getpct", "get", "pct", "object", "method", "dont", "fail", "when", "given", "non", "compar", "object", "becaus", "class", "cast", "except", "caught", "howev", "they", "just", "return", "as", "object", "wa", "not", "present", "final", "object", "obj", "new", "object", "addvalu", "add", "valu", "obj", "thi", "ought", "fail", "but", "doesnt", "caus", "unexpect", "behaviour", "below", "system", "out", "println", "getcount", "get", "count", "obj", "system", "out", "println", "getpct", "get", "pct", "obj", "rather", "than", "ad", "extra", "check", "compar", "it", "seem", "me", "that", "api", "would", "much", "improv", "by", "compar", "instead", "object", "also", "it", "make", "it", "easier", "implement", "gener", "howev", "thi", "would", "caus", "compil", "failur", "some", "program", "that", "pass", "object", "rather", "than", "compar", "class", "these", "would", "need", "recod", "but", "think", "they", "would", "continu", "run", "ok", "against", "new", "api", "it", "would", "also", "affect", "run", "time", "behaviour", "slightli", "as", "first", "attempt", "add", "non", "compar", "object", "would", "fail", "rather", "than", "second", "add", "possibl", "valid", "object", "but", "that", "viabl", "program", "it", "onli", "add", "one", "object", "ani", "attempt", "get", "statist", "will", "either", "return", "or", "except", "appli", "instanceof", "fix", "would", "also", "caus", "it", "fail"], "B_title": "- check for Comparable when adding values", "B_clean_title": ["check", "compar", "when", "ad", "valu"]},
{"A_title": "Ordered index fails with old index contentWith the latest changes the ordered index no longer works with old index data. When running the latest Oak 1.0.2 snapshot run against an Oak 1.0.0 repository with an existing ordered index the index fails with the exception below.  As a workaround the ordered index can be manually re-built. Either the index re-build needs to be automatic or the ordered index needs to work with the old index content.  noformat java.lang.IndexOutOfBoundsException: index (3) must be less than size (1)     at com.google.common.base.Preconditions.checkElementIndex(Preconditions.java:306)     at com.google.common.base.Preconditions.checkElementIndex(Preconditions.java:285)     at org.apache.jackrabbit.oak.plugins.segment.SegmentPropertyState.getValue(SegmentPropertyState.java:157)     at org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStoreStrategy.getPropertyNext(OrderedContentMirrorStoreStrategy.java:1024) noformat", "A_clean_title": ["order", "index", "fail", "old", "index", "contentwith", "content", "latest", "chang", "order", "index", "no", "longer", "work", "old", "index", "data", "when", "run", "latest", "oak", "snapshot", "run", "against", "oak", "repositori", "exist", "order", "index", "index", "fail", "except", "below", "as", "workaround", "order", "index", "manual", "re", "built", "either", "index", "re", "build", "need", "automat", "or", "order", "index", "need", "work", "old", "index", "content", "noformat", "java", "lang", "indexoutofboundsexcept", "index", "out", "bound", "except", "index", "must", "less", "than", "size", "at", "com", "googl", "common", "base", "precondit", "checkelementindex", "check", "element", "index", "precondit", "java:306", "at", "com", "googl", "common", "base", "precondit", "checkelementindex", "check", "element", "index", "precondit", "java:285", "at", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "segmentpropertyst", "getvalu", "segment", "properti", "state", "get", "valu", "segmentpropertyst", "java:157", "segment", "properti", "state", "at", "org", "apach", "jackrabbit", "oak", "plugin", "index", "properti", "strategi", "orderedcontentmirrorstorestrategi", "getpropertynext", "order", "content", "mirror", "store", "strategi", "get", "properti", "next", "orderedcontentmirrorstorestrategi", "java:1024", "order", "content", "mirror", "store", "strategi", "noformat"], "B_title": "Ordered index fails with old index content", "B_clean_title": ["order", "index", "fail", "old", "index", "content"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Applying test for LANG-304 and fix to LocaleUtils", "B_clean_title": ["appli", "test", "lang", "304", "fix", "localeutil", "local", "util"]},
{"A_title": "Ignore files in the root directory of the FileDataStore in #getAllIdentifiersThe call to OakFileDataStore#getAllIdentifiers should ignore the the files directly at the root of the DataStore (These files are used for SharedDataStore etc). This does not cause any functional problems but leads to logging warning in the logs.  There is already a check but it fails when the data store root is specified as a relative path.", "A_clean_title": ["ignor", "file", "root", "directori", "filedatastor", "file", "data", "store", "getallidentifiersth", "get", "all", "identifi", "call", "oakfiledatastor", "oak", "file", "data", "store", "getallidentifi", "get", "all", "identifi", "ignor", "file", "directli", "at", "root", "datastor", "data", "store", "these", "file", "are", "use", "shareddatastor", "share", "data", "store", "etc", "thi", "not", "caus", "ani", "function", "problem", "but", "lead", "log", "warn", "log", "there", "alreadi", "check", "but", "it", "fail", "when", "data", "store", "root", "specifi", "as", "rel", "path"], "B_title": "Ignore files in the root directory of the FileDataStore in #getAllIdentifiers", "B_clean_title": ["ignor", "file", "root", "directori", "filedatastor", "file", "data", "store", "getallidentifi", "get", "all", "identifi"]},
{"A_title": "Node name having non space whitspace chars should not be allowedDue to the changes done in OAK-1174 node with non space whitespace chars like n r etc can be created. This is not desirable and also JR2 does not allow such node to be created so check must be added to prevent such a name from getting created.  As discussed in 1 this is regression due to usage of incorrect utility method as part of 2 the fix can be simply using a Character#isWhitespace instead of Character#isSpaceChar  1 http://mail-archives.apache.org/mod_mbox/jackrabbit-oak-dev/201509.mbox/%3CCAHCW-mkkGtxkn%2B9xfXuvMTfgykewjMPsLwrVH%2B00%2BXaBQjA0sg%40mail.gmail.com%3E 2 https://github.com/apache/jackrabbit-oak/commit/342809f7f04221782ca6bbfbde9392ec4ff441c2", "A_clean_title": ["node", "name", "have", "non", "space", "whitspac", "char", "not", "alloweddu", "allow", "due", "chang", "done", "oak", "1174", "node", "non", "space", "whitespac", "char", "like", "etc", "creat", "thi", "not", "desir", "also", "jr2", "not", "allow", "such", "node", "creat", "so", "check", "must", "ad", "prevent", "such", "name", "get", "creat", "as", "discuss", "thi", "regress", "due", "usag", "incorrect", "util", "method", "as", "part", "fix", "simpli", "charact", "iswhitespac", "whitespac", "instead", "charact", "isspacechar", "space", "char", "http", "oak", "mail", "archiv", "apach", "dev", "201509", "mbox", "org", "mod", "mbox", "jackrabbit", "3ccahcw", "mkkgtxkn", "mkk", "gtxkn", "2b9xfxuvmtfgykewjmpslwrvh", "2b9xf", "xuv", "tfgykewj", "ps", "lwr", "vh", "2b00", "2bxabqja0sg", "2b", "xa", "qj", "a0sg", "40mail", "gmail", "com", "3e", "http", "oak", "commit", "342809f7f04221782ca6bbfbde9392ec4ff441c2", "github", "com", "apach", "jackrabbit"], "B_title": "- Node name having non space whitspace chars should not be allowed", "B_clean_title": ["node", "name", "have", "non", "space", "whitspac", "char", "not", "allow"]},
{"A_title": "DateTimeSerializerBase ignores configured date format when creating contextualDateTimeSerializerBase#createContextual creates a new serializer with StdDateFormat.DATE_FORMAT_STR_ISO8601 format instead of re-using the actual format that may have been specified on the configuration. See the following code:  Using the  @JsonFormat annotation on a field will therefore reset the format to Jacksons default even if the annotation doesnt specify any custom format.  DateBasedDeserializer#createContextual behaves differently and tries to re-use the configured format:  Shouldnt the serializer follow the same approach ?", "A_clean_title": ["datetimeserializerbas", "date", "time", "serial", "base", "ignor", "configur", "date", "format", "when", "creat", "contextualdatetimeserializerbas", "contextu", "date", "time", "serial", "base", "createcontextu", "creat", "contextu", "creat", "new", "serial", "stddateformat", "std", "date", "format", "date", "format", "str", "iso8601", "format", "instead", "re", "actual", "format", "that", "may", "have", "been", "specifi", "configur", "see", "follow", "code", "jsonformat", "json", "format", "annot", "field", "will", "therefor", "reset", "format", "jackson", "default", "even", "annot", "doesnt", "specifi", "ani", "custom", "format", "datebaseddeseri", "date", "base", "deseri", "createcontextu", "creat", "contextu", "behav", "differ", "tri", "re", "use", "configur", "format", "shouldnt", "serial", "follow", "same", "approach"], "B_title": "Fix #1648", "B_clean_title": ["fix", "1648"]},
{"A_title": "Fraction specified with maxDenominator and a value very close to a simple fraction should not throw an overflow exceptionAn overflow exception is thrown when a Fraction is initialized with a maxDenominator from a double that is very close to a simple fraction.  For example: double d = 0.5000000001; Fraction f = new Fraction(d 10); Patch with unit test on way.", "A_clean_title": ["fraction", "specifi", "maxdenomin", "max", "denomin", "valu", "veri", "close", "simpl", "fraction", "not", "throw", "overflow", "exceptionan", "except", "overflow", "except", "thrown", "when", "fraction", "initi", "maxdenomin", "max", "denomin", "doubl", "that", "veri", "close", "simpl", "fraction", "exampl", "doubl", "5000000001", "fraction", "new", "fraction", "10", "patch", "unit", "test", "way"], "B_title": "Fix creation of Fraction/BigFraction objects in maxDenominator mode when the value is close to an actual fraction.", "B_clean_title": ["fix", "creation", "fraction", "bigfract", "big", "fraction", "object", "maxdenomin", "max", "denomin", "mode", "when", "valu", "close", "actual", "fraction"]},
{"A_title": "better this type checkingNone", "A_clean_title": ["better", "thi", "type", "checkingnon", "check", "none"], "B_title": "Fix parts of issue 635 mostly by deleting hacks that are now obsolete", "B_clean_title": ["fix", "part", "issu", "635", "mostli", "by", "delet", "hack", "that", "are", "now", "obsolet"]},
{"A_title": "PhraseQuery fails due to missing posiion info in indexed fieldsFollowing OAK-1487 Ive introduced a regression in the indexing of fields on the Lucene index. There are some types of queries (the ones that use property restrictions) that cannot run anymore.  bq. /jcr:root/content/dam//*jcr:contains(jcr:content/metadata/@dc:format application/pdf)   bq. Caused by: java.lang.IllegalStateException: field dc:format was indexed without position data; cannot run PhraseQuery (term=text)  I could not reproduce this in an unit test so far.", "A_clean_title": ["phrasequeri", "phrase", "queri", "fail", "due", "miss", "posiion", "info", "index", "fieldsfollow", "field", "follow", "oak", "1487", "ive", "introduc", "regress", "index", "field", "lucen", "index", "there", "are", "some", "type", "queri", "one", "that", "use", "properti", "restrict", "that", "not", "run", "anymor", "bq", "jcr", "root", "content", "dam", "jcr", "contain", "jcr", "content", "metadata", "dc", "format", "applic", "pdf", "bq", "caus", "by", "java", "lang", "illegalstateexcept", "illeg", "state", "except", "field", "dc", "format", "wa", "index", "without", "posit", "data", "not", "run", "phrasequeri", "phrase", "queri", "term=text", "could", "not", "reproduc", "thi", "unit", "test", "so", "far"], "B_title": "PhraseQuery fails due to missing posiion info in indexed fields", "B_clean_title": ["phrasequeri", "phrase", "queri", "fail", "due", "miss", "posiion", "info", "index", "field"]},
{"A_title": "Ajax link reports weird error when session is expiredReproducing steps:  1. Put below simple page into a Wicket application and get it mounted:  TestPage.java:  import org.apache.wicket.ajax.AjaxRequestTarget; import org.apache.wicket.ajax.markup.html.AjaxLink; import org.apache.wicket.markup.html.WebPage;  @SuppressWarnings(serial) public class TestPage extends WebPage   public TestPage()   add(new AjaxLink<Void>(test)   @Override public void onClick(AjaxRequestTarget target)    );      TestPage.html:  <!DOCTYPE html PUBLIC -//W3C//DTD XHTML 1.0 Strict//EN http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd> <?xml version=1.0 encoding=UTF-8?> <html xmlns=http://www.w3.org/1999/xhtml> <head> <title>Test Page</title> </head> <body> <a wicket:id=test>test</a> </body> </html>  2. Access the page in browser via mounted url the page will display a link.   3. Wait until current session is expired (do not refresh the page or click the link while waiting).   4. Hit the link and below exception will be thrown: Message: Cannot find behavior with id: 0 on component:  Component id = test. Perhaps the behavior did not properly implement getStatelessHint() and returned true to indicate that it is stateless instead of returning false to indicate that it is stateful.  5. In wicket 1.5.0 this results in a PageExpiredException which is more comprehensive.", "A_clean_title": ["ajax", "link", "report", "weird", "error", "when", "session", "expiredreproduc", "expir", "reproduc", "step", "put", "below", "simpl", "page", "into", "wicket", "applic", "get", "it", "mount", "testpag", "java", "test", "page", "import", "org", "apach", "wicket", "ajax", "ajaxrequesttarget", "ajax", "request", "target", "import", "org", "apach", "wicket", "ajax", "markup", "html", "ajaxlink", "ajax", "link", "import", "org", "apach", "wicket", "markup", "html", "webpag", "web", "page", "suppresswarn", "suppress", "warn", "serial", "public", "class", "testpag", "test", "page", "extend", "webpag", "web", "page", "public", "testpag", "test", "page", "add", "new", "ajaxlink", "ajax", "link", "void", "test", "overrid", "public", "void", "onclick", "click", "ajaxrequesttarget", "ajax", "request", "target", "target", "testpag", "html", "test", "page", "doctyp", "html", "public", "w3c", "dtd", "xhtml", "strict", "en", "http", "w3", "strict", "dtd", "www", "org", "tr", "xhtml1", "dtd", "xhtml1", "xml", "version=1", "encoding=utf", "html", "xmlns=http", "w3", "www", "org", "1999", "xhtml", "head", "titl", "test", "page", "titl", "head", "bodi", "wicket", "id=test", "test", "bodi", "html", "access", "page", "browser", "via", "mount", "url", "page", "will", "display", "link", "wait", "until", "current", "session", "expir", "not", "refresh", "page", "or", "click", "link", "while", "wait", "hit", "link", "below", "except", "will", "thrown", "messag", "not", "find", "behavior", "id", "compon", "compon", "id", "test", "perhap", "behavior", "did", "not", "properli", "implement", "getstatelesshint", "get", "stateless", "hint", "return", "true", "indic", "that", "it", "stateless", "instead", "return", "fals", "indic", "that", "it", "state", "wicket", "thi", "result", "pageexpiredexcept", "page", "expir", "except", "which", "more", "comprehens"], "B_title": "Ajax link reports wield error when session is expired", "B_clean_title": ["ajax", "link", "report", "wield", "error", "when", "session", "expir"]},
{"A_title": "kryo serialization problemPerforming a cross of two dataset of POJOs I have got the exception below. The first time I run the process there was no problem. When I run it the second time I have got the exception. My guess is that it could be a race condition related to the reuse of the Kryo serializer object. However it could also be a bug where type registrations are not properly forwarded to all Serializers as suggested by Stephan.  ------------------------------------------------------------------------ 2015-10-01 18:18:21 INFO  JobClient:161 - 10/01/2015 18:18:21Cross(Cross at main(FlinkMongoHadoop2LinkPOI2CDA.java:160))(3/4) switched to FAILED  com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 114 at com.esotericsoftware.kryo.util.DefaultClassResolver.readClass(DefaultClassResolver.java:119) at com.esotericsoftware.kryo.Kryo.readClass(Kryo.java:641) at com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:752) at org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer.deserialize(KryoSerializer.java:210) at org.apache.flink.api.java.typeutils.runtime.TupleSerializer.deserialize(TupleSerializer.java:127) at org.apache.flink.api.java.typeutils.runtime.TupleSerializer.deserialize(TupleSerializer.java:30) at org.apache.flink.runtime.operators.resettable.AbstractBlockResettableIterator.getNextRecord(AbstractBlockResettableIterator.java:180) at org.apache.flink.runtime.operators.resettable.BlockResettableMutableObjectIterator.next(BlockResettableMutableObjectIterator.java:111) at org.apache.flink.runtime.operators.CrossDriver.runBlockedOuterSecond(CrossDriver.java:309) at org.apache.flink.runtime.operators.CrossDriver.run(CrossDriver.java:162) at org.apache.flink.runtime.operators.RegularPactTask.run(RegularPactTask.java:489) at org.apache.flink.runtime.operators.RegularPactTask.invoke(RegularPactTask.java:354) at org.apache.flink.runtime.taskmanager.Task.run(Task.java:581) at java.lang.Thread.run(Thread.java:745)", "A_clean_title": ["kryo", "serial", "problemperform", "problem", "perform", "cross", "two", "dataset", "pojo", "poj", "os", "have", "got", "except", "below", "first", "time", "run", "process", "there", "wa", "no", "problem", "when", "run", "it", "second", "time", "have", "got", "except", "my", "guess", "that", "it", "could", "race", "condit", "relat", "reus", "kryo", "serial", "object", "howev", "it", "could", "also", "bug", "where", "type", "registr", "are", "not", "properli", "forward", "all", "serial", "as", "suggest", "by", "stephan", "2015", "10", "01", "18:18:21", "info", "jobclient:161", "job", "client:161", "10", "01", "2015", "18:18:21", "cross", "cross", "at", "main", "flinkmongohadoop2linkpoi2cda", "java:160", "flink", "mongo", "hadoop2link", "poi2cda", "switch", "fail", "com", "esotericsoftwar", "kryo", "kryoexcept", "kryo", "except", "encount", "unregist", "class", "id", "114", "at", "com", "esotericsoftwar", "kryo", "util", "defaultclassresolv", "readclass", "default", "class", "resolv", "read", "class", "defaultclassresolv", "java:119", "default", "class", "resolv", "at", "com", "esotericsoftwar", "kryo", "kryo", "readclass", "read", "class", "kryo", "java:641", "at", "com", "esotericsoftwar", "kryo", "kryo", "readclassandobject", "read", "class", "object", "kryo", "java:752", "at", "org", "apach", "flink", "api", "java", "typeutil", "runtim", "kryo", "kryoseri", "deseri", "kryo", "serial", "kryoseri", "java:210", "kryo", "serial", "at", "org", "apach", "flink", "api", "java", "typeutil", "runtim", "tupleseri", "deseri", "tupl", "serial", "tupleseri", "java:127", "tupl", "serial", "at", "org", "apach", "flink", "api", "java", "typeutil", "runtim", "tupleseri", "deseri", "tupl", "serial", "tupleseri", "java:30", "tupl", "serial", "at", "org", "apach", "flink", "runtim", "oper", "resett", "abstractblockresettableiter", "getnextrecord", "abstract", "block", "resett", "iter", "get", "next", "record", "abstractblockresettableiter", "java:180", "abstract", "block", "resett", "iter", "at", "org", "apach", "flink", "runtim", "oper", "resett", "blockresettablemutableobjectiter", "next", "block", "resett", "mutabl", "object", "iter", "blockresettablemutableobjectiter", "java:111", "block", "resett", "mutabl", "object", "iter", "at", "org", "apach", "flink", "runtim", "oper", "crossdriv", "runblockedoutersecond", "cross", "driver", "run", "block", "outer", "second", "crossdriv", "java:309", "cross", "driver", "at", "org", "apach", "flink", "runtim", "oper", "crossdriv", "run", "cross", "driver", "crossdriv", "java:162", "cross", "driver", "at", "org", "apach", "flink", "runtim", "oper", "regularpacttask", "run", "regular", "pact", "task", "regularpacttask", "java:489", "regular", "pact", "task", "at", "org", "apach", "flink", "runtim", "oper", "regularpacttask", "invok", "regular", "pact", "task", "regularpacttask", "java:354", "regular", "pact", "task", "at", "org", "apach", "flink", "runtim", "taskmanag", "task", "run", "task", "java:581", "at", "java", "lang", "thread", "run", "thread", "java:745"], "B_title": "kryo Fix Kryo serialization to clear buffered data", "B_clean_title": ["kryo", "fix", "kryo", "serial", "clear", "buffer", "data"]},
{"A_title": "Mounted page is not throwing ExpireException with setting setRecreateMountedPagesAfterExpiry(false)We have a page that is both bookmarkable (and accessible with certain page parameters) and has a second constructor taking an object.  When ever the session time-out we want to show a session expired page. But we get a exception because Wicket is trying to rebuild the page with no page parameters.  We have set the setting getPageSettings().setRecreateMountedPagesAfterExpiry(false); This works when clicking on (ajax)links but its not working when using the back/forward button in the browser (or javascript:history.go(-1)).  Ill attache a quickstart.", "A_clean_title": ["mount", "page", "not", "throw", "expireexcept", "expir", "except", "set", "setrecreatemountedpagesafterexpiri", "set", "recreat", "mount", "page", "after", "expiri", "fals", "we", "have", "page", "that", "both", "bookmark", "access", "certain", "page", "paramet", "ha", "second", "constructor", "take", "object", "when", "ever", "session", "time", "out", "we", "want", "show", "session", "expir", "page", "but", "we", "get", "except", "becaus", "wicket", "tri", "rebuild", "page", "no", "page", "paramet", "we", "have", "set", "set", "getpageset", "get", "page", "set", "setrecreatemountedpagesafterexpiri", "set", "recreat", "mount", "page", "after", "expiri", "fals", "thi", "work", "when", "click", "ajax", "link", "but", "it", "not", "work", "when", "back", "forward", "button", "browser", "or", "javascript", "histori", "go", "ill", "attach", "quickstart"], "B_title": "testing recreateMountedPagesAfterExpiry before to recreate a mounted page", "B_clean_title": ["test", "recreatemountedpagesafterexpiri", "recreat", "mount", "page", "after", "expiri", "befor", "recreat", "mount", "page"]},
{"A_title": "StringEscapeUtils.escapeXML() cant process UTF-16 supplementary charactersSupplementary characters in UTF-16 are those whose code points are above 0xffff that is require more than 1 Java char to be encoded as explained here: http://java.sun.com/developer/technicalArticles/Intl/Supplementary/ Currently StringEscapeUtils.escapeXML() isnt aware of this coding scheme and treats each char as one character which is not always right. A possible solution in class Entities would be:     public void escape(Writer writer String str) throws IOException          int len = str.length();         for (int i = 0; i < len; i++)              int code = str.codePointAt;             String entityName = this.entityName(code);             if (entityName != null)                   writer.write(&);                 writer.write(entityName);                 writer.write(;);               else if (code > 0x7F)                       writer.write(&#);                     writer.write(code);                     writer.write(;);               else                       writer.write((char) code);                           if (code > 0xffff)                       i++;                            Besides fixing escapeXML() this will also affect HTML escaping functions. I guess thats a good thing but please remember I have only tested escapeXML().", "A_clean_title": ["stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "cant", "process", "utf", "16", "supplementari", "characterssupplementari", "charact", "supplementari", "charact", "utf", "16", "are", "those", "whose", "code", "point", "are", "abov", "0xffff", "that", "requir", "more", "than", "java", "char", "encod", "as", "explain", "here", "http", "sun", "java", "com", "develop", "technicalarticl", "intl", "supplementari", "technic", "articl", "current", "stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "isnt", "awar", "thi", "code", "scheme", "treat", "each", "char", "as", "one", "charact", "which", "not", "alway", "right", "possibl", "solut", "class", "entiti", "would", "public", "void", "escap", "writer", "writer", "string", "str", "throw", "ioexcept", "io", "except", "int", "len", "str", "length", "int", "len", "i++", "int", "code", "str", "codepointat", "code", "point", "at", "string", "entitynam", "entiti", "name", "thi", "entitynam", "entiti", "name", "code", "entitynam", "entiti", "name", "null", "writer", "write", "writer", "write", "entitynam", "entiti", "name", "writer", "write", "code", "0x7f", "writer", "write", "writer", "write", "code", "writer", "write", "writer", "write", "char", "code", "code", "0xffff", "i++", "besid", "fix", "escapexml", "escap", "xml", "thi", "will", "also", "affect", "html", "escap", "function", "guess", "that", "good", "thing", "but", "pleas", "rememb", "have", "onli", "test", "escapexml", "escap", "xml"], "B_title": "Adding a test and code fix to have supplementary chars working in numeric entity unescaping. See LANG-617", "B_clean_title": ["ad", "test", "code", "fix", "have", "supplementari", "char", "work", "numer", "entiti", "unescap", "see", "lang", "617"]},
{"A_title": "WicketTester.assertRedirectUrl always fails because it always thinks the redirect was nullI have a page which always redirects.  When I write a test for this page tester.assertRedirectUrl(...) always fails with the assertion failure showing that the redirect URL was null.  The page does redirect when running the application for real and I have stepped through in the debugger when running the test and it goes all the way to the HttpServletResponse.sendRedirect call.  However in the same debugging session tester.getLastResponse().getRedirectLocation() == null  Cut-down example follows.   public class AlwaysRedirectPage extends WebPage      public AlwaysRedirectPage()              // redirects to another web server on the same computer         throw new RedirectToUrlException(http://localhost:4333/);        public class TestAlwaysRedirectPage      @Test     public void test()              WicketTester tester = new WicketTester();         tester.startPage(AlwaysRedirectPage.class);         tester.assertRedirectUrl(http://localhost:4333/);", "A_clean_title": ["wickettest", "assertredirecturl", "wicket", "tester", "assert", "redirect", "url", "alway", "fail", "becaus", "it", "alway", "think", "redirect", "wa", "nulli", "null", "have", "page", "which", "alway", "redirect", "when", "write", "test", "thi", "page", "tester", "assertredirecturl", "assert", "redirect", "url", "alway", "fail", "assert", "failur", "show", "that", "redirect", "url", "wa", "null", "page", "redirect", "when", "run", "applic", "real", "have", "step", "through", "debugg", "when", "run", "test", "it", "goe", "all", "way", "httpservletrespons", "sendredirect", "http", "servlet", "respons", "send", "redirect", "call", "howev", "same", "debug", "session", "tester", "getlastrespons", "get", "last", "respons", "getredirectloc", "get", "redirect", "locat", "null", "cut", "down", "exampl", "follow", "public", "class", "alwaysredirectpag", "alway", "redirect", "page", "extend", "webpag", "web", "page", "public", "alwaysredirectpag", "alway", "redirect", "page", "redirect", "anoth", "web", "server", "same", "comput", "throw", "new", "redirecttourlexcept", "redirect", "url", "except", "http", "localhost:4333", "public", "class", "testalwaysredirectpag", "test", "alway", "redirect", "page", "test", "public", "void", "test", "wickettest", "wicket", "tester", "tester", "new", "wickettest", "wicket", "tester", "tester", "startpag", "start", "page", "alwaysredirectpag", "class", "alway", "redirect", "page", "tester", "assertredirecturl", "assert", "redirect", "url", "http", "localhost:4333"], "B_title": "WicketTester.assertRedirectUrl always fails because it always thinks the redirect was null", "B_clean_title": ["wickettest", "assertredirecturl", "wicket", "tester", "assert", "redirect", "url", "alway", "fail", "becaus", "it", "alway", "think", "redirect", "wa", "null"]},
{"A_title": "ValuedEnum.compareTo(Object other) not typesafe - it easily could be...int org.apache.commons.lang.enums.ValuedEnum.compareTo(Object other)  is not typesafe - if the int-values are the same it will return 0 even for two totally different sub-classes of ValuedEnum", "A_clean_title": ["valuedenum", "compareto", "valu", "enum", "compar", "object", "other", "not", "typesaf", "it", "easili", "could", "int", "org", "apach", "common", "lang", "enum", "valuedenum", "compareto", "valu", "enum", "compar", "object", "other", "not", "typesaf", "int", "valu", "are", "same", "it", "will", "return", "even", "two", "total", "differ", "sub", "class", "valuedenum", "valu", "enum"], "B_title": "- Fix compareTo to check the type is the same", "B_clean_title": ["fix", "compareto", "compar", "check", "type", "same"]},
{"A_title": "StringEscapeUtils.escapeXml(input) outputs wrong results when an input contains characters in Supplementary Planes.Hello. I use StringEscapeUtils.escapeXml(input) to escape special characters for XML. This method outputs wrong results when input contains characters in Supplementary Planes. String str1 = uD842uDFB7 + A; String str2 = StringEscapeUtils.escapeXml(str1); // The value of str2 must be equal to the one of str1 // because str1 does not contain characters to be escaped. // However str2 is diffrent from str1. System.out.println(URLEncoder.encode(str1 UTF-16BE)); //%D8%42%DF%B7A System.out.println(URLEncoder.encode(str2 UTF-16BE)); //%D8%42%DF%B7%FF%FD The cause of this problem is that the loop to translate input character by character is wrong. In CharSequenceTranslator.translate(CharSequence input Writer out) loop counter i moves from 0 to Character.codePointCount(input 0 input.length()) but it should move from 0 to input.length().", "A_clean_title": ["stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "input", "output", "wrong", "result", "when", "input", "contain", "charact", "supplementari", "plane", "hello", "use", "stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "input", "escap", "special", "charact", "xml", "thi", "method", "output", "wrong", "result", "when", "input", "contain", "charact", "supplementari", "plane", "string", "str1", "ud842udfb7", "d842u", "dfb7", "string", "str2", "stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "str1", "valu", "str2", "must", "equal", "one", "str1", "becaus", "str1", "not", "contain", "charact", "escap", "howev", "str2", "diffrent", "str1", "system", "out", "println", "urlencod", "encod", "url", "encod", "str1", "utf", "16be", "d8", "42", "df", "b7a", "system", "out", "println", "urlencod", "encod", "url", "encod", "str2", "utf", "16be", "d8", "42", "df", "b7", "ff", "fd", "caus", "thi", "problem", "that", "loop", "translat", "input", "charact", "by", "charact", "wrong", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequ", "char", "sequenc", "input", "writer", "out", "loop", "counter", "move", "charact", "codepointcount", "code", "point", "count", "input", "input", "length", "but", "it", "move", "input", "length"], "B_title": "StringEscapeUtils.escapeXml(input) outputs wrong results when an input contains characters in Supplementary Planes.  ALSO rewrite method to avoid modification of counter variable in for loop", "B_clean_title": ["stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "input", "output", "wrong", "result", "when", "input", "contain", "charact", "supplementari", "plane", "also", "rewrit", "method", "avoid", "modif", "counter", "variabl", "loop"]},
{"A_title": "ReactiveCommandSegmentCommandFactory resolves StreamingOutput for all reactive typesIm using Redis Lettuce dynamic client as described in official documentation  https://github.com/lettuce-io/lettuce-core/wiki/Redis-Command-Interfaces#command-interfaces.response-types My commands interface looks exactly the same   The problem is when method get cannot find value by key theres exception thrown instead of returning empty Mono.   When using predefined RedisReactiveCommands get works fine it returns empty Mono. So it seems like a bug to me.  The Redis Lettuce version being used is   < Also checked with 5.0.4 RELEASE - issue remained", "A_clean_title": ["reactivecommandsegmentcommandfactori", "reactiv", "command", "segment", "command", "factori", "resolv", "streamingoutput", "stream", "output", "all", "reactiv", "typesim", "type", "im", "redi", "lettuc", "dynam", "client", "as", "describ", "offici", "document", "http", "command", "interfac", "io", "lettuc", "core", "wiki", "redi", "github", "com", "lettuc", "command", "type", "interfac", "respons", "my", "command", "interfac", "look", "exactli", "same", "problem", "when", "method", "get", "not", "find", "valu", "by", "key", "there", "except", "thrown", "instead", "return", "empti", "mono", "when", "predefin", "redisreactivecommand", "redi", "reactiv", "command", "get", "work", "fine", "it", "return", "empti", "mono", "so", "it", "seem", "like", "bug", "me", "redi", "lettuc", "version", "be", "use", "also", "check", "releas", "issu", "remain"], "B_title": "Consider value multiplicity in reactive output resolution #879  Lettuce now checks for the value multiplicity when resolving the actual output type for reactive Redis commands methods.  Previously all reactive types were considered streaming ones which caused usage of a not applicable output type. So Mono<String> used KeyListOutput which propagated null values.", "B_clean_title": ["consid", "valu", "multipl", "reactiv", "output", "resolut", "879", "lettuc", "now", "check", "valu", "multipl", "when", "resolv", "actual", "output", "type", "reactiv", "redi", "command", "method", "previous", "all", "reactiv", "type", "were", "consid", "stream", "one", "which", "caus", "usag", "not", "applic", "output", "type", "so", "mono", "string", "use", "keylistoutput", "key", "list", "output", "which", "propag", "null", "valu"]},
{"A_title": "IllegalStateException: Header was already written to response!Getting this error for no apparent reason the code works fine on wicket 1.4.17. Code example with error is attached.  Click on the click here link to see the error occur in the console below is part of the stack trace.   ERROR - DefaultExceptionMapper     - Unexpected error occurred java.lang.IllegalStateException: Header was already written to response!         at org.apache.wicket.protocol.http.HeaderBufferingWebResponse.checkHeader(HeaderBufferingWebResponse.java:62)         at org.apache.wicket.protocol.http.HeaderBufferingWebResponse.setDateHeader(HeaderBufferingWebResponse.java:131)          at org.apache.wicket.protocol.http.BufferedWebResponse SetDateHeaderAction.invoke(BufferedWebResponse.java:241)         at org.apache.wicket.protocol.http.BufferedWebResponse.writeTo(BufferedWebResponse.java:487)         at org.apache.wicket.request.handler.render.WebPageRenderer.respond(WebPageRenderer.java:225)         at org.apache.wicket.request.handler.RenderPageRequestHandler.respond(RenderPageRequestHandler.java:139)         at org.apache.wicket.request.cycle.RequestCycle HandlerExecutor.respond(RequestCycle.java:715)         at org.apache.wicket.request.RequestHandlerStack.execute(RequestHandlerStack.java:63)         at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:274)         at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:283)         at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:283)         at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:283)         at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:283)         at org.apache.wicket.request.cycle.RequestCycle.executeExceptionRequestHandler(RequestCycle.java:283)         at org.apache.wicket.request.cycle.RequestCycle.processRequest(RequestCycle.java:227)         at org.apache.wicket.request.cycle.RequestCycle.processRequestAndDetach(RequestCycle.java:253)         at org.apache.wicket.protocol.http.WicketFilter.processRequest(WicketFilter.java:138)         at org.apache.wicket.protocol.http.WicketFilter.doFilter(WicketFilter.java:194)         at org.eclipse.jetty.servlet.ServletHandler CachedChain.doFilter(ServletHandler.java:1323)         at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:474)         at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:119)         at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:517)         at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:226)         at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:935)         at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:404)         at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:184)         at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:870)         at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:117)         at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:247)         at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:151)         at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:116)         at org.eclipse.jetty.server.Server.handle(Server.java:346)         at org.eclipse.jetty.server.HttpConnection.handleRequest(HttpConnection.java:596)         at org.eclipse.jetty.server.HttpConnection RequestHandler.headerComplete(HttpConnection.java:1051)         at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:592)         at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:214)         at org.eclipse.jetty.server.HttpConnection.handle(HttpConnection.java:426)         at org.eclipse.jetty.server.bio.SocketConnector ConnectorEndPoint.run(SocketConnector.java:241)         at org.eclipse.jetty.server.ssl.SslSocketConnector SslConnectorEndPoint.run(SslSocketConnector.java:646)         at org.eclipse.jetty.util.thread.QueuedThreadPool 3.run(QueuedThreadPool.java:528)         at java.lang.Thread.run(Thread.java:619)", "A_clean_title": ["illegalstateexcept", "illeg", "state", "except", "header", "wa", "alreadi", "written", "respons", "get", "thi", "error", "no", "appar", "reason", "code", "work", "fine", "wicket", "17", "code", "exampl", "error", "attach", "click", "click", "here", "link", "see", "error", "occur", "consol", "below", "part", "stack", "trace", "error", "defaultexceptionmapp", "default", "except", "mapper", "unexpect", "error", "occur", "java", "lang", "illegalstateexcept", "illeg", "state", "except", "header", "wa", "alreadi", "written", "respons", "at", "org", "apach", "wicket", "protocol", "http", "headerbufferingwebrespons", "checkhead", "header", "buffer", "web", "respons", "check", "header", "headerbufferingwebrespons", "java:62", "header", "buffer", "web", "respons", "at", "org", "apach", "wicket", "protocol", "http", "headerbufferingwebrespons", "setdatehead", "header", "buffer", "web", "respons", "set", "date", "header", "headerbufferingwebrespons", "java:131", "header", "buffer", "web", "respons", "at", "org", "apach", "wicket", "protocol", "http", "bufferedwebrespons", "buffer", "web", "respons", "setdateheaderact", "invok", "set", "date", "header", "action", "bufferedwebrespons", "java:241", "buffer", "web", "respons", "at", "org", "apach", "wicket", "protocol", "http", "bufferedwebrespons", "writeto", "buffer", "web", "respons", "write", "bufferedwebrespons", "java:487", "buffer", "web", "respons", "at", "org", "apach", "wicket", "request", "handler", "render", "webpagerender", "respond", "web", "page", "render", "webpagerender", "java:225", "web", "page", "render", "at", "org", "apach", "wicket", "request", "handler", "renderpagerequesthandl", "respond", "render", "page", "request", "handler", "renderpagerequesthandl", "java:139", "render", "page", "request", "handler", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "request", "cycl", "handlerexecutor", "respond", "handler", "executor", "requestcycl", "java:715", "request", "cycl", "at", "org", "apach", "wicket", "request", "requesthandlerstack", "execut", "request", "handler", "stack", "requesthandlerstack", "java:63", "request", "handler", "stack", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:274", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:283", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:283", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:283", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:283", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "executeexceptionrequesthandl", "request", "cycl", "execut", "except", "request", "handler", "requestcycl", "java:283", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "processrequest", "request", "cycl", "process", "request", "requestcycl", "java:227", "request", "cycl", "at", "org", "apach", "wicket", "request", "cycl", "requestcycl", "processrequestanddetach", "request", "cycl", "process", "request", "detach", "requestcycl", "java:253", "request", "cycl", "at", "org", "apach", "wicket", "protocol", "http", "wicketfilt", "processrequest", "wicket", "filter", "process", "request", "wicketfilt", "java:138", "wicket", "filter", "at", "org", "apach", "wicket", "protocol", "http", "wicketfilt", "dofilt", "wicket", "filter", "filter", "wicketfilt", "java:194", "wicket", "filter", "at", "org", "eclips", "jetti", "servlet", "servlethandl", "servlet", "handler", "cachedchain", "dofilt", "cach", "chain", "filter", "servlethandl", "java:1323", "servlet", "handler", "at", "org", "eclips", "jetti", "servlet", "servlethandl", "dohandl", "servlet", "handler", "handl", "servlethandl", "java:474", "servlet", "handler", "at", "org", "eclips", "jetti", "server", "handler", "scopedhandl", "handl", "scope", "handler", "scopedhandl", "java:119", "scope", "handler", "at", "org", "eclips", "jetti", "secur", "securityhandl", "handl", "secur", "handler", "securityhandl", "java:517", "secur", "handler", "at", "org", "eclips", "jetti", "server", "session", "sessionhandl", "dohandl", "session", "handler", "handl", "sessionhandl", "java:226", "session", "handler", "at", "org", "eclips", "jetti", "server", "handler", "contexthandl", "dohandl", "context", "handler", "handl", "contexthandl", "java:935", "context", "handler", "at", "org", "eclips", "jetti", "servlet", "servlethandl", "doscop", "servlet", "handler", "scope", "servlethandl", "java:404", "servlet", "handler", "at", "org", "eclips", "jetti", "server", "session", "sessionhandl", "doscop", "session", "handler", "scope", "sessionhandl", "java:184", "session", "handler", "at", "org", "eclips", "jetti", "server", "handler", "contexthandl", "doscop", "context", "handler", "scope", "contexthandl", "java:870", "context", "handler", "at", "org", "eclips", "jetti", "server", "handler", "scopedhandl", "handl", "scope", "handler", "scopedhandl", "java:117", "scope", "handler", "at", "org", "eclips", "jetti", "server", "handler", "contexthandlercollect", "handl", "context", "handler", "collect", "contexthandlercollect", "java:247", "context", "handler", "collect", "at", "org", "eclips", "jetti", "server", "handler", "handlercollect", "handl", "handler", "collect", "handlercollect", "java:151", "handler", "collect", "at", "org", "eclips", "jetti", "server", "handler", "handlerwrapp", "handl", "handler", "wrapper", "handlerwrapp", "java:116", "handler", "wrapper", "at", "org", "eclips", "jetti", "server", "server", "handl", "server", "java:346", "at", "org", "eclips", "jetti", "server", "httpconnect", "handlerequest", "http", "connect", "handl", "request", "httpconnect", "java:596", "http", "connect", "at", "org", "eclips", "jetti", "server", "httpconnect", "http", "connect", "requesthandl", "headercomplet", "request", "handler", "header", "complet", "httpconnect", "java:1051", "http", "connect", "at", "org", "eclips", "jetti", "http", "httpparser", "parsenext", "http", "parser", "pars", "next", "httpparser", "java:592", "http", "parser", "at", "org", "eclips", "jetti", "http", "httpparser", "parseavail", "http", "parser", "pars", "avail", "httpparser", "java:214", "http", "parser", "at", "org", "eclips", "jetti", "server", "httpconnect", "handl", "http", "connect", "httpconnect", "java:426", "http", "connect", "at", "org", "eclips", "jetti", "server", "bio", "socketconnector", "socket", "connector", "connectorendpoint", "run", "connector", "end", "point", "socketconnector", "java:241", "socket", "connector", "at", "org", "eclips", "jetti", "server", "ssl", "sslsocketconnector", "ssl", "socket", "connector", "sslconnectorendpoint", "run", "ssl", "connector", "end", "point", "sslsocketconnector", "java:646", "ssl", "socket", "connector", "at", "org", "eclips", "jetti", "util", "thread", "queuedthreadpool", "queu", "thread", "pool", "run", "queuedthreadpool", "java:528", "queu", "thread", "pool", "at", "java", "lang", "thread", "run", "thread", "java:619"], "B_title": "improving BufferedWebResponse to invoke set header actions before write in response. Issue: WICKET-3618", "B_clean_title": ["improv", "bufferedwebrespons", "buffer", "web", "respons", "invok", "set", "header", "action", "befor", "write", "respons", "issu", "wicket", "3618"]},
{"A_title": "Stale cache after MongoMK GCAfter a MongoMK revision GC the docChildrenCache may be stale and lead to a NPE when reading children with deleted and GCed siblings.", "A_clean_title": ["stale", "cach", "after", "mongomk", "mongo", "mk", "gcafter", "gc", "after", "mongomk", "mongo", "mk", "revis", "gc", "docchildrencach", "doc", "children", "cach", "may", "stale", "lead", "npe", "when", "read", "children", "delet", "gced", "ced", "sibl"], "B_title": "Stale cache after MongoMK GC", "B_clean_title": ["stale", "cach", "after", "mongomk", "mongo", "mk", "gc"]},
{"A_title": "Events at unitialized input channels are lostIf a program sends an event backwards to the producer task it might happen that some of it input channels have not been initialized yet (UnknownInputChannel). In that case the events are lost and will never be received at the producer.", "A_clean_title": ["event", "at", "uniti", "input", "channel", "are", "lostif", "lost", "program", "send", "event", "backward", "produc", "task", "it", "might", "happen", "that", "some", "it", "input", "channel", "have", "not", "been", "initi", "yet", "unknowninputchannel", "unknown", "input", "channel", "that", "case", "event", "are", "lost", "will", "never", "receiv", "at", "produc"], "B_title": "distributed runtime Fix loss of events at uninitialized input channels", "B_clean_title": ["distribut", "runtim", "fix", "loss", "event", "at", "uniniti", "input", "channel"]},
{"A_title": "Type extractor cannot determine type of functionThis function fails in the type extractor.  code public static final class DuplicateValue<T> implements MapFunction<Tuple1<T> Tuple2<T T>>   @Override public Tuple2<T T> map(Tuple1<T> vertex)  return new Tuple2<T T>(vertex.f0 vertex.f0);   code", "A_clean_title": ["type", "extractor", "not", "determin", "type", "functionthi", "function", "thi", "function", "fail", "type", "extractor", "code", "public", "static", "final", "class", "duplicatevalu", "duplic", "valu", "implement", "mapfunct", "map", "function", "tuple1", "tuple2", "overrid", "public", "tuple2", "map", "tuple1", "vertex", "return", "new", "tuple2", "vertex", "f0", "vertex", "f0", "code"], "B_title": "TypeExtractor now also supports nested Tuple-input derivation", "B_clean_title": ["typeextractor", "type", "extractor", "now", "also", "support", "nest", "tupl", "input", "deriv"]},
{"A_title": "StringIndexOutOfBoundsException in CharSequenceTranslatorI found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. uD83DuDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception      assertEquals(uD83DuDE30 StringEscapeUtils.escapeCsv(uD83DuDE30));    Youll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 at java.lang.String.charAt(String.java:658) at java.lang.Character.codePointAt(Character.java:4668) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached the method affected:  public final void translate(CharSequence input Writer out) throws IOException", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "charsequencetranslatori", "char", "sequenc", "translat", "found", "that", "there", "bad", "surrog", "pair", "handl", "charsequencetransl", "char", "sequenc", "translat", "thi", "simpl", "test", "case", "thi", "problem", "ud83dude30", "d83du", "de30", "surrog", "pair", "test", "public", "void", "testescapesurrogatepair", "test", "escap", "surrog", "pair", "throw", "except", "assertequ", "assert", "equal", "ud83dude30", "d83du", "de30", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "ud83dude30", "d83du", "de30", "youll", "get", "except", "as", "shown", "below", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:658", "at", "java", "lang", "charact", "codepointat", "code", "point", "at", "charact", "java:4668", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:95", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:59", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "stringescapeutil", "java:556", "string", "escap", "util", "patch", "attach", "method", "affect", "public", "final", "void", "translat", "charsequ", "char", "sequenc", "input", "writer", "out", "throw", "ioexcept", "io", "except"], "B_title": "StringIndexOutOfBoundsException in CharSequenceTranslator.", "B_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "charsequencetransl", "char", "sequenc", "translat"]},
{"A_title": "Fraction specified with maxDenominator and a value very close to a simple fraction should not throw an overflow exceptionAn overflow exception is thrown when a Fraction is initialized with a maxDenominator from a double that is very close to a simple fraction.  For example:  double d = 0.5000000001; Fraction f = new Fraction(d 10);  Patch with unit test on way.", "A_clean_title": ["fraction", "specifi", "maxdenomin", "max", "denomin", "valu", "veri", "close", "simpl", "fraction", "not", "throw", "overflow", "exceptionan", "except", "overflow", "except", "thrown", "when", "fraction", "initi", "maxdenomin", "max", "denomin", "doubl", "that", "veri", "close", "simpl", "fraction", "exampl", "doubl", "5000000001", "fraction", "new", "fraction", "10", "patch", "unit", "test", "way"], "B_title": "Fix creation of Fraction/BigFraction objects in maxDenominator mode when the value is close to an actual fraction.", "B_clean_title": ["fix", "creation", "fraction", "bigfract", "big", "fraction", "object", "maxdenomin", "max", "denomin", "mode", "when", "valu", "close", "actual", "fraction"]},
{"A_title": "NaN singular value from SVDThe following jython code Start code from org.apache.commons.math.linear import * Alist = 1.0 2.0 3.02.03.04.03.05.07.0 A = Array2DRowRealMatrix(Alist) decomp = SingularValueDecompositionImpl(A) print decomp.getSingularValues() End code prints array(d 11.218599757513008 0.3781791648535976 nan) The last singular value should be something very close to 0 since the matrix is rank deficient.  When i use the result from getSolver() to solve a system i end  up with a bunch of NaNs in the solution.  I assumed i would get back a least squares solution. Does this SVD implementation require that the matrix be full rank?  If so then i would expect an exception to be thrown from the constructor or one of the methods.", "A_clean_title": ["nan", "na", "singular", "valu", "svdthe", "svd", "follow", "jython", "code", "start", "code", "org", "apach", "common", "math", "linear", "import", "alist", "02", "03", "04", "03", "05", "07", "array2drowrealmatrix", "array2d", "row", "real", "matrix", "alist", "decomp", "singularvaluedecompositionimpl", "singular", "valu", "decomposit", "impl", "print", "decomp", "getsingularvalu", "get", "singular", "valu", "end", "code", "print", "array", "11", "218599757513008", "3781791648535976", "nan", "last", "singular", "valu", "someth", "veri", "close", "sinc", "matrix", "rank", "defici", "when", "use", "result", "getsolv", "get", "solver", "solv", "system", "end", "up", "bunch", "nan", "na", "ns", "solut", "assum", "would", "get", "back", "least", "squar", "solut", "thi", "svd", "implement", "requir", "that", "matrix", "full", "rank", "so", "then", "would", "expect", "except", "thrown", "constructor", "or", "one", "method"], "B_title": "Singular Value Decomposition now computes either the compact SVD (using only positive singular values) or truncated SVD (using a user-specified maximal number of singular values). Fixed Singular Value Decomposition solving of singular systems. JIRA: MATH-320 MATH-321", "B_clean_title": ["singular", "valu", "decomposit", "now", "comput", "either", "compact", "svd", "onli", "posit", "singular", "valu", "or", "truncat", "svd", "user", "specifi", "maxim", "number", "singular", "valu", "fix", "singular", "valu", "decomposit", "solv", "singular", "system", "jira", "math", "320", "math", "321"]},
{"A_title": "XPath: queries starting with // are not always converted correctlyXPath queries starting with // are not always converted to the expected SQL-2 query. Examples:  noformat //element(* oak:QueryIndexDefinition)/* select jcr:path jcr:score * from oak:QueryIndexDefinition as a  //element(* oak:QueryIndexDefinition)//* select jcr:path jcr:score * from oak:QueryIndexDefinition as a noformat  This is wrong. Instead a join should be used.", "A_clean_title": ["xpath", "path", "queri", "start", "are", "not", "alway", "convert", "correctlyxpath", "correctli", "path", "queri", "start", "are", "not", "alway", "convert", "expect", "sql", "queri", "exampl", "noformat", "element", "oak", "queryindexdefinit", "queri", "index", "definit", "select", "jcr", "path", "jcr", "score", "oak", "queryindexdefinit", "queri", "index", "definit", "as", "element", "oak", "queryindexdefinit", "queri", "index", "definit", "select", "jcr", "path", "jcr", "score", "oak", "queryindexdefinit", "queri", "index", "definit", "as", "noformat", "thi", "wrong", "instead", "join", "use"], "B_title": "XPath: queries starting with // are not always converted correctly", "B_clean_title": ["xpath", "path", "queri", "start", "are", "not", "alway", "convert", "correctli"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Add additional heuristic for rare cases in pivotRow selection.", "B_clean_title": ["add", "addit", "heurist", "rare", "case", "pivotrow", "pivot", "row", "select"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Adding a unit test for #LANG-281 and a fix. The fix involves removing the reduceAndCorrect method. It appears that this method was doing sod all - which is worrying as it used to be important. Im guessing that it was a bad fix for a bug that was then subsequently fixed with other code. Ill create a JIRA issue to create more tests to test out the +31 block of code.", "B_clean_title": ["ad", "unit", "test", "lang", "281", "fix", "fix", "involv", "remov", "reduceandcorrect", "reduc", "correct", "method", "it", "appear", "that", "thi", "method", "wa", "do", "sod", "all", "which", "worri", "as", "it", "use", "import", "im", "guess", "that", "it", "wa", "bad", "fix", "bug", "that", "wa", "then", "subsequ", "fix", "other", "code", "ill", "creat", "jira", "issu", "creat", "more", "test", "test", "out", "+31", "block", "code"]},
{"A_title": "goog.isArray doesnt hint compilerNone", "A_clean_title": ["goog", "isarray", "array", "doesnt", "hint", "compilernon", "compil", "none"], "B_title": "Restrict goog.isArray to * properly. Fixes issue 1114 R=blickly", "B_clean_title": ["restrict", "goog", "isarray", "array", "properli", "fix", "issu", "1114", "r=blickli"]},
{"A_title": "Stale cluster ids can potentially lead to lots of previous docs traversal in NodeDocument.getNewestRevisionWhen some (actual test case and conditions still being investigated) of the following conditions are met: * There are property value changes from different cluster id * There are very old and stale cluster id (probably older incarnations of current node itself) * A parallel background split removes all _commitRoot _revision entries such that the latest one (which is less that baseRev) is very old   finding newest revision traverses a lot of previous docs. Since root document gets split a lot and is a very common commitRoot (thus participating during checkConflicts in lot of commits) the issue can slow down commits by a lot", "A_clean_title": ["stale", "cluster", "id", "potenti", "lead", "lot", "previou", "doc", "travers", "nodedocu", "getnewestrevisionwhen", "node", "document", "get", "newest", "revis", "when", "some", "actual", "test", "case", "condit", "still", "be", "investig", "follow", "condit", "are", "met", "there", "are", "properti", "valu", "chang", "differ", "cluster", "id", "there", "are", "veri", "old", "stale", "cluster", "id", "probabl", "older", "incarn", "current", "node", "itself", "parallel", "background", "split", "remov", "all", "commitroot", "commit", "root", "revis", "entri", "such", "that", "latest", "one", "which", "less", "that", "baserev", "base", "rev", "veri", "old", "find", "newest", "revis", "travers", "lot", "previou", "doc", "sinc", "root", "document", "get", "split", "lot", "veri", "common", "commitroot", "commit", "root", "thu", "particip", "dure", "checkconflict", "check", "conflict", "lot", "commit", "issu", "slow", "down", "commit", "by", "lot"], "B_title": "Stale cluster ids can potentially lead to lots of previous docs traversal in NodeDocument.getNewestRevision", "B_clean_title": ["stale", "cluster", "id", "potenti", "lead", "lot", "previou", "doc", "travers", "nodedocu", "getnewestrevis", "node", "document", "get", "newest", "revis"]},
{"A_title": "numerical problems in rotation creationbuilding a rotation from the following vector pairs leads to NaN: u1 = -4921140.837095533 -2.1512094250440013E7 -890093.279426377 u2 = -2.7238580938724895E9 -2.169664921341876E9 6.749688708885301E10 v1 = 1 0 0 v2 = 0 0 1  The constructor first changes the (v1 v2) pair into (v1 v2) ensuring the following scalar products hold:  <v1|v1> == <u1|u1>  <v2|v2> == <u2|u2>  <u1 |u2>  == <v1|v2>  Once the (v1 v2) pair has been computed we compute the cross product:   k = (v1 - u1)^(v2 - u2)  and the scalar product:   c = <k | (u1^u2)>  By construction c is positive or null and the quaternion axis we want to build is q = k/2*sqrt(c). c should be null only if some of the vectors are aligned and this is dealt with later in the algorithm.  However there are numerical problems with the vector above with the way these computations are done as shown by the following comparisons showing the result we get from our Java code and the result we get from manual computation with the same formulas but with enhanced precision:  commons math:   k = 38514476.5            -84.                           -1168590144 high precision: k = 38514410.36093388...  -0.374075245201180409222711... -1168590152.10599715208...  and it becomes worse when computing c because the vectors are almost orthogonal to each other hence inducing additional cancellations. We get: commons math    c = -1.2397173627587605E20 high precision: c =  558382746168463196.7079627...  We have lost ALL significant digits in cancellations and even the sign is wrong!", "A_clean_title": ["numer", "problem", "rotat", "creationbuild", "rotat", "follow", "vector", "pair", "lead", "nan", "na", "u1", "4921140", "837095533", "1512094250440013e7", "890093", "279426377", "u2", "7238580938724895e9", "169664921341876e9", "749688708885301e10", "v1", "v2", "constructor", "first", "chang", "v1", "v2", "pair", "into", "v1", "v2", "ensur", "follow", "scalar", "product", "hold", "v1|v1", "u1|u1", "v2|v2", "u2|u2", "u1", "|u2", "v1|v2", "onc", "v1", "v2", "pair", "ha", "been", "comput", "we", "comput", "cross", "product", "v1", "u1", "v2", "u2", "scalar", "product", "u1^u2", "by", "construct", "posit", "or", "null", "quaternion", "axi", "we", "want", "build", "sqrt", "null", "onli", "some", "vector", "are", "align", "thi", "dealt", "later", "algorithm", "howev", "there", "are", "numer", "problem", "vector", "abov", "way", "these", "comput", "are", "done", "as", "shown", "by", "follow", "comparison", "show", "result", "we", "get", "our", "java", "code", "result", "we", "get", "manual", "comput", "same", "formula", "but", "enhanc", "precis", "common", "math", "38514476", "84", "1168590144", "high", "precis", "38514410", "36093388", "374075245201180409222711", "1168590152", "10599715208", "it", "becom", "wors", "when", "comput", "becaus", "vector", "are", "almost", "orthogon", "each", "other", "henc", "induc", "addit", "cancel", "we", "get", "common", "math", "2397173627587605e20", "high", "precis", "558382746168463196", "7079627", "we", "have", "lost", "all", "signific", "digit", "cancel", "even", "sign", "wrong"], "B_title": "Fixed a wrong detection of rotation axis versus vectors plane in Rotation constructor using two vectors pairs.", "B_clean_title": ["fix", "wrong", "detect", "rotat", "axi", "versu", "vector", "plane", "rotat", "constructor", "two", "vector", "pair"]},
{"A_title": "StringValueConversionException for correct situationStringValue.toOptionalLong() produces org.apache.wicket.util.string.StringValueConversionException if empty string was passed. Let me suggest that this behavior should be changes for all toOptionalXXX methods except getOptionalString method.  The problem in inner code:  The problem in following code:  public final Long toOptionalLong() throws StringValueConversionException              return (text == null) ? null : toLongObject();       Should be something like this:  The problem in following code:  public final Long toOptionalLong() throws StringValueConversionException              return Strings.isEmpty() ? null : toLongObject();       But there is another problem: what to do if incorrect param was passed - for example abc for parameter of Long type?", "A_clean_title": ["stringvalueconversionexcept", "string", "valu", "convers", "except", "correct", "situationstringvalu", "tooptionallong", "situat", "string", "valu", "option", "long", "produc", "org", "apach", "wicket", "util", "string", "stringvalueconversionexcept", "string", "valu", "convers", "except", "empti", "string", "wa", "pass", "let", "me", "suggest", "that", "thi", "behavior", "chang", "all", "tooptionalxxx", "option", "xxx", "method", "except", "getoptionalstr", "get", "option", "string", "method", "problem", "inner", "code", "problem", "follow", "code", "public", "final", "long", "tooptionallong", "option", "long", "throw", "stringvalueconversionexcept", "string", "valu", "convers", "except", "return", "text", "null", "null", "tolongobject", "long", "object", "someth", "like", "thi", "problem", "follow", "code", "public", "final", "long", "tooptionallong", "option", "long", "throw", "stringvalueconversionexcept", "string", "valu", "convers", "except", "return", "string", "isempti", "empti", "null", "tolongobject", "long", "object", "but", "there", "anoth", "problem", "what", "incorrect", "param", "wa", "pass", "exampl", "abc", "paramet", "long", "type"], "B_title": "StringValueConversionException for correct situation", "B_clean_title": ["stringvalueconversionexcept", "string", "valu", "convers", "except", "correct", "situat"]},
{"A_title": "Form components name/value are encoded in stateless forms action urlStateless forms arent working well as you can see on wicket examples: http://www.wicket-library.com/wicket-examples/stateless/foo  The first time you submit (for example the value 10) everything works as supposed to. If you now change the value (to 11 for example) and submit the form the value wicket shows is 10.  I think the problem is stateless forms are generating an action URL with submitted values on query string and when you resubmit the form this values on query string replace the POST(or GET) values.", "A_clean_title": ["form", "compon", "name", "valu", "are", "encod", "stateless", "form", "action", "urlstateless", "url", "stateless", "form", "arent", "work", "well", "as", "you", "see", "wicket", "exampl", "http", "wicket", "librari", "exampl", "stateless", "foo", "www", "com", "wicket", "first", "time", "you", "submit", "exampl", "valu", "10", "everyth", "work", "as", "suppos", "you", "now", "chang", "valu", "11", "exampl", "submit", "form", "valu", "wicket", "show", "10", "think", "problem", "stateless", "form", "are", "gener", "action", "url", "submit", "valu", "queri", "string", "when", "you", "resubmit", "form", "thi", "valu", "queri", "string", "replac", "post", "or", "get", "valu"], "B_title": "Form components name/value are encoded in stateless forms action url", "B_clean_title": ["form", "compon", "name", "valu", "are", "encod", "stateless", "form", "action", "url"]},
{"A_title": "TimeOfDay.valueOf(Calendar Time) and TimeOfDay.valueOf(Time) incorrectly use 12-hour clockTimeOfDay.valueOf(Calendar Time) is implemented as:     return militaryTime(time.getHour(calendar) time.getMinute(calendar) time.getSecond(calendar));  This is flawed because Time.getHour() is implemented as:     return get(calendar Calendar.HOUR); and Calendar.HOUR is for the 12-hour clock. The result is that TimeOfDay.valueOf(Calendar Time) incorrectly only returns 12-hour results not 24-hour results. This affects TimeOfDay.valueOf(Time) as well since it is implemented in terms of the previously-named method.  One fix would be to change Time.getHour() to use Calendar.HOUR_OF_DAY. Since Time doesnt have an am/pm indicator this seems reasonable. An alternate more localized fix would be to change TimeOfDay.valueOf(Calendar Time) to call time.get(Calendar.HOUR_OF_DAY) to get the hour value.", "A_clean_title": ["timeofday", "valueof", "time", "day", "valu", "calendar", "time", "timeofday", "valueof", "time", "day", "valu", "time", "incorrectli", "use", "12", "hour", "clocktimeofday", "valueof", "clock", "time", "day", "valu", "calendar", "time", "implement", "as", "return", "militarytim", "militari", "time", "time", "gethour", "get", "hour", "calendar", "time", "getminut", "get", "minut", "calendar", "time", "getsecond", "get", "second", "calendar", "thi", "flaw", "becaus", "time", "gethour", "get", "hour", "implement", "as", "return", "get", "calendar", "calendar", "hour", "calendar", "hour", "12", "hour", "clock", "result", "that", "timeofday", "valueof", "time", "day", "valu", "calendar", "time", "incorrectli", "onli", "return", "12", "hour", "result", "not", "24", "hour", "result", "thi", "affect", "timeofday", "valueof", "time", "day", "valu", "time", "as", "well", "sinc", "it", "implement", "term", "previous", "name", "method", "one", "fix", "would", "chang", "time", "gethour", "get", "hour", "use", "calendar", "hour", "day", "sinc", "time", "doesnt", "have", "am", "pm", "indic", "thi", "seem", "reason", "altern", "more", "local", "fix", "would", "chang", "timeofday", "valueof", "time", "day", "valu", "calendar", "time", "call", "time", "get", "calendar", "hour", "day", "get", "hour", "valu"], "B_title": "fixed Time.getHour() to use 24-hour clock", "B_clean_title": ["fix", "time", "gethour", "get", "hour", "use", "24", "hour", "clock"]},
{"A_title": "CheckpointCoordinator triggers checkpoints even if not all sources are running any moreWhen some sources finish early they will not emit checkpoint barriers any more. That means that pending checkpoint alignments will never be able to complete locking the flow.", "A_clean_title": ["checkpointcoordin", "checkpoint", "coordin", "trigger", "checkpoint", "even", "not", "all", "sourc", "are", "run", "ani", "morewhen", "more", "when", "some", "sourc", "finish", "earli", "they", "will", "not", "emit", "checkpoint", "barrier", "ani", "more", "that", "mean", "that", "pend", "checkpoint", "align", "will", "never", "abl", "complet", "lock", "flow"], "B_title": "job manager Checkpoint coordinator triggers checkpoints only when tasks are running.", "B_clean_title": ["job", "manag", "checkpoint", "coordin", "trigger", "checkpoint", "onli", "when", "task", "are", "run"]},
{"A_title": "Exception at compilation due to a constructor with private visibilityHello  Im having an issue while instrumenting the source code of  AssertJ with Spoon. The instrumentation part will work but the compilation part will fail due to the following error:  I created a small Maven project with the part of the AssertJ source code that I cannot instrument/compile with Spoon.  The project architecture is the following:   According to the Exception message the problems comes from the class  BooleanArraysBaseTest  which contains the following code:  The statement  arrays = new BooleanArrays(); refers to the BooleanArrays class contained in the same package (internal) which is a Singleton having a constructor with the package visibility:  The other class also called  BooleanArrays  but contained in the other package (test) has a private constructor. My Launcher configuration is the following:   Is there something wrong with my configuration ? I managed to instrument several other projects but not this one.  Tell me if you need any other information. An archive containing this project is available  here . Thank you  Thibault", "A_clean_title": ["except", "at", "compil", "due", "constructor", "privat", "visibilityhello", "visibl", "hello", "im", "have", "issu", "while", "instrument", "sourc", "code", "assertj", "assert", "spoon", "instrument", "part", "will", "work", "but", "compil", "part", "will", "fail", "due", "follow", "error", "creat", "small", "maven", "project", "part", "assertj", "assert", "sourc", "code", "that", "not", "instrument", "compil", "spoon", "project", "architectur", "follow", "accord", "except", "messag", "problem", "come", "class", "booleanarraysbasetest", "boolean", "array", "base", "test", "which", "contain", "follow", "code", "statement", "array", "new", "booleanarray", "boolean", "array", "refer", "booleanarray", "boolean", "array", "class", "contain", "same", "packag", "intern", "which", "singleton", "have", "constructor", "packag", "visibl", "other", "class", "also", "call", "booleanarray", "boolean", "array", "but", "contain", "other", "packag", "test", "ha", "privat", "constructor", "my", "launcher", "configur", "follow", "there", "someth", "wrong", "my", "configur", "manag", "instrument", "sever", "other", "project", "but", "not", "thi", "one", "tell", "me", "you", "need", "ani", "other", "inform", "archiv", "contain", "thi", "project", "avail", "here", "thank", "you", "thibault"], "B_title": "fix: fix bug in import inference (auto-import mode). Close #1306. (#1308)", "B_clean_title": ["fix", "fix", "bug", "import", "infer", "auto", "import", "mode", "close", "1306", "1308"]},
{"A_title": "InlineEnclosure are piling up on each renderInlineEnclosureHandler#resolve() uses an auto-incremented id for its resolved InlineEnclosure   On the next render a new instance will be resolved since the id of the already resolved InlineEnclosure does not match the id in the markup.  But InlineEnclosures are not removed after render as other auto-components thus all instances pile up in the owning container of the markup.", "A_clean_title": ["inlineenclosur", "inlin", "enclosur", "are", "pile", "up", "each", "renderinlineenclosurehandl", "render", "inlin", "enclosur", "handler", "resolv", "use", "auto", "increment", "id", "it", "resolv", "inlineenclosur", "inlin", "enclosur", "next", "render", "new", "instanc", "will", "resolv", "sinc", "id", "alreadi", "resolv", "inlineenclosur", "inlin", "enclosur", "not", "match", "id", "markup", "but", "inlineenclosur", "inlin", "enclosur", "are", "not", "remov", "after", "render", "as", "other", "auto", "compon", "thu", "all", "instanc", "pile", "up", "own", "contain", "markup"], "B_title": "make id of enclosure stable in markup so that InlineEnclosure is resolved once only", "B_clean_title": ["make", "id", "enclosur", "stabl", "markup", "so", "that", "inlineenclosur", "inlin", "enclosur", "resolv", "onc", "onli"]},
{"A_title": "Stateless/Statefull pages - incorrect behaviourPlease advise how to do in following situation or confirm thats a bug and should be fixed.  There is a page (login page) with stateless form. That page has lots of common components (menu and etc.). There are some stateful components in the components tree that are visible only for signed in users: but once user isnt signed in - that components are hidden. Thats why page is becoming stateless (no visible components) and form prepared correspondingly. But when form data is submitted: during obtaining of form component to process request - wicket thinks that page actually is stateful. As a result - the page is recreated and fully rendered - instead of processing of the form.  There is a workaround: setStatelessHint(false). But imho reason is a little bit another: 1) After construction of page: page is stateful - because of some stateful components are in the tree. 2) After initialization of page: page is still stateful - because there are that stateful components 3) After configuration of page (method onConfigure) - page is becoming stateless - because all stateful components marked as invisible. 4) Form has been rendered as stateless - with no version number is in the URL. 5) Page canbe reconstructed correctly because of p.1 and p.2  I think that stateless flag should be precalculated right after initialization step and should be changed due to some stuff in configuration methods.  What do you think?  Will provide quick start in near future!", "A_clean_title": ["stateless", "stateful", "page", "incorrect", "behaviourpleas", "behaviour", "pleas", "advis", "how", "follow", "situat", "or", "confirm", "that", "bug", "fix", "there", "page", "login", "page", "stateless", "form", "that", "page", "ha", "lot", "common", "compon", "menu", "etc", "there", "are", "some", "state", "compon", "compon", "tree", "that", "are", "visibl", "onli", "sign", "user", "but", "onc", "user", "isnt", "sign", "that", "compon", "are", "hidden", "that", "whi", "page", "becom", "stateless", "no", "visibl", "compon", "form", "prepar", "correspondingli", "but", "when", "form", "data", "submit", "dure", "obtain", "form", "compon", "process", "request", "wicket", "think", "that", "page", "actual", "state", "as", "result", "page", "recreat", "fulli", "render", "instead", "process", "form", "there", "workaround", "setstatelesshint", "set", "stateless", "hint", "fals", "but", "imho", "reason", "littl", "bit", "anoth", "after", "construct", "page", "page", "state", "becaus", "some", "state", "compon", "are", "tree", "after", "initi", "page", "page", "still", "state", "becaus", "there", "are", "that", "state", "compon", "after", "configur", "page", "method", "onconfigur", "configur", "page", "becom", "stateless", "becaus", "all", "state", "compon", "mark", "as", "invis", "form", "ha", "been", "render", "as", "stateless", "no", "version", "number", "url", "page", "canb", "reconstruct", "correctli", "becaus", "think", "that", "stateless", "flag", "precalcul", "right", "after", "initi", "step", "chang", "due", "some", "stuff", "configur", "method", "what", "you", "think", "will", "provid", "quick", "start", "near", "futur"], "B_title": "Stateless/Statefull pages - incorrect behaviour", "B_clean_title": ["stateless", "stateful", "page", "incorrect", "behaviour"]},
{"A_title": "TimestampFilter should serialize start and end as longs in the IteratorSettingAlthough the TimestampFilter supports using longs to set the start or end timestamp it formats them as strings using SimpleDateFormat when storing or retrieving them in the IteratorSetting.  This results in exceptions when the timestamps being used arent able to be formatted as _yyyyMMddHHmmssz_. For example try setEnd(253402300800001true)  Instead setStart() and setEnd() could just as easily use String.valueOf(long i) to store the values and init() could retrieve them using Long.valueOf(String s).", "A_clean_title": ["timestampfilt", "timestamp", "filter", "serial", "start", "end", "as", "long", "iteratorsettingalthough", "iter", "set", "although", "timestampfilt", "timestamp", "filter", "support", "long", "set", "start", "or", "end", "timestamp", "it", "format", "them", "as", "string", "simpledateformat", "simpl", "date", "format", "when", "store", "or", "retriev", "them", "iteratorset", "iter", "set", "thi", "result", "except", "when", "timestamp", "be", "use", "arent", "abl", "format", "as", "yyyymmddhhmmssz", "yyyi", "mdd", "hmmssz", "exampl", "tri", "setend", "set", "end", "253402300800001true", "instead", "setstart", "set", "start", "setend", "set", "end", "could", "just", "as", "easili", "use", "string", "valueof", "valu", "long", "store", "valu", "init", "could", "retriev", "them", "long", "valueof", "valu", "string"], "B_title": "made timestamp filter support longs greater than max date - merged to trunk", "B_clean_title": ["made", "timestamp", "filter", "support", "long", "greater", "than", "max", "date", "merg", "trunk"]},
{"A_title": "1.10 regression (StackOverflowError) with interface where generic type has itself as upper bound.None", "A_clean_title": ["10", "regress", "stackoverflowerror", "stack", "overflow", "error", "interfac", "where", "gener", "type", "ha", "itself", "as", "upper", "bound", "none"], "B_title": "Fixes issue #114", "B_clean_title": ["fix", "issu", "114"]},
{"A_title": "@JsonProperty(access = READ_ONLY) together with generated constructor (lombok) causes JsonMappingException: Could not find creator property with name ...The following class fails to deserialise with a  com.fasterxml.jackson.databind.JsonMappingException: Could not find creator property with name s (in class LombokObject) :  Whereas the following class - which is functionally identical but with constructors getters and setters in the code - can be deserialised:   The exception is", "A_clean_title": ["jsonproperti", "json", "properti", "access", "read", "onli", "togeth", "gener", "constructor", "lombok", "caus", "jsonmappingexcept", "json", "map", "except", "could", "not", "find", "creator", "properti", "name", "follow", "class", "fail", "deserialis", "com", "fasterxml", "jackson", "databind", "jsonmappingexcept", "json", "map", "except", "could", "not", "find", "creator", "properti", "name", "class", "lombokobject", "lombok", "object", "wherea", "follow", "class", "which", "function", "ident", "but", "constructor", "getter", "setter", "code", "deserialis", "except"], "B_title": "Fixed #1345", "B_clean_title": ["fix", "1345"]},
{"A_title": "Make Mockito JUnit rule easier to useMockito JUnit rule easier to use by avoiding the need to pass test instance. Make it compatible with JUnit 4.7+ instead of 4.9+.", "A_clean_title": ["make", "mockito", "junit", "unit", "rule", "easier", "usemockito", "use", "mockito", "junit", "unit", "rule", "easier", "use", "by", "avoid", "need", "pass", "test", "instanc", "make", "it", "compat", "junit", "unit", "7+", "instead", "9+"], "B_title": "Inform the user immediately when she tries to callRealMethod() on a mock of a interface. Fixed issue 140", "B_clean_title": ["inform", "user", "immedi", "when", "she", "tri", "callrealmethod", "call", "real", "method", "mock", "interfac", "fix", "issu", "140"]},
{"A_title": "ValueFactory: Missing identifier validation when creating (weak)reference value from Stringthe JCR specification mandates validation of the identifier during value conversion from STRING to REFERENCE or WEAK_REFERENCE:  <quote from 3.6.4.1 From STRING To)> REFERENCE or WEAKREFERENCE: If the string is a syntactically valid  identifier according to the implementation it is converted directly otherwise a  ValueFormatException is thrown. The identifier is not required to be that of an  existing node in the current workspace.  <end_quote>  the current ValueFactory implementation in oak-jcr lacks that validation: creating a REFERENCE or WEAKREFERENCE value using ValueFactory#createValue(String int) succeeds even if the specified string isnt a valid referenceable node identifier.", "A_clean_title": ["valuefactori", "valu", "factori", "miss", "identifi", "valid", "when", "creat", "weak", "refer", "valu", "stringth", "jcr", "specif", "mandat", "valid", "identifi", "dure", "valu", "convers", "string", "refer", "or", "weak", "refer", "quot", "string", "refer", "or", "weakrefer", "string", "syntact", "valid", "identifi", "accord", "implement", "it", "convert", "directli", "otherwis", "valueformatexcept", "valu", "format", "except", "thrown", "identifi", "not", "requir", "that", "exist", "node", "current", "workspac", "end", "quot", "current", "valuefactori", "valu", "factori", "implement", "oak", "jcr", "lack", "that", "valid", "creat", "refer", "or", "weakrefer", "valu", "valuefactori", "valu", "factori", "createvalu", "creat", "valu", "string", "int", "succe", "even", "specifi", "string", "isnt", "valid", "referenc", "node", "identifi"], "B_title": "ValueFactory: Missing identifier validation when creating (weak)reference value from String", "B_clean_title": ["valuefactori", "valu", "factori", "miss", "identifi", "valid", "when", "creat", "weak", "refer", "valu", "string"]},
{"A_title": "MathUtils round method should propagate rather than wrap Runitme exceptionsMathUtils.round(double int int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.", "A_clean_title": ["mathutil", "math", "util", "round", "method", "propag", "rather", "than", "wrap", "runitm", "exceptionsmathutil", "round", "except", "math", "util", "doubl", "int", "int", "gener", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "instead", "wrap", "these", "except", "mathruntimeexcept", "math", "runtim", "except", "condit", "under", "which", "these", "except", "thrown", "document", "except", "propag", "directli", "caller"], "B_title": "Changed MathUtils.round(doubleintint) to propagate rather than wrap runtime exceptions.  Instead of MathRuntimeException this method now throws IllegalArgumentException or ArithmeticException under the conditions specified in the javadoc. JIRA: MATH-555", "B_clean_title": ["chang", "mathutil", "round", "math", "util", "doubleintint", "propag", "rather", "than", "wrap", "runtim", "except", "instead", "mathruntimeexcept", "math", "runtim", "except", "thi", "method", "now", "throw", "illegalargumentexcept", "illeg", "argument", "except", "or", "arithmeticexcept", "arithmet", "except", "under", "condit", "specifi", "javadoc", "jira", "math", "555"]},
{"A_title": "Incompatible API changes in 1.6.0While examining API changes for 1.6.0 I noticed some non-deprecated methods were removed.  I am not sure how important these are but technically these methods are in the public API.  Opening this issue to document what I found.  I compared 1.6.0 to 1.5.0.  In ACCUMULO-1674 the following methods were removed  noformat package org.apache.accumulo.core.client.mapreduce.lib.util ConfiguratorBase.getToken ( Class<?> Configuration ) static  :  byte  ConfiguratorBase.getTokenClass ( Class<?> Configuration) static  :  String noformat  In ACCUMULO-391 the following method was removed  noformat package org.apache.accumulo.core.client.mapreduce.lib.util InputConfigurator.getTabletLocator ( Class<?> Configuration ) static  : TabletLocator  noformat  In ACCUMULO-391 the following method was removed and not properly fixed in ACCUMULO-2586  noformat accumulo-core.jar RangeInputSplit.class package org.apache.accumulo.core.client.mapred InputFormatBase.RangeInputSplit.InputFormatBase.RangeInputSplit ( String table Range range String  locations ) package org.apache.accumulo.core.client.mapreduce InputFormatBase.RangeInputSplit.InputFormatBase.RangeInputSplit ( String table Range range String  locations )  noformat   It seems like the following were removed in ACCUMULO-1854   noformat package org.apache.accumulo.core.client.mapred InputFormatBase.RecordReaderBase<K.setupIterators (JobConf job Scanner scanner )  :  void package org.apache.accumulo.core.client.mapreduce InputFormatBase.RecordReaderBase<K.setupIterators (TaskAttemptContext context Scanner scanner)  :  void noformat  In ACCUMULO-1018 the following method was removed  noformat package org.apache.accumulo.core.client MutationsRejectedException.MutationsRejectedException ( List HashMap Set Collection int cause Throwable cvsList )  noformat", "A_clean_title": ["incompat", "api", "chang", "0while", "examin", "api", "chang", "notic", "some", "non", "deprec", "method", "were", "remov", "am", "not", "sure", "how", "import", "these", "are", "but", "technic", "these", "method", "are", "public", "api", "open", "thi", "issu", "document", "what", "found", "compar", "accumulo", "1674", "follow", "method", "were", "remov", "noformat", "packag", "org", "apach", "accumulo", "core", "client", "mapreduc", "lib", "util", "configuratorbas", "gettoken", "configur", "base", "get", "token", "class", "configur", "static", "byte", "configuratorbas", "gettokenclass", "configur", "base", "get", "token", "class", "class", "configur", "static", "string", "noformat", "accumulo", "391", "follow", "method", "wa", "remov", "noformat", "packag", "org", "apach", "accumulo", "core", "client", "mapreduc", "lib", "util", "inputconfigur", "gettabletloc", "input", "configur", "get", "tablet", "locat", "class", "configur", "static", "tabletloc", "tablet", "locat", "noformat", "accumulo", "391", "follow", "method", "wa", "remov", "not", "properli", "fix", "accumulo", "2586", "noformat", "accumulo", "core", "jar", "rangeinputsplit", "class", "rang", "input", "split", "packag", "org", "apach", "accumulo", "core", "client", "mapr", "inputformatbas", "rangeinputsplit", "inputformatbas", "rangeinputsplit", "input", "format", "base", "rang", "input", "split", "input", "format", "base", "rang", "input", "split", "string", "tabl", "rang", "rang", "string", "locat", "packag", "org", "apach", "accumulo", "core", "client", "mapreduc", "inputformatbas", "rangeinputsplit", "inputformatbas", "rangeinputsplit", "input", "format", "base", "rang", "input", "split", "input", "format", "base", "rang", "input", "split", "string", "tabl", "rang", "rang", "string", "locat", "noformat", "it", "seem", "like", "follow", "were", "remov", "accumulo", "1854", "noformat", "packag", "org", "apach", "accumulo", "core", "client", "mapr", "inputformatbas", "recordreaderbas", "input", "format", "base", "record", "reader", "base", "setupiter", "setup", "iter", "jobconf", "job", "conf", "job", "scanner", "scanner", "void", "packag", "org", "apach", "accumulo", "core", "client", "mapreduc", "inputformatbas", "recordreaderbas", "input", "format", "base", "record", "reader", "base", "setupiter", "setup", "iter", "taskattemptcontext", "task", "attempt", "context", "context", "scanner", "scanner", "void", "noformat", "accumulo", "1018", "follow", "method", "wa", "remov", "noformat", "packag", "org", "apach", "accumulo", "core", "client", "mutationsrejectedexcept", "mutationsrejectedexcept", "mutat", "reject", "except", "mutat", "reject", "except", "list", "hashmap", "hash", "map", "set", "collect", "int", "caus", "throwabl", "cvslist", "cv", "list", "noformat"], "B_title": "Fall back to the configuration when the iterator setting arent in the split", "B_clean_title": ["fall", "back", "configur", "when", "iter", "set", "arent", "split"]},
{"A_title": "MountMapper does not support correctly parameter placeholdersPackage mounting doesnt support parameter placeholders. The problem seems to be inside MountMapper which should wrap PackageMapper and take care of substituting placeholders with their actual value.  More precisely this class doesnt read parameter values from PageParameters and its not very clear to me how it tries to read these values. Does anybody have some hints about this class?", "A_clean_title": ["mountmapp", "mount", "mapper", "not", "support", "correctli", "paramet", "placeholderspackag", "placehold", "packag", "mount", "doesnt", "support", "paramet", "placehold", "problem", "seem", "insid", "mountmapp", "mount", "mapper", "which", "wrap", "packagemapp", "packag", "mapper", "take", "care", "substitut", "placehold", "their", "actual", "valu", "more", "precis", "thi", "class", "doesnt", "read", "paramet", "valu", "pageparamet", "page", "paramet", "it", "not", "veri", "clear", "me", "how", "it", "tri", "read", "these", "valu", "anybodi", "have", "some", "hint", "about", "thi", "class"], "B_title": "MountMapper does not support correctly parameter placeholders", "B_clean_title": ["mountmapp", "mount", "mapper", "not", "support", "correctli", "paramet", "placehold"]},
{"A_title": "Component Use Check always fails for visible components inside an invisible border bodyNone", "A_clean_title": ["compon", "use", "check", "alway", "fail", "visibl", "compon", "insid", "invis", "border", "bodynon", "bodi", "none"], "B_title": "", "B_clean_title": []},
{"A_title": "Incomplete journal when move and copy operations are involvedGiven a node at /source:  code head = mk.commit(/     >source : moved +     *moved : copy     head ); code  results in the following journal:  code >/source:/copy code  where the freshly created node at /moved is missing.  Similarly   code head = mk.commit(/     *source : copy +     >copy : moved     head ); code  results in  code +/moved: code  where moved away node at /source is missing.", "A_clean_title": ["incomplet", "journal", "when", "move", "copi", "oper", "are", "involvedgiven", "involv", "given", "node", "at", "sourc", "code", "head", "mk", "commit", "sourc", "move", "move", "copi", "head", "code", "result", "follow", "journal", "code", "sourc", "copi", "code", "where", "freshli", "creat", "node", "at", "move", "miss", "similarli", "code", "head", "mk", "commit", "sourc", "copi", "copi", "move", "head", "code", "result", "code", "move", "code", "where", "move", "away", "node", "at", "sourc", "miss"], "B_title": "Incomplete journal when move and copy operations are involved", "B_clean_title": ["incomplet", "journal", "when", "move", "copi", "oper", "are", "involv"]},
{"A_title": "Value implementation provides conflicting statementsThe javadoc for the no-arg constructor for Value states that it Creates a zero-size sequence. However the implementation of get will error in this case. code public byte get()      if (this.value == null)        throw new IllegalStateException(Uninitialized. Null constructor  + called w/o accompanying readFields invocation);      code  Either we need to change the javadoc to be more explicit or change the behaviour of various accessors in the class. I would consider both solutions to be breaking of the API contract since we are changing what clients can expect from us.", "A_clean_title": ["valu", "implement", "provid", "conflict", "statementsth", "statement", "javadoc", "no", "arg", "constructor", "valu", "state", "that", "it", "creat", "zero", "size", "sequenc", "howev", "implement", "get", "will", "error", "thi", "case", "code", "public", "byte", "get", "thi", "valu", "null", "throw", "new", "illegalstateexcept", "illeg", "state", "except", "uniniti", "null", "constructor", "call", "accompani", "readfield", "read", "field", "invoc", "code", "either", "we", "need", "chang", "javadoc", "more", "explicit", "or", "chang", "behaviour", "variou", "accessor", "class", "would", "consid", "both", "solut", "break", "api", "contract", "sinc", "we", "are", "chang", "what", "client", "expect", "us"], "B_title": "match Value implementation to javadocs. check for null args.", "B_clean_title": ["match", "valu", "implement", "javadoc", "check", "null", "arg"]},
{"A_title": "DocumentNodeStore revision GC may lead to NPEThe DocumentNodeStore revision GC may cause a NPE in a reader thread when the GC deletes documents currently accessed by the reader. The docChildrenCache is invalidated in VersionGarbageCollector.collectDeletedDocuments() after documents are removed in the DocumentStore. The NPE may occur if removed documents are access in between.", "A_clean_title": ["documentnodestor", "document", "node", "store", "revis", "gc", "may", "lead", "npeth", "npe", "documentnodestor", "document", "node", "store", "revis", "gc", "may", "caus", "npe", "reader", "thread", "when", "gc", "delet", "document", "current", "access", "by", "reader", "docchildrencach", "doc", "children", "cach", "invalid", "versiongarbagecollector", "collectdeleteddocu", "version", "garbag", "collector", "collect", "delet", "document", "after", "document", "are", "remov", "documentstor", "document", "store", "npe", "may", "occur", "remov", "document", "are", "access", "between"], "B_title": "DocumentNodeStore revision GC may lead to NPE", "B_clean_title": ["documentnodestor", "document", "node", "store", "revis", "gc", "may", "lead", "npe"]},
{"A_title": "getMarkupId() can be used only if the components markup is attachedWith change r1037139 Component#getMarkupImpl() first tries to get the markup id from the components markup. If the markup is not available/attached yet for this component the call ends with : org.apache.wicket.markup.MarkupException: Can not determine Markup. Component is not yet connected to a parent. Component id = label", "A_clean_title": ["getmarkupid", "get", "markup", "id", "use", "onli", "compon", "markup", "attachedwith", "attach", "chang", "r1037139", "compon", "getmarkupimpl", "get", "markup", "impl", "first", "tri", "get", "markup", "id", "compon", "markup", "markup", "not", "avail", "attach", "yet", "thi", "compon", "call", "end", "org", "apach", "wicket", "markup", "markupexcept", "markup", "except", "not", "determin", "markup", "compon", "not", "yet", "connect", "parent", "compon", "id", "label"], "B_title": "fixed WICKET-3197: addOrReplace() failed with exception while copying markupId Issue: WICKET-3197", "B_clean_title": ["fix", "wicket", "3197", "addorreplac", "add", "or", "replac", "fail", "except", "while", "copi", "markupid", "markup", "id", "issu", "wicket", "3197"]},
{"A_title": "Bugs in DatasetUtilities.iterateRangeBounds() methodsNone", "A_clean_title": ["bug", "datasetutil", "iteraterangebound", "dataset", "util", "iter", "rang", "bound", "methodsnon", "method", "none"], "B_title": "source/org/jfree/chart/DatasetUtilities.java (iterateRangeBounds(XYDataste boolean)): For IntervalXYDataset include regular value and account for nulls / Double.NaN.", "B_clean_title": ["java", "sourc", "org", "jfree", "chart", "datasetutil", "dataset", "util", "iteraterangebound", "iter", "rang", "bound", "xydatast", "xy", "datast", "boolean", "intervalxydataset", "interv", "xy", "dataset", "includ", "regular", "valu", "account", "null", "doubl", "nan", "na"]},
{"A_title": "Range queries and relative properties resultset should be consistent with JR2When running a range query like /jcr:root/content/nodes//*(*/*/*/@prop >= 9) the resultset is not consistent for the same use-case when running in jacrabbit 2.", "A_clean_title": ["rang", "queri", "rel", "properti", "resultset", "consist", "jr2when", "run", "rang", "queri", "like", "jcr", "root", "content", "node", "prop", "resultset", "not", "consist", "same", "use", "case", "when", "run", "jacrabbit"], "B_title": "Range queries and relative properties resultset should be consistent with JR2", "B_clean_title": ["rang", "queri", "rel", "properti", "resultset", "consist", "jr2"]},
{"A_title": "possibly a bug in org.joda.time.field.FieldUtils.safeMultiplyIt seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1 int scalar) doesnt detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldnt see anything that looked relevant.", "A_clean_title": ["possibl", "bug", "org", "joda", "time", "field", "fieldutil", "safemultiplyit", "field", "util", "safe", "multipli", "it", "seem", "me", "that", "as", "current", "written", "joda", "time", "jar", "org", "joda", "time", "field", "fieldutil", "safemultipli", "field", "util", "safe", "multipli", "long", "val1", "int", "scalar", "doesnt", "detect", "overflow", "long", "val1", "long", "min", "valu", "int", "scalar", "attach", "file", "demonstr", "what", "think", "bug", "suggest", "patch", "look", "at", "joda", "time", "bug", "list", "sourceforg", "sourc", "forg", "but", "couldnt", "see", "anyth", "that", "look", "relev"], "B_title": "FieldUtils.safeMultiply(longint) 3520651", "B_clean_title": ["fieldutil", "safemultipli", "field", "util", "safe", "multipli", "longint", "3520651"]},
{"A_title": "StringIndexOutOfBoundsException when calling unescapeHtml4(&#03)When calling unescapeHtml4() on the String &#03 (or any String that contains these characters) an Exception is thrown: Exception in thread main java.lang.StringIndexOutOfBoundsException: String index out of range: 4 at java.lang.String.charAt(String.java:686) at org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(NumericEntityUnescaper.java:49) at org.apache.commons.lang3.text.translate.AggregateTranslator.translate(AggregateTranslator.java:53) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:88) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:60) at org.apache.commons.lang3.StringEscapeUtils.unescapeHtml4(StringEscapeUtils.java:351)", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "call", "unescapehtml4", "unescap", "html4", "03", "when", "call", "unescapehtml4", "unescap", "html4", "string", "03", "or", "ani", "string", "that", "contain", "these", "charact", "except", "thrown", "except", "thread", "main", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:686", "at", "org", "apach", "common", "lang3", "text", "translat", "numericentityunescap", "translat", "numer", "entiti", "unescap", "numericentityunescap", "java:49", "numer", "entiti", "unescap", "at", "org", "apach", "common", "lang3", "text", "translat", "aggregatetransl", "translat", "aggreg", "translat", "aggregatetransl", "java:53", "aggreg", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:88", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:60", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "unescapehtml4", "string", "escap", "util", "unescap", "html4", "stringescapeutil", "java:351", "string", "escap", "util"], "B_title": "Adding tests and resolving LANG-710 reported by Benjamin Valentin. Note that this changed such that the code will now escape an unfinished entity (i.e. &#030). This matches browser behaviour.", "B_clean_title": ["ad", "test", "resolv", "lang", "710", "report", "by", "benjamin", "valentin", "note", "that", "thi", "chang", "such", "that", "code", "will", "now", "escap", "unfinish", "entiti", "030", "thi", "match", "browser", "behaviour"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Applying Sebbs test and fix for LANG-365", "B_clean_title": ["appli", "sebb", "test", "fix", "lang", "365"]},
{"A_title": "java.lang.StringIndexOutOfBoundsException in ComplexFormat.parse(String source ParsePosition pos)The parse(String source ParsePosition pos) method in the ComplexFormat class does not check whether the imaginary character is set or not which produces StringIndexOutOfBoundsException in the substring method : (line 375 of ComplexFormat) ...         // parse imaginary character         int n = getImaginaryCharacter().length();         startIndex = pos.getIndex();         int endIndex = startIndex + n;         if (source.substring(startIndex endIndex).compareTo(             getImaginaryCharacter()) != 0)  ... I encoutered this exception typing in a JTextFied with ComplexFormat set to look up an AbstractFormatter. If only the user types the imaginary part of the complex number first he gets this exception. Solution: Before setting to n length of the imaginary character check if the source contains it. My proposal: ...         int n = 0;         if (source.contains(getImaginaryCharacter()))         n = getImaginaryCharacter().length(); ...  F.S.", "A_clean_title": ["java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "complexformat", "pars", "complex", "format", "string", "sourc", "parseposit", "pars", "posit", "po", "pars", "string", "sourc", "parseposit", "pars", "posit", "po", "method", "complexformat", "complex", "format", "class", "not", "check", "whether", "imaginari", "charact", "set", "or", "not", "which", "produc", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "substr", "method", "line", "375", "complexformat", "complex", "format", "pars", "imaginari", "charact", "int", "getimaginarycharact", "get", "imaginari", "charact", "length", "startindex", "start", "index", "po", "getindex", "get", "index", "int", "endindex", "end", "index", "startindex", "start", "index", "sourc", "substr", "startindex", "start", "index", "endindex", "end", "index", "compareto", "compar", "getimaginarycharact", "get", "imaginari", "charact", "encout", "thi", "except", "type", "jtextfi", "text", "fie", "complexformat", "complex", "format", "set", "look", "up", "abstractformatt", "abstract", "formatt", "onli", "user", "type", "imaginari", "part", "complex", "number", "first", "he", "get", "thi", "except", "solut", "befor", "set", "length", "imaginari", "charact", "check", "sourc", "contain", "it", "my", "propos", "int", "sourc", "contain", "getimaginarycharact", "get", "imaginari", "charact", "getimaginarycharact", "get", "imaginari", "charact", "length"], "B_title": "added an error detection for missing imaginary character while parsing complex string JIRA: MATH-198", "B_clean_title": ["ad", "error", "detect", "miss", "imaginari", "charact", "while", "pars", "complex", "string", "jira", "math", "198"]},
{"A_title": "issue with isOverriding behavior when extending TypeParametersIf you consider the interface  Iterable<E> which contain a method forEach(Consumer<? super E>) and if you create a class with a T extends String which implements Iterable<T>  then you implement your own version of forEach : if you use ClassTypingContext.isSameSignature() on the two forEach methods it will return false because they do not have the same type parameter. Im really not sure if this is a bug or not: in the overriding method the type parameter is more defined so the signature is not exactly the same. But then if we only use  isSameSignature in getAllMethods (see #1375 ) we will get both Iterable#forEach and ArrayList#forEach  when using it on ArrayList . WDYT? Should we consider the signature are the same or should we consider that  getAllMethods should indeed return the two different methods? Edit: Actually I extended my test to check with  isOverriding and it returns false which is obviously wrong. So theres a real issue here.", "A_clean_title": ["issu", "isoverrid", "overrid", "behavior", "when", "extend", "typeparametersif", "type", "paramet", "you", "consid", "interfac", "iter", "which", "contain", "method", "foreach", "each", "consum", "super", "you", "creat", "class", "extend", "string", "which", "implement", "iter", "then", "you", "implement", "your", "own", "version", "foreach", "each", "you", "use", "classtypingcontext", "issamesignatur", "class", "type", "context", "same", "signatur", "two", "foreach", "each", "method", "it", "will", "return", "fals", "becaus", "they", "not", "have", "same", "type", "paramet", "im", "realli", "not", "sure", "thi", "bug", "or", "not", "overrid", "method", "type", "paramet", "more", "defin", "so", "signatur", "not", "exactli", "same", "but", "then", "we", "onli", "use", "issamesignatur", "same", "signatur", "getallmethod", "get", "all", "method", "see", "1375", "we", "will", "get", "both", "iter", "foreach", "each", "arraylist", "array", "list", "foreach", "each", "when", "it", "arraylist", "array", "list", "wdyt", "we", "consid", "signatur", "are", "same", "or", "we", "consid", "that", "getallmethod", "get", "all", "method", "inde", "return", "two", "differ", "method", "edit", "actual", "extend", "my", "test", "check", "isoverrid", "overrid", "it", "return", "fals", "which", "obvious", "wrong", "so", "there", "real", "issu", "here"], "B_title": "fix: fix issue in ClassTypingContext#isOverriding (#1411)  close #1407", "B_clean_title": ["fix", "fix", "issu", "classtypingcontext", "class", "type", "context", "isoverrid", "overrid", "1411", "close", "1407"]},
{"A_title": "MongoMK GC removes documents with data still in useThe version garbage collector may delete previous documents that contain commit root information still in use by the main document.", "A_clean_title": ["mongomk", "mongo", "mk", "gc", "remov", "document", "data", "still", "useth", "use", "version", "garbag", "collector", "may", "delet", "previou", "document", "that", "contain", "commit", "root", "inform", "still", "use", "by", "main", "document"], "B_title": "MongoMK GC removes documents with data still in use", "B_clean_title": ["mongomk", "mongo", "mk", "gc", "remov", "document", "data", "still", "use"]},
{"A_title": "combining @interface and multiple @extends can crash compilerNone", "A_clean_title": ["combin", "interfac", "multipl", "extend", "crash", "compilernon", "compil", "none"], "B_title": "Fix null pointer bug encountered when trying to extend non-existent interfaces.", "B_clean_title": ["fix", "null", "pointer", "bug", "encount", "when", "tri", "extend", "non", "exist", "interfac"]},
{"A_title": "NullPointerException in SimplexTableau.initializeSimplexTableau throws a NullPointerException when no solution can be found instead of a NoFeasibleSolutionException  Here is the code that causes the NullPointerException:  LinearObjectiveFunction f = new LinearObjectiveFunction(new double  1 5  0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double  2 0  Relationship.GEQ -1.0));  RealPointValuePair solution = new SimplexSolver().optimize(f constraints GoalType.MINIMIZE true);  Note: Tested both with Apache Commons Math 2.0 release and SVN trunk", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "simplextableau", "initializesimplextableau", "simplex", "tableau", "initi", "simplex", "tableau", "throw", "nullpointerexcept", "null", "pointer", "except", "when", "no", "solut", "found", "instead", "nofeasiblesolutionexcept", "no", "feasibl", "solut", "except", "here", "code", "that", "caus", "nullpointerexcept", "null", "pointer", "except", "linearobjectivefunct", "linear", "object", "function", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "constraint", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "geq", "realpointvaluepair", "real", "point", "valu", "pair", "solut", "new", "simplexsolv", "simplex", "solver", "optim", "constraint", "goaltyp", "minim", "goal", "type", "true", "note", "test", "both", "apach", "common", "math", "releas", "svn", "trunk"], "B_title": "fixed an error with negative constraints and unfeasible solution JIRA: MATH-290", "B_clean_title": ["fix", "error", "neg", "constraint", "unfeas", "solut", "jira", "math", "290"]},
{"A_title": "NodeDocument.getNodeAtRevision can go into property history traversal when latest rev on current doc isnt committedNodeDocument.getNodeAtRevision tried to look at latest revisions entries for each property in current document. But it just looks at the *last* entry for a given property. In case this last entry isnt committed the code would go into previous documents to look for a committed value.  (cc ~mreutegg)", "A_clean_title": ["nodedocu", "getnodeatrevis", "node", "document", "get", "node", "at", "revis", "go", "into", "properti", "histori", "travers", "when", "latest", "rev", "current", "doc", "isnt", "committednodedocu", "getnodeatrevis", "commit", "node", "document", "get", "node", "at", "revis", "tri", "look", "at", "latest", "revis", "entri", "each", "properti", "current", "document", "but", "it", "just", "look", "at", "last", "entri", "given", "properti", "case", "thi", "last", "entri", "isnt", "commit", "code", "would", "go", "into", "previou", "document", "look", "commit", "valu", "cc", "~mreutegg"], "B_title": "NodeDocument.getNodeAtRevision can go into property history traversal when latest rev on current doc isnt committed", "B_clean_title": ["nodedocu", "getnodeatrevis", "node", "document", "get", "node", "at", "revis", "go", "into", "properti", "histori", "travers", "when", "latest", "rev", "current", "doc", "isnt", "commit"]},
{"A_title": "AuthenticationTokenSecretManager might delete key while ZooAuthenticationKeyWatcher enumerates existing keysNoticed the following race condition.  The secret manager (in the master) on startup will enumerate the old keys used for creating delegation tokens and delete the keys that are expired.  At the same time the watcher (in each tserver) might see some updates to these keys and update the secret manager. Theres a race condition there that the watcher might try to read a key that the secret manager just deleted.  Need to catch the NoNodeException in the watcher and just accept that its ok if one of these children are deleted to avoid a scary error in the monitor.", "A_clean_title": ["authenticationtokensecretmanag", "authent", "token", "secret", "manag", "might", "delet", "key", "while", "zooauthenticationkeywatch", "zoo", "authent", "key", "watcher", "enumer", "exist", "keysnot", "key", "notic", "follow", "race", "condit", "secret", "manag", "master", "startup", "will", "enumer", "old", "key", "use", "creat", "deleg", "token", "delet", "key", "that", "are", "expir", "at", "same", "time", "watcher", "each", "tserver", "might", "see", "some", "updat", "these", "key", "updat", "secret", "manag", "there", "race", "condit", "there", "that", "watcher", "might", "tri", "read", "key", "that", "secret", "manag", "just", "delet", "need", "catch", "nonodeexcept", "no", "node", "except", "watcher", "just", "accept", "that", "it", "ok", "one", "these", "children", "are", "delet", "avoid", "scari", "error", "monitor"], "B_title": "Fix race condition where master might delete node before tserver sees deletion.", "B_clean_title": ["fix", "race", "condit", "where", "master", "might", "delet", "node", "befor", "tserver", "see", "delet"]},
{"A_title": "The Property2Index eagerly and unnecessarily fetches all dataCurrently the Property2Index (as well as the PropertyIndex and the NodeTypeIndex) loads all paths into a hash set. This is even the case for the getCost operation which should be fast and therefore not load too much data.  This strategy can cause ouf-of-memory if the result is too big. Also loading all data is not necessary unless the user reads all rows.  Instead the index should only load data on demand. Also the getCost operation should only estimate the number of read nodes and not actually read the data.", "A_clean_title": ["property2index", "eagerli", "unnecessarili", "fetch", "all", "datacurr", "data", "current", "property2index", "as", "well", "as", "propertyindex", "properti", "index", "nodetypeindex", "node", "type", "index", "load", "all", "path", "into", "hash", "set", "thi", "even", "case", "getcost", "get", "cost", "oper", "which", "fast", "therefor", "not", "load", "too", "much", "data", "thi", "strategi", "caus", "ouf", "memori", "result", "too", "big", "also", "load", "all", "data", "not", "necessari", "unless", "user", "read", "all", "row", "instead", "index", "onli", "load", "data", "demand", "also", "getcost", "get", "cost", "oper", "onli", "estim", "number", "read", "node", "not", "actual", "read", "data"], "B_title": "The Property2Index eagerly and unnecessarily fetches all data: remove unused code (the case where there is no index); make methods static when possible; use PathUtils instead of parsing the path itself", "B_clean_title": ["property2index", "eagerli", "unnecessarili", "fetch", "all", "data", "remov", "unus", "code", "case", "where", "there", "no", "index", "make", "method", "static", "when", "possibl", "use", "pathutil", "path", "util", "instead", "pars", "path", "itself"]},
{"A_title": "Dangerous code in PoissonDistributionImplIn the following excerpt from class PoissonDistributionImpl: PoissonDistributionImpl.java     public PoissonDistributionImpl(double p NormalDistribution z)          super();         setNormal(z);         setMean(p);        (1) Overridable methods are called within the constructor. (2) The reference z is stored and modified within the class. Ive encountered problem (1) in several classes while working on issue 348. In those cases in order to remove potential problems I copied/pasted the body of the setter methods inside the constructor but I think that a more elegant solution would be to remove the setters altogether (i.e. make the classes immutable). Problem (2) can also create unexpected behaviour. Is it really necessary to pass the NormalDistribution object; cant it be always created within the class?", "A_clean_title": ["danger", "code", "poissondistributionimplin", "poisson", "distribut", "impl", "follow", "excerpt", "class", "poissondistributionimpl", "poisson", "distribut", "impl", "poissondistributionimpl", "java", "poisson", "distribut", "impl", "public", "poissondistributionimpl", "poisson", "distribut", "impl", "doubl", "normaldistribut", "normal", "distribut", "super", "setnorm", "set", "normal", "setmean", "set", "mean", "overrid", "method", "are", "call", "within", "constructor", "refer", "store", "modifi", "within", "class", "ive", "encount", "problem", "sever", "class", "while", "work", "issu", "348", "those", "case", "order", "remov", "potenti", "problem", "copi", "past", "bodi", "setter", "method", "insid", "constructor", "but", "think", "that", "more", "eleg", "solut", "would", "remov", "setter", "altogeth", "make", "class", "immut", "problem", "also", "creat", "unexpect", "behaviour", "it", "realli", "necessari", "pass", "normaldistribut", "normal", "distribut", "object", "cant", "it", "alway", "creat", "within", "class"], "B_title": "Removed deprecated methods.", "B_clean_title": ["remov", "deprec", "method"]},
{"A_title": "Chained stream tasks share the same RuntimeContextChained stream operators currently share the same runtimecontext this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.", "A_clean_title": ["chain", "stream", "task", "share", "same", "runtimecontextchain", "runtim", "context", "chain", "stream", "oper", "current", "share", "same", "runtimecontext", "thi", "will", "certainli", "lead", "problem", "futur", "we", "creat", "separ", "runtim", "context", "each", "oper", "chain"], "B_title": "streaming Create own context for chained streaming operators", "B_clean_title": ["stream", "creat", "own", "context", "chain", "stream", "oper"]},
{"A_title": "Getter/Setter recognition for POJO fields with generics is not workingFields like code private List<Contributors> contributors; code  Are not recognized correctly even if they have getters and setters. Workaround: make them public.", "A_clean_title": ["getter", "setter", "recognit", "pojo", "field", "gener", "not", "workingfield", "work", "field", "like", "code", "privat", "list", "contributor", "contributor", "code", "are", "not", "recogn", "correctli", "even", "they", "have", "getter", "setter", "workaround", "make", "them", "public"], "B_title": "Fixed getter/setter recognition for POJOs", "B_clean_title": ["fix", "getter", "setter", "recognit", "pojo", "poj", "os"]},
{"A_title": "Session.nodeExists(/foo/bar2) must not throw PathNotFoundExceptionsimilar to OAK-1216 Session.nodeExists() of an SNS path with indexes > 1 should return false.", "A_clean_title": ["session", "nodeexist", "node", "exist", "foo", "bar2", "must", "not", "throw", "pathnotfoundexceptionsimilar", "path", "not", "found", "exceptionsimilar", "oak", "1216", "session", "nodeexist", "node", "exist", "sn", "path", "index", "return", "fals"], "B_title": "Session.nodeExists(/foo/bar2) must not throw PathNotFoundException", "B_clean_title": ["session", "nodeexist", "node", "exist", "foo", "bar2", "must", "not", "throw", "pathnotfoundexcept", "path", "not", "found", "except"]},
{"A_title": "CacheLIRS concurrency issueSome of the methods of the cache can throw a NullPointerException when the cache is used concurrently. Example stack trace:  code java.lang.NullPointerException: null org.apache.jackrabbit.oak.cache.CacheLIRS.values(CacheLIRS.java:470)  org.apache.jackrabbit.oak.cache.CacheLIRS 1.values(CacheLIRS.java:1432) org.apache.jackrabbit.oak.plugins.segment.file.FileStore.flush(FileStore.java:205) code", "A_clean_title": ["cachelir", "cach", "lir", "concurr", "issuesom", "issu", "some", "method", "cach", "throw", "nullpointerexcept", "null", "pointer", "except", "when", "cach", "use", "concurr", "exampl", "stack", "trace", "code", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "null", "org", "apach", "jackrabbit", "oak", "cach", "cachelir", "valu", "cach", "lir", "cachelir", "java:470", "cach", "lir", "org", "apach", "jackrabbit", "oak", "cach", "cachelir", "cach", "lir", "valu", "cachelir", "java:1432", "cach", "lir", "org", "apach", "jackrabbit", "oak", "plugin", "segment", "file", "filestor", "flush", "file", "store", "filestor", "java:205", "file", "store", "code"], "B_title": "CacheLIRS concurrency issue", "B_clean_title": ["cachelir", "cach", "lir", "concurr", "issu"]},
{"A_title": "Version garbage collector doesnt collect a rolled back document if it was never deletedIf a commit gets rolled back it can leave (in case the document was never deleted explicitly) a document in a state like: noformat         _id : 7:/etc/workflow/packages/2014/10/12/rep:ours        _deleted :                  _commitRoot :                  jcr:primaryType :                  _modified : NumberLong(1413126245)        _children : true        _modCount : NumberLong(2)  noformat  If the path is fairly busy the document can get created naturally later and then follow the usual cycle. But at times such documents are ephemeral in nature and never re-used. In those cases such documents can remain silently without getting collected.", "A_clean_title": ["version", "garbag", "collector", "doesnt", "collect", "roll", "back", "document", "it", "wa", "never", "deletedif", "delet", "commit", "get", "roll", "back", "it", "leav", "case", "document", "wa", "never", "delet", "explicitli", "document", "state", "like", "noformat", "id", "etc", "workflow", "packag", "2014", "10", "12", "rep", "our", "delet", "commitroot", "commit", "root", "jcr", "primarytyp", "primari", "type", "modifi", "numberlong", "number", "long", "1413126245", "children", "true", "modcount", "mod", "count", "numberlong", "number", "long", "noformat", "path", "fairli", "busi", "document", "get", "creat", "natur", "later", "then", "follow", "usual", "cycl", "but", "at", "time", "such", "document", "are", "ephemer", "natur", "never", "re", "use", "those", "case", "such", "document", "remain", "silent", "without", "get", "collect"], "B_title": "Version garbage collector doesnt collect a rolled back document if it was never deleted", "B_clean_title": ["version", "garbag", "collector", "doesnt", "collect", "roll", "back", "document", "it", "wa", "never", "delet"]},
{"A_title": "DocumentNS may expose branch commit on earlier revisionThe DocumentNodeStore may expose the changes of a branch on a revision earlier than its commit revision. This only happens when the read revision equals the revision of the not yet merged changes on the branch.", "A_clean_title": ["documentn", "document", "ns", "may", "expos", "branch", "commit", "earlier", "revisionth", "revis", "documentnodestor", "document", "node", "store", "may", "expos", "chang", "branch", "revis", "earlier", "than", "it", "commit", "revis", "thi", "onli", "happen", "when", "read", "revis", "equal", "revis", "not", "yet", "merg", "chang", "branch"], "B_title": "DocumentNS may expose branch commit on earlier revision", "B_clean_title": ["documentn", "document", "ns", "may", "expos", "branch", "commit", "earlier", "revis"]},
{"A_title": "bulk imported files showing up in metadata after bulk import failsBulk import fails.  The file is moved to the failures directory.  But references in the !METADATA table remain.", "A_clean_title": ["bulk", "import", "file", "show", "up", "metadata", "after", "bulk", "import", "failsbulk", "fail", "bulk", "import", "fail", "file", "move", "failur", "directori", "but", "refer", "metadata", "tabl", "remain"], "B_title": "add a metadata table constraint to require the bulk load transaction to be alive when writing the bulk-loaded flags", "B_clean_title": ["add", "metadata", "tabl", "constraint", "requir", "bulk", "load", "transact", "aliv", "when", "write", "bulk", "load", "flag"]},
{"A_title": "Authorizations has inconsistent serializationThe same set of authorizations may not serialize to the same value each time if specified in a different order when constructed (like new Authorizations(a b) and new Authorizations(b a)) because serialization reproducibility depends on the insert order in the underlying HashSet.  So one could get the following to happen: code:java true == auths1.equals(auths2) && !auths1.serialize().equals(auths2.serialize()); code", "A_clean_title": ["author", "ha", "inconsist", "serializationth", "serial", "same", "set", "author", "may", "not", "serial", "same", "valu", "each", "time", "specifi", "differ", "order", "when", "construct", "like", "new", "author", "new", "author", "becaus", "serial", "reproduc", "depend", "insert", "order", "underli", "hashset", "hash", "set", "so", "one", "could", "get", "follow", "happen", "code", "java", "true", "auths1", "equal", "auths2", "auths1", "serial", "equal", "auths2", "serial", "code"], "B_title": "reverted previous change which broke unit tests. Awaiting updated patch based on test failures and ticket discussions.", "B_clean_title": ["revert", "previou", "chang", "which", "broke", "unit", "test", "await", "updat", "patch", "base", "test", "failur", "ticket", "discuss"]},
{"A_title": "Miscellaneous issues concerning the optimization packageRevision 990792 contains changes triggered the following issues: * MATH-394|https://issues.apache.org/jira/browse/MATH-394 * MATH-397|https://issues.apache.org/jira/browse/MATH-397 * MATH-404|https://issues.apache.org/jira/browse/MATH-404  This issue collects the currently still unsatisfactory code (not necessarily sorted in order of annoyance): # BrentOptimizer: a specific convergence checker must be used. LevenbergMarquardtOptimizer also has specific convergence checks. # Trying to make convergence checking independent of the optimization algorithm creates problems (conceptual and practical):  ** See BrentOptimizer and LevenbergMarquardtOptimizer the algorithm passes points to the convergence checker but the actual meaning of the points can very well be different in the caller (optimization algorithm) and the callee (convergence checker).  ** In PowellOptimizer the line search (BrentOptimizer) tolerances depend on the tolerances within the main algorithm. Since tolerances come with ConvergenceChecker and so can be changed at any time it is awkward to adapt the values within the line search optimizer without exposing its internals (BrentOptimizer field) to the enclosing class (PowellOptimizer). # Given the numerous changes some Javadoc comments might be out-of-sync although I did try to update them all. # Class DirectSearchOptimizer (in package optimization.direct) inherits from class AbstractScalarOptimizer (in package optimization.general). # Some interfaces are defined in package optimization but their base implementations (abstract class that contain the boiler-plate code) are in package optimization.general (e.g. DifferentiableMultivariateVectorialOptimizer and BaseAbstractVectorialOptimizer). # No check is performed to ensure the the convergence checker has been set (see e.g. BrentOptimizer and PowellOptimizer); if it hasnt there will be a NPE. The alternative is to initialize a default checker that will never be used in case the user had intended to explicitly sets the checker. # NonLinearConjugateGradientOptimizer: Ugly workaround for the checked ConvergenceException. # Everywhere we trail the checked FunctionEvaluationException although it is never used. # There remains some duplicate code (such as the multi-start loop in the various MultiStart... implementations). # The ConvergenceChecker interface is very general (the converged method can take any number of ...PointValuePair). However there remains a semantic problem: One cannot be sure that the list of points means the same thing for the caller of converged and within the implementation of the ConvergenceChecker that was independently set. # It is not clear whether it is wise to aggregate the counter of gradient evaluations to the function evaluation counter. In LevenbergMarquartdOptimizer for example it would be unfair to do so. Currently I had to remove all tests referring to gradient and Jacobian evaluations. # In AbstractLeastSquaresOptimizer and LevenbergMarquardtOptimizer occurences of OptimizationException were replaced by the unchecked ConvergenceException but in some cases it might not be the most appropriate one. # MultiStartUnivariateRealOptimizer: in the other classes (MultiStartMultivariate...) similar to this one the randomization is on the firts-guess value while in this class it is on the search interval. I think that here also we should randomly choose the start value (within the user-selected interval). # The Javadoc utility raises warnings (see output of mvn site) which I couldnt figure out how to correct. # Some previously existing classes and interfaces have become no more than a specialisation of new generics classes; it might be interesting to remove them in order to reduce the number of classes and thus limit the potential for confusion.", "A_clean_title": ["miscellan", "issu", "concern", "optim", "packagerevis", "packag", "revis", "990792", "contain", "chang", "trigger", "follow", "issu", "math", "394|http", "394", "apach", "issu", "org", "jira", "brows", "math", "math", "397|http", "397", "apach", "issu", "org", "jira", "brows", "math", "math", "404|http", "404", "apach", "issu", "org", "jira", "brows", "math", "thi", "issu", "collect", "current", "still", "unsatisfactori", "code", "not", "necessarili", "sort", "order", "annoy", "brentoptim", "brent", "optim", "specif", "converg", "checker", "must", "use", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "also", "ha", "specif", "converg", "check", "tri", "make", "converg", "check", "independ", "optim", "algorithm", "creat", "problem", "conceptu", "practic", "see", "brentoptim", "brent", "optim", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "algorithm", "pass", "point", "converg", "checker", "but", "actual", "mean", "point", "veri", "well", "differ", "caller", "optim", "algorithm", "calle", "converg", "checker", "powelloptim", "powel", "optim", "line", "search", "brentoptim", "brent", "optim", "toler", "depend", "toler", "within", "main", "algorithm", "sinc", "toler", "come", "convergencecheck", "converg", "checker", "so", "chang", "at", "ani", "time", "it", "awkward", "adapt", "valu", "within", "line", "search", "optim", "without", "expos", "it", "intern", "brentoptim", "brent", "optim", "field", "enclos", "class", "powelloptim", "powel", "optim", "given", "numer", "chang", "some", "javadoc", "comment", "might", "out", "sync", "although", "did", "tri", "updat", "them", "all", "class", "directsearchoptim", "direct", "search", "optim", "packag", "optim", "direct", "inherit", "class", "abstractscalaroptim", "abstract", "scalar", "optim", "packag", "optim", "gener", "some", "interfac", "are", "defin", "packag", "optim", "but", "their", "base", "implement", "abstract", "class", "that", "contain", "boiler", "plate", "code", "are", "packag", "optim", "gener", "differentiablemultivariatevectorialoptim", "differenti", "multivari", "vectori", "optim", "baseabstractvectorialoptim", "base", "abstract", "vectori", "optim", "no", "check", "perform", "ensur", "converg", "checker", "ha", "been", "set", "see", "brentoptim", "brent", "optim", "powelloptim", "powel", "optim", "it", "hasnt", "there", "will", "npe", "altern", "initi", "default", "checker", "that", "will", "never", "use", "case", "user", "had", "intend", "explicitli", "set", "checker", "nonlinearconjugategradientoptim", "non", "linear", "conjug", "gradient", "optim", "ugli", "workaround", "check", "convergenceexcept", "converg", "except", "everywher", "we", "trail", "check", "functionevaluationexcept", "function", "evalu", "except", "although", "it", "never", "use", "there", "remain", "some", "duplic", "code", "such", "as", "multi", "start", "loop", "variou", "multistart", "multi", "start", "implement", "convergencecheck", "converg", "checker", "interfac", "veri", "gener", "converg", "method", "take", "ani", "number", "pointvaluepair", "point", "valu", "pair", "howev", "there", "remain", "semant", "problem", "one", "not", "sure", "that", "list", "point", "mean", "same", "thing", "caller", "converg", "within", "implement", "convergencecheck", "converg", "checker", "that", "wa", "independ", "set", "it", "not", "clear", "whether", "it", "wise", "aggreg", "counter", "gradient", "evalu", "function", "evalu", "counter", "levenbergmarquartdoptim", "levenberg", "marquartd", "optim", "exampl", "it", "would", "unfair", "so", "current", "had", "remov", "all", "test", "refer", "gradient", "jacobian", "evalu", "abstractleastsquaresoptim", "abstract", "least", "squar", "optim", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "occur", "optimizationexcept", "optim", "except", "were", "replac", "by", "uncheck", "convergenceexcept", "converg", "except", "but", "some", "case", "it", "might", "not", "most", "appropri", "one", "multistartunivariaterealoptim", "multi", "start", "univari", "real", "optim", "other", "class", "multistartmultivari", "multi", "start", "multivari", "similar", "thi", "one", "random", "firt", "guess", "valu", "while", "thi", "class", "it", "search", "interv", "think", "that", "here", "also", "we", "randomli", "choos", "start", "valu", "within", "user", "select", "interv", "javadoc", "util", "rais", "warn", "see", "output", "mvn", "site", "which", "couldnt", "figur", "out", "how", "correct", "some", "previous", "exist", "class", "interfac", "have", "becom", "no", "more", "than", "specialis", "new", "gener", "class", "it", "might", "interest", "remov", "them", "order", "reduc", "number", "class", "thu", "limit", "potenti", "confus"], "B_title": "(point 13) Selecting a random start value (instead of interval bounds).", "B_clean_title": ["point", "13", "select", "random", "start", "valu", "instead", "interv", "bound"]},
{"A_title": "JavaScriptReference escapes given URLwhile trying to integrate gmaps3 in our webapp i had issues with the wicketstuff-gmap3 stuff ( - we need a client-id for our request) ...  so i have: noformat public static final String GMAP_API_URL = %s://maps.google.com/maps/api/js?v=3&sensor=%s&client-id=%s;  response.render(JavaScriptHeaderItem.forUrl(String.format(GMAP_API_URL schema sensor clientid))); noformat  the rendered result of this is: noformat <script type=text/javascript src=http://maps.google.com/maps/api/js?v=3&amp;sensor=false&amp;client-id=....></script> noformat  so the requestparameters are encoded  which is happening in the JavaScriptUtils Helper: noformat public static void writeJavaScriptUrl(final Response response final CharSequence url final String id boolean defer String charset)          response.write(<script type=text/javascript );         if (id != null)                      response.write(id= + Strings.escapeMarkup(id) +  );                  if (defer)                      response.write(defer=defer );                  if (charset != null)                      response.write(charset= + Strings.escapeMarkup(charset) +  );                  response.write(src=);         response.write(Strings.escapeMarkup(url));         response.write(></script>);         response.write(n);  noformat but ... is this right to escape the url?  when i open the above mentioned script google tells me i have no parameter sensor ... which i can understand as ther is only a parameter amp ...", "A_clean_title": ["javascriptrefer", "java", "script", "refer", "escap", "given", "urlwhil", "ur", "lwhile", "tri", "integr", "gmaps3", "our", "webapp", "had", "issu", "wicketstuff", "gmap3", "stuff", "we", "need", "client", "id", "our", "request", "so", "have", "noformat", "public", "static", "final", "string", "gmap", "api", "url", "googl", "map", "com", "map", "api", "js", "v=3", "sensor=", "client", "id=", "respons", "render", "javascriptheaderitem", "forurl", "java", "script", "header", "item", "url", "string", "format", "gmap", "api", "url", "schema", "sensor", "clientid", "noformat", "render", "result", "thi", "noformat", "script", "type=text", "javascript", "src=http", "googl", "map", "com", "map", "api", "js", "v=3", "amp", "sensor=fals", "amp", "client", "id=", "script", "noformat", "so", "requestparamet", "are", "encod", "which", "happen", "javascriptutil", "java", "script", "util", "helper", "noformat", "public", "static", "void", "writejavascripturl", "write", "java", "script", "url", "final", "respons", "respons", "final", "charsequ", "char", "sequenc", "url", "final", "string", "id", "boolean", "defer", "string", "charset", "respons", "write", "script", "type=text", "javascript", "id", "null", "respons", "write", "id=", "string", "escapemarkup", "escap", "markup", "id", "defer", "respons", "write", "defer=def", "charset", "null", "respons", "write", "charset=", "string", "escapemarkup", "escap", "markup", "charset", "respons", "write", "src=", "respons", "write", "string", "escapemarkup", "escap", "markup", "url", "respons", "write", "script", "respons", "write", "noformat", "but", "thi", "right", "escap", "url", "when", "open", "abov", "mention", "script", "googl", "tell", "me", "have", "no", "paramet", "sensor", "which", "understand", "as", "ther", "onli", "paramet", "amp"], "B_title": "JavaScriptReference escapes given URL", "B_clean_title": ["javascriptrefer", "java", "script", "refer", "escap", "given", "url"]},
{"A_title": "javascript with a less than character (<) fails to execute when added through a header contribution in ajax responseThis is adapted from a wicket users post I made (links are to the same thread in two archive systems):  http://markmail.org/search/?q=wicket%20users%20wicket-ajax.js#query:wicket%20users%20wicket-ajax.js+page:1+mid:rfts3ar3upffhbbt+state:results  http://mail-archives.apache.org/mod_mbox/wicket-users/201102.mbox/%3CAANLkTi=EkmTA0RnA+GyJE-CQWmkCxRLsjp+z8jwv-Aw9@mail.gmail.com%3E  The problem:  I have a panel with this:      <wicket:head> <script> if (someVariable < 0)  someVariable = 0;  </script>     </wicket:head>  This script fails to execute when the panel is loaded by ajax.  If I replace the less than character < with equals == then it executes (but of course this is not what I need).  I tested this in Firefox 4.0b10 and Chrome 8.  After some debugging it seems to me that this needs to be corrected in wicket-ajax.js. The header contribution is sent to the browser inside of a CDATA section so the < character arrives to javascript intact. However in parsing the script tag the < seems to signal the beginning of an HTML tag that then is considered malformed.   Possible workarounds for apps:   - Invert the logic so a greater-than is used. In my example this would be: if (0 > someVariable)   - Put the code into a separate JS file (the downside is it requires another network hop from the browser)  - Embed the script in <wicket:panel> rather than <wicket:head> (the disadvantage is the script will be re-sent with the panel content when the panel is re-used on the same page)", "A_clean_title": ["javascript", "less", "than", "charact", "fail", "execut", "when", "ad", "through", "header", "contribut", "ajax", "responsethi", "respons", "thi", "adapt", "wicket", "user", "post", "made", "link", "are", "same", "thread", "two", "archiv", "system", "http", "markmail", "org", "search", "q=wicket", "20user", "20wicket", "ajax", "js", "queri", "wicket", "20user", "20wicket", "ajax", "js+page:1+mid", "rfts3ar3upffhbbt+st", "result", "http", "mail", "archiv", "apach", "user", "201102", "mbox", "org", "mod", "mbox", "wicket", "3caanlkti=ekmta0rna+gyj", "cqwmkcxrlsjp+z8jwv", "aw9", "3caan", "lk", "ti=ekm", "ta0rn", "a+gi", "je", "cq", "wmk", "cx", "lsjp+z8jwv", "mail", "gmail", "com", "3e", "problem", "have", "panel", "thi", "wicket", "head", "script", "somevari", "some", "variabl", "somevari", "some", "variabl", "script", "wicket", "head", "thi", "script", "fail", "execut", "when", "panel", "load", "by", "ajax", "replac", "less", "than", "charact", "equal", "then", "it", "execut", "but", "cours", "thi", "not", "what", "need", "test", "thi", "firefox", "0b10", "chrome", "after", "some", "debug", "it", "seem", "me", "that", "thi", "need", "correct", "wicket", "ajax", "js", "header", "contribut", "sent", "browser", "insid", "cdata", "section", "so", "charact", "arriv", "javascript", "intact", "howev", "pars", "script", "tag", "seem", "signal", "begin", "html", "tag", "that", "then", "consid", "malform", "possibl", "workaround", "app", "invert", "logic", "so", "greater", "than", "use", "my", "exampl", "thi", "would", "somevari", "some", "variabl", "put", "code", "into", "separ", "js", "file", "downsid", "it", "requir", "anoth", "network", "hop", "browser", "emb", "script", "wicket", "panel", "rather", "than", "wicket", "head", "disadvantag", "script", "will", "re", "sent", "panel", "content", "when", "panel", "re", "use", "same", "page"], "B_title": "Test case preventing problems during the page serialization process outside Wicket lifecycle Issue: WICKET-3420", "B_clean_title": ["test", "case", "prevent", "problem", "dure", "page", "serial", "process", "outsid", "wicket", "lifecycl", "issu", "wicket", "3420"]},
{"A_title": "Assertion error when adding node with expanded namecode node.addNode(http://foonew); code  results in an assertion error", "A_clean_title": ["assert", "error", "when", "ad", "node", "expand", "namecod", "node", "addnod", "add", "node", "http", "foonew", "code", "result", "assert", "error"], "B_title": "Assertion error when adding node with expanded name", "B_clean_title": ["assert", "error", "when", "ad", "node", "expand", "name"]},
{"A_title": "DocumentNodeStore revision GC removes intermediate docsThe revision garbage collection in DocumentNodeStore removes intermediate documents of the revision history of a node even if it is still in use.", "A_clean_title": ["documentnodestor", "document", "node", "store", "revis", "gc", "remov", "intermedi", "docsth", "doc", "revis", "garbag", "collect", "documentnodestor", "document", "node", "store", "remov", "intermedi", "document", "revis", "histori", "node", "even", "it", "still", "use"], "B_title": "DocumentNodeStore revision GC removes intermediate docs", "B_clean_title": ["documentnodestor", "document", "node", "store", "revis", "gc", "remov", "intermedi", "doc"]},
{"A_title": "cloning of TimeSeriesIts just a minor bug!  When I clone a TimeSeries which has no items I get an IllegalArgumentException (Requires start <= end). But I dont think the user should be responsible for checking whether the TimeSeries has any items or not.", "A_clean_title": ["clone", "timeseriesit", "time", "seri", "it", "just", "minor", "bug", "when", "clone", "timeseri", "time", "seri", "which", "ha", "no", "item", "get", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "but", "dont", "think", "user", "respons", "check", "whether", "timeseri", "time", "seri", "ha", "ani", "item", "or", "not"], "B_title": "source/org/jfree/data/time/TimeSeries.java (clone): Reimplemented.", "B_clean_title": ["java", "sourc", "org", "jfree", "data", "time", "timeseri", "time", "seri", "clone", "reimplement"]},
{"A_title": "Intermittent IllegalMonitorStateException seen while releaseing IndexNodeAt times following exception seen. On this system the index got corrupted because backing index files got deleted from the system and hence index is not accessible.   noformat 21.09.2015 09:26:36.764 *ERROR* FelixStartLevel com.adobe.granite.repository.impl.SlingRepositoryManager start: Uncaught Throwable trying to access Repository calling stopRepository() java.lang.IllegalMonitorStateException: attempt to unlock read lock not locked by current thread         at java.util.concurrent.locks.ReentrantReadWriteLock Sync.unmatchedUnlockException(ReentrantReadWriteLock.java:444)         at java.util.concurrent.locks.ReentrantReadWriteLock Sync.tryReleaseShared(ReentrantReadWriteLock.java:428)         at java.util.concurrent.locks.AbstractQueuedSynchronizer.releaseShared(AbstractQueuedSynchronizer.java:1341)         at java.util.concurrent.locks.ReentrantReadWriteLock ReadLock.unlock(ReentrantReadWriteLock.java:881)         at org.apache.jackrabbit.oak.plugins.index.lucene.IndexNode.release(IndexNode.java:121)         at org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlans(LucenePropertyIndex.java:212)         at org.apache.jackrabbit.oak.query.QueryImpl.getBestSelectorExecutionPlan(QueryImpl.java:847)         at org.apache.jackrabbit.oak.query.QueryImpl.getBestSelectorExecutionPlan(QueryImpl.java:793)         at org.apache.jackrabbit.oak.query.ast.SelectorImpl.prepare(SelectorImpl.java:283)         at org.apache.jackrabbit.oak.query.QueryImpl.prepare(QueryImpl.java:568)         at org.apache.jackrabbit.oak.query.QueryEngineImpl.executeQuery(QueryEngineImpl.java:183)         at org.apache.jackrabbit.oak.security.user.UserProvider.getAuthorizableByPrincipal(UserProvider.java:234)         at org.apache.jackrabbit.oak.security.user.UserManagerImpl.getAuthorizable(UserManagerImpl.java:116)         at org.apache.jackrabbit.oak.security.principal.PrincipalProviderImpl.getAuthorizable(PrincipalProviderImpl.java:140)         at org.apache.jackrabbit.oak.security.principal.PrincipalProviderImpl.getPrincipal(PrincipalProviderImpl.java:69)         at org.apache.jackrabbit.oak.spi.security.principal.CompositePrincipalProvider.getPrincipal(CompositePrincipalProvider.java:50)         at org.apache.jackrabbit.oak.spi.security.principal.PrincipalManagerImpl.getPrincipal(PrincipalManagerImpl.java:47)         at com.adobe.granite.repository.impl.SlingRepositoryManager.setupPermissions(SlingRepositoryManager.java:997)         at com.adobe.granite.repository.impl.SlingRepositoryManager.createRepository(SlingRepositoryManager.java:420)         at com.adobe.granite.repository.impl.SlingRepositoryManager.acquireRepository(SlingRepositoryManager.java:290)         at org.apache.sling.jcr.base.AbstractSlingRepositoryManager.start(AbstractSlingRepositoryManager.java:304)         at com.adobe.granite.repository.impl.SlingRepositoryManager.activate(SlingRepositoryManager.java:267)         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:483)         at org.apache.felix.scr.impl.helper.BaseMethod.invokeMethod(BaseMethod.java:222)         at org.apache.felix.scr.impl.helper.BaseMethod.access 500(BaseMethod.java:37)         at org.apache.felix.scr.impl.helper.BaseMethod Resolved.invoke(BaseMethod.java:615)         at org.apache.felix.scr.impl.helper.BaseMethod.invoke(BaseMethod.java:499)         at org.apache.felix.scr.impl.helper.ActivateMethod.invoke(ActivateMethod.java:295)         at org.apache.felix.scr.impl.manager.SingleComponentManager.createImplementationObject(SingleComponentManager.java:302)         at org.apache.felix.scr.impl.manager.SingleComponentManager.createComponent(SingleComponentManager.java:113)         at org.apache.felix.scr.impl.manager.SingleComponentManager.getService(SingleComponentManager.java:832)         at org.apache.felix.scr.impl.manager.SingleComponentManager.getServiceInternal(SingleComponentManager.java:799)         at org.apache.felix.scr.impl.manager.AbstractComponentManager.activateInternal(AbstractComponentManager.java:724)         at org.apache.felix.scr.impl.manager.DependencyManager SingleStaticCustomizer.addedService(DependencyManager.java:927)         at org.apache.felix.scr.impl.manager.DependencyManager SingleStaticCustomizer.addedService(DependencyManager.java:891)         at org.apache.felix.scr.impl.manager.ServiceTracker Tracked.customizerAdded(ServiceTracker.java:1492)         at org.apache.felix.scr.impl.manager.ServiceTracker Tracked.customizerAdded(ServiceTracker.java:1413)         at org.apache.felix.scr.impl.manager.ServiceTracker AbstractTracked.trackAdding(ServiceTracker.java:1222)         at org.apache.felix.scr.impl.manager.ServiceTracker AbstractTracked.track(ServiceTracker.java:1158)         at org.apache.felix.scr.impl.manager.ServiceTracker Tracked.serviceChanged(ServiceTracker.java:1444)         at org.apache.felix.framework.util.EventDispatcher.invokeServiceListenerCallback(EventDispatcher.java:987)         at org.apache.felix.framework.util.EventDispatcher.fireEventImmediately(EventDispatcher.java:838)         at org.apache.felix.framework.util.EventDispatcher.fireServiceEvent(EventDispatcher.java:545)         at org.apache.felix.framework.Felix.fireServiceEvent(Felix.java:4547)         at org.apache.felix.framework.Felix.registerService(Felix.java:3521)         at org.apache.felix.framework.BundleContextImpl.registerService(BundleContextImpl.java:348)         at org.apache.sling.commons.threads.impl.Activator.start(Activator.java:55)         at org.apache.felix.framework.util.SecureAction.startActivator(SecureAction.java:697)         at org.apache.felix.framework.Felix.activateBundle(Felix.java:2223)         at org.apache.felix.framework.Felix.startBundle(Felix.java:2141)         at org.apache.felix.framework.Felix.setActiveStartLevel(Felix.java:1368)         at org.apache.felix.framework.FrameworkStartLevelImpl.run(FrameworkStartLevelImpl.java:308)         at java.lang.Thread.run(Thread.java:745) noformat  Above exception happens at  code for (String path : indexPaths)              try                  indexNode = tracker.acquireIndexNode(path);                  if (indexNode != null)                      IndexPlan plan = new IndexPlanner(indexNode path filter sortOrder).getPlan();                     if (plan != null)                          plans.add(plan);                                                    finally                  if (indexNode != null)                      indexNode.release();                                        code  It has been ensured that if indexNode is initialized then it has been acquired. So only way for such an exception to happen is that in a loop of say 2 paths indexNode got initialized for Loop 1 and then while acquiring in Loop 2 the indexNode still refers to old released value and that would cause the exception. The fix should be simply to null the variable once released", "A_clean_title": ["intermitt", "illegalmonitorstateexcept", "illeg", "monitor", "state", "except", "seen", "while", "releas", "indexnodeat", "index", "node", "at", "time", "follow", "except", "seen", "thi", "system", "index", "got", "corrupt", "becaus", "back", "index", "file", "got", "delet", "system", "henc", "index", "not", "access", "noformat", "21", "09", "2015", "09:26:36", "764", "error", "felixstartlevel", "felix", "start", "level", "com", "adob", "granit", "repositori", "impl", "slingrepositorymanag", "sling", "repositori", "manag", "start", "uncaught", "throwabl", "tri", "access", "repositori", "call", "stoprepositori", "stop", "repositori", "java", "lang", "illegalmonitorstateexcept", "illeg", "monitor", "state", "except", "attempt", "unlock", "read", "lock", "not", "lock", "by", "current", "thread", "at", "java", "util", "concurr", "lock", "reentrantreadwritelock", "reentrant", "read", "write", "lock", "sync", "unmatchedunlockexcept", "unmatch", "unlock", "except", "reentrantreadwritelock", "java:444", "reentrant", "read", "write", "lock", "at", "java", "util", "concurr", "lock", "reentrantreadwritelock", "reentrant", "read", "write", "lock", "sync", "tryreleaseshar", "tri", "releas", "share", "reentrantreadwritelock", "java:428", "reentrant", "read", "write", "lock", "at", "java", "util", "concurr", "lock", "abstractqueuedsynchron", "releaseshar", "abstract", "queu", "synchron", "releas", "share", "abstractqueuedsynchron", "java:1341", "abstract", "queu", "synchron", "at", "java", "util", "concurr", "lock", "reentrantreadwritelock", "reentrant", "read", "write", "lock", "readlock", "unlock", "read", "lock", "reentrantreadwritelock", "java:881", "reentrant", "read", "write", "lock", "at", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "indexnod", "releas", "index", "node", "indexnod", "java:121", "index", "node", "at", "org", "apach", "jackrabbit", "oak", "plugin", "index", "lucen", "lucenepropertyindex", "getplan", "lucen", "properti", "index", "get", "plan", "lucenepropertyindex", "java:212", "lucen", "properti", "index", "at", "org", "apach", "jackrabbit", "oak", "queri", "queryimpl", "getbestselectorexecutionplan", "queri", "impl", "get", "best", "selector", "execut", "plan", "queryimpl", "java:847", "queri", "impl", "at", "org", "apach", "jackrabbit", "oak", "queri", "queryimpl", "getbestselectorexecutionplan", "queri", "impl", "get", "best", "selector", "execut", "plan", "queryimpl", "java:793", "queri", "impl", "at", "org", "apach", "jackrabbit", "oak", "queri", "ast", "selectorimpl", "prepar", "selector", "impl", "selectorimpl", "java:283", "selector", "impl", "at", "org", "apach", "jackrabbit", "oak", "queri", "queryimpl", "prepar", "queri", "impl", "queryimpl", "java:568", "queri", "impl", "at", "org", "apach", "jackrabbit", "oak", "queri", "queryengineimpl", "executequeri", "queri", "engin", "impl", "execut", "queri", "queryengineimpl", "java:183", "queri", "engin", "impl", "at", "org", "apach", "jackrabbit", "oak", "secur", "user", "userprovid", "getauthorizablebyprincip", "user", "provid", "get", "authoriz", "by", "princip", "userprovid", "java:234", "user", "provid", "at", "org", "apach", "jackrabbit", "oak", "secur", "user", "usermanagerimpl", "getauthoriz", "user", "manag", "impl", "get", "authoriz", "usermanagerimpl", "java:116", "user", "manag", "impl", "at", "org", "apach", "jackrabbit", "oak", "secur", "princip", "principalproviderimpl", "getauthoriz", "princip", "provid", "impl", "get", "authoriz", "principalproviderimpl", "java:140", "princip", "provid", "impl", "at", "org", "apach", "jackrabbit", "oak", "secur", "princip", "principalproviderimpl", "getprincip", "princip", "provid", "impl", "get", "princip", "principalproviderimpl", "java:69", "princip", "provid", "impl", "at", "org", "apach", "jackrabbit", "oak", "spi", "secur", "princip", "compositeprincipalprovid", "getprincip", "composit", "princip", "provid", "get", "princip", "compositeprincipalprovid", "java:50", "composit", "princip", "provid", "at", "org", "apach", "jackrabbit", "oak", "spi", "secur", "princip", "principalmanagerimpl", "getprincip", "princip", "manag", "impl", "get", "princip", "principalmanagerimpl", "java:47", "princip", "manag", "impl", "at", "com", "adob", "granit", "repositori", "impl", "slingrepositorymanag", "setuppermiss", "sling", "repositori", "manag", "setup", "permiss", "slingrepositorymanag", "java:997", "sling", "repositori", "manag", "at", "com", "adob", "granit", "repositori", "impl", "slingrepositorymanag", "createrepositori", "sling", "repositori", "manag", "creat", "repositori", "slingrepositorymanag", "java:420", "sling", "repositori", "manag", "at", "com", "adob", "granit", "repositori", "impl", "slingrepositorymanag", "acquirerepositori", "sling", "repositori", "manag", "acquir", "repositori", "slingrepositorymanag", "java:290", "sling", "repositori", "manag", "at", "org", "apach", "sling", "jcr", "base", "abstractslingrepositorymanag", "start", "abstract", "sling", "repositori", "manag", "abstractslingrepositorymanag", "java:304", "abstract", "sling", "repositori", "manag", "at", "com", "adob", "granit", "repositori", "impl", "slingrepositorymanag", "activ", "sling", "repositori", "manag", "slingrepositorymanag", "java:267", "sling", "repositori", "manag", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:62", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:43", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:483", "at", "org", "apach", "felix", "scr", "impl", "helper", "basemethod", "invokemethod", "base", "method", "invok", "method", "basemethod", "java:222", "base", "method", "at", "org", "apach", "felix", "scr", "impl", "helper", "basemethod", "access", "base", "method", "500", "basemethod", "java:37", "base", "method", "at", "org", "apach", "felix", "scr", "impl", "helper", "basemethod", "base", "method", "resolv", "invok", "basemethod", "java:615", "base", "method", "at", "org", "apach", "felix", "scr", "impl", "helper", "basemethod", "invok", "base", "method", "basemethod", "java:499", "base", "method", "at", "org", "apach", "felix", "scr", "impl", "helper", "activatemethod", "invok", "activ", "method", "activatemethod", "java:295", "activ", "method", "at", "org", "apach", "felix", "scr", "impl", "manag", "singlecomponentmanag", "createimplementationobject", "singl", "compon", "manag", "creat", "implement", "object", "singlecomponentmanag", "java:302", "singl", "compon", "manag", "at", "org", "apach", "felix", "scr", "impl", "manag", "singlecomponentmanag", "createcompon", "singl", "compon", "manag", "creat", "compon", "singlecomponentmanag", "java:113", "singl", "compon", "manag", "at", "org", "apach", "felix", "scr", "impl", "manag", "singlecomponentmanag", "getservic", "singl", "compon", "manag", "get", "servic", "singlecomponentmanag", "java:832", "singl", "compon", "manag", "at", "org", "apach", "felix", "scr", "impl", "manag", "singlecomponentmanag", "getserviceintern", "singl", "compon", "manag", "get", "servic", "intern", "singlecomponentmanag", "java:799", "singl", "compon", "manag", "at", "org", "apach", "felix", "scr", "impl", "manag", "abstractcomponentmanag", "activateintern", "abstract", "compon", "manag", "activ", "intern", "abstractcomponentmanag", "java:724", "abstract", "compon", "manag", "at", "org", "apach", "felix", "scr", "impl", "manag", "dependencymanag", "depend", "manag", "singlestaticcustom", "addedservic", "singl", "static", "custom", "ad", "servic", "dependencymanag", "java:927", "depend", "manag", "at", "org", "apach", "felix", "scr", "impl", "manag", "dependencymanag", "depend", "manag", "singlestaticcustom", "addedservic", "singl", "static", "custom", "ad", "servic", "dependencymanag", "java:891", "depend", "manag", "at", "org", "apach", "felix", "scr", "impl", "manag", "servicetrack", "servic", "tracker", "track", "customizerad", "custom", "ad", "servicetrack", "java:1492", "servic", "tracker", "at", "org", "apach", "felix", "scr", "impl", "manag", "servicetrack", "servic", "tracker", "track", "customizerad", "custom", "ad", "servicetrack", "java:1413", "servic", "tracker", "at", "org", "apach", "felix", "scr", "impl", "manag", "servicetrack", "servic", "tracker", "abstracttrack", "trackad", "abstract", "track", "track", "ad", "servicetrack", "java:1222", "servic", "tracker", "at", "org", "apach", "felix", "scr", "impl", "manag", "servicetrack", "servic", "tracker", "abstracttrack", "track", "abstract", "track", "servicetrack", "java:1158", "servic", "tracker", "at", "org", "apach", "felix", "scr", "impl", "manag", "servicetrack", "servic", "tracker", "track", "servicechang", "servic", "chang", "servicetrack", "java:1444", "servic", "tracker", "at", "org", "apach", "felix", "framework", "util", "eventdispatch", "invokeservicelistenercallback", "event", "dispatch", "invok", "servic", "listen", "callback", "eventdispatch", "java:987", "event", "dispatch", "at", "org", "apach", "felix", "framework", "util", "eventdispatch", "fireeventimmedi", "event", "dispatch", "fire", "event", "immedi", "eventdispatch", "java:838", "event", "dispatch", "at", "org", "apach", "felix", "framework", "util", "eventdispatch", "fireserviceev", "event", "dispatch", "fire", "servic", "event", "eventdispatch", "java:545", "event", "dispatch", "at", "org", "apach", "felix", "framework", "felix", "fireserviceev", "fire", "servic", "event", "felix", "java:4547", "at", "org", "apach", "felix", "framework", "felix", "registerservic", "regist", "servic", "felix", "java:3521", "at", "org", "apach", "felix", "framework", "bundlecontextimpl", "registerservic", "bundl", "context", "impl", "regist", "servic", "bundlecontextimpl", "java:348", "bundl", "context", "impl", "at", "org", "apach", "sling", "common", "thread", "impl", "activ", "start", "activ", "java:55", "at", "org", "apach", "felix", "framework", "util", "secureact", "startactiv", "secur", "action", "start", "activ", "secureact", "java:697", "secur", "action", "at", "org", "apach", "felix", "framework", "felix", "activatebundl", "activ", "bundl", "felix", "java:2223", "at", "org", "apach", "felix", "framework", "felix", "startbundl", "start", "bundl", "felix", "java:2141", "at", "org", "apach", "felix", "framework", "felix", "setactivestartlevel", "set", "activ", "start", "level", "felix", "java:1368", "at", "org", "apach", "felix", "framework", "frameworkstartlevelimpl", "run", "framework", "start", "level", "impl", "frameworkstartlevelimpl", "java:308", "framework", "start", "level", "impl", "at", "java", "lang", "thread", "run", "thread", "java:745", "noformat", "abov", "except", "happen", "at", "code", "string", "path", "indexpath", "index", "path", "tri", "indexnod", "index", "node", "tracker", "acquireindexnod", "acquir", "index", "node", "path", "indexnod", "index", "node", "null", "indexplan", "index", "plan", "plan", "new", "indexplann", "index", "planner", "indexnod", "index", "node", "path", "filter", "sortord", "sort", "order", "getplan", "get", "plan", "plan", "null", "plan", "add", "plan", "final", "indexnod", "index", "node", "null", "indexnod", "releas", "index", "node", "code", "it", "ha", "been", "ensur", "that", "indexnod", "index", "node", "initi", "then", "it", "ha", "been", "acquir", "so", "onli", "way", "such", "except", "happen", "that", "loop", "say", "path", "indexnod", "index", "node", "got", "initi", "loop", "then", "while", "acquir", "loop", "indexnod", "index", "node", "still", "refer", "old", "releas", "valu", "that", "would", "caus", "except", "fix", "simpli", "null", "variabl", "onc", "releas"], "B_title": "- Intermittent IllegalMonitorStateException seen while releaseing IndexNode", "B_clean_title": ["intermitt", "illegalmonitorstateexcept", "illeg", "monitor", "state", "except", "seen", "while", "releas", "indexnod", "index", "node"]},
{"A_title": "Handling of NO_MINIFIED_NAME in PackageResourceReference#internalGetMinifiedName()The Value NO_MINIFIED_NAME is not handled correctly as entry in the MINIFIED_NAMES_CACHE in PackageResourceReference#internalGetMinifiedName()     private String internalGetMinifiedName()  String minifiedName = MINIFIED_NAMES_CACHE.get(this); if (minifiedName != null && minifiedName != NO_MINIFIED_NAME)                                                         ^^^^^^^ return minifiedName;                                  ...  You should remove the condition minifiedName != NO_MINIFIED_NAME here to leverage the  MINIFIED_NAMES_CACHE for NO_MINIFIED_NAME cache entries. Otherwise you always run into the resource resolving code if there is no minified resource.", "A_clean_title": ["handl", "no", "minifi", "name", "packageresourcerefer", "packag", "resourc", "refer", "internalgetminifiednam", "intern", "get", "minifi", "name", "valu", "no", "minifi", "name", "not", "handl", "correctli", "as", "entri", "minifi", "name", "cach", "packageresourcerefer", "packag", "resourc", "refer", "internalgetminifiednam", "intern", "get", "minifi", "name", "privat", "string", "internalgetminifiednam", "intern", "get", "minifi", "name", "string", "minifiednam", "minifi", "name", "get", "minifi", "name", "cach", "thi", "minifiednam", "minifi", "name", "null", "minifiednam", "minifi", "name", "no", "minifi", "name", "return", "minifiednam", "minifi", "name", "you", "remov", "condit", "minifiednam", "minifi", "name", "no", "minifi", "name", "here", "leverag", "minifi", "name", "cach", "no", "minifi", "name", "cach", "entri", "otherwis", "you", "alway", "run", "into", "resourc", "resolv", "code", "there", "no", "minifi", "resourc"], "B_title": "cache minified name correctly", "B_clean_title": ["cach", "minifi", "name", "correctli"]},
{"A_title": "isPrimary check is not applied to beans in parent contextssee this comment in WICKET-2771: https://issues.apache.org/jira/browse/WICKET-2771?focusedCommentId=12872246&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12872246", "A_clean_title": ["isprimari", "primari", "check", "not", "appli", "bean", "parent", "contextsse", "thi", "comment", "wicket", "2771", "http", "2771", "apach", "issu", "org", "jira", "brows", "wicket", "focusedcommentid=12872246", "focus", "comment", "id=12872246", "page=com", "atlassian", "jira", "plugin", "system", "issuetabpanel", "3acom", "tabpanel", "action", "12872246"], "B_title": "look for bean definition in parent contexts WICKET-2901: only return a primary bean if its the only one", "B_clean_title": ["look", "bean", "definit", "parent", "context", "wicket", "2901", "onli", "return", "primari", "bean", "it", "onli", "one"]},
{"A_title": "TARMK Cold Standby size increase due to checkpoints copyThe current sync design gets confused by existing checkpoints and tries to copy them by value bypassing the current storage optimization where there are a lot of references to existing content. this can result in a considerable size increase on the standby.", "A_clean_title": ["tarmk", "cold", "standbi", "size", "increas", "due", "checkpoint", "copyth", "copi", "current", "sync", "design", "get", "confus", "by", "exist", "checkpoint", "tri", "copi", "them", "by", "valu", "bypass", "current", "storag", "optim", "where", "there", "are", "lot", "refer", "exist", "content", "thi", "result", "consider", "size", "increas", "standbi"], "B_title": "TARMK Cold Standby size increase due to checkpoints copy  - switched sync to a different approach to leverage existing recordid info", "B_clean_title": ["tarmk", "cold", "standbi", "size", "increas", "due", "checkpoint", "copi", "switch", "sync", "differ", "approach", "leverag", "exist", "recordid", "info"]},
{"A_title": "onError call order doesnt match onSubmitonError in Forms and Buttons should be called in the same order as onSubmit (i.e. post-order).", "A_clean_title": ["onerror", "error", "call", "order", "doesnt", "match", "onsubmitonerror", "submiton", "error", "form", "button", "call", "same", "order", "as", "onsubmit", "submit", "post", "order"], "B_title": "onError now called post-order just like onSubmit", "B_clean_title": ["onerror", "error", "now", "call", "post", "order", "just", "like", "onsubmit", "submit"]}]